// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: invalid_annotation_target
part of anthropic_schema;

// ==========================================
// CLASS: CountMessageTokensRequest
// ==========================================

/// The request parameters for counting tokens in a message.
@freezed
abstract class CountMessageTokensRequest with _$CountMessageTokensRequest {
  const CountMessageTokensRequest._();

  /// Factory constructor for CountMessageTokensRequest
  const factory CountMessageTokensRequest({
    /// The model that will complete your prompt.
    ///
    /// See [models](https://docs.anthropic.com/en/docs/models-overview) for additional
    /// details and options.
    @_CountMessageTokensRequestModelConverter()
    required CountMessageTokensRequestModel model,

    /// Input messages.
    ///
    /// Our models are trained to operate on alternating `user` and `assistant`
    /// conversational turns. When creating a new `Message`, you specify the prior
    /// conversational turns with the `messages` parameter, and the model then generates
    /// the next `Message` in the conversation.
    ///
    /// Each input message must be an object with a `role` and `content`. You can
    /// specify a single `user`-role message, or you can include multiple `user` and
    /// `assistant` messages. The first message must always use the `user` role.
    ///
    /// If the final message uses the `assistant` role, the response content will
    /// continue immediately from the content in that message. This can be used to
    /// constrain part of the model's response.
    required List<Message> messages,

    /// System prompt.
    ///
    /// A system prompt is a way of providing context and instructions to Claude, such
    /// as specifying a particular goal or role. See our
    /// [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
    @_CountMessageTokensRequestSystemConverter()
    @JsonKey(includeIfNull: false)
    CountMessageTokensRequestSystem? system,

    /// How the model should use the provided tools. The model can use a specific tool,
    /// any available tool, or decide by itself.
    ///
    /// - `auto`: allows Claude to decide whether to call any provided tools or not. This is the default value.
    /// - `any`: tells Claude that it must use one of the provided tools, but doesnâ€™t force a particular tool.
    /// - `tool`: allows us to force Claude to always use a particular tool specified in the `name` field.
    @JsonKey(name: 'tool_choice', includeIfNull: false) ToolChoice? toolChoice,

    /// Definitions of tools that the model may use.
    ///
    /// If you include `tools` in your API request, the model may return `tool_use`
    /// content blocks that represent the model's use of those tools. You can then run
    /// those tools using the tool input generated by the model and then optionally
    /// return results back to the model using `tool_result` content blocks.
    @JsonKey(includeIfNull: false) List<Tool>? tools,

    /// Configuration for enabling Claude's extended thinking. When enabled, responses
    /// include `thinking` content blocks showing Claude's thinking process before the
    /// final answer. Requires a minimum budget of 1,024 tokens and counts towards your
    /// `max_tokens` limit.
    /// Any of: [ThinkingConfigEnabled], [ThinkingConfigDisabled]
    @JsonKey(includeIfNull: false) ThinkingConfig? thinking,
  }) = _CountMessageTokensRequest;

  /// Object construction from a JSON representation
  factory CountMessageTokensRequest.fromJson(Map<String, dynamic> json) =>
      _$CountMessageTokensRequestFromJson(json);

  /// List of all property names of schema
  static const List<String> propertyNames = [
    'model',
    'messages',
    'system',
    'tool_choice',
    'tools',
    'thinking',
  ];

  /// Perform validations on the schema property values
  String? validateSchema() {
    return null;
  }

  /// Map representation of object (not serialized)
  Map<String, dynamic> toMap() {
    return {
      'model': model,
      'messages': messages,
      'system': system,
      'tool_choice': toolChoice,
      'tools': tools,
      'thinking': thinking,
    };
  }
}

// ==========================================
// CLASS: CountMessageTokensRequestModel
// ==========================================

/// The model that will complete your prompt.
///
/// See [models](https://docs.anthropic.com/en/docs/models-overview) for additional
/// details and options.
@freezed
sealed class CountMessageTokensRequestModel
    with _$CountMessageTokensRequestModel {
  const CountMessageTokensRequestModel._();

  /// Available models. Mind that the list may not be exhaustive nor up-to-date.
  const factory CountMessageTokensRequestModel.enumeration(Models value) =
      CountMessageTokensRequestModelEnumeration;

  /// The ID of the model to use for this request.
  const factory CountMessageTokensRequestModel.string(String value) =
      CountMessageTokensRequestModelString;

  /// Object construction from a JSON representation
  factory CountMessageTokensRequestModel.fromJson(Map<String, dynamic> json) =>
      _$CountMessageTokensRequestModelFromJson(json);
}

/// Custom JSON converter for [CountMessageTokensRequestModel]
class _CountMessageTokensRequestModelConverter
    implements JsonConverter<CountMessageTokensRequestModel, Object?> {
  const _CountMessageTokensRequestModelConverter();

  @override
  CountMessageTokensRequestModel fromJson(Object? data) {
    if (data is String && _$ModelsEnumMap.values.contains(data)) {
      return CountMessageTokensRequestModelEnumeration(
        _$ModelsEnumMap.keys.elementAt(
          _$ModelsEnumMap.values.toList().indexOf(data),
        ),
      );
    }
    if (data is String) {
      return CountMessageTokensRequestModelString(data);
    }
    throw Exception(
      'Unexpected value for CountMessageTokensRequestModel: $data',
    );
  }

  @override
  Object? toJson(CountMessageTokensRequestModel data) {
    return switch (data) {
      CountMessageTokensRequestModelEnumeration(value: final v) =>
        _$ModelsEnumMap[v]!,
      CountMessageTokensRequestModelString(value: final v) => v,
    };
  }
}

// ==========================================
// CLASS: CountMessageTokensRequestSystem
// ==========================================

/// System prompt.
///
/// A system prompt is a way of providing context and instructions to Claude, such
/// as specifying a particular goal or role. See our
/// [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
@freezed
sealed class CountMessageTokensRequestSystem
    with _$CountMessageTokensRequestSystem {
  const CountMessageTokensRequestSystem._();

  /// An array of content blocks.
  const factory CountMessageTokensRequestSystem.listBlock(List<Block> value) =
      CountMessageTokensRequestSystemListBlock;

  /// A single text block.
  const factory CountMessageTokensRequestSystem.string(String value) =
      CountMessageTokensRequestSystemString;

  /// Object construction from a JSON representation
  factory CountMessageTokensRequestSystem.fromJson(Map<String, dynamic> json) =>
      _$CountMessageTokensRequestSystemFromJson(json);
}

/// Custom JSON converter for [CountMessageTokensRequestSystem]
class _CountMessageTokensRequestSystemConverter
    implements JsonConverter<CountMessageTokensRequestSystem?, Object?> {
  const _CountMessageTokensRequestSystemConverter();

  @override
  CountMessageTokensRequestSystem? fromJson(Object? data) {
    if (data == null) {
      return null;
    }
    if (data is List && data.every((item) => item is Map)) {
      return CountMessageTokensRequestSystemListBlock(
        data
            .map((i) => Block.fromJson(i as Map<String, dynamic>))
            .toList(growable: false),
      );
    }
    if (data is String) {
      return CountMessageTokensRequestSystemString(data);
    }
    throw Exception(
      'Unexpected value for CountMessageTokensRequestSystem: $data',
    );
  }

  @override
  Object? toJson(CountMessageTokensRequestSystem? data) {
    return switch (data) {
      CountMessageTokensRequestSystemListBlock(value: final v) => v,
      CountMessageTokensRequestSystemString(value: final v) => v,
      null => null,
    };
  }
}
