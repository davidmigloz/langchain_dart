// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schema.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

CreateCompletionRequest _$CreateCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionRequest {
  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model => throw _privateConstructorUsedError;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt => throw _privateConstructorUsedError;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf => throw _privateConstructorUsedError;

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop => throw _privateConstructorUsedError;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// The suffix that comes after a completion of inserted text.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionRequestCopyWith<CreateCompletionRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionRequestCopyWith<$Res> {
  factory $CreateCompletionRequestCopyWith(CreateCompletionRequest value,
          $Res Function(CreateCompletionRequest) then) =
      _$CreateCompletionRequestCopyWithImpl<$Res, CreateCompletionRequest>;
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  $CompletionModelCopyWith<$Res> get model;
  $CompletionPromptCopyWith<$Res>? get prompt;
  $CompletionStopCopyWith<$Res>? get stop;
}

/// @nodoc
class _$CreateCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateCompletionRequest>
    implements $CreateCompletionRequestCopyWith<$Res> {
  _$CreateCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionModelCopyWith<$Res> get model {
    return $CompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionPromptCopyWith<$Res>? get prompt {
    if (_value.prompt == null) {
      return null;
    }

    return $CompletionPromptCopyWith<$Res>(_value.prompt!, (value) {
      return _then(_value.copyWith(prompt: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $CompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionRequestImplCopyWith<$Res>
    implements $CreateCompletionRequestCopyWith<$Res> {
  factory _$$CreateCompletionRequestImplCopyWith(
          _$CreateCompletionRequestImpl value,
          $Res Function(_$CreateCompletionRequestImpl) then) =
      __$$CreateCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CompletionModelCopyWith<$Res> get model;
  @override
  $CompletionPromptCopyWith<$Res>? get prompt;
  @override
  $CompletionStopCopyWith<$Res>? get stop;
}

/// @nodoc
class __$$CreateCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateCompletionRequestCopyWithImpl<$Res,
        _$CreateCompletionRequestImpl>
    implements _$$CreateCompletionRequestImplCopyWith<$Res> {
  __$$CreateCompletionRequestImplCopyWithImpl(
      _$CreateCompletionRequestImpl _value,
      $Res Function(_$CreateCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionRequestImpl extends _CreateCompletionRequest {
  const _$CreateCompletionRequestImpl(
      {@_CompletionModelConverter() required this.model,
      @_CompletionPromptConverter() required this.prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) this.bestOf,
      @JsonKey(includeIfNull: false) this.echo = false,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens = 16,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @JsonKey(includeIfNull: false) this.seed,
      @_CompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) this.user})
      : _logitBias = logitBias,
        super._();

  factory _$CreateCompletionRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @override
  @_CompletionModelConverter()
  final CompletionModel model;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @override
  @_CompletionPromptConverter()
  final CompletionPrompt? prompt;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(name: 'best_of', includeIfNull: false)
  final int? bestOf;

  /// Echo back the prompt in addition to the completion
  @override
  @JsonKey(includeIfNull: false)
  final bool? echo;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @override
  @JsonKey(includeIfNull: false)
  final int? logprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @override
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final CompletionStop? stop;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// The suffix that comes after a completion of inserted text.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateCompletionRequest(model: $model, prompt: $prompt, bestOf: $bestOf, echo: $echo, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, seed: $seed, stop: $stop, stream: $stream, suffix: $suffix, temperature: $temperature, topP: $topP, user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.bestOf, bestOf) || other.bestOf == bestOf) &&
            (identical(other.echo, echo) || other.echo == echo) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      prompt,
      bestOf,
      echo,
      frequencyPenalty,
      const DeepCollectionEquality().hash(_logitBias),
      logprobs,
      maxTokens,
      n,
      presencePenalty,
      seed,
      stop,
      stream,
      suffix,
      temperature,
      topP,
      user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => __$$CreateCompletionRequestImplCopyWithImpl<
          _$CreateCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionRequest extends CreateCompletionRequest {
  const factory _CreateCompletionRequest(
      {@_CompletionModelConverter() required final CompletionModel model,
      @_CompletionPromptConverter() required final CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) final int? bestOf,
      @JsonKey(includeIfNull: false) final bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) final int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @JsonKey(includeIfNull: false) final int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final CompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(includeIfNull: false) final String? suffix,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false)
      final String? user}) = _$CreateCompletionRequestImpl;
  const _CreateCompletionRequest._() : super._();

  factory _CreateCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model;
  @override

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt;
  @override

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf;
  @override

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop;
  @override

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// The suffix that comes after a completion of inserted text.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionModel _$CompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return CompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionModelCopyWith<$Res> {
  factory $CompletionModelCopyWith(
          CompletionModel value, $Res Function(CompletionModel) then) =
      _$CompletionModelCopyWithImpl<$Res, CompletionModel>;
}

/// @nodoc
class _$CompletionModelCopyWithImpl<$Res, $Val extends CompletionModel>
    implements $CompletionModelCopyWith<$Res> {
  _$CompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionModelEnumerationImplCopyWith<$Res> {
  factory _$$CompletionModelEnumerationImplCopyWith(
          _$CompletionModelEnumerationImpl value,
          $Res Function(_$CompletionModelEnumerationImpl) then) =
      __$$CompletionModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CompletionModels value});
}

/// @nodoc
class __$$CompletionModelEnumerationImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res,
        _$CompletionModelEnumerationImpl>
    implements _$$CompletionModelEnumerationImplCopyWith<$Res> {
  __$$CompletionModelEnumerationImplCopyWithImpl(
      _$CompletionModelEnumerationImpl _value,
      $Res Function(_$CompletionModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionModelEnumerationImpl extends CompletionModelEnumeration {
  const _$CompletionModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$CompletionModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionModelEnumerationImplFromJson(json);

  @override
  final CompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.model(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionModelEnumerationImplCopyWith<_$CompletionModelEnumerationImpl>
      get copyWith => __$$CompletionModelEnumerationImplCopyWithImpl<
          _$CompletionModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class CompletionModelEnumeration extends CompletionModel {
  const factory CompletionModelEnumeration(final CompletionModels value) =
      _$CompletionModelEnumerationImpl;
  const CompletionModelEnumeration._() : super._();

  factory CompletionModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$CompletionModelEnumerationImpl.fromJson;

  @override
  CompletionModels get value;
  @JsonKey(ignore: true)
  _$$CompletionModelEnumerationImplCopyWith<_$CompletionModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionModelStringImplCopyWith<$Res> {
  factory _$$CompletionModelStringImplCopyWith(
          _$CompletionModelStringImpl value,
          $Res Function(_$CompletionModelStringImpl) then) =
      __$$CompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CompletionModelStringImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res, _$CompletionModelStringImpl>
    implements _$$CompletionModelStringImplCopyWith<$Res> {
  __$$CompletionModelStringImplCopyWithImpl(_$CompletionModelStringImpl _value,
      $Res Function(_$CompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionModelStringImpl extends CompletionModelString {
  const _$CompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$CompletionModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.modelId(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionModelStringImplCopyWith<_$CompletionModelStringImpl>
      get copyWith => __$$CompletionModelStringImplCopyWithImpl<
          _$CompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class CompletionModelString extends CompletionModel {
  const factory CompletionModelString(final String value) =
      _$CompletionModelStringImpl;
  const CompletionModelString._() : super._();

  factory CompletionModelString.fromJson(Map<String, dynamic> json) =
      _$CompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CompletionModelStringImplCopyWith<_$CompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionPrompt _$CompletionPromptFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return CompletionPromptListListInt.fromJson(json);
    case 'tokens':
      return CompletionPromptListInt.fromJson(json);
    case 'listString':
      return CompletionPromptListString.fromJson(json);
    case 'string':
      return CompletionPromptString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionPrompt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionPrompt {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptCopyWith(
          CompletionPrompt value, $Res Function(CompletionPrompt) then) =
      _$CompletionPromptCopyWithImpl<$Res, CompletionPrompt>;
}

/// @nodoc
class _$CompletionPromptCopyWithImpl<$Res, $Val extends CompletionPrompt>
    implements $CompletionPromptCopyWith<$Res> {
  _$CompletionPromptCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionPromptListListIntImplCopyWith<$Res> {
  factory _$$CompletionPromptListListIntImplCopyWith(
          _$CompletionPromptListListIntImpl value,
          $Res Function(_$CompletionPromptListListIntImpl) then) =
      __$$CompletionPromptListListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$CompletionPromptListListIntImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$CompletionPromptListListIntImpl>
    implements _$$CompletionPromptListListIntImplCopyWith<$Res> {
  __$$CompletionPromptListListIntImplCopyWithImpl(
      _$CompletionPromptListListIntImpl _value,
      $Res Function(_$CompletionPromptListListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListListIntImpl extends CompletionPromptListListInt {
  const _$CompletionPromptListListIntImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();

  factory _$CompletionPromptListListIntImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionPromptListListIntImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.listTokens(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListListIntImplCopyWith<_$CompletionPromptListListIntImpl>
      get copyWith => __$$CompletionPromptListListIntImplCopyWithImpl<
          _$CompletionPromptListListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listTokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listTokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return listTokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return listTokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListListIntImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListListInt extends CompletionPrompt {
  const factory CompletionPromptListListInt(final List<List<int>> value) =
      _$CompletionPromptListListIntImpl;
  const CompletionPromptListListInt._() : super._();

  factory CompletionPromptListListInt.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListListIntImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListListIntImplCopyWith<_$CompletionPromptListListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptListIntImplCopyWith<$Res> {
  factory _$$CompletionPromptListIntImplCopyWith(
          _$CompletionPromptListIntImpl value,
          $Res Function(_$CompletionPromptListIntImpl) then) =
      __$$CompletionPromptListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$CompletionPromptListIntImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res, _$CompletionPromptListIntImpl>
    implements _$$CompletionPromptListIntImplCopyWith<$Res> {
  __$$CompletionPromptListIntImplCopyWithImpl(
      _$CompletionPromptListIntImpl _value,
      $Res Function(_$CompletionPromptListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListIntImpl extends CompletionPromptListInt {
  const _$CompletionPromptListIntImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();

  factory _$CompletionPromptListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionPromptListIntImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.tokens(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListIntImplCopyWith<_$CompletionPromptListIntImpl>
      get copyWith => __$$CompletionPromptListIntImplCopyWithImpl<
          _$CompletionPromptListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return tokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return tokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return tokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return tokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListIntImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListInt extends CompletionPrompt {
  const factory CompletionPromptListInt(final List<int> value) =
      _$CompletionPromptListIntImpl;
  const CompletionPromptListInt._() : super._();

  factory CompletionPromptListInt.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListIntImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListIntImplCopyWith<_$CompletionPromptListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptListStringImplCopyWith<$Res> {
  factory _$$CompletionPromptListStringImplCopyWith(
          _$CompletionPromptListStringImpl value,
          $Res Function(_$CompletionPromptListStringImpl) then) =
      __$$CompletionPromptListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$CompletionPromptListStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$CompletionPromptListStringImpl>
    implements _$$CompletionPromptListStringImplCopyWith<$Res> {
  __$$CompletionPromptListStringImplCopyWithImpl(
      _$CompletionPromptListStringImpl _value,
      $Res Function(_$CompletionPromptListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListStringImpl extends CompletionPromptListString {
  const _$CompletionPromptListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$CompletionPromptListStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionPromptListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.listString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListStringImplCopyWith<_$CompletionPromptListStringImpl>
      get copyWith => __$$CompletionPromptListStringImplCopyWithImpl<
          _$CompletionPromptListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListStringImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListString extends CompletionPrompt {
  const factory CompletionPromptListString(final List<String> value) =
      _$CompletionPromptListStringImpl;
  const CompletionPromptListString._() : super._();

  factory CompletionPromptListString.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListStringImplCopyWith<_$CompletionPromptListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptStringImplCopyWith<$Res> {
  factory _$$CompletionPromptStringImplCopyWith(
          _$CompletionPromptStringImpl value,
          $Res Function(_$CompletionPromptStringImpl) then) =
      __$$CompletionPromptStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CompletionPromptStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res, _$CompletionPromptStringImpl>
    implements _$$CompletionPromptStringImplCopyWith<$Res> {
  __$$CompletionPromptStringImplCopyWithImpl(
      _$CompletionPromptStringImpl _value,
      $Res Function(_$CompletionPromptStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptStringImpl extends CompletionPromptString {
  const _$CompletionPromptStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$CompletionPromptStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionPromptStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptStringImplCopyWith<_$CompletionPromptStringImpl>
      get copyWith => __$$CompletionPromptStringImplCopyWithImpl<
          _$CompletionPromptStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptStringImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptString extends CompletionPrompt {
  const factory CompletionPromptString(final String value) =
      _$CompletionPromptStringImpl;
  const CompletionPromptString._() : super._();

  factory CompletionPromptString.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptStringImplCopyWith<_$CompletionPromptStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionStop _$CompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return CompletionStopListString.fromJson(json);
    case 'string':
      return CompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionStop {
  Object? get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionStopCopyWith<$Res> {
  factory $CompletionStopCopyWith(
          CompletionStop value, $Res Function(CompletionStop) then) =
      _$CompletionStopCopyWithImpl<$Res, CompletionStop>;
}

/// @nodoc
class _$CompletionStopCopyWithImpl<$Res, $Val extends CompletionStop>
    implements $CompletionStopCopyWith<$Res> {
  _$CompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionStopListStringImplCopyWith<$Res> {
  factory _$$CompletionStopListStringImplCopyWith(
          _$CompletionStopListStringImpl value,
          $Res Function(_$CompletionStopListStringImpl) then) =
      __$$CompletionStopListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$CompletionStopListStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res, _$CompletionStopListStringImpl>
    implements _$$CompletionStopListStringImplCopyWith<$Res> {
  __$$CompletionStopListStringImplCopyWithImpl(
      _$CompletionStopListStringImpl _value,
      $Res Function(_$CompletionStopListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionStopListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionStopListStringImpl extends CompletionStopListString {
  const _$CompletionStopListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$CompletionStopListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionStopListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.listString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionStopListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionStopListStringImplCopyWith<_$CompletionStopListStringImpl>
      get copyWith => __$$CompletionStopListStringImplCopyWithImpl<
          _$CompletionStopListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionStopListStringImplToJson(
      this,
    );
  }
}

abstract class CompletionStopListString extends CompletionStop {
  const factory CompletionStopListString(final List<String> value) =
      _$CompletionStopListStringImpl;
  const CompletionStopListString._() : super._();

  factory CompletionStopListString.fromJson(Map<String, dynamic> json) =
      _$CompletionStopListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$CompletionStopListStringImplCopyWith<_$CompletionStopListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionStopStringImplCopyWith<$Res> {
  factory _$$CompletionStopStringImplCopyWith(_$CompletionStopStringImpl value,
          $Res Function(_$CompletionStopStringImpl) then) =
      __$$CompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class __$$CompletionStopStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res, _$CompletionStopStringImpl>
    implements _$$CompletionStopStringImplCopyWith<$Res> {
  __$$CompletionStopStringImplCopyWithImpl(_$CompletionStopStringImpl _value,
      $Res Function(_$CompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$CompletionStopStringImpl(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionStopStringImpl extends CompletionStopString {
  const _$CompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$CompletionStopStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionStopStringImplFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionStopStringImplCopyWith<_$CompletionStopStringImpl>
      get copyWith =>
          __$$CompletionStopStringImplCopyWithImpl<_$CompletionStopStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class CompletionStopString extends CompletionStop {
  const factory CompletionStopString(final String? value) =
      _$CompletionStopStringImpl;
  const CompletionStopString._() : super._();

  factory CompletionStopString.fromJson(Map<String, dynamic> json) =
      _$CompletionStopStringImpl.fromJson;

  @override
  String? get value;
  @JsonKey(ignore: true)
  _$$CompletionStopStringImplCopyWith<_$CompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateCompletionResponse _$CreateCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionResponse {
  /// A unique identifier for the completion.
  String get id => throw _privateConstructorUsedError;

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always "text_completion"
  CreateCompletionResponseObject get object =>
      throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionResponseCopyWith<CreateCompletionResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionResponseCopyWith<$Res> {
  factory $CreateCompletionResponseCopyWith(CreateCompletionResponse value,
          $Res Function(CreateCompletionResponse) then) =
      _$CreateCompletionResponseCopyWithImpl<$Res, CreateCompletionResponse>;
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateCompletionResponse>
    implements $CreateCompletionResponseCopyWith<$Res> {
  _$CreateCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionResponseImplCopyWith<$Res>
    implements $CreateCompletionResponseCopyWith<$Res> {
  factory _$$CreateCompletionResponseImplCopyWith(
          _$CreateCompletionResponseImpl value,
          $Res Function(_$CreateCompletionResponseImpl) then) =
      __$$CreateCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateCompletionResponseCopyWithImpl<$Res,
        _$CreateCompletionResponseImpl>
    implements _$$CreateCompletionResponseImplCopyWith<$Res> {
  __$$CreateCompletionResponseImplCopyWithImpl(
      _$CreateCompletionResponseImpl _value,
      $Res Function(_$CreateCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateCompletionResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionResponseImpl extends _CreateCompletionResponse {
  const _$CreateCompletionResponseImpl(
      {required this.id,
      required final List<CompletionChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateCompletionResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionResponseImplFromJson(json);

  /// A unique identifier for the completion.
  @override
  final String id;

  /// The list of completion choices the model generated for the input prompt.
  final List<CompletionChoice> _choices;

  /// The list of completion choices the model generated for the input prompt.
  @override
  List<CompletionChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the completion was created.
  @override
  final int created;

  /// The model used for completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always "text_completion"
  @override
  final CreateCompletionResponseObject object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => __$$CreateCompletionResponseImplCopyWithImpl<
          _$CreateCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionResponse extends CreateCompletionResponse {
  const factory _CreateCompletionResponse(
          {required final String id,
          required final List<CompletionChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final CreateCompletionResponseObject object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateCompletionResponseImpl;
  const _CreateCompletionResponse._() : super._();

  factory _CreateCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the completion.
  String get id;
  @override

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created;
  @override

  /// The model used for completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always "text_completion"
  CreateCompletionResponseObject get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionChoice _$CompletionChoiceFromJson(Map<String, dynamic> json) {
  return _CompletionChoice.fromJson(json);
}

/// @nodoc
mixin _$CompletionChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of generated choices.
  int get index => throw _privateConstructorUsedError;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs => throw _privateConstructorUsedError;

  /// The text of the completion.
  String get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionChoiceCopyWith<CompletionChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionChoiceCopyWith<$Res> {
  factory $CompletionChoiceCopyWith(
          CompletionChoice value, $Res Function(CompletionChoice) then) =
      _$CompletionChoiceCopyWithImpl<$Res, CompletionChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$CompletionChoiceCopyWithImpl<$Res, $Val extends CompletionChoice>
    implements $CompletionChoiceCopyWith<$Res> {
  _$CompletionChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_value.copyWith(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $CompletionLogprobsCopyWith<$Res>(_value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CompletionChoiceImplCopyWith<$Res>
    implements $CompletionChoiceCopyWith<$Res> {
  factory _$$CompletionChoiceImplCopyWith(_$CompletionChoiceImpl value,
          $Res Function(_$CompletionChoiceImpl) then) =
      __$$CompletionChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  @override
  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$CompletionChoiceImplCopyWithImpl<$Res>
    extends _$CompletionChoiceCopyWithImpl<$Res, _$CompletionChoiceImpl>
    implements _$$CompletionChoiceImplCopyWith<$Res> {
  __$$CompletionChoiceImplCopyWithImpl(_$CompletionChoiceImpl _value,
      $Res Function(_$CompletionChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_$CompletionChoiceImpl(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionChoiceImpl extends _CompletionChoice {
  const _$CompletionChoiceImpl(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index,
      required this.logprobs,
      required this.text})
      : super._();

  factory _$CompletionChoiceImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final CompletionFinishReason? finishReason;

  /// The index of the choice in the list of generated choices.
  @override
  final int index;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  @override
  final CompletionLogprobs? logprobs;

  /// The text of the completion.
  @override
  final String text;

  @override
  String toString() {
    return 'CompletionChoice(finishReason: $finishReason, index: $index, logprobs: $logprobs, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, finishReason, index, logprobs, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      __$$CompletionChoiceImplCopyWithImpl<_$CompletionChoiceImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionChoiceImplToJson(
      this,
    );
  }
}

abstract class _CompletionChoice extends CompletionChoice {
  const factory _CompletionChoice(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required final CompletionFinishReason? finishReason,
      required final int index,
      required final CompletionLogprobs? logprobs,
      required final String text}) = _$CompletionChoiceImpl;
  const _CompletionChoice._() : super._();

  factory _CompletionChoice.fromJson(Map<String, dynamic> json) =
      _$CompletionChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of generated choices.
  int get index;
  @override

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs;
  @override

  /// The text of the completion.
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CompletionLogprobs _$CompletionLogprobsFromJson(Map<String, dynamic> json) {
  return _CompletionLogprobs.fromJson(json);
}

/// @nodoc
mixin _$CompletionLogprobs {
  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset => throw _privateConstructorUsedError;

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs => throw _privateConstructorUsedError;

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens => throw _privateConstructorUsedError;

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionLogprobsCopyWith<CompletionLogprobs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionLogprobsCopyWith<$Res> {
  factory $CompletionLogprobsCopyWith(
          CompletionLogprobs value, $Res Function(CompletionLogprobs) then) =
      _$CompletionLogprobsCopyWithImpl<$Res, CompletionLogprobs>;
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class _$CompletionLogprobsCopyWithImpl<$Res, $Val extends CompletionLogprobs>
    implements $CompletionLogprobsCopyWith<$Res> {
  _$CompletionLogprobsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_value.copyWith(
      textOffset: freezed == textOffset
          ? _value.textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value.tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value.tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionLogprobsImplCopyWith<$Res>
    implements $CompletionLogprobsCopyWith<$Res> {
  factory _$$CompletionLogprobsImplCopyWith(_$CompletionLogprobsImpl value,
          $Res Function(_$CompletionLogprobsImpl) then) =
      __$$CompletionLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class __$$CompletionLogprobsImplCopyWithImpl<$Res>
    extends _$CompletionLogprobsCopyWithImpl<$Res, _$CompletionLogprobsImpl>
    implements _$$CompletionLogprobsImplCopyWith<$Res> {
  __$$CompletionLogprobsImplCopyWithImpl(_$CompletionLogprobsImpl _value,
      $Res Function(_$CompletionLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_$CompletionLogprobsImpl(
      textOffset: freezed == textOffset
          ? _value._textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value._tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value._tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionLogprobsImpl extends _CompletionLogprobs {
  const _$CompletionLogprobsImpl(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      final List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      final List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) final List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      final List<Map<String, double>?>? topLogprobs})
      : _textOffset = textOffset,
        _tokenLogprobs = tokenLogprobs,
        _tokens = tokens,
        _topLogprobs = topLogprobs,
        super._();

  factory _$CompletionLogprobsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionLogprobsImplFromJson(json);

  /// The offset of the token from the beginning of the prompt.
  final List<int>? _textOffset;

  /// The offset of the token from the beginning of the prompt.
  @override
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset {
    final value = _textOffset;
    if (value == null) return null;
    if (_textOffset is EqualUnmodifiableListView) return _textOffset;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of tokens in the completion.
  final List<double?>? _tokenLogprobs;

  /// The log probabilities of tokens in the completion.
  @override
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs {
    final value = _tokenLogprobs;
    if (value == null) return null;
    if (_tokenLogprobs is EqualUnmodifiableListView) return _tokenLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The tokens generated by the model converted back to text.
  final List<String>? _tokens;

  /// The tokens generated by the model converted back to text.
  @override
  @JsonKey(includeIfNull: false)
  List<String>? get tokens {
    final value = _tokens;
    if (value == null) return null;
    if (_tokens is EqualUnmodifiableListView) return _tokens;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of the `logprobs` most likely tokens.
  final List<Map<String, double>?>? _topLogprobs;

  /// The log probabilities of the `logprobs` most likely tokens.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs {
    final value = _topLogprobs;
    if (value == null) return null;
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CompletionLogprobs(textOffset: $textOffset, tokenLogprobs: $tokenLogprobs, tokens: $tokens, topLogprobs: $topLogprobs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionLogprobsImpl &&
            const DeepCollectionEquality()
                .equals(other._textOffset, _textOffset) &&
            const DeepCollectionEquality()
                .equals(other._tokenLogprobs, _tokenLogprobs) &&
            const DeepCollectionEquality().equals(other._tokens, _tokens) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_textOffset),
      const DeepCollectionEquality().hash(_tokenLogprobs),
      const DeepCollectionEquality().hash(_tokens),
      const DeepCollectionEquality().hash(_topLogprobs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      __$$CompletionLogprobsImplCopyWithImpl<_$CompletionLogprobsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionLogprobsImplToJson(
      this,
    );
  }
}

abstract class _CompletionLogprobs extends CompletionLogprobs {
  const factory _CompletionLogprobs(
          {@JsonKey(name: 'text_offset', includeIfNull: false)
          final List<int>? textOffset,
          @JsonKey(name: 'token_logprobs', includeIfNull: false)
          final List<double?>? tokenLogprobs,
          @JsonKey(includeIfNull: false) final List<String>? tokens,
          @JsonKey(name: 'top_logprobs', includeIfNull: false)
          final List<Map<String, double>?>? topLogprobs}) =
      _$CompletionLogprobsImpl;
  const _CompletionLogprobs._() : super._();

  factory _CompletionLogprobs.fromJson(Map<String, dynamic> json) =
      _$CompletionLogprobsImpl.fromJson;

  @override

  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset;
  @override

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs;
  @override

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens;
  @override

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs;
  @override
  @JsonKey(ignore: true)
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateChatCompletionRequest _$CreateChatCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionRequest {
  /// ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model => throw _privateConstructorUsedError;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages =>
      throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many chat completion choices to generate for each input message.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// An object specifying the format that the model must output.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in increased latency and appearance of a "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop => throw _privateConstructorUsedError;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools => throw _privateConstructorUsedError;

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type: "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice =>
      throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto`` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionRequestCopyWith<CreateChatCompletionRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionRequestCopyWith<$Res> {
  factory $CreateChatCompletionRequestCopyWith(
          CreateChatCompletionRequest value,
          $Res Function(CreateChatCompletionRequest) then) =
      _$CreateChatCompletionRequestCopyWithImpl<$Res,
          CreateChatCompletionRequest>;
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions});

  $ChatCompletionModelCopyWith<$Res> get model;
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  $ChatCompletionStopCopyWith<$Res>? get stop;
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$CreateChatCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateChatCompletionRequest>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  _$CreateChatCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value.functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionModelCopyWith<$Res> get model {
    return $ChatCompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $ChatCompletionResponseFormatCopyWith<$Res>(_value.responseFormat!,
        (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $ChatCompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice {
    if (_value.toolChoice == null) {
      return null;
    }

    return $ChatCompletionToolChoiceOptionCopyWith<$Res>(_value.toolChoice!,
        (value) {
      return _then(_value.copyWith(toolChoice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionFunctionCallCopyWith<$Res>(_value.functionCall!,
        (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionRequestImplCopyWith<$Res>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  factory _$$CreateChatCompletionRequestImplCopyWith(
          _$CreateChatCompletionRequestImpl value,
          $Res Function(_$CreateChatCompletionRequestImpl) then) =
      __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions});

  @override
  $ChatCompletionModelCopyWith<$Res> get model;
  @override
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  @override
  $ChatCompletionStopCopyWith<$Res>? get stop;
  @override
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  @override
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionRequestCopyWithImpl<$Res,
        _$CreateChatCompletionRequestImpl>
    implements _$$CreateChatCompletionRequestImplCopyWith<$Res> {
  __$$CreateChatCompletionRequestImplCopyWithImpl(
      _$CreateChatCompletionRequestImpl _value,
      $Res Function(_$CreateChatCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_$CreateChatCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value._functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionRequestImpl extends _CreateChatCompletionRequest {
  const _$CreateChatCompletionRequestImpl(
      {@_ChatCompletionModelConverter() required this.model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.seed,
      @_ChatCompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(includeIfNull: false) this.user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      this.functionCall,
      @JsonKey(includeIfNull: false) final List<FunctionObject>? functions})
      : _messages = messages,
        _logitBias = logitBias,
        _tools = tools,
        _functions = functions,
        super._();

  factory _$CreateChatCompletionRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionRequestImplFromJson(json);

  /// ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @override
  @_ChatCompletionModelConverter()
  final ChatCompletionModel model;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  final List<ChatCompletionMessage> _messages;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  @override
  List<ChatCompletionMessage> get messages {
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_messages);
  }

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many chat completion choices to generate for each input message.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// An object specifying the format that the model must output.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in increased latency and appearance of a "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @JsonKey(name: 'response_format', includeIfNull: false)
  final ChatCompletionResponseFormat? responseFormat;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @override
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final ChatCompletionStop? stop;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  final List<ChatCompletionTool>? _tools;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type: "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @override
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final ChatCompletionToolChoiceOption? toolChoice;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto`` is the default if functions are present.
  @override
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionFunctionCall? functionCall;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  final List<FunctionObject>? _functions;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions {
    final value = _functions;
    if (value == null) return null;
    if (_functions is EqualUnmodifiableListView) return _functions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CreateChatCompletionRequest(model: $model, messages: $messages, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, responseFormat: $responseFormat, seed: $seed, stop: $stop, stream: $stream, temperature: $temperature, topP: $topP, tools: $tools, toolChoice: $toolChoice, user: $user, functionCall: $functionCall, functions: $functions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._functions, _functions));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      const DeepCollectionEquality().hash(_messages),
      frequencyPenalty,
      const DeepCollectionEquality().hash(_logitBias),
      maxTokens,
      n,
      presencePenalty,
      responseFormat,
      seed,
      stop,
      stream,
      temperature,
      topP,
      const DeepCollectionEquality().hash(_tools),
      toolChoice,
      user,
      functionCall,
      const DeepCollectionEquality().hash(_functions));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => __$$CreateChatCompletionRequestImplCopyWithImpl<
          _$CreateChatCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionRequest
    extends CreateChatCompletionRequest {
  const factory _CreateChatCompletionRequest(
      {@_ChatCompletionModelConverter()
      required final ChatCompletionModel model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      final ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) final int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      final ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) final String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      final ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false)
      final List<FunctionObject>?
          functions}) = _$CreateChatCompletionRequestImpl;
  const _CreateChatCompletionRequest._() : super._();

  factory _CreateChatCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model;
  @override

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many chat completion choices to generate for each input message.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// An object specifying the format that the model must output.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in increased latency and appearance of a "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat;
  @override

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop;
  @override

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools;
  @override

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type: "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto`` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall;
  @override

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionModel _$ChatCompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ChatCompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return ChatCompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionModelCopyWith<$Res> {
  factory $ChatCompletionModelCopyWith(
          ChatCompletionModel value, $Res Function(ChatCompletionModel) then) =
      _$ChatCompletionModelCopyWithImpl<$Res, ChatCompletionModel>;
}

/// @nodoc
class _$ChatCompletionModelCopyWithImpl<$Res, $Val extends ChatCompletionModel>
    implements $ChatCompletionModelCopyWith<$Res> {
  _$ChatCompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionModelEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionModelEnumerationImplCopyWith(
          _$ChatCompletionModelEnumerationImpl value,
          $Res Function(_$ChatCompletionModelEnumerationImpl) then) =
      __$$ChatCompletionModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionModels value});
}

/// @nodoc
class __$$ChatCompletionModelEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$ChatCompletionModelEnumerationImpl>
    implements _$$ChatCompletionModelEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionModelEnumerationImplCopyWithImpl(
      _$ChatCompletionModelEnumerationImpl _value,
      $Res Function(_$ChatCompletionModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionModelEnumerationImpl
    extends ChatCompletionModelEnumeration {
  const _$ChatCompletionModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$ChatCompletionModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionModelEnumerationImplFromJson(json);

  @override
  final ChatCompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.model(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionModelEnumerationImplCopyWith<
          _$ChatCompletionModelEnumerationImpl>
      get copyWith => __$$ChatCompletionModelEnumerationImplCopyWithImpl<
          _$ChatCompletionModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionModelEnumeration extends ChatCompletionModel {
  const factory ChatCompletionModelEnumeration(
      final ChatCompletionModels value) = _$ChatCompletionModelEnumerationImpl;
  const ChatCompletionModelEnumeration._() : super._();

  factory ChatCompletionModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionModelEnumerationImpl.fromJson;

  @override
  ChatCompletionModels get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionModelEnumerationImplCopyWith<
          _$ChatCompletionModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionModelStringImplCopyWith<$Res> {
  factory _$$ChatCompletionModelStringImplCopyWith(
          _$ChatCompletionModelStringImpl value,
          $Res Function(_$ChatCompletionModelStringImpl) then) =
      __$$ChatCompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ChatCompletionModelStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$ChatCompletionModelStringImpl>
    implements _$$ChatCompletionModelStringImplCopyWith<$Res> {
  __$$ChatCompletionModelStringImplCopyWithImpl(
      _$ChatCompletionModelStringImpl _value,
      $Res Function(_$ChatCompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionModelStringImpl extends ChatCompletionModelString {
  const _$ChatCompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$ChatCompletionModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.modelId(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionModelStringImplCopyWith<_$ChatCompletionModelStringImpl>
      get copyWith => __$$ChatCompletionModelStringImplCopyWithImpl<
          _$ChatCompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionModelString extends ChatCompletionModel {
  const factory ChatCompletionModelString(final String value) =
      _$ChatCompletionModelStringImpl;
  const ChatCompletionModelString._() : super._();

  factory ChatCompletionModelString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionModelStringImplCopyWith<_$ChatCompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseFormat _$ChatCompletionResponseFormatFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseFormat.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseFormat {
  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseFormatCopyWith<ChatCompletionResponseFormat>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseFormatCopyWith<$Res> {
  factory $ChatCompletionResponseFormatCopyWith(
          ChatCompletionResponseFormat value,
          $Res Function(ChatCompletionResponseFormat) then) =
      _$ChatCompletionResponseFormatCopyWithImpl<$Res,
          ChatCompletionResponseFormat>;
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseFormat>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  _$ChatCompletionResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseFormatImplCopyWith<$Res>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  factory _$$ChatCompletionResponseFormatImplCopyWith(
          _$ChatCompletionResponseFormatImpl value,
          $Res Function(_$ChatCompletionResponseFormatImpl) then) =
      __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        _$ChatCompletionResponseFormatImpl>
    implements _$$ChatCompletionResponseFormatImplCopyWith<$Res> {
  __$$ChatCompletionResponseFormatImplCopyWithImpl(
      _$ChatCompletionResponseFormatImpl _value,
      $Res Function(_$ChatCompletionResponseFormatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$ChatCompletionResponseFormatImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseFormatImpl extends _ChatCompletionResponseFormat {
  const _$ChatCompletionResponseFormatImpl(
      {this.type = ChatCompletionResponseFormatType.text})
      : super._();

  factory _$ChatCompletionResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseFormatImplFromJson(json);

  /// Must be one of `text` or `json_object`.
  @override
  @JsonKey()
  final ChatCompletionResponseFormatType type;

  @override
  String toString() {
    return 'ChatCompletionResponseFormat(type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseFormatImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => __$$ChatCompletionResponseFormatImplCopyWithImpl<
          _$ChatCompletionResponseFormatImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseFormatImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseFormat
    extends ChatCompletionResponseFormat {
  const factory _ChatCompletionResponseFormat(
          {final ChatCompletionResponseFormatType type}) =
      _$ChatCompletionResponseFormatImpl;
  const _ChatCompletionResponseFormat._() : super._();

  factory _ChatCompletionResponseFormat.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseFormatImpl.fromJson;

  @override

  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStop _$ChatCompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return ChatCompletionStopListString.fromJson(json);
    case 'string':
      return ChatCompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionStop {
  Object? get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStopCopyWith<$Res> {
  factory $ChatCompletionStopCopyWith(
          ChatCompletionStop value, $Res Function(ChatCompletionStop) then) =
      _$ChatCompletionStopCopyWithImpl<$Res, ChatCompletionStop>;
}

/// @nodoc
class _$ChatCompletionStopCopyWithImpl<$Res, $Val extends ChatCompletionStop>
    implements $ChatCompletionStopCopyWith<$Res> {
  _$ChatCompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionStopListStringImplCopyWith<$Res> {
  factory _$$ChatCompletionStopListStringImplCopyWith(
          _$ChatCompletionStopListStringImpl value,
          $Res Function(_$ChatCompletionStopListStringImpl) then) =
      __$$ChatCompletionStopListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$ChatCompletionStopListStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$ChatCompletionStopListStringImpl>
    implements _$$ChatCompletionStopListStringImplCopyWith<$Res> {
  __$$ChatCompletionStopListStringImplCopyWithImpl(
      _$ChatCompletionStopListStringImpl _value,
      $Res Function(_$ChatCompletionStopListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionStopListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStopListStringImpl extends ChatCompletionStopListString {
  const _$ChatCompletionStopListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$ChatCompletionStopListStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStopListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.listString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStopListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStopListStringImplCopyWith<
          _$ChatCompletionStopListStringImpl>
      get copyWith => __$$ChatCompletionStopListStringImplCopyWithImpl<
          _$ChatCompletionStopListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStopListStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionStopListString extends ChatCompletionStop {
  const factory ChatCompletionStopListString(final List<String> value) =
      _$ChatCompletionStopListStringImpl;
  const ChatCompletionStopListString._() : super._();

  factory ChatCompletionStopListString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionStopListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionStopListStringImplCopyWith<
          _$ChatCompletionStopListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionStopStringImplCopyWith<$Res> {
  factory _$$ChatCompletionStopStringImplCopyWith(
          _$ChatCompletionStopStringImpl value,
          $Res Function(_$ChatCompletionStopStringImpl) then) =
      __$$ChatCompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class __$$ChatCompletionStopStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$ChatCompletionStopStringImpl>
    implements _$$ChatCompletionStopStringImplCopyWith<$Res> {
  __$$ChatCompletionStopStringImplCopyWithImpl(
      _$ChatCompletionStopStringImpl _value,
      $Res Function(_$ChatCompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$ChatCompletionStopStringImpl(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStopStringImpl extends ChatCompletionStopString {
  const _$ChatCompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ChatCompletionStopStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionStopStringImplFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStopStringImplCopyWith<_$ChatCompletionStopStringImpl>
      get copyWith => __$$ChatCompletionStopStringImplCopyWithImpl<
          _$ChatCompletionStopStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionStopString extends ChatCompletionStop {
  const factory ChatCompletionStopString(final String? value) =
      _$ChatCompletionStopStringImpl;
  const ChatCompletionStopString._() : super._();

  factory ChatCompletionStopString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionStopStringImpl.fromJson;

  @override
  String? get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionStopStringImplCopyWith<_$ChatCompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionToolChoiceOption _$ChatCompletionToolChoiceOptionFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionToolChoiceOptionEnumeration.fromJson(json);
    case 'tool':
      return ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionToolChoiceOption',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionToolChoiceOption {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  factory $ChatCompletionToolChoiceOptionCopyWith(
          ChatCompletionToolChoiceOption value,
          $Res Function(ChatCompletionToolChoiceOption) then) =
      _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
          ChatCompletionToolChoiceOption>;
}

/// @nodoc
class _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionToolChoiceOption>
    implements $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  _$ChatCompletionToolChoiceOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith(
          _$ChatCompletionToolChoiceOptionEnumerationImpl value,
          $Res Function(_$ChatCompletionToolChoiceOptionEnumerationImpl) then) =
      __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionToolChoiceMode value});
}

/// @nodoc
class __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$ChatCompletionToolChoiceOptionEnumerationImpl>
    implements _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl(
      _$ChatCompletionToolChoiceOptionEnumerationImpl _value,
      $Res Function(_$ChatCompletionToolChoiceOptionEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionToolChoiceOptionEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolChoiceOptionEnumerationImpl
    extends ChatCompletionToolChoiceOptionEnumeration {
  const _$ChatCompletionToolChoiceOptionEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$ChatCompletionToolChoiceOptionEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionToolChoiceOptionEnumerationImplFromJson(json);

  @override
  final ChatCompletionToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.mode(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolChoiceOptionEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<
          _$ChatCompletionToolChoiceOptionEnumerationImpl>
      get copyWith =>
          __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<
                  _$ChatCompletionToolChoiceOptionEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolChoiceOptionEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolChoiceOptionEnumeration
    extends ChatCompletionToolChoiceOption {
  const factory ChatCompletionToolChoiceOptionEnumeration(
          final ChatCompletionToolChoiceMode value) =
      _$ChatCompletionToolChoiceOptionEnumerationImpl;
  const ChatCompletionToolChoiceOptionEnumeration._() : super._();

  factory ChatCompletionToolChoiceOptionEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionToolChoiceOptionEnumerationImpl.fromJson;

  @override
  ChatCompletionToolChoiceMode get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<
          _$ChatCompletionToolChoiceOptionEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
    $Res> {
  factory _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith(
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl value,
          $Res Function(
                  _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
              then) =
      __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionNamedToolChoice value});

  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
    implements
        _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
            $Res> {
  __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl _value,
      $Res Function(
              _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value {
    return $ChatCompletionNamedToolChoiceCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
    extends ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice {
  const _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();

  factory _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplFromJson(
          json);

  @override
  final ChatCompletionNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.tool(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith =>
          __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
                  _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) {
    return tool(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) {
    return tool?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
    extends ChatCompletionToolChoiceOption {
  const factory ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice(
          final ChatCompletionNamedToolChoice value) =
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl;
  const ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice._()
      : super._();

  factory ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
      .fromJson;

  @override
  ChatCompletionNamedToolChoice get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCall _$ChatCompletionFunctionCallFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionFunctionCallEnumeration.fromJson(json);
    case 'function':
      return ChatCompletionFunctionCallChatCompletionFunctionCallOption
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionFunctionCall',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionFunctionCall {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallCopyWith<$Res> {
  factory $ChatCompletionFunctionCallCopyWith(ChatCompletionFunctionCall value,
          $Res Function(ChatCompletionFunctionCall) then) =
      _$ChatCompletionFunctionCallCopyWithImpl<$Res,
          ChatCompletionFunctionCall>;
}

/// @nodoc
class _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCall>
    implements $ChatCompletionFunctionCallCopyWith<$Res> {
  _$ChatCompletionFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionFunctionCallEnumerationImplCopyWith(
          _$ChatCompletionFunctionCallEnumerationImpl value,
          $Res Function(_$ChatCompletionFunctionCallEnumerationImpl) then) =
      __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallMode value});
}

/// @nodoc
class __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallEnumerationImpl>
    implements _$$ChatCompletionFunctionCallEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl(
      _$ChatCompletionFunctionCallEnumerationImpl _value,
      $Res Function(_$ChatCompletionFunctionCallEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionFunctionCallEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallEnumerationImpl
    extends ChatCompletionFunctionCallEnumeration {
  const _$ChatCompletionFunctionCallEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$ChatCompletionFunctionCallEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallEnumerationImplFromJson(json);

  @override
  final ChatCompletionFunctionCallMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.mode(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionCallEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallEnumerationImplCopyWith<
          _$ChatCompletionFunctionCallEnumerationImpl>
      get copyWith => __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<
          _$ChatCompletionFunctionCallEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionCallEnumeration
    extends ChatCompletionFunctionCall {
  const factory ChatCompletionFunctionCallEnumeration(
          final ChatCompletionFunctionCallMode value) =
      _$ChatCompletionFunctionCallEnumerationImpl;
  const ChatCompletionFunctionCallEnumeration._() : super._();

  factory ChatCompletionFunctionCallEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallEnumerationImpl.fromJson;

  @override
  ChatCompletionFunctionCallMode get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallEnumerationImplCopyWith<
          _$ChatCompletionFunctionCallEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
    $Res> {
  factory _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith(
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl value,
          $Res Function(
                  _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
              then) =
      __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallOption value});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value;
}

/// @nodoc
class __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
    implements
        _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
            $Res> {
  __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl _value,
      $Res Function(
              _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl
    extends ChatCompletionFunctionCallChatCompletionFunctionCallOption {
  const _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'function',
        super._();

  factory _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplFromJson(
          json);

  @override
  final ChatCompletionFunctionCallOption value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.function(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith =>
          __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
                  _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) {
    return function(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) {
    return function?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionCallChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCall {
  const factory ChatCompletionFunctionCallChatCompletionFunctionCallOption(
          final ChatCompletionFunctionCallOption value) =
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl;
  const ChatCompletionFunctionCallChatCompletionFunctionCallOption._()
      : super._();

  factory ChatCompletionFunctionCallChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl.fromJson;

  @override
  ChatCompletionFunctionCallOption get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageFunctionCall _$ChatCompletionMessageFunctionCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageFunctionCall {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageFunctionCallCopyWith<ChatCompletionMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionMessageFunctionCallCopyWith(
          ChatCompletionMessageFunctionCall value,
          $Res Function(ChatCompletionMessageFunctionCall) then) =
      _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionMessageFunctionCall>;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageFunctionCall>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionMessageFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageFunctionCallImplCopyWith(
          _$ChatCompletionMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionMessageFunctionCallImpl) then) =
      __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionMessageFunctionCallImpl>
    implements _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_$ChatCompletionMessageFunctionCallImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageFunctionCallImpl
    extends _ChatCompletionMessageFunctionCall {
  const _$ChatCompletionMessageFunctionCallImpl(
      {required this.name, required this.arguments})
      : super._();

  factory _$ChatCompletionMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  final String arguments;

  @override
  String toString() {
    return 'ChatCompletionMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<
          _$ChatCompletionMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageFunctionCall
    extends ChatCompletionMessageFunctionCall {
  const factory _ChatCompletionMessageFunctionCall(
          {required final String name, required final String arguments}) =
      _$ChatCompletionMessageFunctionCallImpl;
  const _ChatCompletionMessageFunctionCall._() : super._();

  factory _ChatCompletionMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCallOption _$ChatCompletionFunctionCallOptionFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionFunctionCallOption.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionFunctionCallOption {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionFunctionCallOptionCopyWith<ChatCompletionFunctionCallOption>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory $ChatCompletionFunctionCallOptionCopyWith(
          ChatCompletionFunctionCallOption value,
          $Res Function(ChatCompletionFunctionCallOption) then) =
      _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
          ChatCompletionFunctionCallOption>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCallOption>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  _$ChatCompletionFunctionCallOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory _$$ChatCompletionFunctionCallOptionImplCopyWith(
          _$ChatCompletionFunctionCallOptionImpl value,
          $Res Function(_$ChatCompletionFunctionCallOptionImpl) then) =
      __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallOptionImpl>
    implements _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res> {
  __$$ChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$ChatCompletionFunctionCallOptionImpl _value,
      $Res Function(_$ChatCompletionFunctionCallOptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$ChatCompletionFunctionCallOptionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallOptionImpl
    extends _ChatCompletionFunctionCallOption {
  const _$ChatCompletionFunctionCallOptionImpl({required this.name})
      : super._();

  factory _$ChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallOptionImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'ChatCompletionFunctionCallOption(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionCallOptionImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<
          _$ChatCompletionFunctionCallOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCallOption {
  const factory _ChatCompletionFunctionCallOption(
      {required final String name}) = _$ChatCompletionFunctionCallOptionImpl;
  const _ChatCompletionFunctionCallOption._() : super._();

  factory _ChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallOptionImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FunctionObject _$FunctionObjectFromJson(Map<String, dynamic> json) {
  return _FunctionObject.fromJson(json);
}

/// @nodoc
mixin _$FunctionObject {
  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name => throw _privateConstructorUsedError;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  Map<String, dynamic> get parameters => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FunctionObjectCopyWith<FunctionObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FunctionObjectCopyWith<$Res> {
  factory $FunctionObjectCopyWith(
          FunctionObject value, $Res Function(FunctionObject) then) =
      _$FunctionObjectCopyWithImpl<$Res, FunctionObject>;
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      Map<String, dynamic> parameters});
}

/// @nodoc
class _$FunctionObjectCopyWithImpl<$Res, $Val extends FunctionObject>
    implements $FunctionObjectCopyWith<$Res> {
  _$FunctionObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: null == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FunctionObjectImplCopyWith<$Res>
    implements $FunctionObjectCopyWith<$Res> {
  factory _$$FunctionObjectImplCopyWith(_$FunctionObjectImpl value,
          $Res Function(_$FunctionObjectImpl) then) =
      __$$FunctionObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      Map<String, dynamic> parameters});
}

/// @nodoc
class __$$FunctionObjectImplCopyWithImpl<$Res>
    extends _$FunctionObjectCopyWithImpl<$Res, _$FunctionObjectImpl>
    implements _$$FunctionObjectImplCopyWith<$Res> {
  __$$FunctionObjectImplCopyWithImpl(
      _$FunctionObjectImpl _value, $Res Function(_$FunctionObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = null,
  }) {
    return _then(_$FunctionObjectImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: null == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FunctionObjectImpl extends _FunctionObject {
  const _$FunctionObjectImpl(
      {required this.name,
      @JsonKey(includeIfNull: false) this.description,
      required final Map<String, dynamic> parameters})
      : _parameters = parameters,
        super._();

  factory _$FunctionObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$FunctionObjectImplFromJson(json);

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  @override
  final String name;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  final Map<String, dynamic> _parameters;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  @override
  Map<String, dynamic> get parameters {
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_parameters);
  }

  @override
  String toString() {
    return 'FunctionObject(name: $name, description: $description, parameters: $parameters)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FunctionObjectImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(_parameters));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FunctionObjectImplCopyWith<_$FunctionObjectImpl> get copyWith =>
      __$$FunctionObjectImplCopyWithImpl<_$FunctionObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FunctionObjectImplToJson(
      this,
    );
  }
}

abstract class _FunctionObject extends FunctionObject {
  const factory _FunctionObject(
      {required final String name,
      @JsonKey(includeIfNull: false) final String? description,
      required final Map<String, dynamic> parameters}) = _$FunctionObjectImpl;
  const _FunctionObject._() : super._();

  factory _FunctionObject.fromJson(Map<String, dynamic> json) =
      _$FunctionObjectImpl.fromJson;

  @override

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name;
  @override

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  Map<String, dynamic> get parameters;
  @override
  @JsonKey(ignore: true)
  _$$FunctionObjectImplCopyWith<_$FunctionObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionTool _$ChatCompletionToolFromJson(Map<String, dynamic> json) {
  return _ChatCompletionTool.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTool {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type => throw _privateConstructorUsedError;

  /// A function that the model may call.
  FunctionObject get function => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionToolCopyWith<ChatCompletionTool> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolCopyWith<$Res> {
  factory $ChatCompletionToolCopyWith(
          ChatCompletionTool value, $Res Function(ChatCompletionTool) then) =
      _$ChatCompletionToolCopyWithImpl<$Res, ChatCompletionTool>;
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionToolCopyWithImpl<$Res, $Val extends ChatCompletionTool>
    implements $ChatCompletionToolCopyWith<$Res> {
  _$ChatCompletionToolCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionToolImplCopyWith<$Res>
    implements $ChatCompletionToolCopyWith<$Res> {
  factory _$$ChatCompletionToolImplCopyWith(_$ChatCompletionToolImpl value,
          $Res Function(_$ChatCompletionToolImpl) then) =
      __$$ChatCompletionToolImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  @override
  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionToolImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolCopyWithImpl<$Res, _$ChatCompletionToolImpl>
    implements _$$ChatCompletionToolImplCopyWith<$Res> {
  __$$ChatCompletionToolImplCopyWithImpl(_$ChatCompletionToolImpl _value,
      $Res Function(_$ChatCompletionToolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionToolImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolImpl extends _ChatCompletionTool {
  const _$ChatCompletionToolImpl({required this.type, required this.function})
      : super._();

  factory _$ChatCompletionToolImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionToolImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionToolType type;

  /// A function that the model may call.
  @override
  final FunctionObject function;

  @override
  String toString() {
    return 'ChatCompletionTool(type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      __$$ChatCompletionToolImplCopyWithImpl<_$ChatCompletionToolImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTool extends ChatCompletionTool {
  const factory _ChatCompletionTool(
      {required final ChatCompletionToolType type,
      required final FunctionObject function}) = _$ChatCompletionToolImpl;
  const _ChatCompletionTool._() : super._();

  factory _ChatCompletionTool.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionToolImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type;
  @override

  /// A function that the model may call.
  FunctionObject get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionNamedToolChoice _$ChatCompletionNamedToolChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionNamedToolChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionNamedToolChoice {
  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionNamedToolChoiceType? get type =>
      throw _privateConstructorUsedError;

  /// Forces the model to call the specified function.
  @JsonKey(includeIfNull: false)
  ChatCompletionFunctionCallOption? get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionNamedToolChoiceCopyWith<ChatCompletionNamedToolChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory $ChatCompletionNamedToolChoiceCopyWith(
          ChatCompletionNamedToolChoice value,
          $Res Function(ChatCompletionNamedToolChoice) then) =
      _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
          ChatCompletionNamedToolChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionNamedToolChoiceType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionFunctionCallOption? function});

  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionNamedToolChoice>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  _$ChatCompletionNamedToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.function!,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory _$$ChatCompletionNamedToolChoiceImplCopyWith(
          _$ChatCompletionNamedToolChoiceImpl value,
          $Res Function(_$ChatCompletionNamedToolChoiceImpl) then) =
      __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionNamedToolChoiceType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionFunctionCallOption? function});

  @override
  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        _$ChatCompletionNamedToolChoiceImpl>
    implements _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res> {
  __$$ChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$ChatCompletionNamedToolChoiceImpl _value,
      $Res Function(_$ChatCompletionNamedToolChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_$ChatCompletionNamedToolChoiceImpl(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionNamedToolChoiceImpl
    extends _ChatCompletionNamedToolChoice {
  const _$ChatCompletionNamedToolChoiceImpl(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$ChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionNamedToolChoiceImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionNamedToolChoiceType? type;

  /// Forces the model to call the specified function.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionFunctionCallOption? function;

  @override
  String toString() {
    return 'ChatCompletionNamedToolChoice(type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionNamedToolChoiceImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<
          _$ChatCompletionNamedToolChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionNamedToolChoice
    extends ChatCompletionNamedToolChoice {
  const factory _ChatCompletionNamedToolChoice(
          {@JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionNamedToolChoiceType? type,
          @JsonKey(includeIfNull: false)
          final ChatCompletionFunctionCallOption? function}) =
      _$ChatCompletionNamedToolChoiceImpl;
  const _ChatCompletionNamedToolChoice._() : super._();

  factory _ChatCompletionNamedToolChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionNamedToolChoiceImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionNamedToolChoiceType? get type;
  @override

  /// Forces the model to call the specified function.
  @JsonKey(includeIfNull: false)
  ChatCompletionFunctionCallOption? get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageToolCall _$ChatCompletionMessageToolCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageToolCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageToolCall {
  /// The ID of the tool call.
  String get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageToolCallCopyWith<ChatCompletionMessageToolCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory $ChatCompletionMessageToolCallCopyWith(
          ChatCompletionMessageToolCall value,
          $Res Function(ChatCompletionMessageToolCall) then) =
      _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
          ChatCompletionMessageToolCall>;
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageToolCall>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  _$ChatCompletionMessageToolCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function {
    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageToolCallImplCopyWith<$Res>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageToolCallImplCopyWith(
          _$ChatCompletionMessageToolCallImpl value,
          $Res Function(_$ChatCompletionMessageToolCallImpl) then) =
      __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  @override
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        _$ChatCompletionMessageToolCallImpl>
    implements _$$ChatCompletionMessageToolCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageToolCallImplCopyWithImpl(
      _$ChatCompletionMessageToolCallImpl _value,
      $Res Function(_$ChatCompletionMessageToolCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionMessageToolCallImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageToolCallImpl
    extends _ChatCompletionMessageToolCall {
  const _$ChatCompletionMessageToolCallImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$ChatCompletionMessageToolCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageToolCallImplFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionMessageToolCallType type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  final ChatCompletionMessageFunctionCall function;

  @override
  String toString() {
    return 'ChatCompletionMessageToolCall(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageToolCallImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => __$$ChatCompletionMessageToolCallImplCopyWithImpl<
          _$ChatCompletionMessageToolCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageToolCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageToolCall
    extends ChatCompletionMessageToolCall {
  const factory _ChatCompletionMessageToolCall(
          {required final String id,
          required final ChatCompletionMessageToolCallType type,
          required final ChatCompletionMessageFunctionCall function}) =
      _$ChatCompletionMessageToolCallImpl;
  const _ChatCompletionMessageToolCall._() : super._();

  factory _ChatCompletionMessageToolCall.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageToolCallImpl.fromJson;

  @override

  /// The ID of the tool call.
  String get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionResponse _$CreateChatCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionResponse {
  /// A unique identifier for the chat completion.
  String get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for the chat completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion`.
  CreateChatCompletionResponseObject get object =>
      throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionResponseCopyWith<CreateChatCompletionResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionResponseCopyWith<$Res> {
  factory $CreateChatCompletionResponseCopyWith(
          CreateChatCompletionResponse value,
          $Res Function(CreateChatCompletionResponse) then) =
      _$CreateChatCompletionResponseCopyWithImpl<$Res,
          CreateChatCompletionResponse>;
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateChatCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionResponse>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  _$CreateChatCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionResponseImplCopyWith<$Res>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionResponseImplCopyWith(
          _$CreateChatCompletionResponseImpl value,
          $Res Function(_$CreateChatCompletionResponseImpl) then) =
      __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionResponseCopyWithImpl<$Res,
        _$CreateChatCompletionResponseImpl>
    implements _$$CreateChatCompletionResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionResponseImplCopyWithImpl(
      _$CreateChatCompletionResponseImpl _value,
      $Res Function(_$CreateChatCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateChatCompletionResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionResponseImpl extends _CreateChatCompletionResponse {
  const _$CreateChatCompletionResponseImpl(
      {required this.id,
      required final List<ChatCompletionResponseChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionResponseImplFromJson(json);

  /// A unique identifier for the chat completion.
  @override
  final String id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  @override
  final int created;

  /// The model used for the chat completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion`.
  @override
  final CreateChatCompletionResponseObject object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateChatCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => __$$CreateChatCompletionResponseImplCopyWithImpl<
          _$CreateChatCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionResponse
    extends CreateChatCompletionResponse {
  const factory _CreateChatCompletionResponse(
          {required final String id,
          required final List<ChatCompletionResponseChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final CreateChatCompletionResponseObject object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateChatCompletionResponseImpl;
  const _CreateChatCompletionResponse._() : super._();

  factory _CreateChatCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion.
  String get id;
  @override

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created;
  @override

  /// The model used for the chat completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion`.
  CreateChatCompletionResponseObject get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseChoice _$ChatCompletionResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  int get index => throw _privateConstructorUsedError;

  /// An assistant message in a chat conversation.
  ChatCompletionAssistantMessage get message =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseChoiceCopyWith<ChatCompletionResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionResponseChoiceCopyWith(
          ChatCompletionResponseChoice value,
          $Res Function(ChatCompletionResponseChoice) then) =
      _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
          ChatCompletionResponseChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      int index,
      ChatCompletionAssistantMessage message});
}

/// @nodoc
class _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseChoice>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  _$ChatCompletionResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionResponseChoiceImplCopyWith(
          _$ChatCompletionResponseChoiceImpl value,
          $Res Function(_$ChatCompletionResponseChoiceImpl) then) =
      __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      int index,
      ChatCompletionAssistantMessage message});
}

/// @nodoc
class __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionResponseChoiceImpl>
    implements _$$ChatCompletionResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionResponseChoiceImplCopyWithImpl(
      _$ChatCompletionResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? message = freezed,
  }) {
    return _then(_$ChatCompletionResponseChoiceImpl(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseChoiceImpl extends _ChatCompletionResponseChoice {
  const _$ChatCompletionResponseChoiceImpl(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index,
      required this.message})
      : super._();

  factory _$ChatCompletionResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  final int index;

  /// An assistant message in a chat conversation.
  @override
  final ChatCompletionAssistantMessage message;

  @override
  String toString() {
    return 'ChatCompletionResponseChoice(finishReason: $finishReason, index: $index, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, finishReason, index,
      const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => __$$ChatCompletionResponseChoiceImplCopyWithImpl<
          _$ChatCompletionResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseChoice
    extends ChatCompletionResponseChoice {
  const factory _ChatCompletionResponseChoice(
          {@JsonKey(
              name: 'finish_reason',
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          required final ChatCompletionFinishReason? finishReason,
          required final int index,
          required final ChatCompletionAssistantMessage message}) =
      _$ChatCompletionResponseChoiceImpl;
  const _ChatCompletionResponseChoice._() : super._();

  factory _ChatCompletionResponseChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of choices.
  int get index;
  @override

  /// An assistant message in a chat conversation.
  ChatCompletionAssistantMessage get message;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionStreamResponse _$CreateChatCompletionStreamResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionStreamResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionStreamResponse {
  /// A unique identifier for the chat completion. Each chunk has the same ID.
  String get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionStreamResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  int get created => throw _privateConstructorUsedError;

  /// The model to generate the completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion.chunk`.
  CreateChatCompletionStreamResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionStreamResponseCopyWith<
          CreateChatCompletionStreamResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory $CreateChatCompletionStreamResponseCopyWith(
          CreateChatCompletionStreamResponse value,
          $Res Function(CreateChatCompletionStreamResponse) then) =
      _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
          CreateChatCompletionStreamResponse>;
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionStreamResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionStreamResponseObject object});
}

/// @nodoc
class _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionStreamResponse>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  _$CreateChatCompletionStreamResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionStreamResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionStreamResponseImplCopyWith<$Res>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionStreamResponseImplCopyWith(
          _$CreateChatCompletionStreamResponseImpl value,
          $Res Function(_$CreateChatCompletionStreamResponseImpl) then) =
      __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionStreamResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionStreamResponseObject object});
}

/// @nodoc
class __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        _$CreateChatCompletionStreamResponseImpl>
    implements _$$CreateChatCompletionStreamResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionStreamResponseImplCopyWithImpl(
      _$CreateChatCompletionStreamResponseImpl _value,
      $Res Function(_$CreateChatCompletionStreamResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
  }) {
    return _then(_$CreateChatCompletionStreamResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionStreamResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionStreamResponseImpl
    extends _CreateChatCompletionStreamResponse {
  const _$CreateChatCompletionStreamResponseImpl(
      {required this.id,
      required final List<ChatCompletionStreamResponseChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionStreamResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionStreamResponseImplFromJson(json);

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @override
  final String id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionStreamResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionStreamResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @override
  final int created;

  /// The model to generate the completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion.chunk`.
  @override
  final CreateChatCompletionStreamResponseObject object;

  @override
  String toString() {
    return 'CreateChatCompletionStreamResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionStreamResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => __$$CreateChatCompletionStreamResponseImplCopyWithImpl<
          _$CreateChatCompletionStreamResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionStreamResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionStreamResponse
    extends CreateChatCompletionStreamResponse {
  const factory _CreateChatCompletionStreamResponse(
          {required final String id,
          required final List<ChatCompletionStreamResponseChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final CreateChatCompletionStreamResponseObject object}) =
      _$CreateChatCompletionStreamResponseImpl;
  const _CreateChatCompletionStreamResponse._() : super._();

  factory _CreateChatCompletionStreamResponse.fromJson(
          Map<String, dynamic> json) =
      _$CreateChatCompletionStreamResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  String get id;
  @override

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionStreamResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  int get created;
  @override

  /// The model to generate the completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion.chunk`.
  CreateChatCompletionStreamResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseChoice _$ChatCompletionStreamResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoice {
  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta =>
      throw _privateConstructorUsedError;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  int get index => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseChoiceCopyWith<
          ChatCompletionStreamResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceCopyWith(
          ChatCompletionStreamResponseChoice value,
          $Res Function(ChatCompletionStreamResponseChoice) then) =
      _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
          ChatCompletionStreamResponseChoice>;
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      int index});

  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseChoice>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? finishReason = freezed,
    Object? index = null,
  }) {
    return _then(_value.copyWith(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta {
    return $ChatCompletionStreamResponseDeltaCopyWith<$Res>(_value.delta,
        (value) {
      return _then(_value.copyWith(delta: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseChoiceImplCopyWith(
          _$ChatCompletionStreamResponseChoiceImpl value,
          $Res Function(_$ChatCompletionStreamResponseChoiceImpl) then) =
      __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      int index});

  @override
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseChoiceImpl>
    implements _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl(
      _$ChatCompletionStreamResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionStreamResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? finishReason = freezed,
    Object? index = null,
  }) {
    return _then(_$ChatCompletionStreamResponseChoiceImpl(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseChoiceImpl
    extends _ChatCompletionStreamResponseChoice {
  const _$ChatCompletionStreamResponseChoiceImpl(
      {required this.delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index})
      : super._();

  factory _$ChatCompletionStreamResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseChoiceImplFromJson(json);

  /// A chat completion delta generated by streamed model responses.
  @override
  final ChatCompletionStreamResponseDelta delta;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  final int index;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoice(delta: $delta, finishReason: $finishReason, index: $index)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseChoiceImpl &&
            (identical(other.delta, delta) || other.delta == delta) &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, delta, finishReason, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<
          _$ChatCompletionStreamResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseChoice
    extends ChatCompletionStreamResponseChoice {
  const factory _ChatCompletionStreamResponseChoice(
      {required final ChatCompletionStreamResponseDelta delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required final ChatCompletionFinishReason? finishReason,
      required final int index}) = _$ChatCompletionStreamResponseChoiceImpl;
  const _ChatCompletionStreamResponseChoice._() : super._();

  factory _ChatCompletionStreamResponseChoice.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseChoiceImpl.fromJson;

  @override

  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta;
  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of choices.
  int get index;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseDelta _$ChatCompletionStreamResponseDeltaFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseDelta.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseDelta {
  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content => throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls =>
      throw _privateConstructorUsedError;

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseDeltaCopyWith<ChatCompletionStreamResponseDelta>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory $ChatCompletionStreamResponseDeltaCopyWith(
          ChatCompletionStreamResponseDelta value,
          $Res Function(ChatCompletionStreamResponseDelta) then) =
      _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
          ChatCompletionStreamResponseDelta>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseDelta>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  _$ChatCompletionStreamResponseDeltaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseDeltaImplCopyWith(
          _$ChatCompletionStreamResponseDeltaImpl value,
          $Res Function(_$ChatCompletionStreamResponseDeltaImpl) then) =
      __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseDeltaImpl>
    implements _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl(
      _$ChatCompletionStreamResponseDeltaImpl _value,
      $Res Function(_$ChatCompletionStreamResponseDeltaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseDeltaImpl(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseDeltaImpl
    extends _ChatCompletionStreamResponseDelta {
  const _$ChatCompletionStreamResponseDeltaImpl(
      {@JsonKey(includeIfNull: false) this.content,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.role})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionStreamResponseDeltaImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseDeltaImplFromJson(json);

  /// The contents of the chunk message.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? functionCall;

  /// No Description
  final List<ChatCompletionStreamMessageToolCallChunk>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionMessageRole? role;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDelta(content: $content, functionCall: $functionCall, toolCalls: $toolCalls, role: $role)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseDeltaImpl &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.role, role) || other.role == role));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, content, functionCall,
      const DeepCollectionEquality().hash(_toolCalls), role);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<
          _$ChatCompletionStreamResponseDeltaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseDeltaImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseDelta
    extends ChatCompletionStreamResponseDelta {
  const factory _ChatCompletionStreamResponseDelta(
          {@JsonKey(includeIfNull: false) final String? content,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? functionCall,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionMessageRole? role}) =
      _$ChatCompletionStreamResponseDeltaImpl;
  const _ChatCompletionStreamResponseDelta._() : super._();

  factory _ChatCompletionStreamResponseDelta.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseDeltaImpl.fromJson;

  @override

  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall;
  @override

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls;
  @override

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageFunctionCall
    _$ChatCompletionStreamMessageFunctionCallFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageFunctionCall {
  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageFunctionCallCopyWith<
          ChatCompletionStreamMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionStreamMessageFunctionCallCopyWith(
          ChatCompletionStreamMessageFunctionCall value,
          $Res Function(ChatCompletionStreamMessageFunctionCall) then) =
      _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionStreamMessageFunctionCall>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageFunctionCall>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionStreamMessageFunctionCallCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageFunctionCallImplCopyWith(
          _$ChatCompletionStreamMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) then) =
      __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageFunctionCallImpl>
    implements _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionStreamMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageFunctionCallImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageFunctionCallImpl
    extends _ChatCompletionStreamMessageFunctionCall {
  const _$ChatCompletionStreamMessageFunctionCallImpl(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.arguments})
      : super._();

  factory _$ChatCompletionStreamMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  @JsonKey(includeIfNull: false)
  final String? arguments;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<
              _$ChatCompletionStreamMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageFunctionCall
    extends ChatCompletionStreamMessageFunctionCall {
  const factory _ChatCompletionStreamMessageFunctionCall(
          {@JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? arguments}) =
      _$ChatCompletionStreamMessageFunctionCallImpl;
  const _ChatCompletionStreamMessageFunctionCall._() : super._();

  factory _ChatCompletionStreamMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageToolCallChunk
    _$ChatCompletionStreamMessageToolCallChunkFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageToolCallChunk.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageToolCallChunk {
  /// No Description
  int get index => throw _privateConstructorUsedError;

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageToolCallChunkCopyWith<
          ChatCompletionStreamMessageToolCallChunk>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory $ChatCompletionStreamMessageToolCallChunkCopyWith(
          ChatCompletionStreamMessageToolCallChunk value,
          $Res Function(ChatCompletionStreamMessageToolCallChunk) then) =
      _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
          ChatCompletionStreamMessageToolCallChunk>;
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageToolCallChunk>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.function!, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith(
          _$ChatCompletionStreamMessageToolCallChunkImpl value,
          $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) then) =
      __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageToolCallChunkImpl>
    implements _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl(
      _$ChatCompletionStreamMessageToolCallChunkImpl _value,
      $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageToolCallChunkImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageToolCallChunkImpl
    extends _ChatCompletionStreamMessageToolCallChunk {
  const _$ChatCompletionStreamMessageToolCallChunkImpl(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageToolCallChunkImplFromJson(json);

  /// No Description
  @override
  final int index;

  /// The ID of the tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionStreamMessageToolCallChunkType? type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? function;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageToolCallChunk(index: $index, id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageToolCallChunkImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<
              _$ChatCompletionStreamMessageToolCallChunkImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageToolCallChunkImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageToolCallChunk
    extends ChatCompletionStreamMessageToolCallChunk {
  const factory _ChatCompletionStreamMessageToolCallChunk(
          {required final int index,
          @JsonKey(includeIfNull: false) final String? id,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionStreamMessageToolCallChunkType? type,
          @JsonKey(includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? function}) =
      _$ChatCompletionStreamMessageToolCallChunkImpl;
  const _ChatCompletionStreamMessageToolCallChunk._() : super._();

  factory _ChatCompletionStreamMessageToolCallChunk.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson;

  @override

  /// No Description
  int get index;
  @override

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionUsage _$CompletionUsageFromJson(Map<String, dynamic> json) {
  return _CompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$CompletionUsage {
  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens => throw _privateConstructorUsedError;

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionUsageCopyWith<CompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionUsageCopyWith<$Res> {
  factory $CompletionUsageCopyWith(
          CompletionUsage value, $Res Function(CompletionUsage) then) =
      _$CompletionUsageCopyWithImpl<$Res, CompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$CompletionUsageCopyWithImpl<$Res, $Val extends CompletionUsage>
    implements $CompletionUsageCopyWith<$Res> {
  _$CompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionUsageImplCopyWith<$Res>
    implements $CompletionUsageCopyWith<$Res> {
  factory _$$CompletionUsageImplCopyWith(_$CompletionUsageImpl value,
          $Res Function(_$CompletionUsageImpl) then) =
      __$$CompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$CompletionUsageImplCopyWithImpl<$Res>
    extends _$CompletionUsageCopyWithImpl<$Res, _$CompletionUsageImpl>
    implements _$$CompletionUsageImplCopyWith<$Res> {
  __$$CompletionUsageImplCopyWithImpl(
      _$CompletionUsageImpl _value, $Res Function(_$CompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$CompletionUsageImpl(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionUsageImpl extends _CompletionUsage {
  const _$CompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$CompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionUsageImplFromJson(json);

  /// Number of tokens in the generated completion.
  @override
  @JsonKey(name: 'completion_tokens')
  final int? completionTokens;

  /// Number of tokens in the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used in the request (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'CompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      __$$CompletionUsageImplCopyWithImpl<_$CompletionUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _CompletionUsage extends CompletionUsage {
  const factory _CompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int? completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$CompletionUsageImpl;
  const _CompletionUsage._() : super._();

  factory _CompletionUsage.fromJson(Map<String, dynamic> json) =
      _$CompletionUsageImpl.fromJson;

  @override

  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens;
  @override

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateEmbeddingRequest _$CreateEmbeddingRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingRequest {
  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model => throw _privateConstructorUsedError;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`) and cannot be an empty string. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input => throw _privateConstructorUsedError;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat =>
      throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingRequestCopyWith<CreateEmbeddingRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingRequestCopyWith<$Res> {
  factory $CreateEmbeddingRequestCopyWith(CreateEmbeddingRequest value,
          $Res Function(CreateEmbeddingRequest) then) =
      _$CreateEmbeddingRequestCopyWithImpl<$Res, CreateEmbeddingRequest>;
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) String? user});

  $EmbeddingModelCopyWith<$Res> get model;
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateEmbeddingRequestCopyWithImpl<$Res,
        $Val extends CreateEmbeddingRequest>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  _$CreateEmbeddingRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingModelCopyWith<$Res> get model {
    return $EmbeddingModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingInputCopyWith<$Res> get input {
    return $EmbeddingInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingRequestImplCopyWith<$Res>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  factory _$$CreateEmbeddingRequestImplCopyWith(
          _$CreateEmbeddingRequestImpl value,
          $Res Function(_$CreateEmbeddingRequestImpl) then) =
      __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $EmbeddingModelCopyWith<$Res> get model;
  @override
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingRequestCopyWithImpl<$Res,
        _$CreateEmbeddingRequestImpl>
    implements _$$CreateEmbeddingRequestImplCopyWith<$Res> {
  __$$CreateEmbeddingRequestImplCopyWithImpl(
      _$CreateEmbeddingRequestImpl _value,
      $Res Function(_$CreateEmbeddingRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? user = freezed,
  }) {
    return _then(_$CreateEmbeddingRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingRequestImpl extends _CreateEmbeddingRequest {
  const _$CreateEmbeddingRequestImpl(
      {@_EmbeddingModelConverter() required this.model,
      @_EmbeddingInputConverter() required this.input,
      @JsonKey(name: 'encoding_format')
      this.encodingFormat = EmbeddingEncodingFormat.float,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateEmbeddingRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @override
  @_EmbeddingModelConverter()
  final EmbeddingModel model;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`) and cannot be an empty string. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @_EmbeddingInputConverter()
  final EmbeddingInput input;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @override
  @JsonKey(name: 'encoding_format')
  final EmbeddingEncodingFormat encodingFormat;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateEmbeddingRequest(model: $model, input: $input, encodingFormat: $encodingFormat, user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.encodingFormat, encodingFormat) ||
                other.encodingFormat == encodingFormat) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, model, input, encodingFormat, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => __$$CreateEmbeddingRequestImplCopyWithImpl<
          _$CreateEmbeddingRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingRequest extends CreateEmbeddingRequest {
  const factory _CreateEmbeddingRequest(
          {@_EmbeddingModelConverter() required final EmbeddingModel model,
          @_EmbeddingInputConverter() required final EmbeddingInput input,
          @JsonKey(name: 'encoding_format')
          final EmbeddingEncodingFormat encodingFormat,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateEmbeddingRequestImpl;
  const _CreateEmbeddingRequest._() : super._();

  factory _CreateEmbeddingRequest.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model;
  @override

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`) and cannot be an empty string. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input;
  @override

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingModel _$EmbeddingModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return EmbeddingModelEnumeration.fromJson(json);
    case 'modelId':
      return EmbeddingModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingModelCopyWith<$Res> {
  factory $EmbeddingModelCopyWith(
          EmbeddingModel value, $Res Function(EmbeddingModel) then) =
      _$EmbeddingModelCopyWithImpl<$Res, EmbeddingModel>;
}

/// @nodoc
class _$EmbeddingModelCopyWithImpl<$Res, $Val extends EmbeddingModel>
    implements $EmbeddingModelCopyWith<$Res> {
  _$EmbeddingModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingModelEnumerationImplCopyWith<$Res> {
  factory _$$EmbeddingModelEnumerationImplCopyWith(
          _$EmbeddingModelEnumerationImpl value,
          $Res Function(_$EmbeddingModelEnumerationImpl) then) =
      __$$EmbeddingModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({EmbeddingModels value});
}

/// @nodoc
class __$$EmbeddingModelEnumerationImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$EmbeddingModelEnumerationImpl>
    implements _$$EmbeddingModelEnumerationImplCopyWith<$Res> {
  __$$EmbeddingModelEnumerationImplCopyWithImpl(
      _$EmbeddingModelEnumerationImpl _value,
      $Res Function(_$EmbeddingModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as EmbeddingModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingModelEnumerationImpl extends EmbeddingModelEnumeration {
  const _$EmbeddingModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$EmbeddingModelEnumerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingModelEnumerationImplFromJson(json);

  @override
  final EmbeddingModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.model(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingModelEnumerationImplCopyWith<_$EmbeddingModelEnumerationImpl>
      get copyWith => __$$EmbeddingModelEnumerationImplCopyWithImpl<
          _$EmbeddingModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class EmbeddingModelEnumeration extends EmbeddingModel {
  const factory EmbeddingModelEnumeration(final EmbeddingModels value) =
      _$EmbeddingModelEnumerationImpl;
  const EmbeddingModelEnumeration._() : super._();

  factory EmbeddingModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$EmbeddingModelEnumerationImpl.fromJson;

  @override
  EmbeddingModels get value;
  @JsonKey(ignore: true)
  _$$EmbeddingModelEnumerationImplCopyWith<_$EmbeddingModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingModelStringImplCopyWith<$Res> {
  factory _$$EmbeddingModelStringImplCopyWith(_$EmbeddingModelStringImpl value,
          $Res Function(_$EmbeddingModelStringImpl) then) =
      __$$EmbeddingModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingModelStringImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$EmbeddingModelStringImpl>
    implements _$$EmbeddingModelStringImplCopyWith<$Res> {
  __$$EmbeddingModelStringImplCopyWithImpl(_$EmbeddingModelStringImpl _value,
      $Res Function(_$EmbeddingModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingModelStringImpl extends EmbeddingModelString {
  const _$EmbeddingModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$EmbeddingModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.modelId(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingModelStringImplCopyWith<_$EmbeddingModelStringImpl>
      get copyWith =>
          __$$EmbeddingModelStringImplCopyWithImpl<_$EmbeddingModelStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingModelStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingModelString extends EmbeddingModel {
  const factory EmbeddingModelString(final String value) =
      _$EmbeddingModelStringImpl;
  const EmbeddingModelString._() : super._();

  factory EmbeddingModelString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingModelStringImplCopyWith<_$EmbeddingModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingInput _$EmbeddingInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return EmbeddingInputListListInt.fromJson(json);
    case 'tokens':
      return EmbeddingInputListInt.fromJson(json);
    case 'listString':
      return EmbeddingInputListString.fromJson(json);
    case 'string':
      return EmbeddingInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputCopyWith(
          EmbeddingInput value, $Res Function(EmbeddingInput) then) =
      _$EmbeddingInputCopyWithImpl<$Res, EmbeddingInput>;
}

/// @nodoc
class _$EmbeddingInputCopyWithImpl<$Res, $Val extends EmbeddingInput>
    implements $EmbeddingInputCopyWith<$Res> {
  _$EmbeddingInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingInputListListIntImplCopyWith<$Res> {
  factory _$$EmbeddingInputListListIntImplCopyWith(
          _$EmbeddingInputListListIntImpl value,
          $Res Function(_$EmbeddingInputListListIntImpl) then) =
      __$$EmbeddingInputListListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$EmbeddingInputListListIntImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListListIntImpl>
    implements _$$EmbeddingInputListListIntImplCopyWith<$Res> {
  __$$EmbeddingInputListListIntImplCopyWithImpl(
      _$EmbeddingInputListListIntImpl _value,
      $Res Function(_$EmbeddingInputListListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListListIntImpl extends EmbeddingInputListListInt {
  const _$EmbeddingInputListListIntImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();

  factory _$EmbeddingInputListListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListListIntImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.listTokens(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListListIntImplCopyWith<_$EmbeddingInputListListIntImpl>
      get copyWith => __$$EmbeddingInputListListIntImplCopyWithImpl<
          _$EmbeddingInputListListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listTokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listTokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return listTokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return listTokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListListIntImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListListInt extends EmbeddingInput {
  const factory EmbeddingInputListListInt(final List<List<int>> value) =
      _$EmbeddingInputListListIntImpl;
  const EmbeddingInputListListInt._() : super._();

  factory EmbeddingInputListListInt.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListListIntImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListListIntImplCopyWith<_$EmbeddingInputListListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputListIntImplCopyWith<$Res> {
  factory _$$EmbeddingInputListIntImplCopyWith(
          _$EmbeddingInputListIntImpl value,
          $Res Function(_$EmbeddingInputListIntImpl) then) =
      __$$EmbeddingInputListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$EmbeddingInputListIntImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListIntImpl>
    implements _$$EmbeddingInputListIntImplCopyWith<$Res> {
  __$$EmbeddingInputListIntImplCopyWithImpl(_$EmbeddingInputListIntImpl _value,
      $Res Function(_$EmbeddingInputListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListIntImpl extends EmbeddingInputListInt {
  const _$EmbeddingInputListIntImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();

  factory _$EmbeddingInputListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListIntImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.tokens(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListIntImplCopyWith<_$EmbeddingInputListIntImpl>
      get copyWith => __$$EmbeddingInputListIntImplCopyWithImpl<
          _$EmbeddingInputListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return tokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return tokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return tokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return tokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListIntImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListInt extends EmbeddingInput {
  const factory EmbeddingInputListInt(final List<int> value) =
      _$EmbeddingInputListIntImpl;
  const EmbeddingInputListInt._() : super._();

  factory EmbeddingInputListInt.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListIntImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListIntImplCopyWith<_$EmbeddingInputListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputListStringImplCopyWith<$Res> {
  factory _$$EmbeddingInputListStringImplCopyWith(
          _$EmbeddingInputListStringImpl value,
          $Res Function(_$EmbeddingInputListStringImpl) then) =
      __$$EmbeddingInputListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$EmbeddingInputListStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListStringImpl>
    implements _$$EmbeddingInputListStringImplCopyWith<$Res> {
  __$$EmbeddingInputListStringImplCopyWithImpl(
      _$EmbeddingInputListStringImpl _value,
      $Res Function(_$EmbeddingInputListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListStringImpl extends EmbeddingInputListString {
  const _$EmbeddingInputListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$EmbeddingInputListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.listString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListStringImplCopyWith<_$EmbeddingInputListStringImpl>
      get copyWith => __$$EmbeddingInputListStringImplCopyWithImpl<
          _$EmbeddingInputListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListString extends EmbeddingInput {
  const factory EmbeddingInputListString(final List<String> value) =
      _$EmbeddingInputListStringImpl;
  const EmbeddingInputListString._() : super._();

  factory EmbeddingInputListString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListStringImplCopyWith<_$EmbeddingInputListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputStringImplCopyWith<$Res> {
  factory _$$EmbeddingInputStringImplCopyWith(_$EmbeddingInputStringImpl value,
          $Res Function(_$EmbeddingInputStringImpl) then) =
      __$$EmbeddingInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingInputStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputStringImpl>
    implements _$$EmbeddingInputStringImplCopyWith<$Res> {
  __$$EmbeddingInputStringImplCopyWithImpl(_$EmbeddingInputStringImpl _value,
      $Res Function(_$EmbeddingInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputStringImpl extends EmbeddingInputString {
  const _$EmbeddingInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$EmbeddingInputStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputStringImplCopyWith<_$EmbeddingInputStringImpl>
      get copyWith =>
          __$$EmbeddingInputStringImplCopyWithImpl<_$EmbeddingInputStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputString extends EmbeddingInput {
  const factory EmbeddingInputString(final String value) =
      _$EmbeddingInputStringImpl;
  const EmbeddingInputString._() : super._();

  factory EmbeddingInputString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputStringImplCopyWith<_$EmbeddingInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateEmbeddingResponse _$CreateEmbeddingResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingResponse {
  /// The list of embeddings generated by the model.
  List<Embedding> get data => throw _privateConstructorUsedError;

  /// The name of the model used to generate the embedding.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  CreateEmbeddingResponseObject get object =>
      throw _privateConstructorUsedError;

  /// The usage information for the request.
  EmbeddingUsage get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingResponseCopyWith<CreateEmbeddingResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingResponseCopyWith<$Res> {
  factory $CreateEmbeddingResponseCopyWith(CreateEmbeddingResponse value,
          $Res Function(CreateEmbeddingResponse) then) =
      _$CreateEmbeddingResponseCopyWithImpl<$Res, CreateEmbeddingResponse>;
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      EmbeddingUsage usage});

  $EmbeddingUsageCopyWith<$Res> get usage;
}

/// @nodoc
class _$CreateEmbeddingResponseCopyWithImpl<$Res,
        $Val extends CreateEmbeddingResponse>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  _$CreateEmbeddingResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: null == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingUsageCopyWith<$Res> get usage {
    return $EmbeddingUsageCopyWith<$Res>(_value.usage, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingResponseImplCopyWith<$Res>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  factory _$$CreateEmbeddingResponseImplCopyWith(
          _$CreateEmbeddingResponseImpl value,
          $Res Function(_$CreateEmbeddingResponseImpl) then) =
      __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      EmbeddingUsage usage});

  @override
  $EmbeddingUsageCopyWith<$Res> get usage;
}

/// @nodoc
class __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingResponseCopyWithImpl<$Res,
        _$CreateEmbeddingResponseImpl>
    implements _$$CreateEmbeddingResponseImplCopyWith<$Res> {
  __$$CreateEmbeddingResponseImplCopyWithImpl(
      _$CreateEmbeddingResponseImpl _value,
      $Res Function(_$CreateEmbeddingResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = null,
  }) {
    return _then(_$CreateEmbeddingResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: null == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingResponseImpl extends _CreateEmbeddingResponse {
  const _$CreateEmbeddingResponseImpl(
      {required final List<Embedding> data,
      required this.model,
      required this.object,
      required this.usage})
      : _data = data,
        super._();

  factory _$CreateEmbeddingResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingResponseImplFromJson(json);

  /// The list of embeddings generated by the model.
  final List<Embedding> _data;

  /// The list of embeddings generated by the model.
  @override
  List<Embedding> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The name of the model used to generate the embedding.
  @override
  final String model;

  /// The object type, which is always "list".
  @override
  final CreateEmbeddingResponseObject object;

  /// The usage information for the request.
  @override
  final EmbeddingUsage usage;

  @override
  String toString() {
    return 'CreateEmbeddingResponse(data: $data, model: $model, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_data), model, object, usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => __$$CreateEmbeddingResponseImplCopyWithImpl<
          _$CreateEmbeddingResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingResponse extends CreateEmbeddingResponse {
  const factory _CreateEmbeddingResponse(
      {required final List<Embedding> data,
      required final String model,
      required final CreateEmbeddingResponseObject object,
      required final EmbeddingUsage usage}) = _$CreateEmbeddingResponseImpl;
  const _CreateEmbeddingResponse._() : super._();

  factory _CreateEmbeddingResponse.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingResponseImpl.fromJson;

  @override

  /// The list of embeddings generated by the model.
  List<Embedding> get data;
  @override

  /// The name of the model used to generate the embedding.
  String get model;
  @override

  /// The object type, which is always "list".
  CreateEmbeddingResponseObject get object;
  @override

  /// The usage information for the request.
  EmbeddingUsage get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Embedding _$EmbeddingFromJson(Map<String, dynamic> json) {
  return _Embedding.fromJson(json);
}

/// @nodoc
mixin _$Embedding {
  /// The index of the embedding in the list of embeddings.
  int get index => throw _privateConstructorUsedError;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding => throw _privateConstructorUsedError;

  /// The object type, which is always "embedding".
  EmbeddingObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingCopyWith<Embedding> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingCopyWith<$Res> {
  factory $EmbeddingCopyWith(Embedding value, $Res Function(Embedding) then) =
      _$EmbeddingCopyWithImpl<$Res, Embedding>;
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class _$EmbeddingCopyWithImpl<$Res, $Val extends Embedding>
    implements $EmbeddingCopyWith<$Res> {
  _$EmbeddingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingVectorCopyWith<$Res> get embedding {
    return $EmbeddingVectorCopyWith<$Res>(_value.embedding, (value) {
      return _then(_value.copyWith(embedding: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EmbeddingImplCopyWith<$Res>
    implements $EmbeddingCopyWith<$Res> {
  factory _$$EmbeddingImplCopyWith(
          _$EmbeddingImpl value, $Res Function(_$EmbeddingImpl) then) =
      __$$EmbeddingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  @override
  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class __$$EmbeddingImplCopyWithImpl<$Res>
    extends _$EmbeddingCopyWithImpl<$Res, _$EmbeddingImpl>
    implements _$$EmbeddingImplCopyWith<$Res> {
  __$$EmbeddingImplCopyWithImpl(
      _$EmbeddingImpl _value, $Res Function(_$EmbeddingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_$EmbeddingImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingImpl extends _Embedding {
  const _$EmbeddingImpl(
      {required this.index,
      @_EmbeddingVectorConverter() required this.embedding,
      required this.object})
      : super._();

  factory _$EmbeddingImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingImplFromJson(json);

  /// The index of the embedding in the list of embeddings.
  @override
  final int index;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @override
  @_EmbeddingVectorConverter()
  final EmbeddingVector embedding;

  /// The object type, which is always "embedding".
  @override
  final EmbeddingObject object;

  @override
  String toString() {
    return 'Embedding(index: $index, embedding: $embedding, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.embedding, embedding) ||
                other.embedding == embedding) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, embedding, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      __$$EmbeddingImplCopyWithImpl<_$EmbeddingImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingImplToJson(
      this,
    );
  }
}

abstract class _Embedding extends Embedding {
  const factory _Embedding(
      {required final int index,
      @_EmbeddingVectorConverter() required final EmbeddingVector embedding,
      required final EmbeddingObject object}) = _$EmbeddingImpl;
  const _Embedding._() : super._();

  factory _Embedding.fromJson(Map<String, dynamic> json) =
      _$EmbeddingImpl.fromJson;

  @override

  /// The index of the embedding in the list of embeddings.
  int get index;
  @override

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding;
  @override

  /// The object type, which is always "embedding".
  EmbeddingObject get object;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EmbeddingVector _$EmbeddingVectorFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'vector':
      return EmbeddingVectorListDouble.fromJson(json);
    case 'vectorBase64':
      return EmbeddingVectorString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingVector',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingVector {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingVectorCopyWith<$Res> {
  factory $EmbeddingVectorCopyWith(
          EmbeddingVector value, $Res Function(EmbeddingVector) then) =
      _$EmbeddingVectorCopyWithImpl<$Res, EmbeddingVector>;
}

/// @nodoc
class _$EmbeddingVectorCopyWithImpl<$Res, $Val extends EmbeddingVector>
    implements $EmbeddingVectorCopyWith<$Res> {
  _$EmbeddingVectorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingVectorListDoubleImplCopyWith<$Res> {
  factory _$$EmbeddingVectorListDoubleImplCopyWith(
          _$EmbeddingVectorListDoubleImpl value,
          $Res Function(_$EmbeddingVectorListDoubleImpl) then) =
      __$$EmbeddingVectorListDoubleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<double> value});
}

/// @nodoc
class __$$EmbeddingVectorListDoubleImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res, _$EmbeddingVectorListDoubleImpl>
    implements _$$EmbeddingVectorListDoubleImplCopyWith<$Res> {
  __$$EmbeddingVectorListDoubleImplCopyWithImpl(
      _$EmbeddingVectorListDoubleImpl _value,
      $Res Function(_$EmbeddingVectorListDoubleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingVectorListDoubleImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<double>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingVectorListDoubleImpl extends EmbeddingVectorListDouble {
  const _$EmbeddingVectorListDoubleImpl(final List<double> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'vector',
        super._();

  factory _$EmbeddingVectorListDoubleImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingVectorListDoubleImplFromJson(json);

  final List<double> _value;
  @override
  List<double> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.vector(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingVectorListDoubleImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingVectorListDoubleImplCopyWith<_$EmbeddingVectorListDoubleImpl>
      get copyWith => __$$EmbeddingVectorListDoubleImplCopyWithImpl<
          _$EmbeddingVectorListDoubleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) {
    return vector(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) {
    return vector?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vector != null) {
      return vector(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) {
    return vector(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) {
    return vector?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vector != null) {
      return vector(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingVectorListDoubleImplToJson(
      this,
    );
  }
}

abstract class EmbeddingVectorListDouble extends EmbeddingVector {
  const factory EmbeddingVectorListDouble(final List<double> value) =
      _$EmbeddingVectorListDoubleImpl;
  const EmbeddingVectorListDouble._() : super._();

  factory EmbeddingVectorListDouble.fromJson(Map<String, dynamic> json) =
      _$EmbeddingVectorListDoubleImpl.fromJson;

  @override
  List<double> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingVectorListDoubleImplCopyWith<_$EmbeddingVectorListDoubleImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingVectorStringImplCopyWith<$Res> {
  factory _$$EmbeddingVectorStringImplCopyWith(
          _$EmbeddingVectorStringImpl value,
          $Res Function(_$EmbeddingVectorStringImpl) then) =
      __$$EmbeddingVectorStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingVectorStringImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res, _$EmbeddingVectorStringImpl>
    implements _$$EmbeddingVectorStringImplCopyWith<$Res> {
  __$$EmbeddingVectorStringImplCopyWithImpl(_$EmbeddingVectorStringImpl _value,
      $Res Function(_$EmbeddingVectorStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingVectorStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingVectorStringImpl extends EmbeddingVectorString {
  const _$EmbeddingVectorStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'vectorBase64',
        super._();

  factory _$EmbeddingVectorStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingVectorStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.vectorBase64(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingVectorStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingVectorStringImplCopyWith<_$EmbeddingVectorStringImpl>
      get copyWith => __$$EmbeddingVectorStringImplCopyWithImpl<
          _$EmbeddingVectorStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) {
    return vectorBase64(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) {
    return vectorBase64?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vectorBase64 != null) {
      return vectorBase64(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) {
    return vectorBase64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) {
    return vectorBase64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vectorBase64 != null) {
      return vectorBase64(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingVectorStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingVectorString extends EmbeddingVector {
  const factory EmbeddingVectorString(final String value) =
      _$EmbeddingVectorStringImpl;
  const EmbeddingVectorString._() : super._();

  factory EmbeddingVectorString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingVectorStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingVectorStringImplCopyWith<_$EmbeddingVectorStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingUsage _$EmbeddingUsageFromJson(Map<String, dynamic> json) {
  return _EmbeddingUsage.fromJson(json);
}

/// @nodoc
mixin _$EmbeddingUsage {
  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingUsageCopyWith<EmbeddingUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingUsageCopyWith<$Res> {
  factory $EmbeddingUsageCopyWith(
          EmbeddingUsage value, $Res Function(EmbeddingUsage) then) =
      _$EmbeddingUsageCopyWithImpl<$Res, EmbeddingUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$EmbeddingUsageCopyWithImpl<$Res, $Val extends EmbeddingUsage>
    implements $EmbeddingUsageCopyWith<$Res> {
  _$EmbeddingUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EmbeddingUsageImplCopyWith<$Res>
    implements $EmbeddingUsageCopyWith<$Res> {
  factory _$$EmbeddingUsageImplCopyWith(_$EmbeddingUsageImpl value,
          $Res Function(_$EmbeddingUsageImpl) then) =
      __$$EmbeddingUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$EmbeddingUsageImplCopyWithImpl<$Res>
    extends _$EmbeddingUsageCopyWithImpl<$Res, _$EmbeddingUsageImpl>
    implements _$$EmbeddingUsageImplCopyWith<$Res> {
  __$$EmbeddingUsageImplCopyWithImpl(
      _$EmbeddingUsageImpl _value, $Res Function(_$EmbeddingUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$EmbeddingUsageImpl(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingUsageImpl extends _EmbeddingUsage {
  const _$EmbeddingUsageImpl(
      {@JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$EmbeddingUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingUsageImplFromJson(json);

  /// The number of tokens used by the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// The total number of tokens used by the request.
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'EmbeddingUsage(promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingUsageImpl &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      __$$EmbeddingUsageImplCopyWithImpl<_$EmbeddingUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingUsageImplToJson(
      this,
    );
  }
}

abstract class _EmbeddingUsage extends EmbeddingUsage {
  const factory _EmbeddingUsage(
          {@JsonKey(name: 'prompt_tokens') required final int promptTokens,
          @JsonKey(name: 'total_tokens') required final int totalTokens}) =
      _$EmbeddingUsageImpl;
  const _EmbeddingUsage._() : super._();

  factory _EmbeddingUsage.fromJson(Map<String, dynamic> json) =
      _$EmbeddingUsageImpl.fromJson;

  @override

  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateFineTuningJobRequest _$CreateFineTuningJobRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateFineTuningJobRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateFineTuningJobRequest {
  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters =>
      throw _privateConstructorUsedError;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateFineTuningJobRequestCopyWith<CreateFineTuningJobRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateFineTuningJobRequestCopyWith<$Res> {
  factory $CreateFineTuningJobRequestCopyWith(CreateFineTuningJobRequest value,
          $Res Function(CreateFineTuningJobRequest) then) =
      _$CreateFineTuningJobRequestCopyWithImpl<$Res,
          CreateFineTuningJobRequest>;
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile});

  $FineTuningModelCopyWith<$Res> get model;
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        $Val extends CreateFineTuningJobRequest>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  _$CreateFineTuningJobRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningModelCopyWith<$Res> get model {
    return $FineTuningModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters {
    if (_value.hyperparameters == null) {
      return null;
    }

    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters!,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateFineTuningJobRequestImplCopyWith<$Res>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  factory _$$CreateFineTuningJobRequestImplCopyWith(
          _$CreateFineTuningJobRequestImpl value,
          $Res Function(_$CreateFineTuningJobRequestImpl) then) =
      __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile});

  @override
  $FineTuningModelCopyWith<$Res> get model;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>
    extends _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        _$CreateFineTuningJobRequestImpl>
    implements _$$CreateFineTuningJobRequestImplCopyWith<$Res> {
  __$$CreateFineTuningJobRequestImplCopyWithImpl(
      _$CreateFineTuningJobRequestImpl _value,
      $Res Function(_$CreateFineTuningJobRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
  }) {
    return _then(_$CreateFineTuningJobRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateFineTuningJobRequestImpl extends _CreateFineTuningJobRequest {
  const _$CreateFineTuningJobRequestImpl(
      {@_FineTuningModelConverter() required this.model,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(includeIfNull: false) this.hyperparameters,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      this.validationFile})
      : super._();

  factory _$CreateFineTuningJobRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateFineTuningJobRequestImplFromJson(json);

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @override
  @_FineTuningModelConverter()
  final FineTuningModel model;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(includeIfNull: false)
  final FineTuningJobHyperparameters? hyperparameters;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'validation_file', includeIfNull: false)
  final String? validationFile;

  @override
  String toString() {
    return 'CreateFineTuningJobRequest(model: $model, trainingFile: $trainingFile, hyperparameters: $hyperparameters, suffix: $suffix, validationFile: $validationFile)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateFineTuningJobRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, model, trainingFile,
      hyperparameters, suffix, validationFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => __$$CreateFineTuningJobRequestImplCopyWithImpl<
          _$CreateFineTuningJobRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateFineTuningJobRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateFineTuningJobRequest extends CreateFineTuningJobRequest {
  const factory _CreateFineTuningJobRequest(
      {@_FineTuningModelConverter() required final FineTuningModel model,
      @JsonKey(name: 'training_file') required final String trainingFile,
      @JsonKey(includeIfNull: false)
      final FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) final String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      final String? validationFile}) = _$CreateFineTuningJobRequestImpl;
  const _CreateFineTuningJobRequest._() : super._();

  factory _CreateFineTuningJobRequest.fromJson(Map<String, dynamic> json) =
      _$CreateFineTuningJobRequestImpl.fromJson;

  @override

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model;
  @override

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters;
  @override

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile;
  @override
  @JsonKey(ignore: true)
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningModel _$FineTuningModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return FineTuningModelEnumeration.fromJson(json);
    case 'modelId':
      return FineTuningModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningModelCopyWith<$Res> {
  factory $FineTuningModelCopyWith(
          FineTuningModel value, $Res Function(FineTuningModel) then) =
      _$FineTuningModelCopyWithImpl<$Res, FineTuningModel>;
}

/// @nodoc
class _$FineTuningModelCopyWithImpl<$Res, $Val extends FineTuningModel>
    implements $FineTuningModelCopyWith<$Res> {
  _$FineTuningModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FineTuningModelEnumerationImplCopyWith<$Res> {
  factory _$$FineTuningModelEnumerationImplCopyWith(
          _$FineTuningModelEnumerationImpl value,
          $Res Function(_$FineTuningModelEnumerationImpl) then) =
      __$$FineTuningModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningModels value});
}

/// @nodoc
class __$$FineTuningModelEnumerationImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res,
        _$FineTuningModelEnumerationImpl>
    implements _$$FineTuningModelEnumerationImplCopyWith<$Res> {
  __$$FineTuningModelEnumerationImplCopyWithImpl(
      _$FineTuningModelEnumerationImpl _value,
      $Res Function(_$FineTuningModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningModelEnumerationImpl extends FineTuningModelEnumeration {
  const _$FineTuningModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$FineTuningModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningModelEnumerationImplFromJson(json);

  @override
  final FineTuningModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.model(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningModelEnumerationImplCopyWith<_$FineTuningModelEnumerationImpl>
      get copyWith => __$$FineTuningModelEnumerationImplCopyWithImpl<
          _$FineTuningModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class FineTuningModelEnumeration extends FineTuningModel {
  const factory FineTuningModelEnumeration(final FineTuningModels value) =
      _$FineTuningModelEnumerationImpl;
  const FineTuningModelEnumeration._() : super._();

  factory FineTuningModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$FineTuningModelEnumerationImpl.fromJson;

  @override
  FineTuningModels get value;
  @JsonKey(ignore: true)
  _$$FineTuningModelEnumerationImplCopyWith<_$FineTuningModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FineTuningModelStringImplCopyWith<$Res> {
  factory _$$FineTuningModelStringImplCopyWith(
          _$FineTuningModelStringImpl value,
          $Res Function(_$FineTuningModelStringImpl) then) =
      __$$FineTuningModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$FineTuningModelStringImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res, _$FineTuningModelStringImpl>
    implements _$$FineTuningModelStringImplCopyWith<$Res> {
  __$$FineTuningModelStringImplCopyWithImpl(_$FineTuningModelStringImpl _value,
      $Res Function(_$FineTuningModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningModelStringImpl extends FineTuningModelString {
  const _$FineTuningModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$FineTuningModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.modelId(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningModelStringImplCopyWith<_$FineTuningModelStringImpl>
      get copyWith => __$$FineTuningModelStringImplCopyWithImpl<
          _$FineTuningModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningModelStringImplToJson(
      this,
    );
  }
}

abstract class FineTuningModelString extends FineTuningModel {
  const factory FineTuningModelString(final String value) =
      _$FineTuningModelStringImpl;
  const FineTuningModelString._() : super._();

  factory FineTuningModelString.fromJson(Map<String, dynamic> json) =
      _$FineTuningModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$FineTuningModelStringImplCopyWith<_$FineTuningModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJob _$FineTuningJobFromJson(Map<String, dynamic> json) {
  return _FineTuningJob.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJob {
  /// The object identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error => throw _privateConstructorUsedError;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters =>
      throw _privateConstructorUsedError;

  /// The base model that is being fine-tuned.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job".
  FineTuningJobObject get object => throw _privateConstructorUsedError;

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId => throw _privateConstructorUsedError;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles => throw _privateConstructorUsedError;

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status => throw _privateConstructorUsedError;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens => throw _privateConstructorUsedError;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobCopyWith<FineTuningJob> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobCopyWith<$Res> {
  factory $FineTuningJobCopyWith(
          FineTuningJob value, $Res Function(FineTuningJob) then) =
      _$FineTuningJobCopyWithImpl<$Res, FineTuningJob>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile});

  $FineTuningJobErrorCopyWith<$Res>? get error;
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class _$FineTuningJobCopyWithImpl<$Res, $Val extends FineTuningJob>
    implements $FineTuningJobCopyWith<$Res> {
  _$FineTuningJobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value.resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobErrorCopyWith<$Res>? get error {
    if (_value.error == null) {
      return null;
    }

    return $FineTuningJobErrorCopyWith<$Res>(_value.error!, (value) {
      return _then(_value.copyWith(error: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters {
    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobImplCopyWith<$Res>
    implements $FineTuningJobCopyWith<$Res> {
  factory _$$FineTuningJobImplCopyWith(
          _$FineTuningJobImpl value, $Res Function(_$FineTuningJobImpl) then) =
      __$$FineTuningJobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile});

  @override
  $FineTuningJobErrorCopyWith<$Res>? get error;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class __$$FineTuningJobImplCopyWithImpl<$Res>
    extends _$FineTuningJobCopyWithImpl<$Res, _$FineTuningJobImpl>
    implements _$$FineTuningJobImplCopyWith<$Res> {
  __$$FineTuningJobImplCopyWithImpl(
      _$FineTuningJobImpl _value, $Res Function(_$FineTuningJobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
  }) {
    return _then(_$FineTuningJobImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value._resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobImpl extends _FineTuningJob {
  const _$FineTuningJobImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.error,
      @JsonKey(name: 'fine_tuned_model') required this.fineTunedModel,
      @JsonKey(name: 'finished_at') required this.finishedAt,
      required this.hyperparameters,
      required this.model,
      required this.object,
      @JsonKey(name: 'organization_id') required this.organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required this.status,
      @JsonKey(name: 'trained_tokens') required this.trainedTokens,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(name: 'validation_file') required this.validationFile})
      : _resultFiles = resultFiles,
        super._();

  factory _$FineTuningJobImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobImplFromJson(json);

  /// The object identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  @override
  final FineTuningJobError? error;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'fine_tuned_model')
  final String? fineTunedModel;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'finished_at')
  final int? finishedAt;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  final FineTuningJobHyperparameters hyperparameters;

  /// The base model that is being fine-tuned.
  @override
  final String model;

  /// The object type, which is always "fine_tuning.job".
  @override
  final FineTuningJobObject object;

  /// The organization that owns the fine-tuning job.
  @override
  @JsonKey(name: 'organization_id')
  final String organizationId;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  final List<String> _resultFiles;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'result_files')
  List<String> get resultFiles {
    if (_resultFiles is EqualUnmodifiableListView) return _resultFiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_resultFiles);
  }

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  @override
  final FineTuningJobStatus status;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'trained_tokens')
  final int? trainedTokens;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'validation_file')
  final String? validationFile;

  @override
  String toString() {
    return 'FineTuningJob(id: $id, createdAt: $createdAt, error: $error, fineTunedModel: $fineTunedModel, finishedAt: $finishedAt, hyperparameters: $hyperparameters, model: $model, object: $object, organizationId: $organizationId, resultFiles: $resultFiles, status: $status, trainedTokens: $trainedTokens, trainingFile: $trainingFile, validationFile: $validationFile)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.fineTunedModel, fineTunedModel) ||
                other.fineTunedModel == fineTunedModel) &&
            (identical(other.finishedAt, finishedAt) ||
                other.finishedAt == finishedAt) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.organizationId, organizationId) ||
                other.organizationId == organizationId) &&
            const DeepCollectionEquality()
                .equals(other._resultFiles, _resultFiles) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.trainedTokens, trainedTokens) ||
                other.trainedTokens == trainedTokens) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      createdAt,
      error,
      fineTunedModel,
      finishedAt,
      hyperparameters,
      model,
      object,
      organizationId,
      const DeepCollectionEquality().hash(_resultFiles),
      status,
      trainedTokens,
      trainingFile,
      validationFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      __$$FineTuningJobImplCopyWithImpl<_$FineTuningJobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJob extends FineTuningJob {
  const factory _FineTuningJob(
      {required final String id,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') required final String? fineTunedModel,
      @JsonKey(name: 'finished_at') required final int? finishedAt,
      required final FineTuningJobHyperparameters hyperparameters,
      required final String model,
      required final FineTuningJobObject object,
      @JsonKey(name: 'organization_id') required final String organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required final FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') required final int? trainedTokens,
      @JsonKey(name: 'training_file') required final String trainingFile,
      @JsonKey(name: 'validation_file')
      required final String? validationFile}) = _$FineTuningJobImpl;
  const _FineTuningJob._() : super._();

  factory _FineTuningJob.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobImpl.fromJson;

  @override

  /// The object identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error;
  @override

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters;
  @override

  /// The base model that is being fine-tuned.
  String get model;
  @override

  /// The object type, which is always "fine_tuning.job".
  FineTuningJobObject get object;
  @override

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId;
  @override

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles;
  @override

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status;
  @override

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens;
  @override

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobError _$FineTuningJobErrorFromJson(Map<String, dynamic> json) {
  return _FineTuningJobError.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobError {
  /// A machine-readable error code.
  String get code => throw _privateConstructorUsedError;

  /// A human-readable error message.
  String get message => throw _privateConstructorUsedError;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobErrorCopyWith<FineTuningJobError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobErrorCopyWith<$Res> {
  factory $FineTuningJobErrorCopyWith(
          FineTuningJobError value, $Res Function(FineTuningJobError) then) =
      _$FineTuningJobErrorCopyWithImpl<$Res, FineTuningJobError>;
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class _$FineTuningJobErrorCopyWithImpl<$Res, $Val extends FineTuningJobError>
    implements $FineTuningJobErrorCopyWith<$Res> {
  _$FineTuningJobErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobErrorImplCopyWith<$Res>
    implements $FineTuningJobErrorCopyWith<$Res> {
  factory _$$FineTuningJobErrorImplCopyWith(_$FineTuningJobErrorImpl value,
          $Res Function(_$FineTuningJobErrorImpl) then) =
      __$$FineTuningJobErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class __$$FineTuningJobErrorImplCopyWithImpl<$Res>
    extends _$FineTuningJobErrorCopyWithImpl<$Res, _$FineTuningJobErrorImpl>
    implements _$$FineTuningJobErrorImplCopyWith<$Res> {
  __$$FineTuningJobErrorImplCopyWithImpl(_$FineTuningJobErrorImpl _value,
      $Res Function(_$FineTuningJobErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_$FineTuningJobErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobErrorImpl extends _FineTuningJobError {
  const _$FineTuningJobErrorImpl(
      {required this.code, required this.message, required this.param})
      : super._();

  factory _$FineTuningJobErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobErrorImplFromJson(json);

  /// A machine-readable error code.
  @override
  final String code;

  /// A human-readable error message.
  @override
  final String message;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  @override
  final String? param;

  @override
  String toString() {
    return 'FineTuningJobError(code: $code, message: $message, param: $param)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      __$$FineTuningJobErrorImplCopyWithImpl<_$FineTuningJobErrorImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobErrorImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobError extends FineTuningJobError {
  const factory _FineTuningJobError(
      {required final String code,
      required final String message,
      required final String? param}) = _$FineTuningJobErrorImpl;
  const _FineTuningJobError._() : super._();

  factory _FineTuningJobError.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobErrorImpl.fromJson;

  @override

  /// A machine-readable error code.
  String get code;
  @override

  /// A human-readable error message.
  String get message;
  @override

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobHyperparameters _$FineTuningJobHyperparametersFromJson(
    Map<String, dynamic> json) {
  return _FineTuningJobHyperparameters.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobHyperparameters {
  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobHyperparametersCopyWith<FineTuningJobHyperparameters>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobHyperparametersCopyWith<$Res> {
  factory $FineTuningJobHyperparametersCopyWith(
          FineTuningJobHyperparameters value,
          $Res Function(FineTuningJobHyperparameters) then) =
      _$FineTuningJobHyperparametersCopyWithImpl<$Res,
          FineTuningJobHyperparameters>;
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        $Val extends FineTuningJobHyperparameters>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  _$FineTuningJobHyperparametersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_value.copyWith(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsCopyWith<$Res> get nEpochs {
    return $FineTuningNEpochsCopyWith<$Res>(_value.nEpochs, (value) {
      return _then(_value.copyWith(nEpochs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobHyperparametersImplCopyWith<$Res>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  factory _$$FineTuningJobHyperparametersImplCopyWith(
          _$FineTuningJobHyperparametersImpl value,
          $Res Function(_$FineTuningJobHyperparametersImpl) then) =
      __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  @override
  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>
    extends _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        _$FineTuningJobHyperparametersImpl>
    implements _$$FineTuningJobHyperparametersImplCopyWith<$Res> {
  __$$FineTuningJobHyperparametersImplCopyWithImpl(
      _$FineTuningJobHyperparametersImpl _value,
      $Res Function(_$FineTuningJobHyperparametersImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_$FineTuningJobHyperparametersImpl(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobHyperparametersImpl extends _FineTuningJobHyperparameters {
  const _$FineTuningJobHyperparametersImpl(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      required this.nEpochs})
      : super._();

  factory _$FineTuningJobHyperparametersImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningJobHyperparametersImplFromJson(json);

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @override
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  final FineTuningNEpochs nEpochs;

  @override
  String toString() {
    return 'FineTuningJobHyperparameters(nEpochs: $nEpochs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobHyperparametersImpl &&
            (identical(other.nEpochs, nEpochs) || other.nEpochs == nEpochs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, nEpochs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => __$$FineTuningJobHyperparametersImplCopyWithImpl<
          _$FineTuningJobHyperparametersImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobHyperparametersImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobHyperparameters
    extends FineTuningJobHyperparameters {
  const factory _FineTuningJobHyperparameters(
          {@_FineTuningNEpochsConverter()
          @JsonKey(name: 'n_epochs')
          required final FineTuningNEpochs nEpochs}) =
      _$FineTuningJobHyperparametersImpl;
  const _FineTuningJobHyperparameters._() : super._();

  factory _FineTuningJobHyperparameters.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobHyperparametersImpl.fromJson;

  @override

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningNEpochs _$FineTuningNEpochsFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return FineTuningNEpochsEnumeration.fromJson(json);
    case 'number':
      return FineTuningNEpochsInt.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningNEpochs',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningNEpochs {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningNEpochsCopyWith<$Res> {
  factory $FineTuningNEpochsCopyWith(
          FineTuningNEpochs value, $Res Function(FineTuningNEpochs) then) =
      _$FineTuningNEpochsCopyWithImpl<$Res, FineTuningNEpochs>;
}

/// @nodoc
class _$FineTuningNEpochsCopyWithImpl<$Res, $Val extends FineTuningNEpochs>
    implements $FineTuningNEpochsCopyWith<$Res> {
  _$FineTuningNEpochsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FineTuningNEpochsEnumerationImplCopyWith<$Res> {
  factory _$$FineTuningNEpochsEnumerationImplCopyWith(
          _$FineTuningNEpochsEnumerationImpl value,
          $Res Function(_$FineTuningNEpochsEnumerationImpl) then) =
      __$$FineTuningNEpochsEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningNEpochsOptions value});
}

/// @nodoc
class __$$FineTuningNEpochsEnumerationImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res,
        _$FineTuningNEpochsEnumerationImpl>
    implements _$$FineTuningNEpochsEnumerationImplCopyWith<$Res> {
  __$$FineTuningNEpochsEnumerationImplCopyWithImpl(
      _$FineTuningNEpochsEnumerationImpl _value,
      $Res Function(_$FineTuningNEpochsEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningNEpochsEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochsOptions,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningNEpochsEnumerationImpl extends FineTuningNEpochsEnumeration {
  const _$FineTuningNEpochsEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$FineTuningNEpochsEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningNEpochsEnumerationImplFromJson(json);

  @override
  final FineTuningNEpochsOptions value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.mode(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningNEpochsEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningNEpochsEnumerationImplCopyWith<
          _$FineTuningNEpochsEnumerationImpl>
      get copyWith => __$$FineTuningNEpochsEnumerationImplCopyWithImpl<
          _$FineTuningNEpochsEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningNEpochsEnumerationImplToJson(
      this,
    );
  }
}

abstract class FineTuningNEpochsEnumeration extends FineTuningNEpochs {
  const factory FineTuningNEpochsEnumeration(
          final FineTuningNEpochsOptions value) =
      _$FineTuningNEpochsEnumerationImpl;
  const FineTuningNEpochsEnumeration._() : super._();

  factory FineTuningNEpochsEnumeration.fromJson(Map<String, dynamic> json) =
      _$FineTuningNEpochsEnumerationImpl.fromJson;

  @override
  FineTuningNEpochsOptions get value;
  @JsonKey(ignore: true)
  _$$FineTuningNEpochsEnumerationImplCopyWith<
          _$FineTuningNEpochsEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FineTuningNEpochsIntImplCopyWith<$Res> {
  factory _$$FineTuningNEpochsIntImplCopyWith(_$FineTuningNEpochsIntImpl value,
          $Res Function(_$FineTuningNEpochsIntImpl) then) =
      __$$FineTuningNEpochsIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$FineTuningNEpochsIntImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res, _$FineTuningNEpochsIntImpl>
    implements _$$FineTuningNEpochsIntImplCopyWith<$Res> {
  __$$FineTuningNEpochsIntImplCopyWithImpl(_$FineTuningNEpochsIntImpl _value,
      $Res Function(_$FineTuningNEpochsIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningNEpochsIntImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningNEpochsIntImpl extends FineTuningNEpochsInt {
  const _$FineTuningNEpochsIntImpl(this.value, {final String? $type})
      : $type = $type ?? 'number',
        super._();

  factory _$FineTuningNEpochsIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningNEpochsIntImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.number(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningNEpochsIntImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningNEpochsIntImplCopyWith<_$FineTuningNEpochsIntImpl>
      get copyWith =>
          __$$FineTuningNEpochsIntImplCopyWithImpl<_$FineTuningNEpochsIntImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) {
    return number(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) {
    return number?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) {
    return number(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) {
    return number?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningNEpochsIntImplToJson(
      this,
    );
  }
}

abstract class FineTuningNEpochsInt extends FineTuningNEpochs {
  const factory FineTuningNEpochsInt(final int value) =
      _$FineTuningNEpochsIntImpl;
  const FineTuningNEpochsInt._() : super._();

  factory FineTuningNEpochsInt.fromJson(Map<String, dynamic> json) =
      _$FineTuningNEpochsIntImpl.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$FineTuningNEpochsIntImplCopyWith<_$FineTuningNEpochsIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListPaginatedFineTuningJobsResponse
    _$ListPaginatedFineTuningJobsResponseFromJson(Map<String, dynamic> json) {
  return _ListPaginatedFineTuningJobsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListPaginatedFineTuningJobsResponse {
  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data => throw _privateConstructorUsedError;

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  ListPaginatedFineTuningJobsResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListPaginatedFineTuningJobsResponseCopyWith<
          ListPaginatedFineTuningJobsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory $ListPaginatedFineTuningJobsResponseCopyWith(
          ListPaginatedFineTuningJobsResponse value,
          $Res Function(ListPaginatedFineTuningJobsResponse) then) =
      _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
          ListPaginatedFineTuningJobsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        $Val extends ListPaginatedFineTuningJobsResponse>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  _$ListPaginatedFineTuningJobsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory _$$ListPaginatedFineTuningJobsResponseImplCopyWith(
          _$ListPaginatedFineTuningJobsResponseImpl value,
          $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) then) =
      __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>
    extends _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        _$ListPaginatedFineTuningJobsResponseImpl>
    implements _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res> {
  __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl(
      _$ListPaginatedFineTuningJobsResponseImpl _value,
      $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_$ListPaginatedFineTuningJobsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListPaginatedFineTuningJobsResponseImpl
    extends _ListPaginatedFineTuningJobsResponse {
  const _$ListPaginatedFineTuningJobsResponseImpl(
      {required final List<FineTuningJob> data,
      @JsonKey(name: 'has_more') required this.hasMore,
      required this.object})
      : _data = data,
        super._();

  factory _$ListPaginatedFineTuningJobsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListPaginatedFineTuningJobsResponseImplFromJson(json);

  /// The list of fine-tuning jobs.
  final List<FineTuningJob> _data;

  /// The list of fine-tuning jobs.
  @override
  List<FineTuningJob> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// Whether there are more fine-tuning jobs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// The object type, which is always "list".
  @override
  final ListPaginatedFineTuningJobsResponseObject object;

  @override
  String toString() {
    return 'ListPaginatedFineTuningJobsResponse(data: $data, hasMore: $hasMore, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListPaginatedFineTuningJobsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), hasMore, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<
          _$ListPaginatedFineTuningJobsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListPaginatedFineTuningJobsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListPaginatedFineTuningJobsResponse
    extends ListPaginatedFineTuningJobsResponse {
  const factory _ListPaginatedFineTuningJobsResponse(
          {required final List<FineTuningJob> data,
          @JsonKey(name: 'has_more') required final bool hasMore,
          required final ListPaginatedFineTuningJobsResponseObject object}) =
      _$ListPaginatedFineTuningJobsResponseImpl;
  const _ListPaginatedFineTuningJobsResponse._() : super._();

  factory _ListPaginatedFineTuningJobsResponse.fromJson(
          Map<String, dynamic> json) =
      _$ListPaginatedFineTuningJobsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data;
  @override

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override

  /// The object type, which is always "list".
  ListPaginatedFineTuningJobsResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListFineTuningJobEventsResponse _$ListFineTuningJobEventsResponseFromJson(
    Map<String, dynamic> json) {
  return _ListFineTuningJobEventsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListFineTuningJobEventsResponse {
  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  ListFineTuningJobEventsResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListFineTuningJobEventsResponseCopyWith<ListFineTuningJobEventsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory $ListFineTuningJobEventsResponseCopyWith(
          ListFineTuningJobEventsResponse value,
          $Res Function(ListFineTuningJobEventsResponse) then) =
      _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
          ListFineTuningJobEventsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        $Val extends ListFineTuningJobEventsResponse>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  _$ListFineTuningJobEventsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListFineTuningJobEventsResponseImplCopyWith<$Res>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory _$$ListFineTuningJobEventsResponseImplCopyWith(
          _$ListFineTuningJobEventsResponseImpl value,
          $Res Function(_$ListFineTuningJobEventsResponseImpl) then) =
      __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>
    extends _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        _$ListFineTuningJobEventsResponseImpl>
    implements _$$ListFineTuningJobEventsResponseImplCopyWith<$Res> {
  __$$ListFineTuningJobEventsResponseImplCopyWithImpl(
      _$ListFineTuningJobEventsResponseImpl _value,
      $Res Function(_$ListFineTuningJobEventsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_$ListFineTuningJobEventsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListFineTuningJobEventsResponseImpl
    extends _ListFineTuningJobEventsResponse {
  const _$ListFineTuningJobEventsResponseImpl(
      {required final List<FineTuningJobEvent> data, required this.object})
      : _data = data,
        super._();

  factory _$ListFineTuningJobEventsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListFineTuningJobEventsResponseImplFromJson(json);

  /// The list of fine-tuning job events.
  final List<FineTuningJobEvent> _data;

  /// The list of fine-tuning job events.
  @override
  List<FineTuningJobEvent> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The object type, which is always "list".
  @override
  final ListFineTuningJobEventsResponseObject object;

  @override
  String toString() {
    return 'ListFineTuningJobEventsResponse(data: $data, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListFineTuningJobEventsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => __$$ListFineTuningJobEventsResponseImplCopyWithImpl<
          _$ListFineTuningJobEventsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListFineTuningJobEventsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListFineTuningJobEventsResponse
    extends ListFineTuningJobEventsResponse {
  const factory _ListFineTuningJobEventsResponse(
          {required final List<FineTuningJobEvent> data,
          required final ListFineTuningJobEventsResponseObject object}) =
      _$ListFineTuningJobEventsResponseImpl;
  const _ListFineTuningJobEventsResponse._() : super._();

  factory _ListFineTuningJobEventsResponse.fromJson(Map<String, dynamic> json) =
      _$ListFineTuningJobEventsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data;
  @override

  /// The object type, which is always "list".
  ListFineTuningJobEventsResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJobEvent _$FineTuningJobEventFromJson(Map<String, dynamic> json) {
  return _FineTuningJobEvent.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobEvent {
  /// The event identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The log level of the event.
  FineTuningJobEventLevel get level => throw _privateConstructorUsedError;

  /// The message of the event.
  String get message => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job.event".
  FineTuningJobEventObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobEventCopyWith<FineTuningJobEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobEventCopyWith<$Res> {
  factory $FineTuningJobEventCopyWith(
          FineTuningJobEvent value, $Res Function(FineTuningJobEvent) then) =
      _$FineTuningJobEventCopyWithImpl<$Res, FineTuningJobEvent>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class _$FineTuningJobEventCopyWithImpl<$Res, $Val extends FineTuningJobEvent>
    implements $FineTuningJobEventCopyWith<$Res> {
  _$FineTuningJobEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobEventImplCopyWith<$Res>
    implements $FineTuningJobEventCopyWith<$Res> {
  factory _$$FineTuningJobEventImplCopyWith(_$FineTuningJobEventImpl value,
          $Res Function(_$FineTuningJobEventImpl) then) =
      __$$FineTuningJobEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class __$$FineTuningJobEventImplCopyWithImpl<$Res>
    extends _$FineTuningJobEventCopyWithImpl<$Res, _$FineTuningJobEventImpl>
    implements _$$FineTuningJobEventImplCopyWith<$Res> {
  __$$FineTuningJobEventImplCopyWithImpl(_$FineTuningJobEventImpl _value,
      $Res Function(_$FineTuningJobEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_$FineTuningJobEventImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobEventImpl extends _FineTuningJobEvent {
  const _$FineTuningJobEventImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.level,
      required this.message,
      required this.object})
      : super._();

  factory _$FineTuningJobEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobEventImplFromJson(json);

  /// The event identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the event was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The log level of the event.
  @override
  final FineTuningJobEventLevel level;

  /// The message of the event.
  @override
  final String message;

  /// The object type, which is always "fine_tuning.job.event".
  @override
  final FineTuningJobEventObject object;

  @override
  String toString() {
    return 'FineTuningJobEvent(id: $id, createdAt: $createdAt, level: $level, message: $message, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobEventImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, createdAt, level, message, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      __$$FineTuningJobEventImplCopyWithImpl<_$FineTuningJobEventImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobEventImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobEvent extends FineTuningJobEvent {
  const factory _FineTuningJobEvent(
          {required final String id,
          @JsonKey(name: 'created_at') required final int createdAt,
          required final FineTuningJobEventLevel level,
          required final String message,
          required final FineTuningJobEventObject object}) =
      _$FineTuningJobEventImpl;
  const _FineTuningJobEvent._() : super._();

  factory _FineTuningJobEvent.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobEventImpl.fromJson;

  @override

  /// The event identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The log level of the event.
  FineTuningJobEventLevel get level;
  @override

  /// The message of the event.
  String get message;
  @override

  /// The object type, which is always "fine_tuning.job.event".
  FineTuningJobEventObject get object;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateImageRequest _$CreateImageRequestFromJson(Map<String, dynamic> json) {
  return _CreateImageRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateImageRequest {
  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  String get prompt => throw _privateConstructorUsedError;

  /// The model to use for image generation.
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateImageRequestModel? get model => throw _privateConstructorUsedError;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  ImageQuality get quality => throw _privateConstructorUsedError;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat => throw _privateConstructorUsedError;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size => throw _privateConstructorUsedError;

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageStyle? get style => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateImageRequestCopyWith<CreateImageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateImageRequestCopyWith<$Res> {
  factory $CreateImageRequestCopyWith(
          CreateImageRequest value, $Res Function(CreateImageRequest) then) =
      _$CreateImageRequestCopyWithImpl<$Res, CreateImageRequest>;
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      ImageQuality quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class _$CreateImageRequestCopyWithImpl<$Res, $Val extends CreateImageRequest>
    implements $CreateImageRequestCopyWith<$Res> {
  _$CreateImageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = null,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateImageRequestModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $CreateImageRequestModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateImageRequestImplCopyWith<$Res>
    implements $CreateImageRequestCopyWith<$Res> {
  factory _$$CreateImageRequestImplCopyWith(_$CreateImageRequestImpl value,
          $Res Function(_$CreateImageRequestImpl) then) =
      __$$CreateImageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      ImageQuality quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class __$$CreateImageRequestImplCopyWithImpl<$Res>
    extends _$CreateImageRequestCopyWithImpl<$Res, _$CreateImageRequestImpl>
    implements _$$CreateImageRequestImplCopyWith<$Res> {
  __$$CreateImageRequestImplCopyWithImpl(_$CreateImageRequestImpl _value,
      $Res Function(_$CreateImageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = null,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateImageRequestImpl(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestImpl extends _CreateImageRequest {
  const _$CreateImageRequestImpl(
      {required this.prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const CreateImageRequestModelString('dall-e-2'),
      @JsonKey(includeIfNull: false) this.n = 1,
      this.quality = ImageQuality.standard,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.responseFormat = ImageResponseFormat.url,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.size = ImageSize.v1024x1024,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.style = ImageStyle.vivid,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateImageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateImageRequestImplFromJson(json);

  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  @override
  final String prompt;

  /// The model to use for image generation.
  @override
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  final CreateImageRequestModel? model;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  @override
  @JsonKey()
  final ImageQuality quality;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @override
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageResponseFormat? responseFormat;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageSize? size;

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageStyle? style;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateImageRequest(prompt: $prompt, model: $model, n: $n, quality: $quality, responseFormat: $responseFormat, size: $size, style: $style, user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestImpl &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, prompt, model, n, quality,
      responseFormat, size, style, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      __$$CreateImageRequestImplCopyWithImpl<_$CreateImageRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateImageRequest extends CreateImageRequest {
  const factory _CreateImageRequest(
          {required final String prompt,
          @_CreateImageRequestModelConverter()
          @JsonKey(includeIfNull: false)
          final CreateImageRequestModel? model,
          @JsonKey(includeIfNull: false) final int? n,
          final ImageQuality quality,
          @JsonKey(
              name: 'response_format',
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageResponseFormat? responseFormat,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageSize? size,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageStyle? style,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateImageRequestImpl;
  const _CreateImageRequest._() : super._();

  factory _CreateImageRequest.fromJson(Map<String, dynamic> json) =
      _$CreateImageRequestImpl.fromJson;

  @override

  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  String get prompt;
  @override

  /// The model to use for image generation.
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateImageRequestModel? get model;
  @override

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  ImageQuality get quality;
  @override

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat;
  @override

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size;
  @override

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageStyle? get style;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateImageRequestModel _$CreateImageRequestModelFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CreateImageRequestModelEnumeration.fromJson(json);
    case 'modelId':
      return CreateImageRequestModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateImageRequestModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateImageRequestModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateImageRequestModelCopyWith<$Res> {
  factory $CreateImageRequestModelCopyWith(CreateImageRequestModel value,
          $Res Function(CreateImageRequestModel) then) =
      _$CreateImageRequestModelCopyWithImpl<$Res, CreateImageRequestModel>;
}

/// @nodoc
class _$CreateImageRequestModelCopyWithImpl<$Res,
        $Val extends CreateImageRequestModel>
    implements $CreateImageRequestModelCopyWith<$Res> {
  _$CreateImageRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateImageRequestModelEnumerationImplCopyWith<$Res> {
  factory _$$CreateImageRequestModelEnumerationImplCopyWith(
          _$CreateImageRequestModelEnumerationImpl value,
          $Res Function(_$CreateImageRequestModelEnumerationImpl) then) =
      __$$CreateImageRequestModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ImageModels value});
}

/// @nodoc
class __$$CreateImageRequestModelEnumerationImplCopyWithImpl<$Res>
    extends _$CreateImageRequestModelCopyWithImpl<$Res,
        _$CreateImageRequestModelEnumerationImpl>
    implements _$$CreateImageRequestModelEnumerationImplCopyWith<$Res> {
  __$$CreateImageRequestModelEnumerationImplCopyWithImpl(
      _$CreateImageRequestModelEnumerationImpl _value,
      $Res Function(_$CreateImageRequestModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateImageRequestModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ImageModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestModelEnumerationImpl
    extends CreateImageRequestModelEnumeration {
  const _$CreateImageRequestModelEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$CreateImageRequestModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateImageRequestModelEnumerationImplFromJson(json);

  @override
  final ImageModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateImageRequestModel.model(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestModelEnumerationImplCopyWith<
          _$CreateImageRequestModelEnumerationImpl>
      get copyWith => __$$CreateImageRequestModelEnumerationImplCopyWithImpl<
          _$CreateImageRequestModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateImageRequestModelEnumeration
    extends CreateImageRequestModel {
  const factory CreateImageRequestModelEnumeration(final ImageModels value) =
      _$CreateImageRequestModelEnumerationImpl;
  const CreateImageRequestModelEnumeration._() : super._();

  factory CreateImageRequestModelEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateImageRequestModelEnumerationImpl.fromJson;

  @override
  ImageModels get value;
  @JsonKey(ignore: true)
  _$$CreateImageRequestModelEnumerationImplCopyWith<
          _$CreateImageRequestModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateImageRequestModelStringImplCopyWith<$Res> {
  factory _$$CreateImageRequestModelStringImplCopyWith(
          _$CreateImageRequestModelStringImpl value,
          $Res Function(_$CreateImageRequestModelStringImpl) then) =
      __$$CreateImageRequestModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CreateImageRequestModelStringImplCopyWithImpl<$Res>
    extends _$CreateImageRequestModelCopyWithImpl<$Res,
        _$CreateImageRequestModelStringImpl>
    implements _$$CreateImageRequestModelStringImplCopyWith<$Res> {
  __$$CreateImageRequestModelStringImplCopyWithImpl(
      _$CreateImageRequestModelStringImpl _value,
      $Res Function(_$CreateImageRequestModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateImageRequestModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestModelStringImpl
    extends CreateImageRequestModelString {
  const _$CreateImageRequestModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$CreateImageRequestModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateImageRequestModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateImageRequestModel.modelId(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestModelStringImplCopyWith<
          _$CreateImageRequestModelStringImpl>
      get copyWith => __$$CreateImageRequestModelStringImplCopyWithImpl<
          _$CreateImageRequestModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestModelStringImplToJson(
      this,
    );
  }
}

abstract class CreateImageRequestModelString extends CreateImageRequestModel {
  const factory CreateImageRequestModelString(final String value) =
      _$CreateImageRequestModelStringImpl;
  const CreateImageRequestModelString._() : super._();

  factory CreateImageRequestModelString.fromJson(Map<String, dynamic> json) =
      _$CreateImageRequestModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CreateImageRequestModelStringImplCopyWith<
          _$CreateImageRequestModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ImagesResponse _$ImagesResponseFromJson(Map<String, dynamic> json) {
  return _ImagesResponse.fromJson(json);
}

/// @nodoc
mixin _$ImagesResponse {
  /// The Unix timestamp (in seconds) when the image was created.
  int get created => throw _privateConstructorUsedError;

  /// The list of images generated by the model.
  List<Image> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImagesResponseCopyWith<ImagesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImagesResponseCopyWith<$Res> {
  factory $ImagesResponseCopyWith(
          ImagesResponse value, $Res Function(ImagesResponse) then) =
      _$ImagesResponseCopyWithImpl<$Res, ImagesResponse>;
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class _$ImagesResponseCopyWithImpl<$Res, $Val extends ImagesResponse>
    implements $ImagesResponseCopyWith<$Res> {
  _$ImagesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImagesResponseImplCopyWith<$Res>
    implements $ImagesResponseCopyWith<$Res> {
  factory _$$ImagesResponseImplCopyWith(_$ImagesResponseImpl value,
          $Res Function(_$ImagesResponseImpl) then) =
      __$$ImagesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class __$$ImagesResponseImplCopyWithImpl<$Res>
    extends _$ImagesResponseCopyWithImpl<$Res, _$ImagesResponseImpl>
    implements _$$ImagesResponseImplCopyWith<$Res> {
  __$$ImagesResponseImplCopyWithImpl(
      _$ImagesResponseImpl _value, $Res Function(_$ImagesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_$ImagesResponseImpl(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImagesResponseImpl extends _ImagesResponse {
  const _$ImagesResponseImpl(
      {required this.created, required final List<Image> data})
      : _data = data,
        super._();

  factory _$ImagesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImagesResponseImplFromJson(json);

  /// The Unix timestamp (in seconds) when the image was created.
  @override
  final int created;

  /// The list of images generated by the model.
  final List<Image> _data;

  /// The list of images generated by the model.
  @override
  List<Image> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ImagesResponse(created: $created, data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImagesResponseImpl &&
            (identical(other.created, created) || other.created == created) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, created, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      __$$ImagesResponseImplCopyWithImpl<_$ImagesResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImagesResponseImplToJson(
      this,
    );
  }
}

abstract class _ImagesResponse extends ImagesResponse {
  const factory _ImagesResponse(
      {required final int created,
      required final List<Image> data}) = _$ImagesResponseImpl;
  const _ImagesResponse._() : super._();

  factory _ImagesResponse.fromJson(Map<String, dynamic> json) =
      _$ImagesResponseImpl.fromJson;

  @override

  /// The Unix timestamp (in seconds) when the image was created.
  int get created;
  @override

  /// The list of images generated by the model.
  List<Image> get data;
  @override
  @JsonKey(ignore: true)
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Image _$ImageFromJson(Map<String, dynamic> json) {
  return _Image.fromJson(json);
}

/// @nodoc
mixin _$Image {
  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json => throw _privateConstructorUsedError;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url => throw _privateConstructorUsedError;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  String? get revisedPrompt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageCopyWith<Image> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageCopyWith<$Res> {
  factory $ImageCopyWith(Image value, $Res Function(Image) then) =
      _$ImageCopyWithImpl<$Res, Image>;
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class _$ImageCopyWithImpl<$Res, $Val extends Image>
    implements $ImageCopyWith<$Res> {
  _$ImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_value.copyWith(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _value.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageImplCopyWith<$Res> implements $ImageCopyWith<$Res> {
  factory _$$ImageImplCopyWith(
          _$ImageImpl value, $Res Function(_$ImageImpl) then) =
      __$$ImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class __$$ImageImplCopyWithImpl<$Res>
    extends _$ImageCopyWithImpl<$Res, _$ImageImpl>
    implements _$$ImageImplCopyWith<$Res> {
  __$$ImageImplCopyWithImpl(
      _$ImageImpl _value, $Res Function(_$ImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_$ImageImpl(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _value.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageImpl extends _Image {
  const _$ImageImpl(
      {@JsonKey(name: 'b64_json', includeIfNull: false) this.b64Json,
      @JsonKey(includeIfNull: false) this.url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      this.revisedPrompt})
      : super._();

  factory _$ImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImageImplFromJson(json);

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @override
  @JsonKey(name: 'b64_json', includeIfNull: false)
  final String? b64Json;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @override
  @JsonKey(includeIfNull: false)
  final String? url;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @override
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  final String? revisedPrompt;

  @override
  String toString() {
    return 'Image(b64Json: $b64Json, url: $url, revisedPrompt: $revisedPrompt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageImpl &&
            (identical(other.b64Json, b64Json) || other.b64Json == b64Json) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.revisedPrompt, revisedPrompt) ||
                other.revisedPrompt == revisedPrompt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, b64Json, url, revisedPrompt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      __$$ImageImplCopyWithImpl<_$ImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageImplToJson(
      this,
    );
  }
}

abstract class _Image extends Image {
  const factory _Image(
      {@JsonKey(name: 'b64_json', includeIfNull: false) final String? b64Json,
      @JsonKey(includeIfNull: false) final String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      final String? revisedPrompt}) = _$ImageImpl;
  const _Image._() : super._();

  factory _Image.fromJson(Map<String, dynamic> json) = _$ImageImpl.fromJson;

  @override

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json;
  @override

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url;
  @override

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  String? get revisedPrompt;
  @override
  @JsonKey(ignore: true)
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Model _$ModelFromJson(Map<String, dynamic> json) {
  return _Model.fromJson(json);
}

/// @nodoc
mixin _$Model {
  /// The model identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) when the model was created.
  int get created => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  ModelObject get object => throw _privateConstructorUsedError;

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModelCopyWith<Model> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) then) =
      _$ModelCopyWithImpl<$Res, Model>;
  @useResult
  $Res call(
      {String id,
      int created,
      ModelObject object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class _$ModelCopyWithImpl<$Res, $Val extends Model>
    implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModelImplCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$$ModelImplCopyWith(
          _$ModelImpl value, $Res Function(_$ModelImpl) then) =
      __$$ModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      int created,
      ModelObject object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class __$$ModelImplCopyWithImpl<$Res>
    extends _$ModelCopyWithImpl<$Res, _$ModelImpl>
    implements _$$ModelImplCopyWith<$Res> {
  __$$ModelImplCopyWithImpl(
      _$ModelImpl _value, $Res Function(_$ModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_$ModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModelImpl extends _Model {
  const _$ModelImpl(
      {required this.id,
      required this.created,
      required this.object,
      @JsonKey(name: 'owned_by') required this.ownedBy})
      : super._();

  factory _$ModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModelImplFromJson(json);

  /// The model identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) when the model was created.
  @override
  final int created;

  /// The object type, which is always "model".
  @override
  final ModelObject object;

  /// The organization that owns the model.
  @override
  @JsonKey(name: 'owned_by')
  final String ownedBy;

  @override
  String toString() {
    return 'Model(id: $id, created: $created, object: $object, ownedBy: $ownedBy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.ownedBy, ownedBy) || other.ownedBy == ownedBy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, created, object, ownedBy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      __$$ModelImplCopyWithImpl<_$ModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModelImplToJson(
      this,
    );
  }
}

abstract class _Model extends Model {
  const factory _Model(
      {required final String id,
      required final int created,
      required final ModelObject object,
      @JsonKey(name: 'owned_by') required final String ownedBy}) = _$ModelImpl;
  const _Model._() : super._();

  factory _Model.fromJson(Map<String, dynamic> json) = _$ModelImpl.fromJson;

  @override

  /// The model identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) when the model was created.
  int get created;
  @override

  /// The object type, which is always "model".
  ModelObject get object;
  @override

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy;
  @override
  @JsonKey(ignore: true)
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListModelsResponse _$ListModelsResponseFromJson(Map<String, dynamic> json) {
  return _ListModelsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListModelsResponse {
  /// The object type, which is always "list".
  ListModelsResponseObject get object => throw _privateConstructorUsedError;

  /// The list of models.
  List<Model> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListModelsResponseCopyWith<ListModelsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListModelsResponseCopyWith<$Res> {
  factory $ListModelsResponseCopyWith(
          ListModelsResponse value, $Res Function(ListModelsResponse) then) =
      _$ListModelsResponseCopyWithImpl<$Res, ListModelsResponse>;
  @useResult
  $Res call({ListModelsResponseObject object, List<Model> data});
}

/// @nodoc
class _$ListModelsResponseCopyWithImpl<$Res, $Val extends ListModelsResponse>
    implements $ListModelsResponseCopyWith<$Res> {
  _$ListModelsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListModelsResponseImplCopyWith<$Res>
    implements $ListModelsResponseCopyWith<$Res> {
  factory _$$ListModelsResponseImplCopyWith(_$ListModelsResponseImpl value,
          $Res Function(_$ListModelsResponseImpl) then) =
      __$$ListModelsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ListModelsResponseObject object, List<Model> data});
}

/// @nodoc
class __$$ListModelsResponseImplCopyWithImpl<$Res>
    extends _$ListModelsResponseCopyWithImpl<$Res, _$ListModelsResponseImpl>
    implements _$$ListModelsResponseImplCopyWith<$Res> {
  __$$ListModelsResponseImplCopyWithImpl(_$ListModelsResponseImpl _value,
      $Res Function(_$ListModelsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_$ListModelsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListModelsResponseImpl extends _ListModelsResponse {
  const _$ListModelsResponseImpl(
      {required this.object, required final List<Model> data})
      : _data = data,
        super._();

  factory _$ListModelsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListModelsResponseImplFromJson(json);

  /// The object type, which is always "list".
  @override
  final ListModelsResponseObject object;

  /// The list of models.
  final List<Model> _data;

  /// The list of models.
  @override
  List<Model> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ListModelsResponse(object: $object, data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListModelsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      __$$ListModelsResponseImplCopyWithImpl<_$ListModelsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListModelsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListModelsResponse extends ListModelsResponse {
  const factory _ListModelsResponse(
      {required final ListModelsResponseObject object,
      required final List<Model> data}) = _$ListModelsResponseImpl;
  const _ListModelsResponse._() : super._();

  factory _ListModelsResponse.fromJson(Map<String, dynamic> json) =
      _$ListModelsResponseImpl.fromJson;

  @override

  /// The object type, which is always "list".
  ListModelsResponseObject get object;
  @override

  /// The list of models.
  List<Model> get data;
  @override
  @JsonKey(ignore: true)
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeleteModelResponse _$DeleteModelResponseFromJson(Map<String, dynamic> json) {
  return _DeleteModelResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteModelResponse {
  /// The model identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the model was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteModelResponseCopyWith<DeleteModelResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteModelResponseCopyWith<$Res> {
  factory $DeleteModelResponseCopyWith(
          DeleteModelResponse value, $Res Function(DeleteModelResponse) then) =
      _$DeleteModelResponseCopyWithImpl<$Res, DeleteModelResponse>;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteModelResponseCopyWithImpl<$Res, $Val extends DeleteModelResponse>
    implements $DeleteModelResponseCopyWith<$Res> {
  _$DeleteModelResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteModelResponseImplCopyWith<$Res>
    implements $DeleteModelResponseCopyWith<$Res> {
  factory _$$DeleteModelResponseImplCopyWith(_$DeleteModelResponseImpl value,
          $Res Function(_$DeleteModelResponseImpl) then) =
      __$$DeleteModelResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$$DeleteModelResponseImplCopyWithImpl<$Res>
    extends _$DeleteModelResponseCopyWithImpl<$Res, _$DeleteModelResponseImpl>
    implements _$$DeleteModelResponseImplCopyWith<$Res> {
  __$$DeleteModelResponseImplCopyWithImpl(_$DeleteModelResponseImpl _value,
      $Res Function(_$DeleteModelResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteModelResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteModelResponseImpl extends _DeleteModelResponse {
  const _$DeleteModelResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteModelResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteModelResponseImplFromJson(json);

  /// The model identifier.
  @override
  final String id;

  /// Whether the model was deleted.
  @override
  final bool deleted;

  /// The object type, which is always "model".
  @override
  final String object;

  @override
  String toString() {
    return 'DeleteModelResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteModelResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      __$$DeleteModelResponseImplCopyWithImpl<_$DeleteModelResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteModelResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteModelResponse extends DeleteModelResponse {
  const factory _DeleteModelResponse(
      {required final String id,
      required final bool deleted,
      required final String object}) = _$DeleteModelResponseImpl;
  const _DeleteModelResponse._() : super._();

  factory _DeleteModelResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteModelResponseImpl.fromJson;

  @override

  /// The model identifier.
  String get id;
  @override

  /// Whether the model was deleted.
  bool get deleted;
  @override

  /// The object type, which is always "model".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateModerationRequest _$CreateModerationRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationRequest {
  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model => throw _privateConstructorUsedError;

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationRequestCopyWith<CreateModerationRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationRequestCopyWith<$Res> {
  factory $CreateModerationRequestCopyWith(CreateModerationRequest value,
          $Res Function(CreateModerationRequest) then) =
      _$CreateModerationRequestCopyWithImpl<$Res, CreateModerationRequest>;
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  $ModerationModelCopyWith<$Res>? get model;
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateModerationRequestCopyWithImpl<$Res,
        $Val extends CreateModerationRequest>
    implements $CreateModerationRequestCopyWith<$Res> {
  _$CreateModerationRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_value.copyWith(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $ModerationModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationInputCopyWith<$Res> get input {
    return $ModerationInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateModerationRequestImplCopyWith<$Res>
    implements $CreateModerationRequestCopyWith<$Res> {
  factory _$$CreateModerationRequestImplCopyWith(
          _$CreateModerationRequestImpl value,
          $Res Function(_$CreateModerationRequestImpl) then) =
      __$$CreateModerationRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  @override
  $ModerationModelCopyWith<$Res>? get model;
  @override
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateModerationRequestImplCopyWithImpl<$Res>
    extends _$CreateModerationRequestCopyWithImpl<$Res,
        _$CreateModerationRequestImpl>
    implements _$$CreateModerationRequestImplCopyWith<$Res> {
  __$$CreateModerationRequestImplCopyWithImpl(
      _$CreateModerationRequestImpl _value,
      $Res Function(_$CreateModerationRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_$CreateModerationRequestImpl(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationRequestImpl extends _CreateModerationRequest {
  const _$CreateModerationRequestImpl(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const ModerationModelString('text-moderation-latest'),
      @_ModerationInputConverter() required this.input})
      : super._();

  factory _$CreateModerationRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationRequestImplFromJson(json);

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @override
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  final ModerationModel? model;

  /// The input text to classify
  @override
  @_ModerationInputConverter()
  final ModerationInput input;

  @override
  String toString() {
    return 'CreateModerationRequest(model: $model, input: $input)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, model, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => __$$CreateModerationRequestImplCopyWithImpl<
          _$CreateModerationRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationRequest extends CreateModerationRequest {
  const factory _CreateModerationRequest(
          {@_ModerationModelConverter()
          @JsonKey(includeIfNull: false)
          final ModerationModel? model,
          @_ModerationInputConverter() required final ModerationInput input}) =
      _$CreateModerationRequestImpl;
  const _CreateModerationRequest._() : super._();

  factory _CreateModerationRequest.fromJson(Map<String, dynamic> json) =
      _$CreateModerationRequestImpl.fromJson;

  @override

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model;
  @override

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationModel _$ModerationModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ModerationModelEnumeration.fromJson(json);
    case 'modelId':
      return ModerationModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationModelCopyWith<$Res> {
  factory $ModerationModelCopyWith(
          ModerationModel value, $Res Function(ModerationModel) then) =
      _$ModerationModelCopyWithImpl<$Res, ModerationModel>;
}

/// @nodoc
class _$ModerationModelCopyWithImpl<$Res, $Val extends ModerationModel>
    implements $ModerationModelCopyWith<$Res> {
  _$ModerationModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ModerationModelEnumerationImplCopyWith<$Res> {
  factory _$$ModerationModelEnumerationImplCopyWith(
          _$ModerationModelEnumerationImpl value,
          $Res Function(_$ModerationModelEnumerationImpl) then) =
      __$$ModerationModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ModerationModels value});
}

/// @nodoc
class __$$ModerationModelEnumerationImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res,
        _$ModerationModelEnumerationImpl>
    implements _$$ModerationModelEnumerationImplCopyWith<$Res> {
  __$$ModerationModelEnumerationImplCopyWithImpl(
      _$ModerationModelEnumerationImpl _value,
      $Res Function(_$ModerationModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ModerationModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationModelEnumerationImpl extends ModerationModelEnumeration {
  const _$ModerationModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$ModerationModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModerationModelEnumerationImplFromJson(json);

  @override
  final ModerationModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.model(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationModelEnumerationImplCopyWith<_$ModerationModelEnumerationImpl>
      get copyWith => __$$ModerationModelEnumerationImplCopyWithImpl<
          _$ModerationModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class ModerationModelEnumeration extends ModerationModel {
  const factory ModerationModelEnumeration(final ModerationModels value) =
      _$ModerationModelEnumerationImpl;
  const ModerationModelEnumeration._() : super._();

  factory ModerationModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$ModerationModelEnumerationImpl.fromJson;

  @override
  ModerationModels get value;
  @JsonKey(ignore: true)
  _$$ModerationModelEnumerationImplCopyWith<_$ModerationModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModerationModelStringImplCopyWith<$Res> {
  factory _$$ModerationModelStringImplCopyWith(
          _$ModerationModelStringImpl value,
          $Res Function(_$ModerationModelStringImpl) then) =
      __$$ModerationModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ModerationModelStringImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res, _$ModerationModelStringImpl>
    implements _$$ModerationModelStringImplCopyWith<$Res> {
  __$$ModerationModelStringImplCopyWithImpl(_$ModerationModelStringImpl _value,
      $Res Function(_$ModerationModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationModelStringImpl extends ModerationModelString {
  const _$ModerationModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$ModerationModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.modelId(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationModelStringImplCopyWith<_$ModerationModelStringImpl>
      get copyWith => __$$ModerationModelStringImplCopyWithImpl<
          _$ModerationModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationModelStringImplToJson(
      this,
    );
  }
}

abstract class ModerationModelString extends ModerationModel {
  const factory ModerationModelString(final String value) =
      _$ModerationModelStringImpl;
  const ModerationModelString._() : super._();

  factory ModerationModelString.fromJson(Map<String, dynamic> json) =
      _$ModerationModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ModerationModelStringImplCopyWith<_$ModerationModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationInput _$ModerationInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return ModerationInputListString.fromJson(json);
    case 'string':
      return ModerationInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationInputCopyWith<$Res> {
  factory $ModerationInputCopyWith(
          ModerationInput value, $Res Function(ModerationInput) then) =
      _$ModerationInputCopyWithImpl<$Res, ModerationInput>;
}

/// @nodoc
class _$ModerationInputCopyWithImpl<$Res, $Val extends ModerationInput>
    implements $ModerationInputCopyWith<$Res> {
  _$ModerationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ModerationInputListStringImplCopyWith<$Res> {
  factory _$$ModerationInputListStringImplCopyWith(
          _$ModerationInputListStringImpl value,
          $Res Function(_$ModerationInputListStringImpl) then) =
      __$$ModerationInputListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$ModerationInputListStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res, _$ModerationInputListStringImpl>
    implements _$$ModerationInputListStringImplCopyWith<$Res> {
  __$$ModerationInputListStringImplCopyWithImpl(
      _$ModerationInputListStringImpl _value,
      $Res Function(_$ModerationInputListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationInputListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationInputListStringImpl extends ModerationInputListString {
  const _$ModerationInputListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$ModerationInputListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationInputListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.listString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationInputListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationInputListStringImplCopyWith<_$ModerationInputListStringImpl>
      get copyWith => __$$ModerationInputListStringImplCopyWithImpl<
          _$ModerationInputListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationInputListStringImplToJson(
      this,
    );
  }
}

abstract class ModerationInputListString extends ModerationInput {
  const factory ModerationInputListString(final List<String> value) =
      _$ModerationInputListStringImpl;
  const ModerationInputListString._() : super._();

  factory ModerationInputListString.fromJson(Map<String, dynamic> json) =
      _$ModerationInputListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$ModerationInputListStringImplCopyWith<_$ModerationInputListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModerationInputStringImplCopyWith<$Res> {
  factory _$$ModerationInputStringImplCopyWith(
          _$ModerationInputStringImpl value,
          $Res Function(_$ModerationInputStringImpl) then) =
      __$$ModerationInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ModerationInputStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res, _$ModerationInputStringImpl>
    implements _$$ModerationInputStringImplCopyWith<$Res> {
  __$$ModerationInputStringImplCopyWithImpl(_$ModerationInputStringImpl _value,
      $Res Function(_$ModerationInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationInputStringImpl extends ModerationInputString {
  const _$ModerationInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ModerationInputStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationInputStringImplCopyWith<_$ModerationInputStringImpl>
      get copyWith => __$$ModerationInputStringImplCopyWithImpl<
          _$ModerationInputStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationInputStringImplToJson(
      this,
    );
  }
}

abstract class ModerationInputString extends ModerationInput {
  const factory ModerationInputString(final String value) =
      _$ModerationInputStringImpl;
  const ModerationInputString._() : super._();

  factory ModerationInputString.fromJson(Map<String, dynamic> json) =
      _$ModerationInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ModerationInputStringImplCopyWith<_$ModerationInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateModerationResponse _$CreateModerationResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationResponse {
  /// The unique identifier for the moderation request.
  String get id => throw _privateConstructorUsedError;

  /// The model used to generate the moderation results.
  String get model => throw _privateConstructorUsedError;

  /// A list of moderation objects.
  List<Moderation> get results => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationResponseCopyWith<CreateModerationResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationResponseCopyWith<$Res> {
  factory $CreateModerationResponseCopyWith(CreateModerationResponse value,
          $Res Function(CreateModerationResponse) then) =
      _$CreateModerationResponseCopyWithImpl<$Res, CreateModerationResponse>;
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class _$CreateModerationResponseCopyWithImpl<$Res,
        $Val extends CreateModerationResponse>
    implements $CreateModerationResponseCopyWith<$Res> {
  _$CreateModerationResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateModerationResponseImplCopyWith<$Res>
    implements $CreateModerationResponseCopyWith<$Res> {
  factory _$$CreateModerationResponseImplCopyWith(
          _$CreateModerationResponseImpl value,
          $Res Function(_$CreateModerationResponseImpl) then) =
      __$$CreateModerationResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class __$$CreateModerationResponseImplCopyWithImpl<$Res>
    extends _$CreateModerationResponseCopyWithImpl<$Res,
        _$CreateModerationResponseImpl>
    implements _$$CreateModerationResponseImplCopyWith<$Res> {
  __$$CreateModerationResponseImplCopyWithImpl(
      _$CreateModerationResponseImpl _value,
      $Res Function(_$CreateModerationResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_$CreateModerationResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationResponseImpl extends _CreateModerationResponse {
  const _$CreateModerationResponseImpl(
      {required this.id,
      required this.model,
      required final List<Moderation> results})
      : _results = results,
        super._();

  factory _$CreateModerationResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationResponseImplFromJson(json);

  /// The unique identifier for the moderation request.
  @override
  final String id;

  /// The model used to generate the moderation results.
  @override
  final String model;

  /// A list of moderation objects.
  final List<Moderation> _results;

  /// A list of moderation objects.
  @override
  List<Moderation> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  @override
  String toString() {
    return 'CreateModerationResponse(id: $id, model: $model, results: $results)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._results, _results));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, model, const DeepCollectionEquality().hash(_results));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => __$$CreateModerationResponseImplCopyWithImpl<
          _$CreateModerationResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationResponse extends CreateModerationResponse {
  const factory _CreateModerationResponse(
          {required final String id,
          required final String model,
          required final List<Moderation> results}) =
      _$CreateModerationResponseImpl;
  const _CreateModerationResponse._() : super._();

  factory _CreateModerationResponse.fromJson(Map<String, dynamic> json) =
      _$CreateModerationResponseImpl.fromJson;

  @override

  /// The unique identifier for the moderation request.
  String get id;
  @override

  /// The model used to generate the moderation results.
  String get model;
  @override

  /// A list of moderation objects.
  List<Moderation> get results;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Moderation _$ModerationFromJson(Map<String, dynamic> json) {
  return _Moderation.fromJson(json);
}

/// @nodoc
mixin _$Moderation {
  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  bool get flagged => throw _privateConstructorUsedError;

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories => throw _privateConstructorUsedError;

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCopyWith<Moderation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCopyWith<$Res> {
  factory $ModerationCopyWith(
          Moderation value, $Res Function(Moderation) then) =
      _$ModerationCopyWithImpl<$Res, Moderation>;
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  $ModerationCategoriesCopyWith<$Res> get categories;
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class _$ModerationCopyWithImpl<$Res, $Val extends Moderation>
    implements $ModerationCopyWith<$Res> {
  _$ModerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_value.copyWith(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesCopyWith<$Res> get categories {
    return $ModerationCategoriesCopyWith<$Res>(_value.categories, (value) {
      return _then(_value.copyWith(categories: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores {
    return $ModerationCategoriesScoresCopyWith<$Res>(_value.categoryScores,
        (value) {
      return _then(_value.copyWith(categoryScores: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModerationImplCopyWith<$Res>
    implements $ModerationCopyWith<$Res> {
  factory _$$ModerationImplCopyWith(
          _$ModerationImpl value, $Res Function(_$ModerationImpl) then) =
      __$$ModerationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  @override
  $ModerationCategoriesCopyWith<$Res> get categories;
  @override
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class __$$ModerationImplCopyWithImpl<$Res>
    extends _$ModerationCopyWithImpl<$Res, _$ModerationImpl>
    implements _$$ModerationImplCopyWith<$Res> {
  __$$ModerationImplCopyWithImpl(
      _$ModerationImpl _value, $Res Function(_$ModerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_$ModerationImpl(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationImpl extends _Moderation {
  const _$ModerationImpl(
      {required this.flagged,
      required this.categories,
      @JsonKey(name: 'category_scores') required this.categoryScores})
      : super._();

  factory _$ModerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationImplFromJson(json);

  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  @override
  final bool flagged;

  /// A list of the categories, and whether they are flagged or not.
  @override
  final ModerationCategories categories;

  /// A list of the categories along with their scores as predicted by model.
  @override
  @JsonKey(name: 'category_scores')
  final ModerationCategoriesScores categoryScores;

  @override
  String toString() {
    return 'Moderation(flagged: $flagged, categories: $categories, categoryScores: $categoryScores)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationImpl &&
            (identical(other.flagged, flagged) || other.flagged == flagged) &&
            (identical(other.categories, categories) ||
                other.categories == categories) &&
            (identical(other.categoryScores, categoryScores) ||
                other.categoryScores == categoryScores));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, flagged, categories, categoryScores);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      __$$ModerationImplCopyWithImpl<_$ModerationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationImplToJson(
      this,
    );
  }
}

abstract class _Moderation extends Moderation {
  const factory _Moderation(
          {required final bool flagged,
          required final ModerationCategories categories,
          @JsonKey(name: 'category_scores')
          required final ModerationCategoriesScores categoryScores}) =
      _$ModerationImpl;
  const _Moderation._() : super._();

  factory _Moderation.fromJson(Map<String, dynamic> json) =
      _$ModerationImpl.fromJson;

  @override

  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  bool get flagged;
  @override

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories;
  @override

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores;
  @override
  @JsonKey(ignore: true)
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModerationCategories _$ModerationCategoriesFromJson(Map<String, dynamic> json) {
  return _ModerationCategories.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategories {
  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harrassment.
  bool get hate => throw _privateConstructorUsedError;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening => throw _privateConstructorUsedError;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment => throw _privateConstructorUsedError;

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening => throw _privateConstructorUsedError;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm => throw _privateConstructorUsedError;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent => throw _privateConstructorUsedError;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions => throw _privateConstructorUsedError;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual => throw _privateConstructorUsedError;

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury.
  bool get violence => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesCopyWith<ModerationCategories> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesCopyWith<$Res> {
  factory $ModerationCategoriesCopyWith(ModerationCategories value,
          $Res Function(ModerationCategories) then) =
      _$ModerationCategoriesCopyWithImpl<$Res, ModerationCategories>;
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesCopyWithImpl<$Res,
        $Val extends ModerationCategories>
    implements $ModerationCategoriesCopyWith<$Res> {
  _$ModerationCategoriesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesImplCopyWith<$Res>
    implements $ModerationCategoriesCopyWith<$Res> {
  factory _$$ModerationCategoriesImplCopyWith(_$ModerationCategoriesImpl value,
          $Res Function(_$ModerationCategoriesImpl) then) =
      __$$ModerationCategoriesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesCopyWithImpl<$Res, _$ModerationCategoriesImpl>
    implements _$$ModerationCategoriesImplCopyWith<$Res> {
  __$$ModerationCategoriesImplCopyWithImpl(_$ModerationCategoriesImpl _value,
      $Res Function(_$ModerationCategoriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesImpl extends _ModerationCategories {
  const _$ModerationCategoriesImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationCategoriesImplFromJson(json);

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harrassment.
  @override
  final bool hate;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @override
  @JsonKey(name: 'hate/threatening')
  final bool hateThreatening;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  @override
  final bool harassment;

  /// Harassment content that also includes violence or serious harm towards any target.
  @override
  @JsonKey(name: 'harassment/threatening')
  final bool harassmentThreatening;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm')
  final bool selfHarm;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm/intent')
  final bool selfHarmIntent;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final bool selfHarmInstructions;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  @override
  final bool sexual;

  /// Sexual content that includes an individual who is under 18 years old.
  @override
  @JsonKey(name: 'sexual/minors')
  final bool sexualMinors;

  /// Content that depicts death, violence, or physical injury.
  @override
  final bool violence;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @override
  @JsonKey(name: 'violence/graphic')
  final bool violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategories(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith =>
          __$$ModerationCategoriesImplCopyWithImpl<_$ModerationCategoriesImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategories extends ModerationCategories {
  const factory _ModerationCategories(
      {required final bool hate,
      @JsonKey(name: 'hate/threatening') required final bool hateThreatening,
      required final bool harassment,
      @JsonKey(name: 'harassment/threatening')
      required final bool harassmentThreatening,
      @JsonKey(name: 'self-harm') required final bool selfHarm,
      @JsonKey(name: 'self-harm/intent') required final bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final bool selfHarmInstructions,
      required final bool sexual,
      @JsonKey(name: 'sexual/minors') required final bool sexualMinors,
      required final bool violence,
      @JsonKey(name: 'violence/graphic')
      required final bool violenceGraphic}) = _$ModerationCategoriesImpl;
  const _ModerationCategories._() : super._();

  factory _ModerationCategories.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesImpl.fromJson;

  @override

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harrassment.
  bool get hate;
  @override

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening;
  @override

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment;
  @override

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening;
  @override

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm;
  @override

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent;
  @override

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions;
  @override

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual;
  @override

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors;
  @override

  /// Content that depicts death, violence, or physical injury.
  bool get violence;
  @override

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationCategoriesScores _$ModerationCategoriesScoresFromJson(
    Map<String, dynamic> json) {
  return _ModerationCategoriesScores.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategoriesScores {
  /// The score for the category 'hate'.
  double get hate => throw _privateConstructorUsedError;

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'harassment'.
  double get harassment => throw _privateConstructorUsedError;

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions => throw _privateConstructorUsedError;

  /// The score for the category 'sexual'.
  double get sexual => throw _privateConstructorUsedError;

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors => throw _privateConstructorUsedError;

  /// The score for the category 'violence'.
  double get violence => throw _privateConstructorUsedError;

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesScoresCopyWith<ModerationCategoriesScores>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesScoresCopyWith<$Res> {
  factory $ModerationCategoriesScoresCopyWith(ModerationCategoriesScores value,
          $Res Function(ModerationCategoriesScores) then) =
      _$ModerationCategoriesScoresCopyWithImpl<$Res,
          ModerationCategoriesScores>;
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesScoresCopyWithImpl<$Res,
        $Val extends ModerationCategoriesScores>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  _$ModerationCategoriesScoresCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesScoresImplCopyWith<$Res>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  factory _$$ModerationCategoriesScoresImplCopyWith(
          _$ModerationCategoriesScoresImpl value,
          $Res Function(_$ModerationCategoriesScoresImpl) then) =
      __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesScoresCopyWithImpl<$Res,
        _$ModerationCategoriesScoresImpl>
    implements _$$ModerationCategoriesScoresImplCopyWith<$Res> {
  __$$ModerationCategoriesScoresImplCopyWithImpl(
      _$ModerationCategoriesScoresImpl _value,
      $Res Function(_$ModerationCategoriesScoresImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesScoresImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesScoresImpl extends _ModerationCategoriesScores {
  const _$ModerationCategoriesScoresImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesScoresImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModerationCategoriesScoresImplFromJson(json);

  /// The score for the category 'hate'.
  @override
  final double hate;

  /// The score for the category 'hate/threatening'.
  @override
  @JsonKey(name: 'hate/threatening')
  final double hateThreatening;

  /// The score for the category 'harassment'.
  @override
  final double harassment;

  /// The score for the category 'harassment/threatening'.
  @override
  @JsonKey(name: 'harassment/threatening')
  final double harassmentThreatening;

  /// The score for the category 'self-harm'.
  @override
  @JsonKey(name: 'self-harm')
  final double selfHarm;

  /// The score for the category 'self-harm/intent'.
  @override
  @JsonKey(name: 'self-harm/intent')
  final double selfHarmIntent;

  /// The score for the category 'self-harm/instructions'.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final double selfHarmInstructions;

  /// The score for the category 'sexual'.
  @override
  final double sexual;

  /// The score for the category 'sexual/minors'.
  @override
  @JsonKey(name: 'sexual/minors')
  final double sexualMinors;

  /// The score for the category 'violence'.
  @override
  final double violence;

  /// The score for the category 'violence/graphic'.
  @override
  @JsonKey(name: 'violence/graphic')
  final double violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategoriesScores(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesScoresImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => __$$ModerationCategoriesScoresImplCopyWithImpl<
          _$ModerationCategoriesScoresImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesScoresImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategoriesScores extends ModerationCategoriesScores {
  const factory _ModerationCategoriesScores(
      {required final double hate,
      @JsonKey(name: 'hate/threatening') required final double hateThreatening,
      required final double harassment,
      @JsonKey(name: 'harassment/threatening')
      required final double harassmentThreatening,
      @JsonKey(name: 'self-harm') required final double selfHarm,
      @JsonKey(name: 'self-harm/intent') required final double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final double selfHarmInstructions,
      required final double sexual,
      @JsonKey(name: 'sexual/minors') required final double sexualMinors,
      required final double violence,
      @JsonKey(name: 'violence/graphic')
      required final double
          violenceGraphic}) = _$ModerationCategoriesScoresImpl;
  const _ModerationCategoriesScores._() : super._();

  factory _ModerationCategoriesScores.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesScoresImpl.fromJson;

  @override

  /// The score for the category 'hate'.
  double get hate;
  @override

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening;
  @override

  /// The score for the category 'harassment'.
  double get harassment;
  @override

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening;
  @override

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm;
  @override

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent;
  @override

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions;
  @override

  /// The score for the category 'sexual'.
  double get sexual;
  @override

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors;
  @override

  /// The score for the category 'violence'.
  double get violence;
  @override

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessage _$ChatCompletionMessageFromJson(
    Map<String, dynamic> json) {
  switch (json['role']) {
    case 'system':
      return ChatCompletionSystemMessage.fromJson(json);
    case 'user':
      return ChatCompletionUserMessage.fromJson(json);
    case 'assistant':
      return ChatCompletionAssistantMessage.fromJson(json);
    case 'tool':
      return ChatCompletionToolMessage.fromJson(json);
    case 'function':
      return ChatCompletionFunctionMessage.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'role', 'ChatCompletionMessage',
          'Invalid union type "${json['role']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessage {
  /// The role of the messages author, in this case `system`.
  ChatCompletionMessageRole get role => throw _privateConstructorUsedError;

  /// The contents of the system message.
  Object? get content => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String? content)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String? content)? system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String? content)? system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageCopyWith<ChatCompletionMessage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionMessageCopyWith(ChatCompletionMessage value,
          $Res Function(ChatCompletionMessage) then) =
      _$ChatCompletionMessageCopyWithImpl<$Res, ChatCompletionMessage>;
  @useResult
  $Res call({ChatCompletionMessageRole role});
}

/// @nodoc
class _$ChatCompletionMessageCopyWithImpl<$Res,
        $Val extends ChatCompletionMessage>
    implements $ChatCompletionMessageCopyWith<$Res> {
  _$ChatCompletionMessageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
  }) {
    return _then(_value.copyWith(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionSystemMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionSystemMessageImplCopyWith(
          _$ChatCompletionSystemMessageImpl value,
          $Res Function(_$ChatCompletionSystemMessageImpl) then) =
      __$$ChatCompletionSystemMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionMessageRole role, String? content});
}

/// @nodoc
class __$$ChatCompletionSystemMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionSystemMessageImpl>
    implements _$$ChatCompletionSystemMessageImplCopyWith<$Res> {
  __$$ChatCompletionSystemMessageImplCopyWithImpl(
      _$ChatCompletionSystemMessageImpl _value,
      $Res Function(_$ChatCompletionSystemMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
  }) {
    return _then(_$ChatCompletionSystemMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionSystemMessageImpl extends ChatCompletionSystemMessage {
  const _$ChatCompletionSystemMessageImpl(
      {this.role = ChatCompletionMessageRole.system, required this.content})
      : super._();

  factory _$ChatCompletionSystemMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionSystemMessageImplFromJson(json);

  /// The role of the messages author, in this case `system`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the system message.
  @override
  final String? content;

  @override
  String toString() {
    return 'ChatCompletionMessage.system(role: $role, content: $content)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionSystemMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionSystemMessageImplCopyWith<_$ChatCompletionSystemMessageImpl>
      get copyWith => __$$ChatCompletionSystemMessageImplCopyWithImpl<
          _$ChatCompletionSystemMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String? content)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return system(role, content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String? content)? system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return system?.call(role, content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String? content)? system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (system != null) {
      return system(role, content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return system(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return system?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (system != null) {
      return system(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionSystemMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionSystemMessage extends ChatCompletionMessage {
  const factory ChatCompletionSystemMessage(
      {final ChatCompletionMessageRole role,
      required final String? content}) = _$ChatCompletionSystemMessageImpl;
  const ChatCompletionSystemMessage._() : super._();

  factory ChatCompletionSystemMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionSystemMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `system`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the system message.
  String? get content;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionSystemMessageImplCopyWith<_$ChatCompletionSystemMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionUserMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionUserMessageImplCopyWith(
          _$ChatCompletionUserMessageImpl value,
          $Res Function(_$ChatCompletionUserMessageImpl) then) =
      __$$ChatCompletionUserMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @_ChatCompletionUserMessageContentConverter()
      ChatCompletionUserMessageContent? content});

  $ChatCompletionUserMessageContentCopyWith<$Res>? get content;
}

/// @nodoc
class __$$ChatCompletionUserMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionUserMessageImpl>
    implements _$$ChatCompletionUserMessageImplCopyWith<$Res> {
  __$$ChatCompletionUserMessageImplCopyWithImpl(
      _$ChatCompletionUserMessageImpl _value,
      $Res Function(_$ChatCompletionUserMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
  }) {
    return _then(_$ChatCompletionUserMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as ChatCompletionUserMessageContent?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionUserMessageContentCopyWith<$Res>? get content {
    if (_value.content == null) {
      return null;
    }

    return $ChatCompletionUserMessageContentCopyWith<$Res>(_value.content!,
        (value) {
      return _then(_value.copyWith(content: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionUserMessageImpl extends ChatCompletionUserMessage {
  const _$ChatCompletionUserMessageImpl(
      {this.role = ChatCompletionMessageRole.user,
      @_ChatCompletionUserMessageContentConverter() required this.content})
      : super._();

  factory _$ChatCompletionUserMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionUserMessageImplFromJson(json);

  /// The role of the messages author, in this case `user`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the user message.
  @override
  @_ChatCompletionUserMessageContentConverter()
  final ChatCompletionUserMessageContent? content;

  @override
  String toString() {
    return 'ChatCompletionMessage.user(role: $role, content: $content)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionUserMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionUserMessageImplCopyWith<_$ChatCompletionUserMessageImpl>
      get copyWith => __$$ChatCompletionUserMessageImplCopyWithImpl<
          _$ChatCompletionUserMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String? content)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return user(role, content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String? content)? system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return user?.call(role, content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String? content)? system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(role, content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return user(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return user?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionUserMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionUserMessage extends ChatCompletionMessage {
  const factory ChatCompletionUserMessage(
          {final ChatCompletionMessageRole role,
          @_ChatCompletionUserMessageContentConverter()
          required final ChatCompletionUserMessageContent? content}) =
      _$ChatCompletionUserMessageImpl;
  const ChatCompletionUserMessage._() : super._();

  factory ChatCompletionUserMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionUserMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `user`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the user message.
  @_ChatCompletionUserMessageContentConverter()
  ChatCompletionUserMessageContent? get content;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionUserMessageImplCopyWith<_$ChatCompletionUserMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionAssistantMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionAssistantMessageImplCopyWith(
          _$ChatCompletionAssistantMessageImpl value,
          $Res Function(_$ChatCompletionAssistantMessageImpl) then) =
      __$$ChatCompletionAssistantMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String? content,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionMessageFunctionCall? functionCall});

  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionAssistantMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionAssistantMessageImpl>
    implements _$$ChatCompletionAssistantMessageImplCopyWith<$Res> {
  __$$ChatCompletionAssistantMessageImplCopyWithImpl(
      _$ChatCompletionAssistantMessageImpl _value,
      $Res Function(_$ChatCompletionAssistantMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? toolCalls = freezed,
    Object? functionCall = freezed,
  }) {
    return _then(_$ChatCompletionAssistantMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageToolCall>?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionAssistantMessageImpl
    extends ChatCompletionAssistantMessage {
  const _$ChatCompletionAssistantMessageImpl(
      {this.role = ChatCompletionMessageRole.assistant,
      required this.content,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionAssistantMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionAssistantMessageImplFromJson(json);

  /// The role of the messages author, in this case `assistant`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the assistant message.
  @override
  final String? content;

  /// No Description
  final List<ChatCompletionMessageToolCall>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionMessageFunctionCall? functionCall;

  @override
  String toString() {
    return 'ChatCompletionMessage.assistant(role: $role, content: $content, toolCalls: $toolCalls, functionCall: $functionCall)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionAssistantMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content,
      const DeepCollectionEquality().hash(_toolCalls), functionCall);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionAssistantMessageImplCopyWith<
          _$ChatCompletionAssistantMessageImpl>
      get copyWith => __$$ChatCompletionAssistantMessageImplCopyWithImpl<
          _$ChatCompletionAssistantMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String? content)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return assistant(role, content, toolCalls, functionCall);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String? content)? system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return assistant?.call(role, content, toolCalls, functionCall);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String? content)? system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (assistant != null) {
      return assistant(role, content, toolCalls, functionCall);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return assistant(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return assistant?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (assistant != null) {
      return assistant(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionAssistantMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionAssistantMessage extends ChatCompletionMessage {
  const factory ChatCompletionAssistantMessage(
          {final ChatCompletionMessageRole role,
          required final String? content,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionMessageToolCall>? toolCalls,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionMessageFunctionCall? functionCall}) =
      _$ChatCompletionAssistantMessageImpl;
  const ChatCompletionAssistantMessage._() : super._();

  factory ChatCompletionAssistantMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionAssistantMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `assistant`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the assistant message.
  String? get content;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls;

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionMessageFunctionCall? get functionCall;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionAssistantMessageImplCopyWith<
          _$ChatCompletionAssistantMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionToolMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionToolMessageImplCopyWith(
          _$ChatCompletionToolMessageImpl value,
          $Res Function(_$ChatCompletionToolMessageImpl) then) =
      __$$ChatCompletionToolMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String? content,
      @JsonKey(name: 'tool_call_id') String toolCallId});
}

/// @nodoc
class __$$ChatCompletionToolMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionToolMessageImpl>
    implements _$$ChatCompletionToolMessageImplCopyWith<$Res> {
  __$$ChatCompletionToolMessageImplCopyWithImpl(
      _$ChatCompletionToolMessageImpl _value,
      $Res Function(_$ChatCompletionToolMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? toolCallId = null,
  }) {
    return _then(_$ChatCompletionToolMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCallId: null == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolMessageImpl extends ChatCompletionToolMessage {
  const _$ChatCompletionToolMessageImpl(
      {this.role = ChatCompletionMessageRole.tool,
      required this.content,
      @JsonKey(name: 'tool_call_id') required this.toolCallId})
      : super._();

  factory _$ChatCompletionToolMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionToolMessageImplFromJson(json);

  /// The role of the messages author, in this case `tool`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the tool message.
  @override
  final String? content;

  /// Tool call that this message is responding to.
  @override
  @JsonKey(name: 'tool_call_id')
  final String toolCallId;

  @override
  String toString() {
    return 'ChatCompletionMessage.tool(role: $role, content: $content, toolCallId: $toolCallId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, toolCallId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolMessageImplCopyWith<_$ChatCompletionToolMessageImpl>
      get copyWith => __$$ChatCompletionToolMessageImplCopyWithImpl<
          _$ChatCompletionToolMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String? content)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return tool(role, content, toolCallId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String? content)? system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return tool?.call(role, content, toolCallId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String? content)? system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(role, content, toolCallId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolMessage extends ChatCompletionMessage {
  const factory ChatCompletionToolMessage(
          {final ChatCompletionMessageRole role,
          required final String? content,
          @JsonKey(name: 'tool_call_id') required final String toolCallId}) =
      _$ChatCompletionToolMessageImpl;
  const ChatCompletionToolMessage._() : super._();

  factory ChatCompletionToolMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionToolMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `tool`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the tool message.
  String? get content;

  /// Tool call that this message is responding to.
  @JsonKey(name: 'tool_call_id')
  String get toolCallId;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionToolMessageImplCopyWith<_$ChatCompletionToolMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionFunctionMessageImplCopyWith(
          _$ChatCompletionFunctionMessageImpl value,
          $Res Function(_$ChatCompletionFunctionMessageImpl) then) =
      __$$ChatCompletionFunctionMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionMessageRole role, String? content, String name});
}

/// @nodoc
class __$$ChatCompletionFunctionMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionFunctionMessageImpl>
    implements _$$ChatCompletionFunctionMessageImplCopyWith<$Res> {
  __$$ChatCompletionFunctionMessageImplCopyWithImpl(
      _$ChatCompletionFunctionMessageImpl _value,
      $Res Function(_$ChatCompletionFunctionMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? name = null,
  }) {
    return _then(_$ChatCompletionFunctionMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionMessageImpl
    extends ChatCompletionFunctionMessage {
  const _$ChatCompletionFunctionMessageImpl(
      {this.role = ChatCompletionMessageRole.function,
      required this.content,
      required this.name})
      : super._();

  factory _$ChatCompletionFunctionMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionMessageImplFromJson(json);

  /// The role of the messages author, in this case `function`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The return value from the function call, to return to the model.
  @override
  final String? content;

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'ChatCompletionMessage.function(role: $role, content: $content, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionMessageImplCopyWith<
          _$ChatCompletionFunctionMessageImpl>
      get copyWith => __$$ChatCompletionFunctionMessageImplCopyWithImpl<
          _$ChatCompletionFunctionMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String? content)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return function(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String? content)? system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return function?.call(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String? content)? system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent? content)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            String? content,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String? content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(role, content, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionMessage extends ChatCompletionMessage {
  const factory ChatCompletionFunctionMessage(
      {final ChatCompletionMessageRole role,
      required final String? content,
      required final String name}) = _$ChatCompletionFunctionMessageImpl;
  const ChatCompletionFunctionMessage._() : super._();

  factory ChatCompletionFunctionMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionFunctionMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `function`.
  ChatCompletionMessageRole get role;
  @override

  /// The return value from the function call, to return to the model.
  String? get content;

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionMessageImplCopyWith<
          _$ChatCompletionFunctionMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionUserMessageContent _$ChatCompletionUserMessageContentFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'parts':
      return ChatCompletionMessageContentParts.fromJson(json);
    case 'string':
      return ChatCompletionUserMessageContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionUserMessageContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionUserMessageContent {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionUserMessageContentCopyWith<$Res> {
  factory $ChatCompletionUserMessageContentCopyWith(
          ChatCompletionUserMessageContent value,
          $Res Function(ChatCompletionUserMessageContent) then) =
      _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
          ChatCompletionUserMessageContent>;
}

/// @nodoc
class _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        $Val extends ChatCompletionUserMessageContent>
    implements $ChatCompletionUserMessageContentCopyWith<$Res> {
  _$ChatCompletionUserMessageContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartsImplCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartsImplCopyWith(
          _$ChatCompletionMessageContentPartsImpl value,
          $Res Function(_$ChatCompletionMessageContentPartsImpl) then) =
      __$$ChatCompletionMessageContentPartsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ChatCompletionMessageContentPart> value});
}

/// @nodoc
class __$$ChatCompletionMessageContentPartsImplCopyWithImpl<$Res>
    extends _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartsImpl>
    implements _$$ChatCompletionMessageContentPartsImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartsImplCopyWithImpl(
      _$ChatCompletionMessageContentPartsImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartsImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageContentPart>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartsImpl
    extends ChatCompletionMessageContentParts {
  const _$ChatCompletionMessageContentPartsImpl(
      final List<ChatCompletionMessageContentPart> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'parts',
        super._();

  factory _$ChatCompletionMessageContentPartsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartsImplFromJson(json);

  final List<ChatCompletionMessageContentPart> _value;
  @override
  List<ChatCompletionMessageContentPart> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.parts(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartsImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartsImplCopyWith<
          _$ChatCompletionMessageContentPartsImpl>
      get copyWith => __$$ChatCompletionMessageContentPartsImplCopyWithImpl<
          _$ChatCompletionMessageContentPartsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) {
    return parts(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) {
    return parts?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) {
    return parts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) {
    return parts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartsImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentParts
    extends ChatCompletionUserMessageContent {
  const factory ChatCompletionMessageContentParts(
          final List<ChatCompletionMessageContentPart> value) =
      _$ChatCompletionMessageContentPartsImpl;
  const ChatCompletionMessageContentParts._() : super._();

  factory ChatCompletionMessageContentParts.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartsImpl.fromJson;

  @override
  List<ChatCompletionMessageContentPart> get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartsImplCopyWith<
          _$ChatCompletionMessageContentPartsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionUserMessageContentStringImplCopyWith<$Res> {
  factory _$$ChatCompletionUserMessageContentStringImplCopyWith(
          _$ChatCompletionUserMessageContentStringImpl value,
          $Res Function(_$ChatCompletionUserMessageContentStringImpl) then) =
      __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        _$ChatCompletionUserMessageContentStringImpl>
    implements _$$ChatCompletionUserMessageContentStringImplCopyWith<$Res> {
  __$$ChatCompletionUserMessageContentStringImplCopyWithImpl(
      _$ChatCompletionUserMessageContentStringImpl _value,
      $Res Function(_$ChatCompletionUserMessageContentStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionUserMessageContentStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionUserMessageContentStringImpl
    extends ChatCompletionUserMessageContentString {
  const _$ChatCompletionUserMessageContentStringImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ChatCompletionUserMessageContentStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionUserMessageContentStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionUserMessageContentStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionUserMessageContentStringImplCopyWith<
          _$ChatCompletionUserMessageContentStringImpl>
      get copyWith =>
          __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<
              _$ChatCompletionUserMessageContentStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionUserMessageContentStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionUserMessageContentString
    extends ChatCompletionUserMessageContent {
  const factory ChatCompletionUserMessageContentString(final String value) =
      _$ChatCompletionUserMessageContentStringImpl;
  const ChatCompletionUserMessageContentString._() : super._();

  factory ChatCompletionUserMessageContentString.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionUserMessageContentStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionUserMessageContentStringImplCopyWith<
          _$ChatCompletionUserMessageContentStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageContentPart _$ChatCompletionMessageContentPartFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'text':
      return ChatCompletionMessageContentPartText.fromJson(json);
    case 'image_url':
      return ChatCompletionMessageContentPartImage.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChatCompletionMessageContentPart',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessageContentPart {
  /// The type of the content part, in this case `text`.
  ChatCompletionMessageContentPartType get type =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageContentPartCopyWith<ChatCompletionMessageContentPart>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartCopyWith(
          ChatCompletionMessageContentPart value,
          $Res Function(ChatCompletionMessageContentPart) then) =
      _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
          ChatCompletionMessageContentPart>;
  @useResult
  $Res call({ChatCompletionMessageContentPartType type});
}

/// @nodoc
class _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageContentPart>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  _$ChatCompletionMessageContentPartCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartTextImplCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartTextImplCopyWith(
          _$ChatCompletionMessageContentPartTextImpl value,
          $Res Function(_$ChatCompletionMessageContentPartTextImpl) then) =
      __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionMessageContentPartType type, String text});
}

/// @nodoc
class __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartTextImpl>
    implements _$$ChatCompletionMessageContentPartTextImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartTextImplCopyWithImpl(
      _$ChatCompletionMessageContentPartTextImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartTextImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartTextImpl
    extends ChatCompletionMessageContentPartText {
  const _$ChatCompletionMessageContentPartTextImpl(
      {this.type = ChatCompletionMessageContentPartType.text,
      required this.text})
      : super._();

  factory _$ChatCompletionMessageContentPartTextImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartTextImplFromJson(json);

  /// The type of the content part, in this case `text`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The text content.
  @override
  final String text;

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.text(type: $type, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartTextImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartTextImplCopyWith<
          _$ChatCompletionMessageContentPartTextImpl>
      get copyWith => __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<
          _$ChatCompletionMessageContentPartTextImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) {
    return text(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) {
    return text?.call(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(type, this.text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartTextImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentPartText
    extends ChatCompletionMessageContentPart {
  const factory ChatCompletionMessageContentPartText(
      {final ChatCompletionMessageContentPartType type,
      required final String text}) = _$ChatCompletionMessageContentPartTextImpl;
  const ChatCompletionMessageContentPartText._() : super._();

  factory ChatCompletionMessageContentPartText.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartTextImpl.fromJson;

  @override

  /// The type of the content part, in this case `text`.
  ChatCompletionMessageContentPartType get type;

  /// The text content.
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartTextImplCopyWith<
          _$ChatCompletionMessageContentPartTextImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartImageImplCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartImageImplCopyWith(
          _$ChatCompletionMessageContentPartImageImpl value,
          $Res Function(_$ChatCompletionMessageContentPartImageImpl) then) =
      __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageContentPartType type,
      @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl});

  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl;
}

/// @nodoc
class __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartImageImpl>
    implements _$$ChatCompletionMessageContentPartImageImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartImageImplCopyWithImpl(
      _$ChatCompletionMessageContentPartImageImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? imageUrl = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartImageImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageUrl,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl {
    return $ChatCompletionMessageImageUrlCopyWith<$Res>(_value.imageUrl,
        (value) {
      return _then(_value.copyWith(imageUrl: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartImageImpl
    extends ChatCompletionMessageContentPartImage {
  const _$ChatCompletionMessageContentPartImageImpl(
      {this.type = ChatCompletionMessageContentPartType.imageUrl,
      @JsonKey(name: 'image_url') required this.imageUrl})
      : super._();

  factory _$ChatCompletionMessageContentPartImageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartImageImplFromJson(json);

  /// The type of the content part, in this case `image_url`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The URL of the image.
  @override
  @JsonKey(name: 'image_url')
  final ChatCompletionMessageImageUrl imageUrl;

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.image(type: $type, imageUrl: $imageUrl)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartImageImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartImageImplCopyWith<
          _$ChatCompletionMessageContentPartImageImpl>
      get copyWith => __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<
          _$ChatCompletionMessageContentPartImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) {
    return image(type, imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) {
    return image?.call(type, imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(type, imageUrl);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartImageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentPartImage
    extends ChatCompletionMessageContentPart {
  const factory ChatCompletionMessageContentPartImage(
          {final ChatCompletionMessageContentPartType type,
          @JsonKey(name: 'image_url')
          required final ChatCompletionMessageImageUrl imageUrl}) =
      _$ChatCompletionMessageContentPartImageImpl;
  const ChatCompletionMessageContentPartImage._() : super._();

  factory ChatCompletionMessageContentPartImage.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartImageImpl.fromJson;

  @override

  /// The type of the content part, in this case `image_url`.
  ChatCompletionMessageContentPartType get type;

  /// The URL of the image.
  @JsonKey(name: 'image_url')
  ChatCompletionMessageImageUrl get imageUrl;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartImageImplCopyWith<
          _$ChatCompletionMessageContentPartImageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageImageUrl _$ChatCompletionMessageImageUrlFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageImageUrl.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageImageUrl {
  /// Either a URL of the image or the base64 encoded image data.
  String get url => throw _privateConstructorUsedError;

  /// Specifies the detail level of the image.
  ChatCompletionMessageImageDetail get detail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageImageUrlCopyWith<ChatCompletionMessageImageUrl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory $ChatCompletionMessageImageUrlCopyWith(
          ChatCompletionMessageImageUrl value,
          $Res Function(ChatCompletionMessageImageUrl) then) =
      _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
          ChatCompletionMessageImageUrl>;
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageImageUrl>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  _$ChatCompletionMessageImageUrlCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_value.copyWith(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageImageUrlImplCopyWith<$Res>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory _$$ChatCompletionMessageImageUrlImplCopyWith(
          _$ChatCompletionMessageImageUrlImpl value,
          $Res Function(_$ChatCompletionMessageImageUrlImpl) then) =
      __$$ChatCompletionMessageImageUrlImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class __$$ChatCompletionMessageImageUrlImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
        _$ChatCompletionMessageImageUrlImpl>
    implements _$$ChatCompletionMessageImageUrlImplCopyWith<$Res> {
  __$$ChatCompletionMessageImageUrlImplCopyWithImpl(
      _$ChatCompletionMessageImageUrlImpl _value,
      $Res Function(_$ChatCompletionMessageImageUrlImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_$ChatCompletionMessageImageUrlImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageImageUrlImpl
    extends _ChatCompletionMessageImageUrl {
  const _$ChatCompletionMessageImageUrlImpl(
      {required this.url, this.detail = ChatCompletionMessageImageDetail.auto})
      : super._();

  factory _$ChatCompletionMessageImageUrlImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageImageUrlImplFromJson(json);

  /// Either a URL of the image or the base64 encoded image data.
  @override
  final String url;

  /// Specifies the detail level of the image.
  @override
  @JsonKey()
  final ChatCompletionMessageImageDetail detail;

  @override
  String toString() {
    return 'ChatCompletionMessageImageUrl(url: $url, detail: $detail)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageImageUrlImpl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageImageUrlImplCopyWith<
          _$ChatCompletionMessageImageUrlImpl>
      get copyWith => __$$ChatCompletionMessageImageUrlImplCopyWithImpl<
          _$ChatCompletionMessageImageUrlImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageImageUrlImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageImageUrl
    extends ChatCompletionMessageImageUrl {
  const factory _ChatCompletionMessageImageUrl(
          {required final String url,
          final ChatCompletionMessageImageDetail detail}) =
      _$ChatCompletionMessageImageUrlImpl;
  const _ChatCompletionMessageImageUrl._() : super._();

  factory _ChatCompletionMessageImageUrl.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageImageUrlImpl.fromJson;

  @override

  /// Either a URL of the image or the base64 encoded image data.
  String get url;
  @override

  /// Specifies the detail level of the image.
  ChatCompletionMessageImageDetail get detail;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageImageUrlImplCopyWith<
          _$ChatCompletionMessageImageUrlImpl>
      get copyWith => throw _privateConstructorUsedError;
}
