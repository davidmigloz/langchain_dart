// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schema.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

CreateCompletionRequest _$CreateCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionRequest {
  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model => throw _privateConstructorUsedError;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt => throw _privateConstructorUsedError;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf => throw _privateConstructorUsedError;

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a json object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop => throw _privateConstructorUsedError;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// The suffix that comes after a completion of inserted text.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionRequestCopyWith<CreateCompletionRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionRequestCopyWith<$Res> {
  factory $CreateCompletionRequestCopyWith(CreateCompletionRequest value,
          $Res Function(CreateCompletionRequest) then) =
      _$CreateCompletionRequestCopyWithImpl<$Res, CreateCompletionRequest>;
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  $CompletionModelCopyWith<$Res> get model;
  $CompletionPromptCopyWith<$Res>? get prompt;
  $CompletionStopCopyWith<$Res>? get stop;
}

/// @nodoc
class _$CreateCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateCompletionRequest>
    implements $CreateCompletionRequestCopyWith<$Res> {
  _$CreateCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionModelCopyWith<$Res> get model {
    return $CompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionPromptCopyWith<$Res>? get prompt {
    if (_value.prompt == null) {
      return null;
    }

    return $CompletionPromptCopyWith<$Res>(_value.prompt!, (value) {
      return _then(_value.copyWith(prompt: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $CompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionRequestImplCopyWith<$Res>
    implements $CreateCompletionRequestCopyWith<$Res> {
  factory _$$CreateCompletionRequestImplCopyWith(
          _$CreateCompletionRequestImpl value,
          $Res Function(_$CreateCompletionRequestImpl) then) =
      __$$CreateCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CompletionModelCopyWith<$Res> get model;
  @override
  $CompletionPromptCopyWith<$Res>? get prompt;
  @override
  $CompletionStopCopyWith<$Res>? get stop;
}

/// @nodoc
class __$$CreateCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateCompletionRequestCopyWithImpl<$Res,
        _$CreateCompletionRequestImpl>
    implements _$$CreateCompletionRequestImplCopyWith<$Res> {
  __$$CreateCompletionRequestImplCopyWithImpl(
      _$CreateCompletionRequestImpl _value,
      $Res Function(_$CreateCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionRequestImpl extends _CreateCompletionRequest {
  const _$CreateCompletionRequestImpl(
      {@_CompletionModelConverter() required this.model,
      @_CompletionPromptConverter() required this.prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) this.bestOf,
      @JsonKey(includeIfNull: false) this.echo = false,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens = 16,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @_CompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) this.user})
      : _logitBias = logitBias,
        super._();

  factory _$CreateCompletionRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @override
  @_CompletionModelConverter()
  final CompletionModel model;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @override
  @_CompletionPromptConverter()
  final CompletionPrompt? prompt;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(name: 'best_of', includeIfNull: false)
  final int? bestOf;

  /// Echo back the prompt in addition to the completion
  @override
  @JsonKey(includeIfNull: false)
  final bool? echo;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a json object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a json object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @override
  @JsonKey(includeIfNull: false)
  final int? logprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @override
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final CompletionStop? stop;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// The suffix that comes after a completion of inserted text.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateCompletionRequest(model: $model, prompt: $prompt, bestOf: $bestOf, echo: $echo, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, stop: $stop, stream: $stream, suffix: $suffix, temperature: $temperature, topP: $topP, user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.bestOf, bestOf) || other.bestOf == bestOf) &&
            (identical(other.echo, echo) || other.echo == echo) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      prompt,
      bestOf,
      echo,
      frequencyPenalty,
      const DeepCollectionEquality().hash(_logitBias),
      logprobs,
      maxTokens,
      n,
      presencePenalty,
      stop,
      stream,
      suffix,
      temperature,
      topP,
      user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => __$$CreateCompletionRequestImplCopyWithImpl<
          _$CreateCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionRequest extends CreateCompletionRequest {
  const factory _CreateCompletionRequest(
      {@_CompletionModelConverter() required final CompletionModel model,
      @_CompletionPromptConverter() required final CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) final int? bestOf,
      @JsonKey(includeIfNull: false) final bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) final int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final CompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(includeIfNull: false) final String? suffix,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false)
      final String? user}) = _$CreateCompletionRequestImpl;
  const _CreateCompletionRequest._() : super._();

  factory _CreateCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model;
  @override

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt;
  @override

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf;
  @override

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a json object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop;
  @override

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// The suffix that comes after a completion of inserted text.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionModel _$CompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionCompletionModelEnum.fromJson(json);
    case 'string':
      return _UnionCompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) enumeration,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? enumeration,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionModelEnum value) enumeration,
    required TResult Function(_UnionCompletionModelString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionModelEnum value)? enumeration,
    TResult? Function(_UnionCompletionModelString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionModelEnum value)? enumeration,
    TResult Function(_UnionCompletionModelString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionModelCopyWith<$Res> {
  factory $CompletionModelCopyWith(
          CompletionModel value, $Res Function(CompletionModel) then) =
      _$CompletionModelCopyWithImpl<$Res, CompletionModel>;
}

/// @nodoc
class _$CompletionModelCopyWithImpl<$Res, $Val extends CompletionModel>
    implements $CompletionModelCopyWith<$Res> {
  _$CompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionCompletionModelEnumImplCopyWith<$Res> {
  factory _$$UnionCompletionModelEnumImplCopyWith(
          _$UnionCompletionModelEnumImpl value,
          $Res Function(_$UnionCompletionModelEnumImpl) then) =
      __$$UnionCompletionModelEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CompletionModels value});
}

/// @nodoc
class __$$UnionCompletionModelEnumImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res, _$UnionCompletionModelEnumImpl>
    implements _$$UnionCompletionModelEnumImplCopyWith<$Res> {
  __$$UnionCompletionModelEnumImplCopyWithImpl(
      _$UnionCompletionModelEnumImpl _value,
      $Res Function(_$UnionCompletionModelEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionModelEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionModelEnumImpl extends _UnionCompletionModelEnum {
  const _$UnionCompletionModelEnumImpl(this.value, {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionCompletionModelEnumImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionCompletionModelEnumImplFromJson(json);

  @override
  final CompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionModelEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionModelEnumImplCopyWith<_$UnionCompletionModelEnumImpl>
      get copyWith => __$$UnionCompletionModelEnumImplCopyWithImpl<
          _$UnionCompletionModelEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionModelEnum value) enumeration,
    required TResult Function(_UnionCompletionModelString value) string,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionModelEnum value)? enumeration,
    TResult? Function(_UnionCompletionModelString value)? string,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionModelEnum value)? enumeration,
    TResult Function(_UnionCompletionModelString value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionModelEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionModelEnum extends CompletionModel {
  const factory _UnionCompletionModelEnum(final CompletionModels value) =
      _$UnionCompletionModelEnumImpl;
  const _UnionCompletionModelEnum._() : super._();

  factory _UnionCompletionModelEnum.fromJson(Map<String, dynamic> json) =
      _$UnionCompletionModelEnumImpl.fromJson;

  @override
  CompletionModels get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionModelEnumImplCopyWith<_$UnionCompletionModelEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionCompletionModelStringImplCopyWith<$Res> {
  factory _$$UnionCompletionModelStringImplCopyWith(
          _$UnionCompletionModelStringImpl value,
          $Res Function(_$UnionCompletionModelStringImpl) then) =
      __$$UnionCompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionCompletionModelStringImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res,
        _$UnionCompletionModelStringImpl>
    implements _$$UnionCompletionModelStringImplCopyWith<$Res> {
  __$$UnionCompletionModelStringImplCopyWithImpl(
      _$UnionCompletionModelStringImpl _value,
      $Res Function(_$UnionCompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionModelStringImpl extends _UnionCompletionModelString {
  const _$UnionCompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionCompletionModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionModelStringImplCopyWith<_$UnionCompletionModelStringImpl>
      get copyWith => __$$UnionCompletionModelStringImplCopyWithImpl<
          _$UnionCompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionModelEnum value) enumeration,
    required TResult Function(_UnionCompletionModelString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionModelEnum value)? enumeration,
    TResult? Function(_UnionCompletionModelString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionModelEnum value)? enumeration,
    TResult Function(_UnionCompletionModelString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionModelString extends CompletionModel {
  const factory _UnionCompletionModelString(final String value) =
      _$UnionCompletionModelStringImpl;
  const _UnionCompletionModelString._() : super._();

  factory _UnionCompletionModelString.fromJson(Map<String, dynamic> json) =
      _$UnionCompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionModelStringImplCopyWith<_$UnionCompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionPrompt _$CompletionPromptFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'array':
      return _UnionCompletionPromptArray.fromJson(json);
    case 'arrayInteger':
      return _UnionCompletionPromptArrayInteger.fromJson(json);
    case 'arrayString':
      return _UnionCompletionPromptArrayString.fromJson(json);
    case 'string':
      return _UnionCompletionPromptString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionPrompt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionPrompt {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionPromptArray value) array,
    required TResult Function(_UnionCompletionPromptArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionCompletionPromptArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionPromptString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionPromptArray value)? array,
    TResult? Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult? Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult? Function(_UnionCompletionPromptString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionPromptArray value)? array,
    TResult Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult Function(_UnionCompletionPromptString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptCopyWith(
          CompletionPrompt value, $Res Function(CompletionPrompt) then) =
      _$CompletionPromptCopyWithImpl<$Res, CompletionPrompt>;
}

/// @nodoc
class _$CompletionPromptCopyWithImpl<$Res, $Val extends CompletionPrompt>
    implements $CompletionPromptCopyWith<$Res> {
  _$CompletionPromptCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionCompletionPromptArrayImplCopyWith<$Res> {
  factory _$$UnionCompletionPromptArrayImplCopyWith(
          _$UnionCompletionPromptArrayImpl value,
          $Res Function(_$UnionCompletionPromptArrayImpl) then) =
      __$$UnionCompletionPromptArrayImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$UnionCompletionPromptArrayImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$UnionCompletionPromptArrayImpl>
    implements _$$UnionCompletionPromptArrayImplCopyWith<$Res> {
  __$$UnionCompletionPromptArrayImplCopyWithImpl(
      _$UnionCompletionPromptArrayImpl _value,
      $Res Function(_$UnionCompletionPromptArrayImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionPromptArrayImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionPromptArrayImpl extends _UnionCompletionPromptArray {
  const _$UnionCompletionPromptArrayImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'array',
        super._();

  factory _$UnionCompletionPromptArrayImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionPromptArrayImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.array(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionPromptArrayImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionPromptArrayImplCopyWith<_$UnionCompletionPromptArrayImpl>
      get copyWith => __$$UnionCompletionPromptArrayImplCopyWithImpl<
          _$UnionCompletionPromptArrayImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return array(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return array?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionPromptArray value) array,
    required TResult Function(_UnionCompletionPromptArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionCompletionPromptArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionPromptString value) string,
  }) {
    return array(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionPromptArray value)? array,
    TResult? Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult? Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult? Function(_UnionCompletionPromptString value)? string,
  }) {
    return array?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionPromptArray value)? array,
    TResult Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult Function(_UnionCompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionPromptArrayImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionPromptArray extends CompletionPrompt {
  const factory _UnionCompletionPromptArray(final List<List<int>> value) =
      _$UnionCompletionPromptArrayImpl;
  const _UnionCompletionPromptArray._() : super._();

  factory _UnionCompletionPromptArray.fromJson(Map<String, dynamic> json) =
      _$UnionCompletionPromptArrayImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionPromptArrayImplCopyWith<_$UnionCompletionPromptArrayImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionCompletionPromptArrayIntegerImplCopyWith<$Res> {
  factory _$$UnionCompletionPromptArrayIntegerImplCopyWith(
          _$UnionCompletionPromptArrayIntegerImpl value,
          $Res Function(_$UnionCompletionPromptArrayIntegerImpl) then) =
      __$$UnionCompletionPromptArrayIntegerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$UnionCompletionPromptArrayIntegerImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$UnionCompletionPromptArrayIntegerImpl>
    implements _$$UnionCompletionPromptArrayIntegerImplCopyWith<$Res> {
  __$$UnionCompletionPromptArrayIntegerImplCopyWithImpl(
      _$UnionCompletionPromptArrayIntegerImpl _value,
      $Res Function(_$UnionCompletionPromptArrayIntegerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionPromptArrayIntegerImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionPromptArrayIntegerImpl
    extends _UnionCompletionPromptArrayInteger {
  const _$UnionCompletionPromptArrayIntegerImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayInteger',
        super._();

  factory _$UnionCompletionPromptArrayIntegerImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionPromptArrayIntegerImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.arrayInteger(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionPromptArrayIntegerImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionPromptArrayIntegerImplCopyWith<
          _$UnionCompletionPromptArrayIntegerImpl>
      get copyWith => __$$UnionCompletionPromptArrayIntegerImplCopyWithImpl<
          _$UnionCompletionPromptArrayIntegerImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return arrayInteger(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return arrayInteger?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayInteger != null) {
      return arrayInteger(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionPromptArray value) array,
    required TResult Function(_UnionCompletionPromptArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionCompletionPromptArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionPromptString value) string,
  }) {
    return arrayInteger(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionPromptArray value)? array,
    TResult? Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult? Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult? Function(_UnionCompletionPromptString value)? string,
  }) {
    return arrayInteger?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionPromptArray value)? array,
    TResult Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult Function(_UnionCompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (arrayInteger != null) {
      return arrayInteger(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionPromptArrayIntegerImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionPromptArrayInteger extends CompletionPrompt {
  const factory _UnionCompletionPromptArrayInteger(final List<int> value) =
      _$UnionCompletionPromptArrayIntegerImpl;
  const _UnionCompletionPromptArrayInteger._() : super._();

  factory _UnionCompletionPromptArrayInteger.fromJson(
          Map<String, dynamic> json) =
      _$UnionCompletionPromptArrayIntegerImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionPromptArrayIntegerImplCopyWith<
          _$UnionCompletionPromptArrayIntegerImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionCompletionPromptArrayStringImplCopyWith<$Res> {
  factory _$$UnionCompletionPromptArrayStringImplCopyWith(
          _$UnionCompletionPromptArrayStringImpl value,
          $Res Function(_$UnionCompletionPromptArrayStringImpl) then) =
      __$$UnionCompletionPromptArrayStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$UnionCompletionPromptArrayStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$UnionCompletionPromptArrayStringImpl>
    implements _$$UnionCompletionPromptArrayStringImplCopyWith<$Res> {
  __$$UnionCompletionPromptArrayStringImplCopyWithImpl(
      _$UnionCompletionPromptArrayStringImpl _value,
      $Res Function(_$UnionCompletionPromptArrayStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionPromptArrayStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionPromptArrayStringImpl
    extends _UnionCompletionPromptArrayString {
  const _$UnionCompletionPromptArrayStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayString',
        super._();

  factory _$UnionCompletionPromptArrayStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionPromptArrayStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.arrayString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionPromptArrayStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionPromptArrayStringImplCopyWith<
          _$UnionCompletionPromptArrayStringImpl>
      get copyWith => __$$UnionCompletionPromptArrayStringImplCopyWithImpl<
          _$UnionCompletionPromptArrayStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return arrayString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return arrayString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionPromptArray value) array,
    required TResult Function(_UnionCompletionPromptArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionCompletionPromptArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionPromptString value) string,
  }) {
    return arrayString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionPromptArray value)? array,
    TResult? Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult? Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult? Function(_UnionCompletionPromptString value)? string,
  }) {
    return arrayString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionPromptArray value)? array,
    TResult Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult Function(_UnionCompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionPromptArrayStringImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionPromptArrayString extends CompletionPrompt {
  const factory _UnionCompletionPromptArrayString(final List<String> value) =
      _$UnionCompletionPromptArrayStringImpl;
  const _UnionCompletionPromptArrayString._() : super._();

  factory _UnionCompletionPromptArrayString.fromJson(
          Map<String, dynamic> json) =
      _$UnionCompletionPromptArrayStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionPromptArrayStringImplCopyWith<
          _$UnionCompletionPromptArrayStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionCompletionPromptStringImplCopyWith<$Res> {
  factory _$$UnionCompletionPromptStringImplCopyWith(
          _$UnionCompletionPromptStringImpl value,
          $Res Function(_$UnionCompletionPromptStringImpl) then) =
      __$$UnionCompletionPromptStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionCompletionPromptStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$UnionCompletionPromptStringImpl>
    implements _$$UnionCompletionPromptStringImplCopyWith<$Res> {
  __$$UnionCompletionPromptStringImplCopyWithImpl(
      _$UnionCompletionPromptStringImpl _value,
      $Res Function(_$UnionCompletionPromptStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionPromptStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionPromptStringImpl extends _UnionCompletionPromptString {
  const _$UnionCompletionPromptStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionCompletionPromptStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionPromptStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionPromptStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionPromptStringImplCopyWith<_$UnionCompletionPromptStringImpl>
      get copyWith => __$$UnionCompletionPromptStringImplCopyWithImpl<
          _$UnionCompletionPromptStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionPromptArray value) array,
    required TResult Function(_UnionCompletionPromptArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionCompletionPromptArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionPromptString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionPromptArray value)? array,
    TResult? Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult? Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult? Function(_UnionCompletionPromptString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionPromptArray value)? array,
    TResult Function(_UnionCompletionPromptArrayInteger value)? arrayInteger,
    TResult Function(_UnionCompletionPromptArrayString value)? arrayString,
    TResult Function(_UnionCompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionPromptStringImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionPromptString extends CompletionPrompt {
  const factory _UnionCompletionPromptString(final String value) =
      _$UnionCompletionPromptStringImpl;
  const _UnionCompletionPromptString._() : super._();

  factory _UnionCompletionPromptString.fromJson(Map<String, dynamic> json) =
      _$UnionCompletionPromptStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionPromptStringImplCopyWith<_$UnionCompletionPromptStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionStop _$CompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'arrayString':
      return _UnionCompletionStopArrayString.fromJson(json);
    case 'string':
      return _UnionCompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionStop {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionStopArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionStopArrayString value)? arrayString,
    TResult? Function(_UnionCompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionStopArrayString value)? arrayString,
    TResult Function(_UnionCompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionStopCopyWith<$Res> {
  factory $CompletionStopCopyWith(
          CompletionStop value, $Res Function(CompletionStop) then) =
      _$CompletionStopCopyWithImpl<$Res, CompletionStop>;
}

/// @nodoc
class _$CompletionStopCopyWithImpl<$Res, $Val extends CompletionStop>
    implements $CompletionStopCopyWith<$Res> {
  _$CompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionCompletionStopArrayStringImplCopyWith<$Res> {
  factory _$$UnionCompletionStopArrayStringImplCopyWith(
          _$UnionCompletionStopArrayStringImpl value,
          $Res Function(_$UnionCompletionStopArrayStringImpl) then) =
      __$$UnionCompletionStopArrayStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$UnionCompletionStopArrayStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res,
        _$UnionCompletionStopArrayStringImpl>
    implements _$$UnionCompletionStopArrayStringImplCopyWith<$Res> {
  __$$UnionCompletionStopArrayStringImplCopyWithImpl(
      _$UnionCompletionStopArrayStringImpl _value,
      $Res Function(_$UnionCompletionStopArrayStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionStopArrayStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionStopArrayStringImpl
    extends _UnionCompletionStopArrayString {
  const _$UnionCompletionStopArrayStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayString',
        super._();

  factory _$UnionCompletionStopArrayStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionStopArrayStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.arrayString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionStopArrayStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionStopArrayStringImplCopyWith<
          _$UnionCompletionStopArrayStringImpl>
      get copyWith => __$$UnionCompletionStopArrayStringImplCopyWithImpl<
          _$UnionCompletionStopArrayStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return arrayString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return arrayString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionStopArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionStopString value) string,
  }) {
    return arrayString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionStopArrayString value)? arrayString,
    TResult? Function(_UnionCompletionStopString value)? string,
  }) {
    return arrayString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionStopArrayString value)? arrayString,
    TResult Function(_UnionCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionStopArrayStringImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionStopArrayString extends CompletionStop {
  const factory _UnionCompletionStopArrayString(final List<String> value) =
      _$UnionCompletionStopArrayStringImpl;
  const _UnionCompletionStopArrayString._() : super._();

  factory _UnionCompletionStopArrayString.fromJson(Map<String, dynamic> json) =
      _$UnionCompletionStopArrayStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionStopArrayStringImplCopyWith<
          _$UnionCompletionStopArrayStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionCompletionStopStringImplCopyWith<$Res> {
  factory _$$UnionCompletionStopStringImplCopyWith(
          _$UnionCompletionStopStringImpl value,
          $Res Function(_$UnionCompletionStopStringImpl) then) =
      __$$UnionCompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionCompletionStopStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res, _$UnionCompletionStopStringImpl>
    implements _$$UnionCompletionStopStringImplCopyWith<$Res> {
  __$$UnionCompletionStopStringImplCopyWithImpl(
      _$UnionCompletionStopStringImpl _value,
      $Res Function(_$UnionCompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionCompletionStopStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionStopStringImpl extends _UnionCompletionStopString {
  const _$UnionCompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionCompletionStopStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionCompletionStopStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionStopStringImplCopyWith<_$UnionCompletionStopStringImpl>
      get copyWith => __$$UnionCompletionStopStringImplCopyWithImpl<
          _$UnionCompletionStopStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionCompletionStopArrayString value)
        arrayString,
    required TResult Function(_UnionCompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionCompletionStopArrayString value)? arrayString,
    TResult? Function(_UnionCompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionCompletionStopArrayString value)? arrayString,
    TResult Function(_UnionCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class _UnionCompletionStopString extends CompletionStop {
  const factory _UnionCompletionStopString(final String value) =
      _$UnionCompletionStopStringImpl;
  const _UnionCompletionStopString._() : super._();

  factory _UnionCompletionStopString.fromJson(Map<String, dynamic> json) =
      _$UnionCompletionStopStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionCompletionStopStringImplCopyWith<_$UnionCompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateCompletionResponse _$CreateCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionResponse {
  /// A unique identifier for the completion.
  String get id => throw _privateConstructorUsedError;

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for completion.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "text_completion"
  String get object => throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionResponseCopyWith<CreateCompletionResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionResponseCopyWith<$Res> {
  factory $CreateCompletionResponseCopyWith(CreateCompletionResponse value,
          $Res Function(CreateCompletionResponse) then) =
      _$CreateCompletionResponseCopyWithImpl<$Res, CreateCompletionResponse>;
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateCompletionResponse>
    implements $CreateCompletionResponseCopyWith<$Res> {
  _$CreateCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionResponseImplCopyWith<$Res>
    implements $CreateCompletionResponseCopyWith<$Res> {
  factory _$$CreateCompletionResponseImplCopyWith(
          _$CreateCompletionResponseImpl value,
          $Res Function(_$CreateCompletionResponseImpl) then) =
      __$$CreateCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateCompletionResponseCopyWithImpl<$Res,
        _$CreateCompletionResponseImpl>
    implements _$$CreateCompletionResponseImplCopyWith<$Res> {
  __$$CreateCompletionResponseImplCopyWithImpl(
      _$CreateCompletionResponseImpl _value,
      $Res Function(_$CreateCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateCompletionResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionResponseImpl extends _CreateCompletionResponse {
  const _$CreateCompletionResponseImpl(
      {required this.id,
      required final List<CompletionChoice> choices,
      required this.created,
      required this.model,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateCompletionResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionResponseImplFromJson(json);

  /// A unique identifier for the completion.
  @override
  final String id;

  /// The list of completion choices the model generated for the input prompt.
  final List<CompletionChoice> _choices;

  /// The list of completion choices the model generated for the input prompt.
  @override
  List<CompletionChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the completion was created.
  @override
  final int created;

  /// The model used for completion.
  @override
  final String model;

  /// The object type, which is always "text_completion"
  @override
  final String object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => __$$CreateCompletionResponseImplCopyWithImpl<
          _$CreateCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionResponse extends CreateCompletionResponse {
  const factory _CreateCompletionResponse(
          {required final String id,
          required final List<CompletionChoice> choices,
          required final int created,
          required final String model,
          required final String object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateCompletionResponseImpl;
  const _CreateCompletionResponse._() : super._();

  factory _CreateCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the completion.
  String get id;
  @override

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created;
  @override

  /// The model used for completion.
  String get model;
  @override

  /// The object type, which is always "text_completion"
  String get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionChoice _$CompletionChoiceFromJson(Map<String, dynamic> json) {
  return _CompletionChoice.fromJson(json);
}

/// @nodoc
mixin _$CompletionChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of generated choices.
  int get index => throw _privateConstructorUsedError;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs => throw _privateConstructorUsedError;

  /// The text of the completion.
  String get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionChoiceCopyWith<CompletionChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionChoiceCopyWith<$Res> {
  factory $CompletionChoiceCopyWith(
          CompletionChoice value, $Res Function(CompletionChoice) then) =
      _$CompletionChoiceCopyWithImpl<$Res, CompletionChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$CompletionChoiceCopyWithImpl<$Res, $Val extends CompletionChoice>
    implements $CompletionChoiceCopyWith<$Res> {
  _$CompletionChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_value.copyWith(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $CompletionLogprobsCopyWith<$Res>(_value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CompletionChoiceImplCopyWith<$Res>
    implements $CompletionChoiceCopyWith<$Res> {
  factory _$$CompletionChoiceImplCopyWith(_$CompletionChoiceImpl value,
          $Res Function(_$CompletionChoiceImpl) then) =
      __$$CompletionChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  @override
  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$CompletionChoiceImplCopyWithImpl<$Res>
    extends _$CompletionChoiceCopyWithImpl<$Res, _$CompletionChoiceImpl>
    implements _$$CompletionChoiceImplCopyWith<$Res> {
  __$$CompletionChoiceImplCopyWithImpl(_$CompletionChoiceImpl _value,
      $Res Function(_$CompletionChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_$CompletionChoiceImpl(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionChoiceImpl extends _CompletionChoice {
  const _$CompletionChoiceImpl(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index,
      required this.logprobs,
      required this.text})
      : super._();

  factory _$CompletionChoiceImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final CompletionFinishReason? finishReason;

  /// The index of the choice in the list of generated choices.
  @override
  final int index;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  @override
  final CompletionLogprobs? logprobs;

  /// The text of the completion.
  @override
  final String text;

  @override
  String toString() {
    return 'CompletionChoice(finishReason: $finishReason, index: $index, logprobs: $logprobs, text: $text)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, finishReason, index, logprobs, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      __$$CompletionChoiceImplCopyWithImpl<_$CompletionChoiceImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionChoiceImplToJson(
      this,
    );
  }
}

abstract class _CompletionChoice extends CompletionChoice {
  const factory _CompletionChoice(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required final CompletionFinishReason? finishReason,
      required final int index,
      required final CompletionLogprobs? logprobs,
      required final String text}) = _$CompletionChoiceImpl;
  const _CompletionChoice._() : super._();

  factory _CompletionChoice.fromJson(Map<String, dynamic> json) =
      _$CompletionChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of generated choices.
  int get index;
  @override

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs;
  @override

  /// The text of the completion.
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CompletionLogprobs _$CompletionLogprobsFromJson(Map<String, dynamic> json) {
  return _CompletionLogprobs.fromJson(json);
}

/// @nodoc
mixin _$CompletionLogprobs {
  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset => throw _privateConstructorUsedError;

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs => throw _privateConstructorUsedError;

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens => throw _privateConstructorUsedError;

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionLogprobsCopyWith<CompletionLogprobs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionLogprobsCopyWith<$Res> {
  factory $CompletionLogprobsCopyWith(
          CompletionLogprobs value, $Res Function(CompletionLogprobs) then) =
      _$CompletionLogprobsCopyWithImpl<$Res, CompletionLogprobs>;
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class _$CompletionLogprobsCopyWithImpl<$Res, $Val extends CompletionLogprobs>
    implements $CompletionLogprobsCopyWith<$Res> {
  _$CompletionLogprobsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_value.copyWith(
      textOffset: freezed == textOffset
          ? _value.textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value.tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value.tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionLogprobsImplCopyWith<$Res>
    implements $CompletionLogprobsCopyWith<$Res> {
  factory _$$CompletionLogprobsImplCopyWith(_$CompletionLogprobsImpl value,
          $Res Function(_$CompletionLogprobsImpl) then) =
      __$$CompletionLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class __$$CompletionLogprobsImplCopyWithImpl<$Res>
    extends _$CompletionLogprobsCopyWithImpl<$Res, _$CompletionLogprobsImpl>
    implements _$$CompletionLogprobsImplCopyWith<$Res> {
  __$$CompletionLogprobsImplCopyWithImpl(_$CompletionLogprobsImpl _value,
      $Res Function(_$CompletionLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_$CompletionLogprobsImpl(
      textOffset: freezed == textOffset
          ? _value._textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value._tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value._tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionLogprobsImpl extends _CompletionLogprobs {
  const _$CompletionLogprobsImpl(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      final List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      final List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) final List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      final List<Map<String, double>?>? topLogprobs})
      : _textOffset = textOffset,
        _tokenLogprobs = tokenLogprobs,
        _tokens = tokens,
        _topLogprobs = topLogprobs,
        super._();

  factory _$CompletionLogprobsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionLogprobsImplFromJson(json);

  /// The offset of the token from the beginning of the prompt.
  final List<int>? _textOffset;

  /// The offset of the token from the beginning of the prompt.
  @override
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset {
    final value = _textOffset;
    if (value == null) return null;
    if (_textOffset is EqualUnmodifiableListView) return _textOffset;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of tokens in the completion.
  final List<double?>? _tokenLogprobs;

  /// The log probabilities of tokens in the completion.
  @override
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs {
    final value = _tokenLogprobs;
    if (value == null) return null;
    if (_tokenLogprobs is EqualUnmodifiableListView) return _tokenLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The tokens generated by the model converted back to text.
  final List<String>? _tokens;

  /// The tokens generated by the model converted back to text.
  @override
  @JsonKey(includeIfNull: false)
  List<String>? get tokens {
    final value = _tokens;
    if (value == null) return null;
    if (_tokens is EqualUnmodifiableListView) return _tokens;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of the `logprobs` most likely tokens.
  final List<Map<String, double>?>? _topLogprobs;

  /// The log probabilities of the `logprobs` most likely tokens.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs {
    final value = _topLogprobs;
    if (value == null) return null;
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CompletionLogprobs(textOffset: $textOffset, tokenLogprobs: $tokenLogprobs, tokens: $tokens, topLogprobs: $topLogprobs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionLogprobsImpl &&
            const DeepCollectionEquality()
                .equals(other._textOffset, _textOffset) &&
            const DeepCollectionEquality()
                .equals(other._tokenLogprobs, _tokenLogprobs) &&
            const DeepCollectionEquality().equals(other._tokens, _tokens) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_textOffset),
      const DeepCollectionEquality().hash(_tokenLogprobs),
      const DeepCollectionEquality().hash(_tokens),
      const DeepCollectionEquality().hash(_topLogprobs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      __$$CompletionLogprobsImplCopyWithImpl<_$CompletionLogprobsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionLogprobsImplToJson(
      this,
    );
  }
}

abstract class _CompletionLogprobs extends CompletionLogprobs {
  const factory _CompletionLogprobs(
          {@JsonKey(name: 'text_offset', includeIfNull: false)
          final List<int>? textOffset,
          @JsonKey(name: 'token_logprobs', includeIfNull: false)
          final List<double?>? tokenLogprobs,
          @JsonKey(includeIfNull: false) final List<String>? tokens,
          @JsonKey(name: 'top_logprobs', includeIfNull: false)
          final List<Map<String, double>?>? topLogprobs}) =
      _$CompletionLogprobsImpl;
  const _CompletionLogprobs._() : super._();

  factory _CompletionLogprobs.fromJson(Map<String, dynamic> json) =
      _$CompletionLogprobsImpl.fromJson;

  @override

  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset;
  @override

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs;
  @override

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens;
  @override

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs;
  @override
  @JsonKey(ignore: true)
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateChatCompletionRequest _$CreateChatCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionRequest {
  /// ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model => throw _privateConstructorUsedError;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages =>
      throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many chat completion choices to generate for each input message.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// An object specifying the format that the model must output. Used to enable JSON mode.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop => throw _privateConstructorUsedError;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools => throw _privateConstructorUsedError;

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type: "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice =>
      throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto`` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionFunction>? get functions =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionRequestCopyWith<CreateChatCompletionRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionRequestCopyWith<$Res> {
  factory $CreateChatCompletionRequestCopyWith(
          CreateChatCompletionRequest value,
          $Res Function(CreateChatCompletionRequest) then) =
      _$CreateChatCompletionRequestCopyWithImpl<$Res,
          CreateChatCompletionRequest>;
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<ChatCompletionFunction>? functions});

  $ChatCompletionModelCopyWith<$Res> get model;
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  $ChatCompletionStopCopyWith<$Res>? get stop;
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$CreateChatCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateChatCompletionRequest>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  _$CreateChatCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value.functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionFunction>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionModelCopyWith<$Res> get model {
    return $ChatCompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $ChatCompletionResponseFormatCopyWith<$Res>(_value.responseFormat!,
        (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $ChatCompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice {
    if (_value.toolChoice == null) {
      return null;
    }

    return $ChatCompletionToolChoiceOptionCopyWith<$Res>(_value.toolChoice!,
        (value) {
      return _then(_value.copyWith(toolChoice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionFunctionCallCopyWith<$Res>(_value.functionCall!,
        (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionRequestImplCopyWith<$Res>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  factory _$$CreateChatCompletionRequestImplCopyWith(
          _$CreateChatCompletionRequestImpl value,
          $Res Function(_$CreateChatCompletionRequestImpl) then) =
      __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<ChatCompletionFunction>? functions});

  @override
  $ChatCompletionModelCopyWith<$Res> get model;
  @override
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  @override
  $ChatCompletionStopCopyWith<$Res>? get stop;
  @override
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  @override
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionRequestCopyWithImpl<$Res,
        _$CreateChatCompletionRequestImpl>
    implements _$$CreateChatCompletionRequestImplCopyWith<$Res> {
  __$$CreateChatCompletionRequestImplCopyWithImpl(
      _$CreateChatCompletionRequestImpl _value,
      $Res Function(_$CreateChatCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_$CreateChatCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value._functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionFunction>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionRequestImpl extends _CreateChatCompletionRequest {
  const _$CreateChatCompletionRequestImpl(
      {@_ChatCompletionModelConverter() required this.model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.seed,
      @_ChatCompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(includeIfNull: false) this.user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      this.functionCall,
      @JsonKey(includeIfNull: false)
      final List<ChatCompletionFunction>? functions})
      : _messages = messages,
        _logitBias = logitBias,
        _tools = tools,
        _functions = functions,
        super._();

  factory _$CreateChatCompletionRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionRequestImplFromJson(json);

  /// ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @override
  @_ChatCompletionModelConverter()
  final ChatCompletionModel model;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  final List<ChatCompletionMessage> _messages;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  @override
  List<ChatCompletionMessage> get messages {
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_messages);
  }

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many chat completion choices to generate for each input message.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// An object specifying the format that the model must output. Used to enable JSON mode.
  @override
  @JsonKey(name: 'response_format', includeIfNull: false)
  final ChatCompletionResponseFormat? responseFormat;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @override
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final ChatCompletionStop? stop;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  final List<ChatCompletionTool>? _tools;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type: "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @override
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final ChatCompletionToolChoiceOption? toolChoice;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto`` is the default if functions are present.
  @override
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionFunctionCall? functionCall;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  final List<ChatCompletionFunction>? _functions;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionFunction>? get functions {
    final value = _functions;
    if (value == null) return null;
    if (_functions is EqualUnmodifiableListView) return _functions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CreateChatCompletionRequest(model: $model, messages: $messages, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, responseFormat: $responseFormat, seed: $seed, stop: $stop, stream: $stream, temperature: $temperature, topP: $topP, tools: $tools, toolChoice: $toolChoice, user: $user, functionCall: $functionCall, functions: $functions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._functions, _functions));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      const DeepCollectionEquality().hash(_messages),
      frequencyPenalty,
      const DeepCollectionEquality().hash(_logitBias),
      maxTokens,
      n,
      presencePenalty,
      responseFormat,
      seed,
      stop,
      stream,
      temperature,
      topP,
      const DeepCollectionEquality().hash(_tools),
      toolChoice,
      user,
      functionCall,
      const DeepCollectionEquality().hash(_functions));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => __$$CreateChatCompletionRequestImplCopyWithImpl<
          _$CreateChatCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionRequest
    extends CreateChatCompletionRequest {
  const factory _CreateChatCompletionRequest(
      {@_ChatCompletionModelConverter()
      required final ChatCompletionModel model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      final ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) final int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      final ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) final String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      final ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false)
      final List<ChatCompletionFunction>?
          functions}) = _$CreateChatCompletionRequestImpl;
  const _CreateChatCompletionRequest._() : super._();

  factory _CreateChatCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model;
  @override

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) to generate in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many chat completion choices to generate for each input message.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/gpt/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// An object specifying the format that the model must output. Used to enable JSON mode.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat;
  @override

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop;
  @override

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools;
  @override

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type: "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto`` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall;
  @override

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionFunction>? get functions;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionModel _$ChatCompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionChatCompletionModelEnum.fromJson(json);
    case 'string':
      return _UnionChatCompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) enumeration,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? enumeration,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionModelEnum value) enumeration,
    required TResult Function(_UnionChatCompletionModelString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionModelEnum value)? enumeration,
    TResult? Function(_UnionChatCompletionModelString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionModelEnum value)? enumeration,
    TResult Function(_UnionChatCompletionModelString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionModelCopyWith<$Res> {
  factory $ChatCompletionModelCopyWith(
          ChatCompletionModel value, $Res Function(ChatCompletionModel) then) =
      _$ChatCompletionModelCopyWithImpl<$Res, ChatCompletionModel>;
}

/// @nodoc
class _$ChatCompletionModelCopyWithImpl<$Res, $Val extends ChatCompletionModel>
    implements $ChatCompletionModelCopyWith<$Res> {
  _$ChatCompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionChatCompletionModelEnumImplCopyWith<$Res> {
  factory _$$UnionChatCompletionModelEnumImplCopyWith(
          _$UnionChatCompletionModelEnumImpl value,
          $Res Function(_$UnionChatCompletionModelEnumImpl) then) =
      __$$UnionChatCompletionModelEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionModels value});
}

/// @nodoc
class __$$UnionChatCompletionModelEnumImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$UnionChatCompletionModelEnumImpl>
    implements _$$UnionChatCompletionModelEnumImplCopyWith<$Res> {
  __$$UnionChatCompletionModelEnumImplCopyWithImpl(
      _$UnionChatCompletionModelEnumImpl _value,
      $Res Function(_$UnionChatCompletionModelEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionChatCompletionModelEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionModelEnumImpl extends _UnionChatCompletionModelEnum {
  const _$UnionChatCompletionModelEnumImpl(this.value, {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionChatCompletionModelEnumImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionModelEnumImplFromJson(json);

  @override
  final ChatCompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionChatCompletionModelEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionModelEnumImplCopyWith<
          _$UnionChatCompletionModelEnumImpl>
      get copyWith => __$$UnionChatCompletionModelEnumImplCopyWithImpl<
          _$UnionChatCompletionModelEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionModelEnum value) enumeration,
    required TResult Function(_UnionChatCompletionModelString value) string,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionModelEnum value)? enumeration,
    TResult? Function(_UnionChatCompletionModelString value)? string,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionModelEnum value)? enumeration,
    TResult Function(_UnionChatCompletionModelString value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionModelEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionModelEnum extends ChatCompletionModel {
  const factory _UnionChatCompletionModelEnum(
      final ChatCompletionModels value) = _$UnionChatCompletionModelEnumImpl;
  const _UnionChatCompletionModelEnum._() : super._();

  factory _UnionChatCompletionModelEnum.fromJson(Map<String, dynamic> json) =
      _$UnionChatCompletionModelEnumImpl.fromJson;

  @override
  ChatCompletionModels get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionModelEnumImplCopyWith<
          _$UnionChatCompletionModelEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionChatCompletionModelStringImplCopyWith<$Res> {
  factory _$$UnionChatCompletionModelStringImplCopyWith(
          _$UnionChatCompletionModelStringImpl value,
          $Res Function(_$UnionChatCompletionModelStringImpl) then) =
      __$$UnionChatCompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionChatCompletionModelStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$UnionChatCompletionModelStringImpl>
    implements _$$UnionChatCompletionModelStringImplCopyWith<$Res> {
  __$$UnionChatCompletionModelStringImplCopyWithImpl(
      _$UnionChatCompletionModelStringImpl _value,
      $Res Function(_$UnionChatCompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionChatCompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionModelStringImpl
    extends _UnionChatCompletionModelString {
  const _$UnionChatCompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionChatCompletionModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionChatCompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionModelStringImplCopyWith<
          _$UnionChatCompletionModelStringImpl>
      get copyWith => __$$UnionChatCompletionModelStringImplCopyWithImpl<
          _$UnionChatCompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionModelEnum value) enumeration,
    required TResult Function(_UnionChatCompletionModelString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionModelEnum value)? enumeration,
    TResult? Function(_UnionChatCompletionModelString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionModelEnum value)? enumeration,
    TResult Function(_UnionChatCompletionModelString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionModelString extends ChatCompletionModel {
  const factory _UnionChatCompletionModelString(final String value) =
      _$UnionChatCompletionModelStringImpl;
  const _UnionChatCompletionModelString._() : super._();

  factory _UnionChatCompletionModelString.fromJson(Map<String, dynamic> json) =
      _$UnionChatCompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionModelStringImplCopyWith<
          _$UnionChatCompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseFormat _$ChatCompletionResponseFormatFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseFormat.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseFormat {
  /// Setting to `json_object` enables JSON mode. This guarantees that the message the model generates is valid JSON.
  ///
  /// Note that your system prompt must still instruct the model to produce JSON, and to help ensure you don't forget, the API will throw an error if the string `JSON` does not appear in your system message. Also note that the message content may be partial (i.e. cut off) if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  ///
  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseFormatCopyWith<ChatCompletionResponseFormat>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseFormatCopyWith<$Res> {
  factory $ChatCompletionResponseFormatCopyWith(
          ChatCompletionResponseFormat value,
          $Res Function(ChatCompletionResponseFormat) then) =
      _$ChatCompletionResponseFormatCopyWithImpl<$Res,
          ChatCompletionResponseFormat>;
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseFormat>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  _$ChatCompletionResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseFormatImplCopyWith<$Res>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  factory _$$ChatCompletionResponseFormatImplCopyWith(
          _$ChatCompletionResponseFormatImpl value,
          $Res Function(_$ChatCompletionResponseFormatImpl) then) =
      __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        _$ChatCompletionResponseFormatImpl>
    implements _$$ChatCompletionResponseFormatImplCopyWith<$Res> {
  __$$ChatCompletionResponseFormatImplCopyWithImpl(
      _$ChatCompletionResponseFormatImpl _value,
      $Res Function(_$ChatCompletionResponseFormatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$ChatCompletionResponseFormatImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseFormatImpl extends _ChatCompletionResponseFormat {
  const _$ChatCompletionResponseFormatImpl(
      {this.type = ChatCompletionResponseFormatType.text})
      : super._();

  factory _$ChatCompletionResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseFormatImplFromJson(json);

  /// Setting to `json_object` enables JSON mode. This guarantees that the message the model generates is valid JSON.
  ///
  /// Note that your system prompt must still instruct the model to produce JSON, and to help ensure you don't forget, the API will throw an error if the string `JSON` does not appear in your system message. Also note that the message content may be partial (i.e. cut off) if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  ///
  /// Must be one of `text` or `json_object`.
  @override
  @JsonKey()
  final ChatCompletionResponseFormatType type;

  @override
  String toString() {
    return 'ChatCompletionResponseFormat(type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseFormatImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => __$$ChatCompletionResponseFormatImplCopyWithImpl<
          _$ChatCompletionResponseFormatImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseFormatImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseFormat
    extends ChatCompletionResponseFormat {
  const factory _ChatCompletionResponseFormat(
          {final ChatCompletionResponseFormatType type}) =
      _$ChatCompletionResponseFormatImpl;
  const _ChatCompletionResponseFormat._() : super._();

  factory _ChatCompletionResponseFormat.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseFormatImpl.fromJson;

  @override

  /// Setting to `json_object` enables JSON mode. This guarantees that the message the model generates is valid JSON.
  ///
  /// Note that your system prompt must still instruct the model to produce JSON, and to help ensure you don't forget, the API will throw an error if the string `JSON` does not appear in your system message. Also note that the message content may be partial (i.e. cut off) if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  ///
  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStop _$ChatCompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'arrayString':
      return _UnionChatCompletionStopArrayString.fromJson(json);
    case 'string':
      return _UnionChatCompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionStop {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionStopArrayString value)
        arrayString,
    required TResult Function(_UnionChatCompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionStopArrayString value)? arrayString,
    TResult? Function(_UnionChatCompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionStopArrayString value)? arrayString,
    TResult Function(_UnionChatCompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStopCopyWith<$Res> {
  factory $ChatCompletionStopCopyWith(
          ChatCompletionStop value, $Res Function(ChatCompletionStop) then) =
      _$ChatCompletionStopCopyWithImpl<$Res, ChatCompletionStop>;
}

/// @nodoc
class _$ChatCompletionStopCopyWithImpl<$Res, $Val extends ChatCompletionStop>
    implements $ChatCompletionStopCopyWith<$Res> {
  _$ChatCompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionChatCompletionStopArrayStringImplCopyWith<$Res> {
  factory _$$UnionChatCompletionStopArrayStringImplCopyWith(
          _$UnionChatCompletionStopArrayStringImpl value,
          $Res Function(_$UnionChatCompletionStopArrayStringImpl) then) =
      __$$UnionChatCompletionStopArrayStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$UnionChatCompletionStopArrayStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$UnionChatCompletionStopArrayStringImpl>
    implements _$$UnionChatCompletionStopArrayStringImplCopyWith<$Res> {
  __$$UnionChatCompletionStopArrayStringImplCopyWithImpl(
      _$UnionChatCompletionStopArrayStringImpl _value,
      $Res Function(_$UnionChatCompletionStopArrayStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionChatCompletionStopArrayStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionStopArrayStringImpl
    extends _UnionChatCompletionStopArrayString {
  const _$UnionChatCompletionStopArrayStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayString',
        super._();

  factory _$UnionChatCompletionStopArrayStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionStopArrayStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.arrayString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionChatCompletionStopArrayStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionStopArrayStringImplCopyWith<
          _$UnionChatCompletionStopArrayStringImpl>
      get copyWith => __$$UnionChatCompletionStopArrayStringImplCopyWithImpl<
          _$UnionChatCompletionStopArrayStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return arrayString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return arrayString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionStopArrayString value)
        arrayString,
    required TResult Function(_UnionChatCompletionStopString value) string,
  }) {
    return arrayString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionStopArrayString value)? arrayString,
    TResult? Function(_UnionChatCompletionStopString value)? string,
  }) {
    return arrayString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionStopArrayString value)? arrayString,
    TResult Function(_UnionChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionStopArrayStringImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionStopArrayString extends ChatCompletionStop {
  const factory _UnionChatCompletionStopArrayString(final List<String> value) =
      _$UnionChatCompletionStopArrayStringImpl;
  const _UnionChatCompletionStopArrayString._() : super._();

  factory _UnionChatCompletionStopArrayString.fromJson(
          Map<String, dynamic> json) =
      _$UnionChatCompletionStopArrayStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionStopArrayStringImplCopyWith<
          _$UnionChatCompletionStopArrayStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionChatCompletionStopStringImplCopyWith<$Res> {
  factory _$$UnionChatCompletionStopStringImplCopyWith(
          _$UnionChatCompletionStopStringImpl value,
          $Res Function(_$UnionChatCompletionStopStringImpl) then) =
      __$$UnionChatCompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionChatCompletionStopStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$UnionChatCompletionStopStringImpl>
    implements _$$UnionChatCompletionStopStringImplCopyWith<$Res> {
  __$$UnionChatCompletionStopStringImplCopyWithImpl(
      _$UnionChatCompletionStopStringImpl _value,
      $Res Function(_$UnionChatCompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionChatCompletionStopStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionStopStringImpl
    extends _UnionChatCompletionStopString {
  const _$UnionChatCompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionChatCompletionStopStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionStopStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionChatCompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionStopStringImplCopyWith<
          _$UnionChatCompletionStopStringImpl>
      get copyWith => __$$UnionChatCompletionStopStringImplCopyWithImpl<
          _$UnionChatCompletionStopStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionStopArrayString value)
        arrayString,
    required TResult Function(_UnionChatCompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionStopArrayString value)? arrayString,
    TResult? Function(_UnionChatCompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionStopArrayString value)? arrayString,
    TResult Function(_UnionChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionStopString extends ChatCompletionStop {
  const factory _UnionChatCompletionStopString(final String value) =
      _$UnionChatCompletionStopStringImpl;
  const _UnionChatCompletionStopString._() : super._();

  factory _UnionChatCompletionStopString.fromJson(Map<String, dynamic> json) =
      _$UnionChatCompletionStopStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionStopStringImplCopyWith<
          _$UnionChatCompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionToolChoiceOption _$ChatCompletionToolChoiceOptionFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionChatCompletionToolChoiceOptionEnum.fromJson(json);
    case 'chatCompletionNamedToolChoice':
      return _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionToolChoiceOption',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionToolChoiceOption {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnum value)
        enumeration,
    required TResult Function(ChatCompletionNamedToolChoice value)
        chatCompletionNamedToolChoice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnum value)? enumeration,
    TResult? Function(ChatCompletionNamedToolChoice value)?
        chatCompletionNamedToolChoice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnum value)? enumeration,
    TResult Function(ChatCompletionNamedToolChoice value)?
        chatCompletionNamedToolChoice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionToolChoiceOptionEnum value)
        enumeration,
    required TResult Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)
        chatCompletionNamedToolChoice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionToolChoiceOptionEnum value)?
        enumeration,
    TResult? Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)?
        chatCompletionNamedToolChoice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionToolChoiceOptionEnum value)?
        enumeration,
    TResult Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)?
        chatCompletionNamedToolChoice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  factory $ChatCompletionToolChoiceOptionCopyWith(
          ChatCompletionToolChoiceOption value,
          $Res Function(ChatCompletionToolChoiceOption) then) =
      _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
          ChatCompletionToolChoiceOption>;
}

/// @nodoc
class _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionToolChoiceOption>
    implements $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  _$ChatCompletionToolChoiceOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionChatCompletionToolChoiceOptionEnumImplCopyWith<$Res> {
  factory _$$UnionChatCompletionToolChoiceOptionEnumImplCopyWith(
          _$UnionChatCompletionToolChoiceOptionEnumImpl value,
          $Res Function(_$UnionChatCompletionToolChoiceOptionEnumImpl) then) =
      __$$UnionChatCompletionToolChoiceOptionEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionToolChoiceOptionEnum value});
}

/// @nodoc
class __$$UnionChatCompletionToolChoiceOptionEnumImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$UnionChatCompletionToolChoiceOptionEnumImpl>
    implements _$$UnionChatCompletionToolChoiceOptionEnumImplCopyWith<$Res> {
  __$$UnionChatCompletionToolChoiceOptionEnumImplCopyWithImpl(
      _$UnionChatCompletionToolChoiceOptionEnumImpl _value,
      $Res Function(_$UnionChatCompletionToolChoiceOptionEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionChatCompletionToolChoiceOptionEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOptionEnum,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionToolChoiceOptionEnumImpl
    extends _UnionChatCompletionToolChoiceOptionEnum {
  const _$UnionChatCompletionToolChoiceOptionEnumImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionChatCompletionToolChoiceOptionEnumImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionToolChoiceOptionEnumImplFromJson(json);

  @override
  final ChatCompletionToolChoiceOptionEnum value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionChatCompletionToolChoiceOptionEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionToolChoiceOptionEnumImplCopyWith<
          _$UnionChatCompletionToolChoiceOptionEnumImpl>
      get copyWith =>
          __$$UnionChatCompletionToolChoiceOptionEnumImplCopyWithImpl<
              _$UnionChatCompletionToolChoiceOptionEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnum value)
        enumeration,
    required TResult Function(ChatCompletionNamedToolChoice value)
        chatCompletionNamedToolChoice,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnum value)? enumeration,
    TResult? Function(ChatCompletionNamedToolChoice value)?
        chatCompletionNamedToolChoice,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnum value)? enumeration,
    TResult Function(ChatCompletionNamedToolChoice value)?
        chatCompletionNamedToolChoice,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionToolChoiceOptionEnum value)
        enumeration,
    required TResult Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)
        chatCompletionNamedToolChoice,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionToolChoiceOptionEnum value)?
        enumeration,
    TResult? Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)?
        chatCompletionNamedToolChoice,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionToolChoiceOptionEnum value)?
        enumeration,
    TResult Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)?
        chatCompletionNamedToolChoice,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionToolChoiceOptionEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionToolChoiceOptionEnum
    extends ChatCompletionToolChoiceOption {
  const factory _UnionChatCompletionToolChoiceOptionEnum(
          final ChatCompletionToolChoiceOptionEnum value) =
      _$UnionChatCompletionToolChoiceOptionEnumImpl;
  const _UnionChatCompletionToolChoiceOptionEnum._() : super._();

  factory _UnionChatCompletionToolChoiceOptionEnum.fromJson(
          Map<String, dynamic> json) =
      _$UnionChatCompletionToolChoiceOptionEnumImpl.fromJson;

  @override
  ChatCompletionToolChoiceOptionEnum get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionToolChoiceOptionEnumImplCopyWith<
          _$UnionChatCompletionToolChoiceOptionEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
    $Res> {
  factory _$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith(
          _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
              value,
          $Res Function(
                  _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
              then) =
      __$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionNamedToolChoice value});

  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class __$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
    implements
        _$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
            $Res> {
  __$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
          _value,
      $Res Function(
              _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value {
    return $ChatCompletionNamedToolChoiceCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
    extends _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice {
  const _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'chatCompletionNamedToolChoice',
        super._();

  factory _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplFromJson(
          json);

  @override
  final ChatCompletionNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.chatCompletionNamedToolChoice(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith =>
          __$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
                  _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnum value)
        enumeration,
    required TResult Function(ChatCompletionNamedToolChoice value)
        chatCompletionNamedToolChoice,
  }) {
    return chatCompletionNamedToolChoice(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnum value)? enumeration,
    TResult? Function(ChatCompletionNamedToolChoice value)?
        chatCompletionNamedToolChoice,
  }) {
    return chatCompletionNamedToolChoice?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnum value)? enumeration,
    TResult Function(ChatCompletionNamedToolChoice value)?
        chatCompletionNamedToolChoice,
    required TResult orElse(),
  }) {
    if (chatCompletionNamedToolChoice != null) {
      return chatCompletionNamedToolChoice(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionToolChoiceOptionEnum value)
        enumeration,
    required TResult Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)
        chatCompletionNamedToolChoice,
  }) {
    return chatCompletionNamedToolChoice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionToolChoiceOptionEnum value)?
        enumeration,
    TResult? Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)?
        chatCompletionNamedToolChoice,
  }) {
    return chatCompletionNamedToolChoice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionToolChoiceOptionEnum value)?
        enumeration,
    TResult Function(
            _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
                value)?
        chatCompletionNamedToolChoice,
    required TResult orElse(),
  }) {
    if (chatCompletionNamedToolChoice != null) {
      return chatCompletionNamedToolChoice(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
    extends ChatCompletionToolChoiceOption {
  const factory _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice(
          final ChatCompletionNamedToolChoice value) =
      _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl;
  const _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice._()
      : super._();

  factory _UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoice.fromJson(
          Map<String, dynamic> json) =
      _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
      .fromJson;

  @override
  ChatCompletionNamedToolChoice get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$UnionChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCall _$ChatCompletionFunctionCallFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionChatCompletionFunctionCallEnum.fromJson(json);
    case 'chatCompletionFunctionCallOption':
      return _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionFunctionCall',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionFunctionCall {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) enumeration,
    required TResult Function(ChatCompletionFunctionCallOption value)
        chatCompletionFunctionCallOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? enumeration,
    TResult? Function(ChatCompletionFunctionCallOption value)?
        chatCompletionFunctionCallOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? enumeration,
    TResult Function(ChatCompletionFunctionCallOption value)?
        chatCompletionFunctionCallOption,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionFunctionCallEnum value)
        enumeration,
    required TResult Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)
        chatCompletionFunctionCallOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionFunctionCallEnum value)? enumeration,
    TResult? Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)?
        chatCompletionFunctionCallOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionFunctionCallEnum value)? enumeration,
    TResult Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)?
        chatCompletionFunctionCallOption,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallCopyWith<$Res> {
  factory $ChatCompletionFunctionCallCopyWith(ChatCompletionFunctionCall value,
          $Res Function(ChatCompletionFunctionCall) then) =
      _$ChatCompletionFunctionCallCopyWithImpl<$Res,
          ChatCompletionFunctionCall>;
}

/// @nodoc
class _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCall>
    implements $ChatCompletionFunctionCallCopyWith<$Res> {
  _$ChatCompletionFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionChatCompletionFunctionCallEnumImplCopyWith<$Res> {
  factory _$$UnionChatCompletionFunctionCallEnumImplCopyWith(
          _$UnionChatCompletionFunctionCallEnumImpl value,
          $Res Function(_$UnionChatCompletionFunctionCallEnumImpl) then) =
      __$$UnionChatCompletionFunctionCallEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallMode value});
}

/// @nodoc
class __$$UnionChatCompletionFunctionCallEnumImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$UnionChatCompletionFunctionCallEnumImpl>
    implements _$$UnionChatCompletionFunctionCallEnumImplCopyWith<$Res> {
  __$$UnionChatCompletionFunctionCallEnumImplCopyWithImpl(
      _$UnionChatCompletionFunctionCallEnumImpl _value,
      $Res Function(_$UnionChatCompletionFunctionCallEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionChatCompletionFunctionCallEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionFunctionCallEnumImpl
    extends _UnionChatCompletionFunctionCallEnum {
  const _$UnionChatCompletionFunctionCallEnumImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionChatCompletionFunctionCallEnumImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionFunctionCallEnumImplFromJson(json);

  @override
  final ChatCompletionFunctionCallMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionChatCompletionFunctionCallEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionFunctionCallEnumImplCopyWith<
          _$UnionChatCompletionFunctionCallEnumImpl>
      get copyWith => __$$UnionChatCompletionFunctionCallEnumImplCopyWithImpl<
          _$UnionChatCompletionFunctionCallEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) enumeration,
    required TResult Function(ChatCompletionFunctionCallOption value)
        chatCompletionFunctionCallOption,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? enumeration,
    TResult? Function(ChatCompletionFunctionCallOption value)?
        chatCompletionFunctionCallOption,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? enumeration,
    TResult Function(ChatCompletionFunctionCallOption value)?
        chatCompletionFunctionCallOption,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionFunctionCallEnum value)
        enumeration,
    required TResult Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)
        chatCompletionFunctionCallOption,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionFunctionCallEnum value)? enumeration,
    TResult? Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)?
        chatCompletionFunctionCallOption,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionFunctionCallEnum value)? enumeration,
    TResult Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)?
        chatCompletionFunctionCallOption,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionFunctionCallEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionFunctionCallEnum
    extends ChatCompletionFunctionCall {
  const factory _UnionChatCompletionFunctionCallEnum(
          final ChatCompletionFunctionCallMode value) =
      _$UnionChatCompletionFunctionCallEnumImpl;
  const _UnionChatCompletionFunctionCallEnum._() : super._();

  factory _UnionChatCompletionFunctionCallEnum.fromJson(
          Map<String, dynamic> json) =
      _$UnionChatCompletionFunctionCallEnumImpl.fromJson;

  @override
  ChatCompletionFunctionCallMode get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionFunctionCallEnumImplCopyWith<
          _$UnionChatCompletionFunctionCallEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
    $Res> {
  factory _$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith(
          _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl
              value,
          $Res Function(
                  _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
              then) =
      __$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallOption value});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value;
}

/// @nodoc
class __$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
    implements
        _$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
            $Res> {
  __$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl
          _value,
      $Res Function(
              _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl
    extends _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption {
  const _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'chatCompletionFunctionCallOption',
        super._();

  factory _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplFromJson(
          json);

  @override
  final ChatCompletionFunctionCallOption value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.chatCompletionFunctionCallOption(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith =>
          __$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
                  _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) enumeration,
    required TResult Function(ChatCompletionFunctionCallOption value)
        chatCompletionFunctionCallOption,
  }) {
    return chatCompletionFunctionCallOption(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? enumeration,
    TResult? Function(ChatCompletionFunctionCallOption value)?
        chatCompletionFunctionCallOption,
  }) {
    return chatCompletionFunctionCallOption?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? enumeration,
    TResult Function(ChatCompletionFunctionCallOption value)?
        chatCompletionFunctionCallOption,
    required TResult orElse(),
  }) {
    if (chatCompletionFunctionCallOption != null) {
      return chatCompletionFunctionCallOption(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionChatCompletionFunctionCallEnum value)
        enumeration,
    required TResult Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)
        chatCompletionFunctionCallOption,
  }) {
    return chatCompletionFunctionCallOption(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionChatCompletionFunctionCallEnum value)? enumeration,
    TResult? Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)?
        chatCompletionFunctionCallOption,
  }) {
    return chatCompletionFunctionCallOption?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionChatCompletionFunctionCallEnum value)? enumeration,
    TResult Function(
            _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
                value)?
        chatCompletionFunctionCallOption,
    required TResult orElse(),
  }) {
    if (chatCompletionFunctionCallOption != null) {
      return chatCompletionFunctionCallOption(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCall {
  const factory _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption(
          final ChatCompletionFunctionCallOption value) =
      _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl;
  const _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption._()
      : super._();

  factory _UnionChatCompletionFunctionCallChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl
      .fromJson;

  @override
  ChatCompletionFunctionCallOption get value;
  @JsonKey(ignore: true)
  _$$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$UnionChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessage _$ChatCompletionMessageFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessage.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessage {
  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  ChatCompletionMessageRole get role => throw _privateConstructorUsedError;

  /// The contents of the message. `content` is required for all messages, and may be null for assistant messages with function calls.
  String? get content => throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls =>
      throw _privateConstructorUsedError;

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionMessageFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// Tool call that this message is responding to.
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  String? get toolCallId => throw _privateConstructorUsedError;

  /// The name of the author of this message. `name` is required if role is `function`, and it should be the name of the function whose response is in the `content`. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageCopyWith<ChatCompletionMessage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionMessageCopyWith(ChatCompletionMessage value,
          $Res Function(ChatCompletionMessage) then) =
      _$ChatCompletionMessageCopyWithImpl<$Res, ChatCompletionMessage>;
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String? content,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? name});

  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$ChatCompletionMessageCopyWithImpl<$Res,
        $Val extends ChatCompletionMessage>
    implements $ChatCompletionMessageCopyWith<$Res> {
  _$ChatCompletionMessageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? toolCalls = freezed,
    Object? functionCall = freezed,
    Object? toolCallId = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _value.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageToolCall>?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall?,
      toolCallId: freezed == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionMessageImplCopyWith(
          _$ChatCompletionMessageImpl value,
          $Res Function(_$ChatCompletionMessageImpl) then) =
      __$$ChatCompletionMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String? content,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? name});

  @override
  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionMessageImpl>
    implements _$$ChatCompletionMessageImplCopyWith<$Res> {
  __$$ChatCompletionMessageImplCopyWithImpl(_$ChatCompletionMessageImpl _value,
      $Res Function(_$ChatCompletionMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? toolCalls = freezed,
    Object? functionCall = freezed,
    Object? toolCallId = freezed,
    Object? name = freezed,
  }) {
    return _then(_$ChatCompletionMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageToolCall>?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall?,
      toolCallId: freezed == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageImpl extends _ChatCompletionMessage {
  const _$ChatCompletionMessageImpl(
      {required this.role,
      required this.content,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall,
      @JsonKey(name: 'tool_call_id', includeIfNull: false) this.toolCallId,
      @JsonKey(includeIfNull: false) this.name})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionMessageImplFromJson(json);

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @override
  final ChatCompletionMessageRole role;

  /// The contents of the message. `content` is required for all messages, and may be null for assistant messages with function calls.
  @override
  final String? content;

  /// No Description
  final List<ChatCompletionMessageToolCall>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionMessageFunctionCall? functionCall;

  /// Tool call that this message is responding to.
  @override
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  final String? toolCallId;

  /// The name of the author of this message. `name` is required if role is `function`, and it should be the name of the function whose response is in the `content`. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  @override
  String toString() {
    return 'ChatCompletionMessage(role: $role, content: $content, toolCalls: $toolCalls, functionCall: $functionCall, toolCallId: $toolCallId, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      role,
      content,
      const DeepCollectionEquality().hash(_toolCalls),
      functionCall,
      toolCallId,
      name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageImplCopyWith<_$ChatCompletionMessageImpl>
      get copyWith => __$$ChatCompletionMessageImplCopyWithImpl<
          _$ChatCompletionMessageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessage extends ChatCompletionMessage {
  const factory _ChatCompletionMessage(
          {required final ChatCompletionMessageRole role,
          required final String? content,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionMessageToolCall>? toolCalls,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionMessageFunctionCall? functionCall,
          @JsonKey(name: 'tool_call_id', includeIfNull: false)
          final String? toolCallId,
          @JsonKey(includeIfNull: false) final String? name}) =
      _$ChatCompletionMessageImpl;
  const _ChatCompletionMessage._() : super._();

  factory _ChatCompletionMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageImpl.fromJson;

  @override

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the message. `content` is required for all messages, and may be null for assistant messages with function calls.
  String? get content;
  @override

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls;
  @override

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionMessageFunctionCall? get functionCall;
  @override

  /// Tool call that this message is responding to.
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  String? get toolCallId;
  @override

  /// The name of the author of this message. `name` is required if role is `function`, and it should be the name of the function whose response is in the `content`. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageImplCopyWith<_$ChatCompletionMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageFunctionCall _$ChatCompletionMessageFunctionCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageFunctionCall {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageFunctionCallCopyWith<ChatCompletionMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionMessageFunctionCallCopyWith(
          ChatCompletionMessageFunctionCall value,
          $Res Function(ChatCompletionMessageFunctionCall) then) =
      _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionMessageFunctionCall>;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageFunctionCall>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionMessageFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageFunctionCallImplCopyWith(
          _$ChatCompletionMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionMessageFunctionCallImpl) then) =
      __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionMessageFunctionCallImpl>
    implements _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_$ChatCompletionMessageFunctionCallImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageFunctionCallImpl
    extends _ChatCompletionMessageFunctionCall {
  const _$ChatCompletionMessageFunctionCallImpl(
      {required this.name, required this.arguments})
      : super._();

  factory _$ChatCompletionMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  final String arguments;

  @override
  String toString() {
    return 'ChatCompletionMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<
          _$ChatCompletionMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageFunctionCall
    extends ChatCompletionMessageFunctionCall {
  const factory _ChatCompletionMessageFunctionCall(
          {required final String name, required final String arguments}) =
      _$ChatCompletionMessageFunctionCallImpl;
  const _ChatCompletionMessageFunctionCall._() : super._();

  factory _ChatCompletionMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunction _$ChatCompletionFunctionFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionFunction.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionFunction {
  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name => throw _privateConstructorUsedError;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  Map<String, dynamic> get parameters => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionFunctionCopyWith<ChatCompletionFunction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCopyWith<$Res> {
  factory $ChatCompletionFunctionCopyWith(ChatCompletionFunction value,
          $Res Function(ChatCompletionFunction) then) =
      _$ChatCompletionFunctionCopyWithImpl<$Res, ChatCompletionFunction>;
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      Map<String, dynamic> parameters});
}

/// @nodoc
class _$ChatCompletionFunctionCopyWithImpl<$Res,
        $Val extends ChatCompletionFunction>
    implements $ChatCompletionFunctionCopyWith<$Res> {
  _$ChatCompletionFunctionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: null == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionFunctionImplCopyWith<$Res>
    implements $ChatCompletionFunctionCopyWith<$Res> {
  factory _$$ChatCompletionFunctionImplCopyWith(
          _$ChatCompletionFunctionImpl value,
          $Res Function(_$ChatCompletionFunctionImpl) then) =
      __$$ChatCompletionFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      Map<String, dynamic> parameters});
}

/// @nodoc
class __$$ChatCompletionFunctionImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCopyWithImpl<$Res,
        _$ChatCompletionFunctionImpl>
    implements _$$ChatCompletionFunctionImplCopyWith<$Res> {
  __$$ChatCompletionFunctionImplCopyWithImpl(
      _$ChatCompletionFunctionImpl _value,
      $Res Function(_$ChatCompletionFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = null,
  }) {
    return _then(_$ChatCompletionFunctionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: null == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionImpl extends _ChatCompletionFunction {
  const _$ChatCompletionFunctionImpl(
      {required this.name,
      @JsonKey(includeIfNull: false) this.description,
      required final Map<String, dynamic> parameters})
      : _parameters = parameters,
        super._();

  factory _$ChatCompletionFunctionImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionImplFromJson(json);

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  @override
  final String name;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  final Map<String, dynamic> _parameters;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  @override
  Map<String, dynamic> get parameters {
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_parameters);
  }

  @override
  String toString() {
    return 'ChatCompletionFunction(name: $name, description: $description, parameters: $parameters)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(_parameters));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionImplCopyWith<_$ChatCompletionFunctionImpl>
      get copyWith => __$$ChatCompletionFunctionImplCopyWithImpl<
          _$ChatCompletionFunctionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionFunction extends ChatCompletionFunction {
  const factory _ChatCompletionFunction(
          {required final String name,
          @JsonKey(includeIfNull: false) final String? description,
          required final Map<String, dynamic> parameters}) =
      _$ChatCompletionFunctionImpl;
  const _ChatCompletionFunction._() : super._();

  factory _ChatCompletionFunction.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionFunctionImpl.fromJson;

  @override

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name;
  @override

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// To describe a function that accepts no parameters, provide the value `{"type": "object", "properties": {}}`.
  Map<String, dynamic> get parameters;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionImplCopyWith<_$ChatCompletionFunctionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCallOption _$ChatCompletionFunctionCallOptionFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionFunctionCallOption.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionFunctionCallOption {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionFunctionCallOptionCopyWith<ChatCompletionFunctionCallOption>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory $ChatCompletionFunctionCallOptionCopyWith(
          ChatCompletionFunctionCallOption value,
          $Res Function(ChatCompletionFunctionCallOption) then) =
      _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
          ChatCompletionFunctionCallOption>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCallOption>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  _$ChatCompletionFunctionCallOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory _$$ChatCompletionFunctionCallOptionImplCopyWith(
          _$ChatCompletionFunctionCallOptionImpl value,
          $Res Function(_$ChatCompletionFunctionCallOptionImpl) then) =
      __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallOptionImpl>
    implements _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res> {
  __$$ChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$ChatCompletionFunctionCallOptionImpl _value,
      $Res Function(_$ChatCompletionFunctionCallOptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$ChatCompletionFunctionCallOptionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallOptionImpl
    extends _ChatCompletionFunctionCallOption {
  const _$ChatCompletionFunctionCallOptionImpl({required this.name})
      : super._();

  factory _$ChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallOptionImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'ChatCompletionFunctionCallOption(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionCallOptionImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<
          _$ChatCompletionFunctionCallOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCallOption {
  const factory _ChatCompletionFunctionCallOption(
      {required final String name}) = _$ChatCompletionFunctionCallOptionImpl;
  const _ChatCompletionFunctionCallOption._() : super._();

  factory _ChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallOptionImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionTool _$ChatCompletionToolFromJson(Map<String, dynamic> json) {
  return _ChatCompletionTool.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTool {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type => throw _privateConstructorUsedError;

  /// A function that the model may call.
  ChatCompletionFunction get function => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionToolCopyWith<ChatCompletionTool> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolCopyWith<$Res> {
  factory $ChatCompletionToolCopyWith(
          ChatCompletionTool value, $Res Function(ChatCompletionTool) then) =
      _$ChatCompletionToolCopyWithImpl<$Res, ChatCompletionTool>;
  @useResult
  $Res call({ChatCompletionToolType type, ChatCompletionFunction function});

  $ChatCompletionFunctionCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionToolCopyWithImpl<$Res, $Val extends ChatCompletionTool>
    implements $ChatCompletionToolCopyWith<$Res> {
  _$ChatCompletionToolCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunction,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCopyWith<$Res> get function {
    return $ChatCompletionFunctionCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionToolImplCopyWith<$Res>
    implements $ChatCompletionToolCopyWith<$Res> {
  factory _$$ChatCompletionToolImplCopyWith(_$ChatCompletionToolImpl value,
          $Res Function(_$ChatCompletionToolImpl) then) =
      __$$ChatCompletionToolImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionToolType type, ChatCompletionFunction function});

  @override
  $ChatCompletionFunctionCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionToolImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolCopyWithImpl<$Res, _$ChatCompletionToolImpl>
    implements _$$ChatCompletionToolImplCopyWith<$Res> {
  __$$ChatCompletionToolImplCopyWithImpl(_$ChatCompletionToolImpl _value,
      $Res Function(_$ChatCompletionToolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionToolImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunction,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolImpl extends _ChatCompletionTool {
  const _$ChatCompletionToolImpl({required this.type, required this.function})
      : super._();

  factory _$ChatCompletionToolImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionToolImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionToolType type;

  /// A function that the model may call.
  @override
  final ChatCompletionFunction function;

  @override
  String toString() {
    return 'ChatCompletionTool(type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      __$$ChatCompletionToolImplCopyWithImpl<_$ChatCompletionToolImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTool extends ChatCompletionTool {
  const factory _ChatCompletionTool(
          {required final ChatCompletionToolType type,
          required final ChatCompletionFunction function}) =
      _$ChatCompletionToolImpl;
  const _ChatCompletionTool._() : super._();

  factory _ChatCompletionTool.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionToolImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type;
  @override

  /// A function that the model may call.
  ChatCompletionFunction get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionNamedToolChoice _$ChatCompletionNamedToolChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionNamedToolChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionNamedToolChoice {
  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionNamedToolChoiceType? get type =>
      throw _privateConstructorUsedError;

  /// Forces the model to call the specified function.
  @JsonKey(includeIfNull: false)
  ChatCompletionFunctionCallOption? get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionNamedToolChoiceCopyWith<ChatCompletionNamedToolChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory $ChatCompletionNamedToolChoiceCopyWith(
          ChatCompletionNamedToolChoice value,
          $Res Function(ChatCompletionNamedToolChoice) then) =
      _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
          ChatCompletionNamedToolChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionNamedToolChoiceType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionFunctionCallOption? function});

  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionNamedToolChoice>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  _$ChatCompletionNamedToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.function!,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory _$$ChatCompletionNamedToolChoiceImplCopyWith(
          _$ChatCompletionNamedToolChoiceImpl value,
          $Res Function(_$ChatCompletionNamedToolChoiceImpl) then) =
      __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionNamedToolChoiceType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionFunctionCallOption? function});

  @override
  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        _$ChatCompletionNamedToolChoiceImpl>
    implements _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res> {
  __$$ChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$ChatCompletionNamedToolChoiceImpl _value,
      $Res Function(_$ChatCompletionNamedToolChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_$ChatCompletionNamedToolChoiceImpl(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionNamedToolChoiceImpl
    extends _ChatCompletionNamedToolChoice {
  const _$ChatCompletionNamedToolChoiceImpl(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$ChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionNamedToolChoiceImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionNamedToolChoiceType? type;

  /// Forces the model to call the specified function.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionFunctionCallOption? function;

  @override
  String toString() {
    return 'ChatCompletionNamedToolChoice(type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionNamedToolChoiceImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<
          _$ChatCompletionNamedToolChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionNamedToolChoice
    extends ChatCompletionNamedToolChoice {
  const factory _ChatCompletionNamedToolChoice(
          {@JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionNamedToolChoiceType? type,
          @JsonKey(includeIfNull: false)
          final ChatCompletionFunctionCallOption? function}) =
      _$ChatCompletionNamedToolChoiceImpl;
  const _ChatCompletionNamedToolChoice._() : super._();

  factory _ChatCompletionNamedToolChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionNamedToolChoiceImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionNamedToolChoiceType? get type;
  @override

  /// Forces the model to call the specified function.
  @JsonKey(includeIfNull: false)
  ChatCompletionFunctionCallOption? get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageToolCall _$ChatCompletionMessageToolCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageToolCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageToolCall {
  /// The ID of the tool call.
  String get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageToolCallCopyWith<ChatCompletionMessageToolCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory $ChatCompletionMessageToolCallCopyWith(
          ChatCompletionMessageToolCall value,
          $Res Function(ChatCompletionMessageToolCall) then) =
      _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
          ChatCompletionMessageToolCall>;
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageToolCall>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  _$ChatCompletionMessageToolCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function {
    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageToolCallImplCopyWith<$Res>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageToolCallImplCopyWith(
          _$ChatCompletionMessageToolCallImpl value,
          $Res Function(_$ChatCompletionMessageToolCallImpl) then) =
      __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  @override
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        _$ChatCompletionMessageToolCallImpl>
    implements _$$ChatCompletionMessageToolCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageToolCallImplCopyWithImpl(
      _$ChatCompletionMessageToolCallImpl _value,
      $Res Function(_$ChatCompletionMessageToolCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionMessageToolCallImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageToolCallImpl
    extends _ChatCompletionMessageToolCall {
  const _$ChatCompletionMessageToolCallImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$ChatCompletionMessageToolCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageToolCallImplFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionMessageToolCallType type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  final ChatCompletionMessageFunctionCall function;

  @override
  String toString() {
    return 'ChatCompletionMessageToolCall(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageToolCallImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => __$$ChatCompletionMessageToolCallImplCopyWithImpl<
          _$ChatCompletionMessageToolCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageToolCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageToolCall
    extends ChatCompletionMessageToolCall {
  const factory _ChatCompletionMessageToolCall(
          {required final String id,
          required final ChatCompletionMessageToolCallType type,
          required final ChatCompletionMessageFunctionCall function}) =
      _$ChatCompletionMessageToolCallImpl;
  const _ChatCompletionMessageToolCall._() : super._();

  factory _ChatCompletionMessageToolCall.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageToolCallImpl.fromJson;

  @override

  /// The ID of the tool call.
  String get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionResponse _$CreateChatCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionResponse {
  /// A unique identifier for the chat completion.
  String get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for the chat completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion`.
  CreateChatCompletionResponseObject get object =>
      throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionResponseCopyWith<CreateChatCompletionResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionResponseCopyWith<$Res> {
  factory $CreateChatCompletionResponseCopyWith(
          CreateChatCompletionResponse value,
          $Res Function(CreateChatCompletionResponse) then) =
      _$CreateChatCompletionResponseCopyWithImpl<$Res,
          CreateChatCompletionResponse>;
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateChatCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionResponse>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  _$CreateChatCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionResponseImplCopyWith<$Res>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionResponseImplCopyWith(
          _$CreateChatCompletionResponseImpl value,
          $Res Function(_$CreateChatCompletionResponseImpl) then) =
      __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionResponseCopyWithImpl<$Res,
        _$CreateChatCompletionResponseImpl>
    implements _$$CreateChatCompletionResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionResponseImplCopyWithImpl(
      _$CreateChatCompletionResponseImpl _value,
      $Res Function(_$CreateChatCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateChatCompletionResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionResponseImpl extends _CreateChatCompletionResponse {
  const _$CreateChatCompletionResponseImpl(
      {required this.id,
      required final List<ChatCompletionResponseChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionResponseImplFromJson(json);

  /// A unique identifier for the chat completion.
  @override
  final String id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  @override
  final int created;

  /// The model used for the chat completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion`.
  @override
  final CreateChatCompletionResponseObject object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateChatCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => __$$CreateChatCompletionResponseImplCopyWithImpl<
          _$CreateChatCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionResponse
    extends CreateChatCompletionResponse {
  const factory _CreateChatCompletionResponse(
          {required final String id,
          required final List<ChatCompletionResponseChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final CreateChatCompletionResponseObject object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateChatCompletionResponseImpl;
  const _CreateChatCompletionResponse._() : super._();

  factory _CreateChatCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion.
  String get id;
  @override

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created;
  @override

  /// The model used for the chat completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion`.
  CreateChatCompletionResponseObject get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseChoice _$ChatCompletionResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(name: 'finish_reason')
  ChatCompletionFinishReason get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  int get index => throw _privateConstructorUsedError;

  /// A chat completion message generated by the model.
  ChatCompletionMessage get message => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseChoiceCopyWith<ChatCompletionResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionResponseChoiceCopyWith(
          ChatCompletionResponseChoice value,
          $Res Function(ChatCompletionResponseChoice) then) =
      _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
          ChatCompletionResponseChoice>;
  @useResult
  $Res call(
      {@JsonKey(name: 'finish_reason') ChatCompletionFinishReason finishReason,
      int index,
      ChatCompletionMessage message});

  $ChatCompletionMessageCopyWith<$Res> get message;
}

/// @nodoc
class _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseChoice>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  _$ChatCompletionResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = null,
    Object? index = null,
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      finishReason: null == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessage,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageCopyWith<$Res> get message {
    return $ChatCompletionMessageCopyWith<$Res>(_value.message, (value) {
      return _then(_value.copyWith(message: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionResponseChoiceImplCopyWith(
          _$ChatCompletionResponseChoiceImpl value,
          $Res Function(_$ChatCompletionResponseChoiceImpl) then) =
      __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'finish_reason') ChatCompletionFinishReason finishReason,
      int index,
      ChatCompletionMessage message});

  @override
  $ChatCompletionMessageCopyWith<$Res> get message;
}

/// @nodoc
class __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionResponseChoiceImpl>
    implements _$$ChatCompletionResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionResponseChoiceImplCopyWithImpl(
      _$ChatCompletionResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = null,
    Object? index = null,
    Object? message = null,
  }) {
    return _then(_$ChatCompletionResponseChoiceImpl(
      finishReason: null == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessage,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseChoiceImpl extends _ChatCompletionResponseChoice {
  const _$ChatCompletionResponseChoiceImpl(
      {@JsonKey(name: 'finish_reason') required this.finishReason,
      required this.index,
      required this.message})
      : super._();

  factory _$ChatCompletionResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(name: 'finish_reason')
  final ChatCompletionFinishReason finishReason;

  /// The index of the choice in the list of choices.
  @override
  final int index;

  /// A chat completion message generated by the model.
  @override
  final ChatCompletionMessage message;

  @override
  String toString() {
    return 'ChatCompletionResponseChoice(finishReason: $finishReason, index: $index, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, finishReason, index, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => __$$ChatCompletionResponseChoiceImplCopyWithImpl<
          _$ChatCompletionResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseChoice
    extends ChatCompletionResponseChoice {
  const factory _ChatCompletionResponseChoice(
          {@JsonKey(name: 'finish_reason')
          required final ChatCompletionFinishReason finishReason,
          required final int index,
          required final ChatCompletionMessage message}) =
      _$ChatCompletionResponseChoiceImpl;
  const _ChatCompletionResponseChoice._() : super._();

  factory _ChatCompletionResponseChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(name: 'finish_reason')
  ChatCompletionFinishReason get finishReason;
  @override

  /// The index of the choice in the list of choices.
  int get index;
  @override

  /// A chat completion message generated by the model.
  ChatCompletionMessage get message;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionStreamResponse _$CreateChatCompletionStreamResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionStreamResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionStreamResponse {
  /// A unique identifier for the chat completion. Each chunk has the same ID.
  String get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionStreamResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  int get created => throw _privateConstructorUsedError;

  /// The model to generate the completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion.chunk`.
  CreateChatCompletionStreamResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionStreamResponseCopyWith<
          CreateChatCompletionStreamResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory $CreateChatCompletionStreamResponseCopyWith(
          CreateChatCompletionStreamResponse value,
          $Res Function(CreateChatCompletionStreamResponse) then) =
      _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
          CreateChatCompletionStreamResponse>;
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionStreamResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionStreamResponseObject object});
}

/// @nodoc
class _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionStreamResponse>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  _$CreateChatCompletionStreamResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionStreamResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionStreamResponseImplCopyWith<$Res>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionStreamResponseImplCopyWith(
          _$CreateChatCompletionStreamResponseImpl value,
          $Res Function(_$CreateChatCompletionStreamResponseImpl) then) =
      __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<ChatCompletionStreamResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateChatCompletionStreamResponseObject object});
}

/// @nodoc
class __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        _$CreateChatCompletionStreamResponseImpl>
    implements _$$CreateChatCompletionStreamResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionStreamResponseImplCopyWithImpl(
      _$CreateChatCompletionStreamResponseImpl _value,
      $Res Function(_$CreateChatCompletionStreamResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
  }) {
    return _then(_$CreateChatCompletionStreamResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionStreamResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionStreamResponseImpl
    extends _CreateChatCompletionStreamResponse {
  const _$CreateChatCompletionStreamResponseImpl(
      {required this.id,
      required final List<ChatCompletionStreamResponseChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionStreamResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionStreamResponseImplFromJson(json);

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @override
  final String id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionStreamResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionStreamResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @override
  final int created;

  /// The model to generate the completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion.chunk`.
  @override
  final CreateChatCompletionStreamResponseObject object;

  @override
  String toString() {
    return 'CreateChatCompletionStreamResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionStreamResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => __$$CreateChatCompletionStreamResponseImplCopyWithImpl<
          _$CreateChatCompletionStreamResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionStreamResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionStreamResponse
    extends CreateChatCompletionStreamResponse {
  const factory _CreateChatCompletionStreamResponse(
          {required final String id,
          required final List<ChatCompletionStreamResponseChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final CreateChatCompletionStreamResponseObject object}) =
      _$CreateChatCompletionStreamResponseImpl;
  const _CreateChatCompletionStreamResponse._() : super._();

  factory _CreateChatCompletionStreamResponse.fromJson(
          Map<String, dynamic> json) =
      _$CreateChatCompletionStreamResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  String get id;
  @override

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionStreamResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  int get created;
  @override

  /// The model to generate the completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion.chunk`.
  CreateChatCompletionStreamResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseChoice _$ChatCompletionStreamResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoice {
  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta =>
      throw _privateConstructorUsedError;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  int get index => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseChoiceCopyWith<
          ChatCompletionStreamResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceCopyWith(
          ChatCompletionStreamResponseChoice value,
          $Res Function(ChatCompletionStreamResponseChoice) then) =
      _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
          ChatCompletionStreamResponseChoice>;
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      int index});

  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseChoice>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? finishReason = freezed,
    Object? index = null,
  }) {
    return _then(_value.copyWith(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta {
    return $ChatCompletionStreamResponseDeltaCopyWith<$Res>(_value.delta,
        (value) {
      return _then(_value.copyWith(delta: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseChoiceImplCopyWith(
          _$ChatCompletionStreamResponseChoiceImpl value,
          $Res Function(_$ChatCompletionStreamResponseChoiceImpl) then) =
      __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      int index});

  @override
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseChoiceImpl>
    implements _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl(
      _$ChatCompletionStreamResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionStreamResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? finishReason = freezed,
    Object? index = null,
  }) {
    return _then(_$ChatCompletionStreamResponseChoiceImpl(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseChoiceImpl
    extends _ChatCompletionStreamResponseChoice {
  const _$ChatCompletionStreamResponseChoiceImpl(
      {required this.delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index})
      : super._();

  factory _$ChatCompletionStreamResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseChoiceImplFromJson(json);

  /// A chat completion delta generated by streamed model responses.
  @override
  final ChatCompletionStreamResponseDelta delta;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  final int index;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoice(delta: $delta, finishReason: $finishReason, index: $index)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseChoiceImpl &&
            (identical(other.delta, delta) || other.delta == delta) &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, delta, finishReason, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<
          _$ChatCompletionStreamResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseChoice
    extends ChatCompletionStreamResponseChoice {
  const factory _ChatCompletionStreamResponseChoice(
      {required final ChatCompletionStreamResponseDelta delta,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required final ChatCompletionFinishReason? finishReason,
      required final int index}) = _$ChatCompletionStreamResponseChoiceImpl;
  const _ChatCompletionStreamResponseChoice._() : super._();

  factory _ChatCompletionStreamResponseChoice.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseChoiceImpl.fromJson;

  @override

  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta;
  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of choices.
  int get index;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseDelta _$ChatCompletionStreamResponseDeltaFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseDelta.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseDelta {
  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content => throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls =>
      throw _privateConstructorUsedError;

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseDeltaCopyWith<ChatCompletionStreamResponseDelta>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory $ChatCompletionStreamResponseDeltaCopyWith(
          ChatCompletionStreamResponseDelta value,
          $Res Function(ChatCompletionStreamResponseDelta) then) =
      _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
          ChatCompletionStreamResponseDelta>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseDelta>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  _$ChatCompletionStreamResponseDeltaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseDeltaImplCopyWith(
          _$ChatCompletionStreamResponseDeltaImpl value,
          $Res Function(_$ChatCompletionStreamResponseDeltaImpl) then) =
      __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseDeltaImpl>
    implements _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl(
      _$ChatCompletionStreamResponseDeltaImpl _value,
      $Res Function(_$ChatCompletionStreamResponseDeltaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseDeltaImpl(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseDeltaImpl
    extends _ChatCompletionStreamResponseDelta {
  const _$ChatCompletionStreamResponseDeltaImpl(
      {@JsonKey(includeIfNull: false) this.content,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.role})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionStreamResponseDeltaImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseDeltaImplFromJson(json);

  /// The contents of the chunk message.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? functionCall;

  /// No Description
  final List<ChatCompletionStreamMessageToolCallChunk>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionMessageRole? role;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDelta(content: $content, functionCall: $functionCall, toolCalls: $toolCalls, role: $role)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseDeltaImpl &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.role, role) || other.role == role));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, content, functionCall,
      const DeepCollectionEquality().hash(_toolCalls), role);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<
          _$ChatCompletionStreamResponseDeltaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseDeltaImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseDelta
    extends ChatCompletionStreamResponseDelta {
  const factory _ChatCompletionStreamResponseDelta(
          {@JsonKey(includeIfNull: false) final String? content,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? functionCall,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionMessageRole? role}) =
      _$ChatCompletionStreamResponseDeltaImpl;
  const _ChatCompletionStreamResponseDelta._() : super._();

  factory _ChatCompletionStreamResponseDelta.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseDeltaImpl.fromJson;

  @override

  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall;
  @override

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls;
  @override

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageFunctionCall
    _$ChatCompletionStreamMessageFunctionCallFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageFunctionCall {
  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageFunctionCallCopyWith<
          ChatCompletionStreamMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionStreamMessageFunctionCallCopyWith(
          ChatCompletionStreamMessageFunctionCall value,
          $Res Function(ChatCompletionStreamMessageFunctionCall) then) =
      _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionStreamMessageFunctionCall>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageFunctionCall>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionStreamMessageFunctionCallCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageFunctionCallImplCopyWith(
          _$ChatCompletionStreamMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) then) =
      __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageFunctionCallImpl>
    implements _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionStreamMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageFunctionCallImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageFunctionCallImpl
    extends _ChatCompletionStreamMessageFunctionCall {
  const _$ChatCompletionStreamMessageFunctionCallImpl(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.arguments})
      : super._();

  factory _$ChatCompletionStreamMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  @JsonKey(includeIfNull: false)
  final String? arguments;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<
              _$ChatCompletionStreamMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageFunctionCall
    extends ChatCompletionStreamMessageFunctionCall {
  const factory _ChatCompletionStreamMessageFunctionCall(
          {@JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? arguments}) =
      _$ChatCompletionStreamMessageFunctionCallImpl;
  const _ChatCompletionStreamMessageFunctionCall._() : super._();

  factory _ChatCompletionStreamMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageToolCallChunk
    _$ChatCompletionStreamMessageToolCallChunkFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageToolCallChunk.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageToolCallChunk {
  /// No Description
  int get index => throw _privateConstructorUsedError;

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageToolCallChunkCopyWith<
          ChatCompletionStreamMessageToolCallChunk>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory $ChatCompletionStreamMessageToolCallChunkCopyWith(
          ChatCompletionStreamMessageToolCallChunk value,
          $Res Function(ChatCompletionStreamMessageToolCallChunk) then) =
      _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
          ChatCompletionStreamMessageToolCallChunk>;
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageToolCallChunk>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.function!, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith(
          _$ChatCompletionStreamMessageToolCallChunkImpl value,
          $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) then) =
      __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageToolCallChunkImpl>
    implements _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl(
      _$ChatCompletionStreamMessageToolCallChunkImpl _value,
      $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageToolCallChunkImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageToolCallChunkImpl
    extends _ChatCompletionStreamMessageToolCallChunk {
  const _$ChatCompletionStreamMessageToolCallChunkImpl(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageToolCallChunkImplFromJson(json);

  /// No Description
  @override
  final int index;

  /// The ID of the tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionStreamMessageToolCallChunkType? type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? function;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageToolCallChunk(index: $index, id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageToolCallChunkImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<
              _$ChatCompletionStreamMessageToolCallChunkImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageToolCallChunkImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageToolCallChunk
    extends ChatCompletionStreamMessageToolCallChunk {
  const factory _ChatCompletionStreamMessageToolCallChunk(
          {required final int index,
          @JsonKey(includeIfNull: false) final String? id,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionStreamMessageToolCallChunkType? type,
          @JsonKey(includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? function}) =
      _$ChatCompletionStreamMessageToolCallChunkImpl;
  const _ChatCompletionStreamMessageToolCallChunk._() : super._();

  factory _ChatCompletionStreamMessageToolCallChunk.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson;

  @override

  /// No Description
  int get index;
  @override

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionUsage _$CompletionUsageFromJson(Map<String, dynamic> json) {
  return _CompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$CompletionUsage {
  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens => throw _privateConstructorUsedError;

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionUsageCopyWith<CompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionUsageCopyWith<$Res> {
  factory $CompletionUsageCopyWith(
          CompletionUsage value, $Res Function(CompletionUsage) then) =
      _$CompletionUsageCopyWithImpl<$Res, CompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$CompletionUsageCopyWithImpl<$Res, $Val extends CompletionUsage>
    implements $CompletionUsageCopyWith<$Res> {
  _$CompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionUsageImplCopyWith<$Res>
    implements $CompletionUsageCopyWith<$Res> {
  factory _$$CompletionUsageImplCopyWith(_$CompletionUsageImpl value,
          $Res Function(_$CompletionUsageImpl) then) =
      __$$CompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$CompletionUsageImplCopyWithImpl<$Res>
    extends _$CompletionUsageCopyWithImpl<$Res, _$CompletionUsageImpl>
    implements _$$CompletionUsageImplCopyWith<$Res> {
  __$$CompletionUsageImplCopyWithImpl(
      _$CompletionUsageImpl _value, $Res Function(_$CompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$CompletionUsageImpl(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionUsageImpl extends _CompletionUsage {
  const _$CompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$CompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionUsageImplFromJson(json);

  /// Number of tokens in the generated completion.
  @override
  @JsonKey(name: 'completion_tokens')
  final int? completionTokens;

  /// Number of tokens in the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used in the request (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'CompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      __$$CompletionUsageImplCopyWithImpl<_$CompletionUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _CompletionUsage extends CompletionUsage {
  const factory _CompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int? completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$CompletionUsageImpl;
  const _CompletionUsage._() : super._();

  factory _CompletionUsage.fromJson(Map<String, dynamic> json) =
      _$CompletionUsageImpl.fromJson;

  @override

  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens;
  @override

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateEmbeddingRequest _$CreateEmbeddingRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingRequest {
  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model => throw _privateConstructorUsedError;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`) and cannot be an empty string. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input => throw _privateConstructorUsedError;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat =>
      throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingRequestCopyWith<CreateEmbeddingRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingRequestCopyWith<$Res> {
  factory $CreateEmbeddingRequestCopyWith(CreateEmbeddingRequest value,
          $Res Function(CreateEmbeddingRequest) then) =
      _$CreateEmbeddingRequestCopyWithImpl<$Res, CreateEmbeddingRequest>;
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) String? user});

  $EmbeddingModelCopyWith<$Res> get model;
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateEmbeddingRequestCopyWithImpl<$Res,
        $Val extends CreateEmbeddingRequest>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  _$CreateEmbeddingRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingModelCopyWith<$Res> get model {
    return $EmbeddingModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingInputCopyWith<$Res> get input {
    return $EmbeddingInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingRequestImplCopyWith<$Res>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  factory _$$CreateEmbeddingRequestImplCopyWith(
          _$CreateEmbeddingRequestImpl value,
          $Res Function(_$CreateEmbeddingRequestImpl) then) =
      __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $EmbeddingModelCopyWith<$Res> get model;
  @override
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingRequestCopyWithImpl<$Res,
        _$CreateEmbeddingRequestImpl>
    implements _$$CreateEmbeddingRequestImplCopyWith<$Res> {
  __$$CreateEmbeddingRequestImplCopyWithImpl(
      _$CreateEmbeddingRequestImpl _value,
      $Res Function(_$CreateEmbeddingRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? user = freezed,
  }) {
    return _then(_$CreateEmbeddingRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingRequestImpl extends _CreateEmbeddingRequest {
  const _$CreateEmbeddingRequestImpl(
      {@_EmbeddingModelConverter() required this.model,
      @_EmbeddingInputConverter() required this.input,
      @JsonKey(name: 'encoding_format')
      this.encodingFormat = EmbeddingEncodingFormat.float,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateEmbeddingRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @override
  @_EmbeddingModelConverter()
  final EmbeddingModel model;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`) and cannot be an empty string. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @_EmbeddingInputConverter()
  final EmbeddingInput input;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @override
  @JsonKey(name: 'encoding_format')
  final EmbeddingEncodingFormat encodingFormat;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateEmbeddingRequest(model: $model, input: $input, encodingFormat: $encodingFormat, user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.encodingFormat, encodingFormat) ||
                other.encodingFormat == encodingFormat) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, model, input, encodingFormat, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => __$$CreateEmbeddingRequestImplCopyWithImpl<
          _$CreateEmbeddingRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingRequest extends CreateEmbeddingRequest {
  const factory _CreateEmbeddingRequest(
          {@_EmbeddingModelConverter() required final EmbeddingModel model,
          @_EmbeddingInputConverter() required final EmbeddingInput input,
          @JsonKey(name: 'encoding_format')
          final EmbeddingEncodingFormat encodingFormat,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateEmbeddingRequestImpl;
  const _CreateEmbeddingRequest._() : super._();

  factory _CreateEmbeddingRequest.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model;
  @override

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`) and cannot be an empty string. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input;
  @override

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingModel _$EmbeddingModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionEmbeddingModelEnum.fromJson(json);
    case 'string':
      return _UnionEmbeddingModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) enumeration,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? enumeration,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingModelEnum value) enumeration,
    required TResult Function(_UnionEmbeddingModelString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingModelEnum value)? enumeration,
    TResult? Function(_UnionEmbeddingModelString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingModelEnum value)? enumeration,
    TResult Function(_UnionEmbeddingModelString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingModelCopyWith<$Res> {
  factory $EmbeddingModelCopyWith(
          EmbeddingModel value, $Res Function(EmbeddingModel) then) =
      _$EmbeddingModelCopyWithImpl<$Res, EmbeddingModel>;
}

/// @nodoc
class _$EmbeddingModelCopyWithImpl<$Res, $Val extends EmbeddingModel>
    implements $EmbeddingModelCopyWith<$Res> {
  _$EmbeddingModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionEmbeddingModelEnumImplCopyWith<$Res> {
  factory _$$UnionEmbeddingModelEnumImplCopyWith(
          _$UnionEmbeddingModelEnumImpl value,
          $Res Function(_$UnionEmbeddingModelEnumImpl) then) =
      __$$UnionEmbeddingModelEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({EmbeddingModels value});
}

/// @nodoc
class __$$UnionEmbeddingModelEnumImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$UnionEmbeddingModelEnumImpl>
    implements _$$UnionEmbeddingModelEnumImplCopyWith<$Res> {
  __$$UnionEmbeddingModelEnumImplCopyWithImpl(
      _$UnionEmbeddingModelEnumImpl _value,
      $Res Function(_$UnionEmbeddingModelEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingModelEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as EmbeddingModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingModelEnumImpl extends _UnionEmbeddingModelEnum {
  const _$UnionEmbeddingModelEnumImpl(this.value, {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionEmbeddingModelEnumImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionEmbeddingModelEnumImplFromJson(json);

  @override
  final EmbeddingModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingModelEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingModelEnumImplCopyWith<_$UnionEmbeddingModelEnumImpl>
      get copyWith => __$$UnionEmbeddingModelEnumImplCopyWithImpl<
          _$UnionEmbeddingModelEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingModelEnum value) enumeration,
    required TResult Function(_UnionEmbeddingModelString value) string,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingModelEnum value)? enumeration,
    TResult? Function(_UnionEmbeddingModelString value)? string,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingModelEnum value)? enumeration,
    TResult Function(_UnionEmbeddingModelString value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingModelEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingModelEnum extends EmbeddingModel {
  const factory _UnionEmbeddingModelEnum(final EmbeddingModels value) =
      _$UnionEmbeddingModelEnumImpl;
  const _UnionEmbeddingModelEnum._() : super._();

  factory _UnionEmbeddingModelEnum.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingModelEnumImpl.fromJson;

  @override
  EmbeddingModels get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingModelEnumImplCopyWith<_$UnionEmbeddingModelEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionEmbeddingModelStringImplCopyWith<$Res> {
  factory _$$UnionEmbeddingModelStringImplCopyWith(
          _$UnionEmbeddingModelStringImpl value,
          $Res Function(_$UnionEmbeddingModelStringImpl) then) =
      __$$UnionEmbeddingModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionEmbeddingModelStringImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$UnionEmbeddingModelStringImpl>
    implements _$$UnionEmbeddingModelStringImplCopyWith<$Res> {
  __$$UnionEmbeddingModelStringImplCopyWithImpl(
      _$UnionEmbeddingModelStringImpl _value,
      $Res Function(_$UnionEmbeddingModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingModelStringImpl extends _UnionEmbeddingModelString {
  const _$UnionEmbeddingModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionEmbeddingModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionEmbeddingModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingModelStringImplCopyWith<_$UnionEmbeddingModelStringImpl>
      get copyWith => __$$UnionEmbeddingModelStringImplCopyWithImpl<
          _$UnionEmbeddingModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingModelEnum value) enumeration,
    required TResult Function(_UnionEmbeddingModelString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingModelEnum value)? enumeration,
    TResult? Function(_UnionEmbeddingModelString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingModelEnum value)? enumeration,
    TResult Function(_UnionEmbeddingModelString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingModelStringImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingModelString extends EmbeddingModel {
  const factory _UnionEmbeddingModelString(final String value) =
      _$UnionEmbeddingModelStringImpl;
  const _UnionEmbeddingModelString._() : super._();

  factory _UnionEmbeddingModelString.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingModelStringImplCopyWith<_$UnionEmbeddingModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingInput _$EmbeddingInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'array':
      return _UnionEmbeddingInputArray.fromJson(json);
    case 'arrayInteger':
      return _UnionEmbeddingInputArrayInteger.fromJson(json);
    case 'arrayString':
      return _UnionEmbeddingInputArrayString.fromJson(json);
    case 'string':
      return _UnionEmbeddingInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingInputArray value) array,
    required TResult Function(_UnionEmbeddingInputArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionEmbeddingInputArrayString value)
        arrayString,
    required TResult Function(_UnionEmbeddingInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingInputArray value)? array,
    TResult? Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult? Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult? Function(_UnionEmbeddingInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingInputArray value)? array,
    TResult Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult Function(_UnionEmbeddingInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputCopyWith(
          EmbeddingInput value, $Res Function(EmbeddingInput) then) =
      _$EmbeddingInputCopyWithImpl<$Res, EmbeddingInput>;
}

/// @nodoc
class _$EmbeddingInputCopyWithImpl<$Res, $Val extends EmbeddingInput>
    implements $EmbeddingInputCopyWith<$Res> {
  _$EmbeddingInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionEmbeddingInputArrayImplCopyWith<$Res> {
  factory _$$UnionEmbeddingInputArrayImplCopyWith(
          _$UnionEmbeddingInputArrayImpl value,
          $Res Function(_$UnionEmbeddingInputArrayImpl) then) =
      __$$UnionEmbeddingInputArrayImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$UnionEmbeddingInputArrayImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$UnionEmbeddingInputArrayImpl>
    implements _$$UnionEmbeddingInputArrayImplCopyWith<$Res> {
  __$$UnionEmbeddingInputArrayImplCopyWithImpl(
      _$UnionEmbeddingInputArrayImpl _value,
      $Res Function(_$UnionEmbeddingInputArrayImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingInputArrayImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingInputArrayImpl extends _UnionEmbeddingInputArray {
  const _$UnionEmbeddingInputArrayImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'array',
        super._();

  factory _$UnionEmbeddingInputArrayImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionEmbeddingInputArrayImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.array(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingInputArrayImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingInputArrayImplCopyWith<_$UnionEmbeddingInputArrayImpl>
      get copyWith => __$$UnionEmbeddingInputArrayImplCopyWithImpl<
          _$UnionEmbeddingInputArrayImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return array(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return array?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingInputArray value) array,
    required TResult Function(_UnionEmbeddingInputArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionEmbeddingInputArrayString value)
        arrayString,
    required TResult Function(_UnionEmbeddingInputString value) string,
  }) {
    return array(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingInputArray value)? array,
    TResult? Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult? Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult? Function(_UnionEmbeddingInputString value)? string,
  }) {
    return array?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingInputArray value)? array,
    TResult Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult Function(_UnionEmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingInputArrayImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingInputArray extends EmbeddingInput {
  const factory _UnionEmbeddingInputArray(final List<List<int>> value) =
      _$UnionEmbeddingInputArrayImpl;
  const _UnionEmbeddingInputArray._() : super._();

  factory _UnionEmbeddingInputArray.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingInputArrayImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingInputArrayImplCopyWith<_$UnionEmbeddingInputArrayImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionEmbeddingInputArrayIntegerImplCopyWith<$Res> {
  factory _$$UnionEmbeddingInputArrayIntegerImplCopyWith(
          _$UnionEmbeddingInputArrayIntegerImpl value,
          $Res Function(_$UnionEmbeddingInputArrayIntegerImpl) then) =
      __$$UnionEmbeddingInputArrayIntegerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$UnionEmbeddingInputArrayIntegerImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res,
        _$UnionEmbeddingInputArrayIntegerImpl>
    implements _$$UnionEmbeddingInputArrayIntegerImplCopyWith<$Res> {
  __$$UnionEmbeddingInputArrayIntegerImplCopyWithImpl(
      _$UnionEmbeddingInputArrayIntegerImpl _value,
      $Res Function(_$UnionEmbeddingInputArrayIntegerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingInputArrayIntegerImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingInputArrayIntegerImpl
    extends _UnionEmbeddingInputArrayInteger {
  const _$UnionEmbeddingInputArrayIntegerImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayInteger',
        super._();

  factory _$UnionEmbeddingInputArrayIntegerImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionEmbeddingInputArrayIntegerImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.arrayInteger(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingInputArrayIntegerImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingInputArrayIntegerImplCopyWith<
          _$UnionEmbeddingInputArrayIntegerImpl>
      get copyWith => __$$UnionEmbeddingInputArrayIntegerImplCopyWithImpl<
          _$UnionEmbeddingInputArrayIntegerImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return arrayInteger(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return arrayInteger?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayInteger != null) {
      return arrayInteger(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingInputArray value) array,
    required TResult Function(_UnionEmbeddingInputArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionEmbeddingInputArrayString value)
        arrayString,
    required TResult Function(_UnionEmbeddingInputString value) string,
  }) {
    return arrayInteger(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingInputArray value)? array,
    TResult? Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult? Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult? Function(_UnionEmbeddingInputString value)? string,
  }) {
    return arrayInteger?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingInputArray value)? array,
    TResult Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult Function(_UnionEmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (arrayInteger != null) {
      return arrayInteger(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingInputArrayIntegerImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingInputArrayInteger extends EmbeddingInput {
  const factory _UnionEmbeddingInputArrayInteger(final List<int> value) =
      _$UnionEmbeddingInputArrayIntegerImpl;
  const _UnionEmbeddingInputArrayInteger._() : super._();

  factory _UnionEmbeddingInputArrayInteger.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingInputArrayIntegerImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingInputArrayIntegerImplCopyWith<
          _$UnionEmbeddingInputArrayIntegerImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionEmbeddingInputArrayStringImplCopyWith<$Res> {
  factory _$$UnionEmbeddingInputArrayStringImplCopyWith(
          _$UnionEmbeddingInputArrayStringImpl value,
          $Res Function(_$UnionEmbeddingInputArrayStringImpl) then) =
      __$$UnionEmbeddingInputArrayStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$UnionEmbeddingInputArrayStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res,
        _$UnionEmbeddingInputArrayStringImpl>
    implements _$$UnionEmbeddingInputArrayStringImplCopyWith<$Res> {
  __$$UnionEmbeddingInputArrayStringImplCopyWithImpl(
      _$UnionEmbeddingInputArrayStringImpl _value,
      $Res Function(_$UnionEmbeddingInputArrayStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingInputArrayStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingInputArrayStringImpl
    extends _UnionEmbeddingInputArrayString {
  const _$UnionEmbeddingInputArrayStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayString',
        super._();

  factory _$UnionEmbeddingInputArrayStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionEmbeddingInputArrayStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.arrayString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingInputArrayStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingInputArrayStringImplCopyWith<
          _$UnionEmbeddingInputArrayStringImpl>
      get copyWith => __$$UnionEmbeddingInputArrayStringImplCopyWithImpl<
          _$UnionEmbeddingInputArrayStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return arrayString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return arrayString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingInputArray value) array,
    required TResult Function(_UnionEmbeddingInputArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionEmbeddingInputArrayString value)
        arrayString,
    required TResult Function(_UnionEmbeddingInputString value) string,
  }) {
    return arrayString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingInputArray value)? array,
    TResult? Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult? Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult? Function(_UnionEmbeddingInputString value)? string,
  }) {
    return arrayString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingInputArray value)? array,
    TResult Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult Function(_UnionEmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingInputArrayStringImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingInputArrayString extends EmbeddingInput {
  const factory _UnionEmbeddingInputArrayString(final List<String> value) =
      _$UnionEmbeddingInputArrayStringImpl;
  const _UnionEmbeddingInputArrayString._() : super._();

  factory _UnionEmbeddingInputArrayString.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingInputArrayStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingInputArrayStringImplCopyWith<
          _$UnionEmbeddingInputArrayStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionEmbeddingInputStringImplCopyWith<$Res> {
  factory _$$UnionEmbeddingInputStringImplCopyWith(
          _$UnionEmbeddingInputStringImpl value,
          $Res Function(_$UnionEmbeddingInputStringImpl) then) =
      __$$UnionEmbeddingInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionEmbeddingInputStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$UnionEmbeddingInputStringImpl>
    implements _$$UnionEmbeddingInputStringImplCopyWith<$Res> {
  __$$UnionEmbeddingInputStringImplCopyWithImpl(
      _$UnionEmbeddingInputStringImpl _value,
      $Res Function(_$UnionEmbeddingInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingInputStringImpl extends _UnionEmbeddingInputString {
  const _$UnionEmbeddingInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionEmbeddingInputStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionEmbeddingInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingInputStringImplCopyWith<_$UnionEmbeddingInputStringImpl>
      get copyWith => __$$UnionEmbeddingInputStringImplCopyWithImpl<
          _$UnionEmbeddingInputStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) array,
    required TResult Function(List<int> value) arrayInteger,
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? array,
    TResult? Function(List<int> value)? arrayInteger,
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? array,
    TResult Function(List<int> value)? arrayInteger,
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingInputArray value) array,
    required TResult Function(_UnionEmbeddingInputArrayInteger value)
        arrayInteger,
    required TResult Function(_UnionEmbeddingInputArrayString value)
        arrayString,
    required TResult Function(_UnionEmbeddingInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingInputArray value)? array,
    TResult? Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult? Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult? Function(_UnionEmbeddingInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingInputArray value)? array,
    TResult Function(_UnionEmbeddingInputArrayInteger value)? arrayInteger,
    TResult Function(_UnionEmbeddingInputArrayString value)? arrayString,
    TResult Function(_UnionEmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingInputStringImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingInputString extends EmbeddingInput {
  const factory _UnionEmbeddingInputString(final String value) =
      _$UnionEmbeddingInputStringImpl;
  const _UnionEmbeddingInputString._() : super._();

  factory _UnionEmbeddingInputString.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingInputStringImplCopyWith<_$UnionEmbeddingInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateEmbeddingResponse _$CreateEmbeddingResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingResponse {
  /// The list of embeddings generated by the model.
  List<Embedding> get data => throw _privateConstructorUsedError;

  /// The name of the model used to generate the embedding.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  String get object => throw _privateConstructorUsedError;

  /// The usage information for the request.
  EmbeddingUsage get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingResponseCopyWith<CreateEmbeddingResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingResponseCopyWith<$Res> {
  factory $CreateEmbeddingResponseCopyWith(CreateEmbeddingResponse value,
          $Res Function(CreateEmbeddingResponse) then) =
      _$CreateEmbeddingResponseCopyWithImpl<$Res, CreateEmbeddingResponse>;
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      String object,
      EmbeddingUsage usage});

  $EmbeddingUsageCopyWith<$Res> get usage;
}

/// @nodoc
class _$CreateEmbeddingResponseCopyWithImpl<$Res,
        $Val extends CreateEmbeddingResponse>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  _$CreateEmbeddingResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: null == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingUsageCopyWith<$Res> get usage {
    return $EmbeddingUsageCopyWith<$Res>(_value.usage, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingResponseImplCopyWith<$Res>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  factory _$$CreateEmbeddingResponseImplCopyWith(
          _$CreateEmbeddingResponseImpl value,
          $Res Function(_$CreateEmbeddingResponseImpl) then) =
      __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      String object,
      EmbeddingUsage usage});

  @override
  $EmbeddingUsageCopyWith<$Res> get usage;
}

/// @nodoc
class __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingResponseCopyWithImpl<$Res,
        _$CreateEmbeddingResponseImpl>
    implements _$$CreateEmbeddingResponseImplCopyWith<$Res> {
  __$$CreateEmbeddingResponseImplCopyWithImpl(
      _$CreateEmbeddingResponseImpl _value,
      $Res Function(_$CreateEmbeddingResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = null,
  }) {
    return _then(_$CreateEmbeddingResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: null == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingResponseImpl extends _CreateEmbeddingResponse {
  const _$CreateEmbeddingResponseImpl(
      {required final List<Embedding> data,
      required this.model,
      required this.object,
      required this.usage})
      : _data = data,
        super._();

  factory _$CreateEmbeddingResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingResponseImplFromJson(json);

  /// The list of embeddings generated by the model.
  final List<Embedding> _data;

  /// The list of embeddings generated by the model.
  @override
  List<Embedding> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The name of the model used to generate the embedding.
  @override
  final String model;

  /// The object type, which is always "list".
  @override
  final String object;

  /// The usage information for the request.
  @override
  final EmbeddingUsage usage;

  @override
  String toString() {
    return 'CreateEmbeddingResponse(data: $data, model: $model, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_data), model, object, usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => __$$CreateEmbeddingResponseImplCopyWithImpl<
          _$CreateEmbeddingResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingResponse extends CreateEmbeddingResponse {
  const factory _CreateEmbeddingResponse(
      {required final List<Embedding> data,
      required final String model,
      required final String object,
      required final EmbeddingUsage usage}) = _$CreateEmbeddingResponseImpl;
  const _CreateEmbeddingResponse._() : super._();

  factory _CreateEmbeddingResponse.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingResponseImpl.fromJson;

  @override

  /// The list of embeddings generated by the model.
  List<Embedding> get data;
  @override

  /// The name of the model used to generate the embedding.
  String get model;
  @override

  /// The object type, which is always "list".
  String get object;
  @override

  /// The usage information for the request.
  EmbeddingUsage get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Embedding _$EmbeddingFromJson(Map<String, dynamic> json) {
  return _Embedding.fromJson(json);
}

/// @nodoc
mixin _$Embedding {
  /// The index of the embedding in the list of embeddings.
  int get index => throw _privateConstructorUsedError;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding => throw _privateConstructorUsedError;

  /// The object type, which is always "embedding".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingCopyWith<Embedding> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingCopyWith<$Res> {
  factory $EmbeddingCopyWith(Embedding value, $Res Function(Embedding) then) =
      _$EmbeddingCopyWithImpl<$Res, Embedding>;
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      String object});

  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class _$EmbeddingCopyWithImpl<$Res, $Val extends Embedding>
    implements $EmbeddingCopyWith<$Res> {
  _$EmbeddingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingVectorCopyWith<$Res> get embedding {
    return $EmbeddingVectorCopyWith<$Res>(_value.embedding, (value) {
      return _then(_value.copyWith(embedding: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EmbeddingImplCopyWith<$Res>
    implements $EmbeddingCopyWith<$Res> {
  factory _$$EmbeddingImplCopyWith(
          _$EmbeddingImpl value, $Res Function(_$EmbeddingImpl) then) =
      __$$EmbeddingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      String object});

  @override
  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class __$$EmbeddingImplCopyWithImpl<$Res>
    extends _$EmbeddingCopyWithImpl<$Res, _$EmbeddingImpl>
    implements _$$EmbeddingImplCopyWith<$Res> {
  __$$EmbeddingImplCopyWithImpl(
      _$EmbeddingImpl _value, $Res Function(_$EmbeddingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_$EmbeddingImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingImpl extends _Embedding {
  const _$EmbeddingImpl(
      {required this.index,
      @_EmbeddingVectorConverter() required this.embedding,
      required this.object})
      : super._();

  factory _$EmbeddingImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingImplFromJson(json);

  /// The index of the embedding in the list of embeddings.
  @override
  final int index;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @override
  @_EmbeddingVectorConverter()
  final EmbeddingVector embedding;

  /// The object type, which is always "embedding".
  @override
  final String object;

  @override
  String toString() {
    return 'Embedding(index: $index, embedding: $embedding, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.embedding, embedding) ||
                other.embedding == embedding) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, embedding, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      __$$EmbeddingImplCopyWithImpl<_$EmbeddingImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingImplToJson(
      this,
    );
  }
}

abstract class _Embedding extends Embedding {
  const factory _Embedding(
      {required final int index,
      @_EmbeddingVectorConverter() required final EmbeddingVector embedding,
      required final String object}) = _$EmbeddingImpl;
  const _Embedding._() : super._();

  factory _Embedding.fromJson(Map<String, dynamic> json) =
      _$EmbeddingImpl.fromJson;

  @override

  /// The index of the embedding in the list of embeddings.
  int get index;
  @override

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding;
  @override

  /// The object type, which is always "embedding".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EmbeddingVector _$EmbeddingVectorFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'arrayNumber':
      return _UnionEmbeddingVectorArrayNumber.fromJson(json);
    case 'string':
      return _UnionEmbeddingVectorString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingVector',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingVector {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) arrayNumber,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? arrayNumber,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? arrayNumber,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingVectorArrayNumber value)
        arrayNumber,
    required TResult Function(_UnionEmbeddingVectorString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingVectorArrayNumber value)? arrayNumber,
    TResult? Function(_UnionEmbeddingVectorString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingVectorArrayNumber value)? arrayNumber,
    TResult Function(_UnionEmbeddingVectorString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingVectorCopyWith<$Res> {
  factory $EmbeddingVectorCopyWith(
          EmbeddingVector value, $Res Function(EmbeddingVector) then) =
      _$EmbeddingVectorCopyWithImpl<$Res, EmbeddingVector>;
}

/// @nodoc
class _$EmbeddingVectorCopyWithImpl<$Res, $Val extends EmbeddingVector>
    implements $EmbeddingVectorCopyWith<$Res> {
  _$EmbeddingVectorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionEmbeddingVectorArrayNumberImplCopyWith<$Res> {
  factory _$$UnionEmbeddingVectorArrayNumberImplCopyWith(
          _$UnionEmbeddingVectorArrayNumberImpl value,
          $Res Function(_$UnionEmbeddingVectorArrayNumberImpl) then) =
      __$$UnionEmbeddingVectorArrayNumberImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<double> value});
}

/// @nodoc
class __$$UnionEmbeddingVectorArrayNumberImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res,
        _$UnionEmbeddingVectorArrayNumberImpl>
    implements _$$UnionEmbeddingVectorArrayNumberImplCopyWith<$Res> {
  __$$UnionEmbeddingVectorArrayNumberImplCopyWithImpl(
      _$UnionEmbeddingVectorArrayNumberImpl _value,
      $Res Function(_$UnionEmbeddingVectorArrayNumberImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingVectorArrayNumberImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<double>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingVectorArrayNumberImpl
    extends _UnionEmbeddingVectorArrayNumber {
  const _$UnionEmbeddingVectorArrayNumberImpl(final List<double> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayNumber',
        super._();

  factory _$UnionEmbeddingVectorArrayNumberImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionEmbeddingVectorArrayNumberImplFromJson(json);

  final List<double> _value;
  @override
  List<double> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.arrayNumber(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingVectorArrayNumberImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingVectorArrayNumberImplCopyWith<
          _$UnionEmbeddingVectorArrayNumberImpl>
      get copyWith => __$$UnionEmbeddingVectorArrayNumberImplCopyWithImpl<
          _$UnionEmbeddingVectorArrayNumberImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) arrayNumber,
    required TResult Function(String value) string,
  }) {
    return arrayNumber(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? arrayNumber,
    TResult? Function(String value)? string,
  }) {
    return arrayNumber?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? arrayNumber,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayNumber != null) {
      return arrayNumber(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingVectorArrayNumber value)
        arrayNumber,
    required TResult Function(_UnionEmbeddingVectorString value) string,
  }) {
    return arrayNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingVectorArrayNumber value)? arrayNumber,
    TResult? Function(_UnionEmbeddingVectorString value)? string,
  }) {
    return arrayNumber?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingVectorArrayNumber value)? arrayNumber,
    TResult Function(_UnionEmbeddingVectorString value)? string,
    required TResult orElse(),
  }) {
    if (arrayNumber != null) {
      return arrayNumber(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingVectorArrayNumberImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingVectorArrayNumber extends EmbeddingVector {
  const factory _UnionEmbeddingVectorArrayNumber(final List<double> value) =
      _$UnionEmbeddingVectorArrayNumberImpl;
  const _UnionEmbeddingVectorArrayNumber._() : super._();

  factory _UnionEmbeddingVectorArrayNumber.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingVectorArrayNumberImpl.fromJson;

  @override
  List<double> get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingVectorArrayNumberImplCopyWith<
          _$UnionEmbeddingVectorArrayNumberImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionEmbeddingVectorStringImplCopyWith<$Res> {
  factory _$$UnionEmbeddingVectorStringImplCopyWith(
          _$UnionEmbeddingVectorStringImpl value,
          $Res Function(_$UnionEmbeddingVectorStringImpl) then) =
      __$$UnionEmbeddingVectorStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionEmbeddingVectorStringImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res,
        _$UnionEmbeddingVectorStringImpl>
    implements _$$UnionEmbeddingVectorStringImplCopyWith<$Res> {
  __$$UnionEmbeddingVectorStringImplCopyWithImpl(
      _$UnionEmbeddingVectorStringImpl _value,
      $Res Function(_$UnionEmbeddingVectorStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionEmbeddingVectorStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionEmbeddingVectorStringImpl extends _UnionEmbeddingVectorString {
  const _$UnionEmbeddingVectorStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionEmbeddingVectorStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionEmbeddingVectorStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionEmbeddingVectorStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionEmbeddingVectorStringImplCopyWith<_$UnionEmbeddingVectorStringImpl>
      get copyWith => __$$UnionEmbeddingVectorStringImplCopyWithImpl<
          _$UnionEmbeddingVectorStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) arrayNumber,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? arrayNumber,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? arrayNumber,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionEmbeddingVectorArrayNumber value)
        arrayNumber,
    required TResult Function(_UnionEmbeddingVectorString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionEmbeddingVectorArrayNumber value)? arrayNumber,
    TResult? Function(_UnionEmbeddingVectorString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionEmbeddingVectorArrayNumber value)? arrayNumber,
    TResult Function(_UnionEmbeddingVectorString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionEmbeddingVectorStringImplToJson(
      this,
    );
  }
}

abstract class _UnionEmbeddingVectorString extends EmbeddingVector {
  const factory _UnionEmbeddingVectorString(final String value) =
      _$UnionEmbeddingVectorStringImpl;
  const _UnionEmbeddingVectorString._() : super._();

  factory _UnionEmbeddingVectorString.fromJson(Map<String, dynamic> json) =
      _$UnionEmbeddingVectorStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionEmbeddingVectorStringImplCopyWith<_$UnionEmbeddingVectorStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingUsage _$EmbeddingUsageFromJson(Map<String, dynamic> json) {
  return _EmbeddingUsage.fromJson(json);
}

/// @nodoc
mixin _$EmbeddingUsage {
  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingUsageCopyWith<EmbeddingUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingUsageCopyWith<$Res> {
  factory $EmbeddingUsageCopyWith(
          EmbeddingUsage value, $Res Function(EmbeddingUsage) then) =
      _$EmbeddingUsageCopyWithImpl<$Res, EmbeddingUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$EmbeddingUsageCopyWithImpl<$Res, $Val extends EmbeddingUsage>
    implements $EmbeddingUsageCopyWith<$Res> {
  _$EmbeddingUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EmbeddingUsageImplCopyWith<$Res>
    implements $EmbeddingUsageCopyWith<$Res> {
  factory _$$EmbeddingUsageImplCopyWith(_$EmbeddingUsageImpl value,
          $Res Function(_$EmbeddingUsageImpl) then) =
      __$$EmbeddingUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$EmbeddingUsageImplCopyWithImpl<$Res>
    extends _$EmbeddingUsageCopyWithImpl<$Res, _$EmbeddingUsageImpl>
    implements _$$EmbeddingUsageImplCopyWith<$Res> {
  __$$EmbeddingUsageImplCopyWithImpl(
      _$EmbeddingUsageImpl _value, $Res Function(_$EmbeddingUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$EmbeddingUsageImpl(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingUsageImpl extends _EmbeddingUsage {
  const _$EmbeddingUsageImpl(
      {@JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$EmbeddingUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingUsageImplFromJson(json);

  /// The number of tokens used by the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// The total number of tokens used by the request.
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'EmbeddingUsage(promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingUsageImpl &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      __$$EmbeddingUsageImplCopyWithImpl<_$EmbeddingUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingUsageImplToJson(
      this,
    );
  }
}

abstract class _EmbeddingUsage extends EmbeddingUsage {
  const factory _EmbeddingUsage(
          {@JsonKey(name: 'prompt_tokens') required final int promptTokens,
          @JsonKey(name: 'total_tokens') required final int totalTokens}) =
      _$EmbeddingUsageImpl;
  const _EmbeddingUsage._() : super._();

  factory _EmbeddingUsage.fromJson(Map<String, dynamic> json) =
      _$EmbeddingUsageImpl.fromJson;

  @override

  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateFineTuningJobRequest _$CreateFineTuningJobRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateFineTuningJobRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateFineTuningJobRequest {
  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters =>
      throw _privateConstructorUsedError;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateFineTuningJobRequestCopyWith<CreateFineTuningJobRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateFineTuningJobRequestCopyWith<$Res> {
  factory $CreateFineTuningJobRequestCopyWith(CreateFineTuningJobRequest value,
          $Res Function(CreateFineTuningJobRequest) then) =
      _$CreateFineTuningJobRequestCopyWithImpl<$Res,
          CreateFineTuningJobRequest>;
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile});

  $FineTuningModelCopyWith<$Res> get model;
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        $Val extends CreateFineTuningJobRequest>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  _$CreateFineTuningJobRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningModelCopyWith<$Res> get model {
    return $FineTuningModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters {
    if (_value.hyperparameters == null) {
      return null;
    }

    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters!,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateFineTuningJobRequestImplCopyWith<$Res>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  factory _$$CreateFineTuningJobRequestImplCopyWith(
          _$CreateFineTuningJobRequestImpl value,
          $Res Function(_$CreateFineTuningJobRequestImpl) then) =
      __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile});

  @override
  $FineTuningModelCopyWith<$Res> get model;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>
    extends _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        _$CreateFineTuningJobRequestImpl>
    implements _$$CreateFineTuningJobRequestImplCopyWith<$Res> {
  __$$CreateFineTuningJobRequestImplCopyWithImpl(
      _$CreateFineTuningJobRequestImpl _value,
      $Res Function(_$CreateFineTuningJobRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
  }) {
    return _then(_$CreateFineTuningJobRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateFineTuningJobRequestImpl extends _CreateFineTuningJobRequest {
  const _$CreateFineTuningJobRequestImpl(
      {@_FineTuningModelConverter() required this.model,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(includeIfNull: false) this.hyperparameters,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      this.validationFile})
      : super._();

  factory _$CreateFineTuningJobRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateFineTuningJobRequestImplFromJson(json);

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @override
  @_FineTuningModelConverter()
  final FineTuningModel model;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(includeIfNull: false)
  final FineTuningJobHyperparameters? hyperparameters;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'validation_file', includeIfNull: false)
  final String? validationFile;

  @override
  String toString() {
    return 'CreateFineTuningJobRequest(model: $model, trainingFile: $trainingFile, hyperparameters: $hyperparameters, suffix: $suffix, validationFile: $validationFile)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateFineTuningJobRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, model, trainingFile,
      hyperparameters, suffix, validationFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => __$$CreateFineTuningJobRequestImplCopyWithImpl<
          _$CreateFineTuningJobRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateFineTuningJobRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateFineTuningJobRequest extends CreateFineTuningJobRequest {
  const factory _CreateFineTuningJobRequest(
      {@_FineTuningModelConverter() required final FineTuningModel model,
      @JsonKey(name: 'training_file') required final String trainingFile,
      @JsonKey(includeIfNull: false)
      final FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) final String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      final String? validationFile}) = _$CreateFineTuningJobRequestImpl;
  const _CreateFineTuningJobRequest._() : super._();

  factory _CreateFineTuningJobRequest.fromJson(Map<String, dynamic> json) =
      _$CreateFineTuningJobRequestImpl.fromJson;

  @override

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model;
  @override

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters;
  @override

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile;
  @override
  @JsonKey(ignore: true)
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningModel _$FineTuningModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionFineTuningModelEnum.fromJson(json);
    case 'string':
      return _UnionFineTuningModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) enumeration,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? enumeration,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionFineTuningModelEnum value) enumeration,
    required TResult Function(_UnionFineTuningModelString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionFineTuningModelEnum value)? enumeration,
    TResult? Function(_UnionFineTuningModelString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionFineTuningModelEnum value)? enumeration,
    TResult Function(_UnionFineTuningModelString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningModelCopyWith<$Res> {
  factory $FineTuningModelCopyWith(
          FineTuningModel value, $Res Function(FineTuningModel) then) =
      _$FineTuningModelCopyWithImpl<$Res, FineTuningModel>;
}

/// @nodoc
class _$FineTuningModelCopyWithImpl<$Res, $Val extends FineTuningModel>
    implements $FineTuningModelCopyWith<$Res> {
  _$FineTuningModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionFineTuningModelEnumImplCopyWith<$Res> {
  factory _$$UnionFineTuningModelEnumImplCopyWith(
          _$UnionFineTuningModelEnumImpl value,
          $Res Function(_$UnionFineTuningModelEnumImpl) then) =
      __$$UnionFineTuningModelEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningModels value});
}

/// @nodoc
class __$$UnionFineTuningModelEnumImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res, _$UnionFineTuningModelEnumImpl>
    implements _$$UnionFineTuningModelEnumImplCopyWith<$Res> {
  __$$UnionFineTuningModelEnumImplCopyWithImpl(
      _$UnionFineTuningModelEnumImpl _value,
      $Res Function(_$UnionFineTuningModelEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionFineTuningModelEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionFineTuningModelEnumImpl extends _UnionFineTuningModelEnum {
  const _$UnionFineTuningModelEnumImpl(this.value, {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionFineTuningModelEnumImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionFineTuningModelEnumImplFromJson(json);

  @override
  final FineTuningModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionFineTuningModelEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionFineTuningModelEnumImplCopyWith<_$UnionFineTuningModelEnumImpl>
      get copyWith => __$$UnionFineTuningModelEnumImplCopyWithImpl<
          _$UnionFineTuningModelEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionFineTuningModelEnum value) enumeration,
    required TResult Function(_UnionFineTuningModelString value) string,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionFineTuningModelEnum value)? enumeration,
    TResult? Function(_UnionFineTuningModelString value)? string,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionFineTuningModelEnum value)? enumeration,
    TResult Function(_UnionFineTuningModelString value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionFineTuningModelEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionFineTuningModelEnum extends FineTuningModel {
  const factory _UnionFineTuningModelEnum(final FineTuningModels value) =
      _$UnionFineTuningModelEnumImpl;
  const _UnionFineTuningModelEnum._() : super._();

  factory _UnionFineTuningModelEnum.fromJson(Map<String, dynamic> json) =
      _$UnionFineTuningModelEnumImpl.fromJson;

  @override
  FineTuningModels get value;
  @JsonKey(ignore: true)
  _$$UnionFineTuningModelEnumImplCopyWith<_$UnionFineTuningModelEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionFineTuningModelStringImplCopyWith<$Res> {
  factory _$$UnionFineTuningModelStringImplCopyWith(
          _$UnionFineTuningModelStringImpl value,
          $Res Function(_$UnionFineTuningModelStringImpl) then) =
      __$$UnionFineTuningModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionFineTuningModelStringImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res,
        _$UnionFineTuningModelStringImpl>
    implements _$$UnionFineTuningModelStringImplCopyWith<$Res> {
  __$$UnionFineTuningModelStringImplCopyWithImpl(
      _$UnionFineTuningModelStringImpl _value,
      $Res Function(_$UnionFineTuningModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionFineTuningModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionFineTuningModelStringImpl extends _UnionFineTuningModelString {
  const _$UnionFineTuningModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionFineTuningModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionFineTuningModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionFineTuningModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionFineTuningModelStringImplCopyWith<_$UnionFineTuningModelStringImpl>
      get copyWith => __$$UnionFineTuningModelStringImplCopyWithImpl<
          _$UnionFineTuningModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionFineTuningModelEnum value) enumeration,
    required TResult Function(_UnionFineTuningModelString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionFineTuningModelEnum value)? enumeration,
    TResult? Function(_UnionFineTuningModelString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionFineTuningModelEnum value)? enumeration,
    TResult Function(_UnionFineTuningModelString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionFineTuningModelStringImplToJson(
      this,
    );
  }
}

abstract class _UnionFineTuningModelString extends FineTuningModel {
  const factory _UnionFineTuningModelString(final String value) =
      _$UnionFineTuningModelStringImpl;
  const _UnionFineTuningModelString._() : super._();

  factory _UnionFineTuningModelString.fromJson(Map<String, dynamic> json) =
      _$UnionFineTuningModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionFineTuningModelStringImplCopyWith<_$UnionFineTuningModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJob _$FineTuningJobFromJson(Map<String, dynamic> json) {
  return _FineTuningJob.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJob {
  /// The object identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error => throw _privateConstructorUsedError;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters =>
      throw _privateConstructorUsedError;

  /// The base model that is being fine-tuned.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job".
  String get object => throw _privateConstructorUsedError;

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId => throw _privateConstructorUsedError;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles => throw _privateConstructorUsedError;

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status => throw _privateConstructorUsedError;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens => throw _privateConstructorUsedError;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobCopyWith<FineTuningJob> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobCopyWith<$Res> {
  factory $FineTuningJobCopyWith(
          FineTuningJob value, $Res Function(FineTuningJob) then) =
      _$FineTuningJobCopyWithImpl<$Res, FineTuningJob>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      String object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile});

  $FineTuningJobErrorCopyWith<$Res>? get error;
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class _$FineTuningJobCopyWithImpl<$Res, $Val extends FineTuningJob>
    implements $FineTuningJobCopyWith<$Res> {
  _$FineTuningJobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value.resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobErrorCopyWith<$Res>? get error {
    if (_value.error == null) {
      return null;
    }

    return $FineTuningJobErrorCopyWith<$Res>(_value.error!, (value) {
      return _then(_value.copyWith(error: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters {
    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobImplCopyWith<$Res>
    implements $FineTuningJobCopyWith<$Res> {
  factory _$$FineTuningJobImplCopyWith(
          _$FineTuningJobImpl value, $Res Function(_$FineTuningJobImpl) then) =
      __$$FineTuningJobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      String object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile});

  @override
  $FineTuningJobErrorCopyWith<$Res>? get error;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class __$$FineTuningJobImplCopyWithImpl<$Res>
    extends _$FineTuningJobCopyWithImpl<$Res, _$FineTuningJobImpl>
    implements _$$FineTuningJobImplCopyWith<$Res> {
  __$$FineTuningJobImplCopyWithImpl(
      _$FineTuningJobImpl _value, $Res Function(_$FineTuningJobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
  }) {
    return _then(_$FineTuningJobImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value._resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobImpl extends _FineTuningJob {
  const _$FineTuningJobImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.error,
      @JsonKey(name: 'fine_tuned_model') required this.fineTunedModel,
      @JsonKey(name: 'finished_at') required this.finishedAt,
      required this.hyperparameters,
      required this.model,
      required this.object,
      @JsonKey(name: 'organization_id') required this.organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required this.status,
      @JsonKey(name: 'trained_tokens') required this.trainedTokens,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(name: 'validation_file') required this.validationFile})
      : _resultFiles = resultFiles,
        super._();

  factory _$FineTuningJobImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobImplFromJson(json);

  /// The object identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  @override
  final FineTuningJobError? error;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'fine_tuned_model')
  final String? fineTunedModel;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'finished_at')
  final int? finishedAt;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  final FineTuningJobHyperparameters hyperparameters;

  /// The base model that is being fine-tuned.
  @override
  final String model;

  /// The object type, which is always "fine_tuning.job".
  @override
  final String object;

  /// The organization that owns the fine-tuning job.
  @override
  @JsonKey(name: 'organization_id')
  final String organizationId;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  final List<String> _resultFiles;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'result_files')
  List<String> get resultFiles {
    if (_resultFiles is EqualUnmodifiableListView) return _resultFiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_resultFiles);
  }

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  @override
  final FineTuningJobStatus status;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'trained_tokens')
  final int? trainedTokens;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'validation_file')
  final String? validationFile;

  @override
  String toString() {
    return 'FineTuningJob(id: $id, createdAt: $createdAt, error: $error, fineTunedModel: $fineTunedModel, finishedAt: $finishedAt, hyperparameters: $hyperparameters, model: $model, object: $object, organizationId: $organizationId, resultFiles: $resultFiles, status: $status, trainedTokens: $trainedTokens, trainingFile: $trainingFile, validationFile: $validationFile)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.fineTunedModel, fineTunedModel) ||
                other.fineTunedModel == fineTunedModel) &&
            (identical(other.finishedAt, finishedAt) ||
                other.finishedAt == finishedAt) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.organizationId, organizationId) ||
                other.organizationId == organizationId) &&
            const DeepCollectionEquality()
                .equals(other._resultFiles, _resultFiles) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.trainedTokens, trainedTokens) ||
                other.trainedTokens == trainedTokens) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      createdAt,
      error,
      fineTunedModel,
      finishedAt,
      hyperparameters,
      model,
      object,
      organizationId,
      const DeepCollectionEquality().hash(_resultFiles),
      status,
      trainedTokens,
      trainingFile,
      validationFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      __$$FineTuningJobImplCopyWithImpl<_$FineTuningJobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJob extends FineTuningJob {
  const factory _FineTuningJob(
      {required final String id,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') required final String? fineTunedModel,
      @JsonKey(name: 'finished_at') required final int? finishedAt,
      required final FineTuningJobHyperparameters hyperparameters,
      required final String model,
      required final String object,
      @JsonKey(name: 'organization_id') required final String organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required final FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') required final int? trainedTokens,
      @JsonKey(name: 'training_file') required final String trainingFile,
      @JsonKey(name: 'validation_file')
      required final String? validationFile}) = _$FineTuningJobImpl;
  const _FineTuningJob._() : super._();

  factory _FineTuningJob.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobImpl.fromJson;

  @override

  /// The object identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error;
  @override

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters;
  @override

  /// The base model that is being fine-tuned.
  String get model;
  @override

  /// The object type, which is always "fine_tuning.job".
  String get object;
  @override

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId;
  @override

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles;
  @override

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status;
  @override

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens;
  @override

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobError _$FineTuningJobErrorFromJson(Map<String, dynamic> json) {
  return _FineTuningJobError.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobError {
  /// A machine-readable error code.
  String get code => throw _privateConstructorUsedError;

  /// A human-readable error message.
  String get message => throw _privateConstructorUsedError;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobErrorCopyWith<FineTuningJobError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobErrorCopyWith<$Res> {
  factory $FineTuningJobErrorCopyWith(
          FineTuningJobError value, $Res Function(FineTuningJobError) then) =
      _$FineTuningJobErrorCopyWithImpl<$Res, FineTuningJobError>;
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class _$FineTuningJobErrorCopyWithImpl<$Res, $Val extends FineTuningJobError>
    implements $FineTuningJobErrorCopyWith<$Res> {
  _$FineTuningJobErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobErrorImplCopyWith<$Res>
    implements $FineTuningJobErrorCopyWith<$Res> {
  factory _$$FineTuningJobErrorImplCopyWith(_$FineTuningJobErrorImpl value,
          $Res Function(_$FineTuningJobErrorImpl) then) =
      __$$FineTuningJobErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class __$$FineTuningJobErrorImplCopyWithImpl<$Res>
    extends _$FineTuningJobErrorCopyWithImpl<$Res, _$FineTuningJobErrorImpl>
    implements _$$FineTuningJobErrorImplCopyWith<$Res> {
  __$$FineTuningJobErrorImplCopyWithImpl(_$FineTuningJobErrorImpl _value,
      $Res Function(_$FineTuningJobErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_$FineTuningJobErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobErrorImpl extends _FineTuningJobError {
  const _$FineTuningJobErrorImpl(
      {required this.code, required this.message, required this.param})
      : super._();

  factory _$FineTuningJobErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobErrorImplFromJson(json);

  /// A machine-readable error code.
  @override
  final String code;

  /// A human-readable error message.
  @override
  final String message;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  @override
  final String? param;

  @override
  String toString() {
    return 'FineTuningJobError(code: $code, message: $message, param: $param)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      __$$FineTuningJobErrorImplCopyWithImpl<_$FineTuningJobErrorImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobErrorImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobError extends FineTuningJobError {
  const factory _FineTuningJobError(
      {required final String code,
      required final String message,
      required final String? param}) = _$FineTuningJobErrorImpl;
  const _FineTuningJobError._() : super._();

  factory _FineTuningJobError.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobErrorImpl.fromJson;

  @override

  /// A machine-readable error code.
  String get code;
  @override

  /// A human-readable error message.
  String get message;
  @override

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobHyperparameters _$FineTuningJobHyperparametersFromJson(
    Map<String, dynamic> json) {
  return _FineTuningJobHyperparameters.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobHyperparameters {
  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobHyperparametersCopyWith<FineTuningJobHyperparameters>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobHyperparametersCopyWith<$Res> {
  factory $FineTuningJobHyperparametersCopyWith(
          FineTuningJobHyperparameters value,
          $Res Function(FineTuningJobHyperparameters) then) =
      _$FineTuningJobHyperparametersCopyWithImpl<$Res,
          FineTuningJobHyperparameters>;
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        $Val extends FineTuningJobHyperparameters>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  _$FineTuningJobHyperparametersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_value.copyWith(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsCopyWith<$Res> get nEpochs {
    return $FineTuningNEpochsCopyWith<$Res>(_value.nEpochs, (value) {
      return _then(_value.copyWith(nEpochs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobHyperparametersImplCopyWith<$Res>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  factory _$$FineTuningJobHyperparametersImplCopyWith(
          _$FineTuningJobHyperparametersImpl value,
          $Res Function(_$FineTuningJobHyperparametersImpl) then) =
      __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  @override
  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>
    extends _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        _$FineTuningJobHyperparametersImpl>
    implements _$$FineTuningJobHyperparametersImplCopyWith<$Res> {
  __$$FineTuningJobHyperparametersImplCopyWithImpl(
      _$FineTuningJobHyperparametersImpl _value,
      $Res Function(_$FineTuningJobHyperparametersImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_$FineTuningJobHyperparametersImpl(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobHyperparametersImpl extends _FineTuningJobHyperparameters {
  const _$FineTuningJobHyperparametersImpl(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      required this.nEpochs})
      : super._();

  factory _$FineTuningJobHyperparametersImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningJobHyperparametersImplFromJson(json);

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @override
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  final FineTuningNEpochs nEpochs;

  @override
  String toString() {
    return 'FineTuningJobHyperparameters(nEpochs: $nEpochs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobHyperparametersImpl &&
            (identical(other.nEpochs, nEpochs) || other.nEpochs == nEpochs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, nEpochs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => __$$FineTuningJobHyperparametersImplCopyWithImpl<
          _$FineTuningJobHyperparametersImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobHyperparametersImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobHyperparameters
    extends FineTuningJobHyperparameters {
  const factory _FineTuningJobHyperparameters(
          {@_FineTuningNEpochsConverter()
          @JsonKey(name: 'n_epochs')
          required final FineTuningNEpochs nEpochs}) =
      _$FineTuningJobHyperparametersImpl;
  const _FineTuningJobHyperparameters._() : super._();

  factory _FineTuningJobHyperparameters.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobHyperparametersImpl.fromJson;

  @override

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningNEpochs _$FineTuningNEpochsFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionFineTuningNEpochsEnum.fromJson(json);
    case 'integer':
      return _UnionFineTuningNEpochsInteger.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningNEpochs',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningNEpochs {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) enumeration,
    required TResult Function(int value) integer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? enumeration,
    TResult? Function(int value)? integer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? enumeration,
    TResult Function(int value)? integer,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionFineTuningNEpochsEnum value) enumeration,
    required TResult Function(_UnionFineTuningNEpochsInteger value) integer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionFineTuningNEpochsEnum value)? enumeration,
    TResult? Function(_UnionFineTuningNEpochsInteger value)? integer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionFineTuningNEpochsEnum value)? enumeration,
    TResult Function(_UnionFineTuningNEpochsInteger value)? integer,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningNEpochsCopyWith<$Res> {
  factory $FineTuningNEpochsCopyWith(
          FineTuningNEpochs value, $Res Function(FineTuningNEpochs) then) =
      _$FineTuningNEpochsCopyWithImpl<$Res, FineTuningNEpochs>;
}

/// @nodoc
class _$FineTuningNEpochsCopyWithImpl<$Res, $Val extends FineTuningNEpochs>
    implements $FineTuningNEpochsCopyWith<$Res> {
  _$FineTuningNEpochsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionFineTuningNEpochsEnumImplCopyWith<$Res> {
  factory _$$UnionFineTuningNEpochsEnumImplCopyWith(
          _$UnionFineTuningNEpochsEnumImpl value,
          $Res Function(_$UnionFineTuningNEpochsEnumImpl) then) =
      __$$UnionFineTuningNEpochsEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningNEpochsOptions value});
}

/// @nodoc
class __$$UnionFineTuningNEpochsEnumImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res,
        _$UnionFineTuningNEpochsEnumImpl>
    implements _$$UnionFineTuningNEpochsEnumImplCopyWith<$Res> {
  __$$UnionFineTuningNEpochsEnumImplCopyWithImpl(
      _$UnionFineTuningNEpochsEnumImpl _value,
      $Res Function(_$UnionFineTuningNEpochsEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionFineTuningNEpochsEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochsOptions,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionFineTuningNEpochsEnumImpl extends _UnionFineTuningNEpochsEnum {
  const _$UnionFineTuningNEpochsEnumImpl(this.value, {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionFineTuningNEpochsEnumImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionFineTuningNEpochsEnumImplFromJson(json);

  @override
  final FineTuningNEpochsOptions value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionFineTuningNEpochsEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionFineTuningNEpochsEnumImplCopyWith<_$UnionFineTuningNEpochsEnumImpl>
      get copyWith => __$$UnionFineTuningNEpochsEnumImplCopyWithImpl<
          _$UnionFineTuningNEpochsEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) enumeration,
    required TResult Function(int value) integer,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? enumeration,
    TResult? Function(int value)? integer,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? enumeration,
    TResult Function(int value)? integer,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionFineTuningNEpochsEnum value) enumeration,
    required TResult Function(_UnionFineTuningNEpochsInteger value) integer,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionFineTuningNEpochsEnum value)? enumeration,
    TResult? Function(_UnionFineTuningNEpochsInteger value)? integer,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionFineTuningNEpochsEnum value)? enumeration,
    TResult Function(_UnionFineTuningNEpochsInteger value)? integer,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionFineTuningNEpochsEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionFineTuningNEpochsEnum extends FineTuningNEpochs {
  const factory _UnionFineTuningNEpochsEnum(
      final FineTuningNEpochsOptions value) = _$UnionFineTuningNEpochsEnumImpl;
  const _UnionFineTuningNEpochsEnum._() : super._();

  factory _UnionFineTuningNEpochsEnum.fromJson(Map<String, dynamic> json) =
      _$UnionFineTuningNEpochsEnumImpl.fromJson;

  @override
  FineTuningNEpochsOptions get value;
  @JsonKey(ignore: true)
  _$$UnionFineTuningNEpochsEnumImplCopyWith<_$UnionFineTuningNEpochsEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionFineTuningNEpochsIntegerImplCopyWith<$Res> {
  factory _$$UnionFineTuningNEpochsIntegerImplCopyWith(
          _$UnionFineTuningNEpochsIntegerImpl value,
          $Res Function(_$UnionFineTuningNEpochsIntegerImpl) then) =
      __$$UnionFineTuningNEpochsIntegerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$UnionFineTuningNEpochsIntegerImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res,
        _$UnionFineTuningNEpochsIntegerImpl>
    implements _$$UnionFineTuningNEpochsIntegerImplCopyWith<$Res> {
  __$$UnionFineTuningNEpochsIntegerImplCopyWithImpl(
      _$UnionFineTuningNEpochsIntegerImpl _value,
      $Res Function(_$UnionFineTuningNEpochsIntegerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionFineTuningNEpochsIntegerImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionFineTuningNEpochsIntegerImpl
    extends _UnionFineTuningNEpochsInteger {
  const _$UnionFineTuningNEpochsIntegerImpl(this.value, {final String? $type})
      : $type = $type ?? 'integer',
        super._();

  factory _$UnionFineTuningNEpochsIntegerImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionFineTuningNEpochsIntegerImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.integer(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionFineTuningNEpochsIntegerImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionFineTuningNEpochsIntegerImplCopyWith<
          _$UnionFineTuningNEpochsIntegerImpl>
      get copyWith => __$$UnionFineTuningNEpochsIntegerImplCopyWithImpl<
          _$UnionFineTuningNEpochsIntegerImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) enumeration,
    required TResult Function(int value) integer,
  }) {
    return integer(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? enumeration,
    TResult? Function(int value)? integer,
  }) {
    return integer?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? enumeration,
    TResult Function(int value)? integer,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionFineTuningNEpochsEnum value) enumeration,
    required TResult Function(_UnionFineTuningNEpochsInteger value) integer,
  }) {
    return integer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionFineTuningNEpochsEnum value)? enumeration,
    TResult? Function(_UnionFineTuningNEpochsInteger value)? integer,
  }) {
    return integer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionFineTuningNEpochsEnum value)? enumeration,
    TResult Function(_UnionFineTuningNEpochsInteger value)? integer,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionFineTuningNEpochsIntegerImplToJson(
      this,
    );
  }
}

abstract class _UnionFineTuningNEpochsInteger extends FineTuningNEpochs {
  const factory _UnionFineTuningNEpochsInteger(final int value) =
      _$UnionFineTuningNEpochsIntegerImpl;
  const _UnionFineTuningNEpochsInteger._() : super._();

  factory _UnionFineTuningNEpochsInteger.fromJson(Map<String, dynamic> json) =
      _$UnionFineTuningNEpochsIntegerImpl.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$UnionFineTuningNEpochsIntegerImplCopyWith<
          _$UnionFineTuningNEpochsIntegerImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListPaginatedFineTuningJobsResponse
    _$ListPaginatedFineTuningJobsResponseFromJson(Map<String, dynamic> json) {
  return _ListPaginatedFineTuningJobsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListPaginatedFineTuningJobsResponse {
  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data => throw _privateConstructorUsedError;

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListPaginatedFineTuningJobsResponseCopyWith<
          ListPaginatedFineTuningJobsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory $ListPaginatedFineTuningJobsResponseCopyWith(
          ListPaginatedFineTuningJobsResponse value,
          $Res Function(ListPaginatedFineTuningJobsResponse) then) =
      _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
          ListPaginatedFineTuningJobsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      String object});
}

/// @nodoc
class _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        $Val extends ListPaginatedFineTuningJobsResponse>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  _$ListPaginatedFineTuningJobsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory _$$ListPaginatedFineTuningJobsResponseImplCopyWith(
          _$ListPaginatedFineTuningJobsResponseImpl value,
          $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) then) =
      __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      String object});
}

/// @nodoc
class __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>
    extends _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        _$ListPaginatedFineTuningJobsResponseImpl>
    implements _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res> {
  __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl(
      _$ListPaginatedFineTuningJobsResponseImpl _value,
      $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_$ListPaginatedFineTuningJobsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListPaginatedFineTuningJobsResponseImpl
    extends _ListPaginatedFineTuningJobsResponse {
  const _$ListPaginatedFineTuningJobsResponseImpl(
      {required final List<FineTuningJob> data,
      @JsonKey(name: 'has_more') required this.hasMore,
      required this.object})
      : _data = data,
        super._();

  factory _$ListPaginatedFineTuningJobsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListPaginatedFineTuningJobsResponseImplFromJson(json);

  /// The list of fine-tuning jobs.
  final List<FineTuningJob> _data;

  /// The list of fine-tuning jobs.
  @override
  List<FineTuningJob> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// Whether there are more fine-tuning jobs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// The object type, which is always "list".
  @override
  final String object;

  @override
  String toString() {
    return 'ListPaginatedFineTuningJobsResponse(data: $data, hasMore: $hasMore, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListPaginatedFineTuningJobsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), hasMore, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<
          _$ListPaginatedFineTuningJobsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListPaginatedFineTuningJobsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListPaginatedFineTuningJobsResponse
    extends ListPaginatedFineTuningJobsResponse {
  const factory _ListPaginatedFineTuningJobsResponse(
          {required final List<FineTuningJob> data,
          @JsonKey(name: 'has_more') required final bool hasMore,
          required final String object}) =
      _$ListPaginatedFineTuningJobsResponseImpl;
  const _ListPaginatedFineTuningJobsResponse._() : super._();

  factory _ListPaginatedFineTuningJobsResponse.fromJson(
          Map<String, dynamic> json) =
      _$ListPaginatedFineTuningJobsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data;
  @override

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override

  /// The object type, which is always "list".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListFineTuningJobEventsResponse _$ListFineTuningJobEventsResponseFromJson(
    Map<String, dynamic> json) {
  return _ListFineTuningJobEventsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListFineTuningJobEventsResponse {
  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListFineTuningJobEventsResponseCopyWith<ListFineTuningJobEventsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory $ListFineTuningJobEventsResponseCopyWith(
          ListFineTuningJobEventsResponse value,
          $Res Function(ListFineTuningJobEventsResponse) then) =
      _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
          ListFineTuningJobEventsResponse>;
  @useResult
  $Res call({List<FineTuningJobEvent> data, String object});
}

/// @nodoc
class _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        $Val extends ListFineTuningJobEventsResponse>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  _$ListFineTuningJobEventsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListFineTuningJobEventsResponseImplCopyWith<$Res>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory _$$ListFineTuningJobEventsResponseImplCopyWith(
          _$ListFineTuningJobEventsResponseImpl value,
          $Res Function(_$ListFineTuningJobEventsResponseImpl) then) =
      __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<FineTuningJobEvent> data, String object});
}

/// @nodoc
class __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>
    extends _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        _$ListFineTuningJobEventsResponseImpl>
    implements _$$ListFineTuningJobEventsResponseImplCopyWith<$Res> {
  __$$ListFineTuningJobEventsResponseImplCopyWithImpl(
      _$ListFineTuningJobEventsResponseImpl _value,
      $Res Function(_$ListFineTuningJobEventsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_$ListFineTuningJobEventsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListFineTuningJobEventsResponseImpl
    extends _ListFineTuningJobEventsResponse {
  const _$ListFineTuningJobEventsResponseImpl(
      {required final List<FineTuningJobEvent> data, required this.object})
      : _data = data,
        super._();

  factory _$ListFineTuningJobEventsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListFineTuningJobEventsResponseImplFromJson(json);

  /// The list of fine-tuning job events.
  final List<FineTuningJobEvent> _data;

  /// The list of fine-tuning job events.
  @override
  List<FineTuningJobEvent> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The object type, which is always "list".
  @override
  final String object;

  @override
  String toString() {
    return 'ListFineTuningJobEventsResponse(data: $data, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListFineTuningJobEventsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => __$$ListFineTuningJobEventsResponseImplCopyWithImpl<
          _$ListFineTuningJobEventsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListFineTuningJobEventsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListFineTuningJobEventsResponse
    extends ListFineTuningJobEventsResponse {
  const factory _ListFineTuningJobEventsResponse(
      {required final List<FineTuningJobEvent> data,
      required final String object}) = _$ListFineTuningJobEventsResponseImpl;
  const _ListFineTuningJobEventsResponse._() : super._();

  factory _ListFineTuningJobEventsResponse.fromJson(Map<String, dynamic> json) =
      _$ListFineTuningJobEventsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data;
  @override

  /// The object type, which is always "list".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJobEvent _$FineTuningJobEventFromJson(Map<String, dynamic> json) {
  return _FineTuningJobEvent.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobEvent {
  /// The event identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The log level of the event.
  FineTuningJobEventLevel get level => throw _privateConstructorUsedError;

  /// The message of the event.
  String get message => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job.event".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobEventCopyWith<FineTuningJobEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobEventCopyWith<$Res> {
  factory $FineTuningJobEventCopyWith(
          FineTuningJobEvent value, $Res Function(FineTuningJobEvent) then) =
      _$FineTuningJobEventCopyWithImpl<$Res, FineTuningJobEvent>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      String object});
}

/// @nodoc
class _$FineTuningJobEventCopyWithImpl<$Res, $Val extends FineTuningJobEvent>
    implements $FineTuningJobEventCopyWith<$Res> {
  _$FineTuningJobEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobEventImplCopyWith<$Res>
    implements $FineTuningJobEventCopyWith<$Res> {
  factory _$$FineTuningJobEventImplCopyWith(_$FineTuningJobEventImpl value,
          $Res Function(_$FineTuningJobEventImpl) then) =
      __$$FineTuningJobEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      String object});
}

/// @nodoc
class __$$FineTuningJobEventImplCopyWithImpl<$Res>
    extends _$FineTuningJobEventCopyWithImpl<$Res, _$FineTuningJobEventImpl>
    implements _$$FineTuningJobEventImplCopyWith<$Res> {
  __$$FineTuningJobEventImplCopyWithImpl(_$FineTuningJobEventImpl _value,
      $Res Function(_$FineTuningJobEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_$FineTuningJobEventImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobEventImpl extends _FineTuningJobEvent {
  const _$FineTuningJobEventImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.level,
      required this.message,
      required this.object})
      : super._();

  factory _$FineTuningJobEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobEventImplFromJson(json);

  /// The event identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the event was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The log level of the event.
  @override
  final FineTuningJobEventLevel level;

  /// The message of the event.
  @override
  final String message;

  /// The object type, which is always "fine_tuning.job.event".
  @override
  final String object;

  @override
  String toString() {
    return 'FineTuningJobEvent(id: $id, createdAt: $createdAt, level: $level, message: $message, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobEventImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, createdAt, level, message, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      __$$FineTuningJobEventImplCopyWithImpl<_$FineTuningJobEventImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobEventImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobEvent extends FineTuningJobEvent {
  const factory _FineTuningJobEvent(
      {required final String id,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final FineTuningJobEventLevel level,
      required final String message,
      required final String object}) = _$FineTuningJobEventImpl;
  const _FineTuningJobEvent._() : super._();

  factory _FineTuningJobEvent.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobEventImpl.fromJson;

  @override

  /// The event identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The log level of the event.
  FineTuningJobEventLevel get level;
  @override

  /// The message of the event.
  String get message;
  @override

  /// The object type, which is always "fine_tuning.job.event".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateImageRequest _$CreateImageRequestFromJson(Map<String, dynamic> json) {
  return _CreateImageRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateImageRequest {
  /// A text description of the desired image(s). The maximum length is 1000 characters.
  String get prompt => throw _privateConstructorUsedError;

  /// The number of images to generate. Must be between 1 and 10.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat => throw _privateConstructorUsedError;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateImageRequestCopyWith<CreateImageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateImageRequestCopyWith<$Res> {
  factory $CreateImageRequestCopyWith(
          CreateImageRequest value, $Res Function(CreateImageRequest) then) =
      _$CreateImageRequestCopyWithImpl<$Res, CreateImageRequest>;
  @useResult
  $Res call(
      {String prompt,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(includeIfNull: false) String? user});
}

/// @nodoc
class _$CreateImageRequestCopyWithImpl<$Res, $Val extends CreateImageRequest>
    implements $CreateImageRequestCopyWith<$Res> {
  _$CreateImageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? n = freezed,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateImageRequestImplCopyWith<$Res>
    implements $CreateImageRequestCopyWith<$Res> {
  factory _$$CreateImageRequestImplCopyWith(_$CreateImageRequestImpl value,
          $Res Function(_$CreateImageRequestImpl) then) =
      __$$CreateImageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String prompt,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(includeIfNull: false) String? user});
}

/// @nodoc
class __$$CreateImageRequestImplCopyWithImpl<$Res>
    extends _$CreateImageRequestCopyWithImpl<$Res, _$CreateImageRequestImpl>
    implements _$$CreateImageRequestImplCopyWith<$Res> {
  __$$CreateImageRequestImplCopyWithImpl(_$CreateImageRequestImpl _value,
      $Res Function(_$CreateImageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? n = freezed,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateImageRequestImpl(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestImpl extends _CreateImageRequest {
  const _$CreateImageRequestImpl(
      {required this.prompt,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.responseFormat = ImageResponseFormat.url,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.size = ImageSize.v1024x1024,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateImageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateImageRequestImplFromJson(json);

  /// A text description of the desired image(s). The maximum length is 1000 characters.
  @override
  final String prompt;

  /// The number of images to generate. Must be between 1 and 10.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @override
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageResponseFormat? responseFormat;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageSize? size;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateImageRequest(prompt: $prompt, n: $n, responseFormat: $responseFormat, size: $size, user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestImpl &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, prompt, n, responseFormat, size, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      __$$CreateImageRequestImplCopyWithImpl<_$CreateImageRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateImageRequest extends CreateImageRequest {
  const factory _CreateImageRequest(
          {required final String prompt,
          @JsonKey(includeIfNull: false) final int? n,
          @JsonKey(
              name: 'response_format',
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageResponseFormat? responseFormat,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageSize? size,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateImageRequestImpl;
  const _CreateImageRequest._() : super._();

  factory _CreateImageRequest.fromJson(Map<String, dynamic> json) =
      _$CreateImageRequestImpl.fromJson;

  @override

  /// A text description of the desired image(s). The maximum length is 1000 characters.
  String get prompt;
  @override

  /// The number of images to generate. Must be between 1 and 10.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat;
  @override

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ImagesResponse _$ImagesResponseFromJson(Map<String, dynamic> json) {
  return _ImagesResponse.fromJson(json);
}

/// @nodoc
mixin _$ImagesResponse {
  /// The Unix timestamp (in seconds) when the image was created.
  int get created => throw _privateConstructorUsedError;

  /// The list of images generated by the model.
  List<Image> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImagesResponseCopyWith<ImagesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImagesResponseCopyWith<$Res> {
  factory $ImagesResponseCopyWith(
          ImagesResponse value, $Res Function(ImagesResponse) then) =
      _$ImagesResponseCopyWithImpl<$Res, ImagesResponse>;
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class _$ImagesResponseCopyWithImpl<$Res, $Val extends ImagesResponse>
    implements $ImagesResponseCopyWith<$Res> {
  _$ImagesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImagesResponseImplCopyWith<$Res>
    implements $ImagesResponseCopyWith<$Res> {
  factory _$$ImagesResponseImplCopyWith(_$ImagesResponseImpl value,
          $Res Function(_$ImagesResponseImpl) then) =
      __$$ImagesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class __$$ImagesResponseImplCopyWithImpl<$Res>
    extends _$ImagesResponseCopyWithImpl<$Res, _$ImagesResponseImpl>
    implements _$$ImagesResponseImplCopyWith<$Res> {
  __$$ImagesResponseImplCopyWithImpl(
      _$ImagesResponseImpl _value, $Res Function(_$ImagesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_$ImagesResponseImpl(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImagesResponseImpl extends _ImagesResponse {
  const _$ImagesResponseImpl(
      {required this.created, required final List<Image> data})
      : _data = data,
        super._();

  factory _$ImagesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImagesResponseImplFromJson(json);

  /// The Unix timestamp (in seconds) when the image was created.
  @override
  final int created;

  /// The list of images generated by the model.
  final List<Image> _data;

  /// The list of images generated by the model.
  @override
  List<Image> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ImagesResponse(created: $created, data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImagesResponseImpl &&
            (identical(other.created, created) || other.created == created) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, created, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      __$$ImagesResponseImplCopyWithImpl<_$ImagesResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImagesResponseImplToJson(
      this,
    );
  }
}

abstract class _ImagesResponse extends ImagesResponse {
  const factory _ImagesResponse(
      {required final int created,
      required final List<Image> data}) = _$ImagesResponseImpl;
  const _ImagesResponse._() : super._();

  factory _ImagesResponse.fromJson(Map<String, dynamic> json) =
      _$ImagesResponseImpl.fromJson;

  @override

  /// The Unix timestamp (in seconds) when the image was created.
  int get created;
  @override

  /// The list of images generated by the model.
  List<Image> get data;
  @override
  @JsonKey(ignore: true)
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Image _$ImageFromJson(Map<String, dynamic> json) {
  return _Image.fromJson(json);
}

/// @nodoc
mixin _$Image {
  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json => throw _privateConstructorUsedError;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageCopyWith<Image> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageCopyWith<$Res> {
  factory $ImageCopyWith(Image value, $Res Function(Image) then) =
      _$ImageCopyWithImpl<$Res, Image>;
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url});
}

/// @nodoc
class _$ImageCopyWithImpl<$Res, $Val extends Image>
    implements $ImageCopyWith<$Res> {
  _$ImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageImplCopyWith<$Res> implements $ImageCopyWith<$Res> {
  factory _$$ImageImplCopyWith(
          _$ImageImpl value, $Res Function(_$ImageImpl) then) =
      __$$ImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url});
}

/// @nodoc
class __$$ImageImplCopyWithImpl<$Res>
    extends _$ImageCopyWithImpl<$Res, _$ImageImpl>
    implements _$$ImageImplCopyWith<$Res> {
  __$$ImageImplCopyWithImpl(
      _$ImageImpl _value, $Res Function(_$ImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
  }) {
    return _then(_$ImageImpl(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageImpl extends _Image {
  const _$ImageImpl(
      {@JsonKey(name: 'b64_json', includeIfNull: false) this.b64Json,
      @JsonKey(includeIfNull: false) this.url})
      : super._();

  factory _$ImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImageImplFromJson(json);

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @override
  @JsonKey(name: 'b64_json', includeIfNull: false)
  final String? b64Json;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @override
  @JsonKey(includeIfNull: false)
  final String? url;

  @override
  String toString() {
    return 'Image(b64Json: $b64Json, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageImpl &&
            (identical(other.b64Json, b64Json) || other.b64Json == b64Json) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, b64Json, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      __$$ImageImplCopyWithImpl<_$ImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageImplToJson(
      this,
    );
  }
}

abstract class _Image extends Image {
  const factory _Image(
      {@JsonKey(name: 'b64_json', includeIfNull: false) final String? b64Json,
      @JsonKey(includeIfNull: false) final String? url}) = _$ImageImpl;
  const _Image._() : super._();

  factory _Image.fromJson(Map<String, dynamic> json) = _$ImageImpl.fromJson;

  @override

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json;
  @override

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Model _$ModelFromJson(Map<String, dynamic> json) {
  return _Model.fromJson(json);
}

/// @nodoc
mixin _$Model {
  /// The model identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) when the model was created.
  int get created => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  String get object => throw _privateConstructorUsedError;

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModelCopyWith<Model> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) then) =
      _$ModelCopyWithImpl<$Res, Model>;
  @useResult
  $Res call(
      {String id,
      int created,
      String object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class _$ModelCopyWithImpl<$Res, $Val extends Model>
    implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModelImplCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$$ModelImplCopyWith(
          _$ModelImpl value, $Res Function(_$ModelImpl) then) =
      __$$ModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      int created,
      String object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class __$$ModelImplCopyWithImpl<$Res>
    extends _$ModelCopyWithImpl<$Res, _$ModelImpl>
    implements _$$ModelImplCopyWith<$Res> {
  __$$ModelImplCopyWithImpl(
      _$ModelImpl _value, $Res Function(_$ModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_$ModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModelImpl extends _Model {
  const _$ModelImpl(
      {required this.id,
      required this.created,
      required this.object,
      @JsonKey(name: 'owned_by') required this.ownedBy})
      : super._();

  factory _$ModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModelImplFromJson(json);

  /// The model identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) when the model was created.
  @override
  final int created;

  /// The object type, which is always "model".
  @override
  final String object;

  /// The organization that owns the model.
  @override
  @JsonKey(name: 'owned_by')
  final String ownedBy;

  @override
  String toString() {
    return 'Model(id: $id, created: $created, object: $object, ownedBy: $ownedBy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.ownedBy, ownedBy) || other.ownedBy == ownedBy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, created, object, ownedBy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      __$$ModelImplCopyWithImpl<_$ModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModelImplToJson(
      this,
    );
  }
}

abstract class _Model extends Model {
  const factory _Model(
      {required final String id,
      required final int created,
      required final String object,
      @JsonKey(name: 'owned_by') required final String ownedBy}) = _$ModelImpl;
  const _Model._() : super._();

  factory _Model.fromJson(Map<String, dynamic> json) = _$ModelImpl.fromJson;

  @override

  /// The model identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) when the model was created.
  int get created;
  @override

  /// The object type, which is always "model".
  String get object;
  @override

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy;
  @override
  @JsonKey(ignore: true)
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListModelsResponse _$ListModelsResponseFromJson(Map<String, dynamic> json) {
  return _ListModelsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListModelsResponse {
  /// The object type, which is always "list".
  String get object => throw _privateConstructorUsedError;

  /// The list of models.
  List<Model> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListModelsResponseCopyWith<ListModelsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListModelsResponseCopyWith<$Res> {
  factory $ListModelsResponseCopyWith(
          ListModelsResponse value, $Res Function(ListModelsResponse) then) =
      _$ListModelsResponseCopyWithImpl<$Res, ListModelsResponse>;
  @useResult
  $Res call({String object, List<Model> data});
}

/// @nodoc
class _$ListModelsResponseCopyWithImpl<$Res, $Val extends ListModelsResponse>
    implements $ListModelsResponseCopyWith<$Res> {
  _$ListModelsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListModelsResponseImplCopyWith<$Res>
    implements $ListModelsResponseCopyWith<$Res> {
  factory _$$ListModelsResponseImplCopyWith(_$ListModelsResponseImpl value,
          $Res Function(_$ListModelsResponseImpl) then) =
      __$$ListModelsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String object, List<Model> data});
}

/// @nodoc
class __$$ListModelsResponseImplCopyWithImpl<$Res>
    extends _$ListModelsResponseCopyWithImpl<$Res, _$ListModelsResponseImpl>
    implements _$$ListModelsResponseImplCopyWith<$Res> {
  __$$ListModelsResponseImplCopyWithImpl(_$ListModelsResponseImpl _value,
      $Res Function(_$ListModelsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_$ListModelsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListModelsResponseImpl extends _ListModelsResponse {
  const _$ListModelsResponseImpl(
      {required this.object, required final List<Model> data})
      : _data = data,
        super._();

  factory _$ListModelsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListModelsResponseImplFromJson(json);

  /// The object type, which is always "list".
  @override
  final String object;

  /// The list of models.
  final List<Model> _data;

  /// The list of models.
  @override
  List<Model> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ListModelsResponse(object: $object, data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListModelsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      __$$ListModelsResponseImplCopyWithImpl<_$ListModelsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListModelsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListModelsResponse extends ListModelsResponse {
  const factory _ListModelsResponse(
      {required final String object,
      required final List<Model> data}) = _$ListModelsResponseImpl;
  const _ListModelsResponse._() : super._();

  factory _ListModelsResponse.fromJson(Map<String, dynamic> json) =
      _$ListModelsResponseImpl.fromJson;

  @override

  /// The object type, which is always "list".
  String get object;
  @override

  /// The list of models.
  List<Model> get data;
  @override
  @JsonKey(ignore: true)
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeleteModelResponse _$DeleteModelResponseFromJson(Map<String, dynamic> json) {
  return _DeleteModelResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteModelResponse {
  /// The model identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the model was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteModelResponseCopyWith<DeleteModelResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteModelResponseCopyWith<$Res> {
  factory $DeleteModelResponseCopyWith(
          DeleteModelResponse value, $Res Function(DeleteModelResponse) then) =
      _$DeleteModelResponseCopyWithImpl<$Res, DeleteModelResponse>;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteModelResponseCopyWithImpl<$Res, $Val extends DeleteModelResponse>
    implements $DeleteModelResponseCopyWith<$Res> {
  _$DeleteModelResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteModelResponseImplCopyWith<$Res>
    implements $DeleteModelResponseCopyWith<$Res> {
  factory _$$DeleteModelResponseImplCopyWith(_$DeleteModelResponseImpl value,
          $Res Function(_$DeleteModelResponseImpl) then) =
      __$$DeleteModelResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$$DeleteModelResponseImplCopyWithImpl<$Res>
    extends _$DeleteModelResponseCopyWithImpl<$Res, _$DeleteModelResponseImpl>
    implements _$$DeleteModelResponseImplCopyWith<$Res> {
  __$$DeleteModelResponseImplCopyWithImpl(_$DeleteModelResponseImpl _value,
      $Res Function(_$DeleteModelResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteModelResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteModelResponseImpl extends _DeleteModelResponse {
  const _$DeleteModelResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteModelResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteModelResponseImplFromJson(json);

  /// The model identifier.
  @override
  final String id;

  /// Whether the model was deleted.
  @override
  final bool deleted;

  /// The object type, which is always "model".
  @override
  final String object;

  @override
  String toString() {
    return 'DeleteModelResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteModelResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      __$$DeleteModelResponseImplCopyWithImpl<_$DeleteModelResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteModelResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteModelResponse extends DeleteModelResponse {
  const factory _DeleteModelResponse(
      {required final String id,
      required final bool deleted,
      required final String object}) = _$DeleteModelResponseImpl;
  const _DeleteModelResponse._() : super._();

  factory _DeleteModelResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteModelResponseImpl.fromJson;

  @override

  /// The model identifier.
  String get id;
  @override

  /// Whether the model was deleted.
  bool get deleted;
  @override

  /// The object type, which is always "model".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateModerationRequest _$CreateModerationRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationRequest {
  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model => throw _privateConstructorUsedError;

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationRequestCopyWith<CreateModerationRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationRequestCopyWith<$Res> {
  factory $CreateModerationRequestCopyWith(CreateModerationRequest value,
          $Res Function(CreateModerationRequest) then) =
      _$CreateModerationRequestCopyWithImpl<$Res, CreateModerationRequest>;
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  $ModerationModelCopyWith<$Res>? get model;
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateModerationRequestCopyWithImpl<$Res,
        $Val extends CreateModerationRequest>
    implements $CreateModerationRequestCopyWith<$Res> {
  _$CreateModerationRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_value.copyWith(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $ModerationModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationInputCopyWith<$Res> get input {
    return $ModerationInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateModerationRequestImplCopyWith<$Res>
    implements $CreateModerationRequestCopyWith<$Res> {
  factory _$$CreateModerationRequestImplCopyWith(
          _$CreateModerationRequestImpl value,
          $Res Function(_$CreateModerationRequestImpl) then) =
      __$$CreateModerationRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  @override
  $ModerationModelCopyWith<$Res>? get model;
  @override
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateModerationRequestImplCopyWithImpl<$Res>
    extends _$CreateModerationRequestCopyWithImpl<$Res,
        _$CreateModerationRequestImpl>
    implements _$$CreateModerationRequestImplCopyWith<$Res> {
  __$$CreateModerationRequestImplCopyWithImpl(
      _$CreateModerationRequestImpl _value,
      $Res Function(_$CreateModerationRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_$CreateModerationRequestImpl(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationRequestImpl extends _CreateModerationRequest {
  const _$CreateModerationRequestImpl(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const ModerationModel.string('text-moderation-latest'),
      @_ModerationInputConverter() required this.input})
      : super._();

  factory _$CreateModerationRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationRequestImplFromJson(json);

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @override
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  final ModerationModel? model;

  /// The input text to classify
  @override
  @_ModerationInputConverter()
  final ModerationInput input;

  @override
  String toString() {
    return 'CreateModerationRequest(model: $model, input: $input)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, model, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => __$$CreateModerationRequestImplCopyWithImpl<
          _$CreateModerationRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationRequest extends CreateModerationRequest {
  const factory _CreateModerationRequest(
          {@_ModerationModelConverter()
          @JsonKey(includeIfNull: false)
          final ModerationModel? model,
          @_ModerationInputConverter() required final ModerationInput input}) =
      _$CreateModerationRequestImpl;
  const _CreateModerationRequest._() : super._();

  factory _CreateModerationRequest.fromJson(Map<String, dynamic> json) =
      _$CreateModerationRequestImpl.fromJson;

  @override

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model;
  @override

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationModel _$ModerationModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return _UnionModerationModelEnum.fromJson(json);
    case 'string':
      return _UnionModerationModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) enumeration,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? enumeration,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionModerationModelEnum value) enumeration,
    required TResult Function(_UnionModerationModelString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionModerationModelEnum value)? enumeration,
    TResult? Function(_UnionModerationModelString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionModerationModelEnum value)? enumeration,
    TResult Function(_UnionModerationModelString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationModelCopyWith<$Res> {
  factory $ModerationModelCopyWith(
          ModerationModel value, $Res Function(ModerationModel) then) =
      _$ModerationModelCopyWithImpl<$Res, ModerationModel>;
}

/// @nodoc
class _$ModerationModelCopyWithImpl<$Res, $Val extends ModerationModel>
    implements $ModerationModelCopyWith<$Res> {
  _$ModerationModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionModerationModelEnumImplCopyWith<$Res> {
  factory _$$UnionModerationModelEnumImplCopyWith(
          _$UnionModerationModelEnumImpl value,
          $Res Function(_$UnionModerationModelEnumImpl) then) =
      __$$UnionModerationModelEnumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ModerationModels value});
}

/// @nodoc
class __$$UnionModerationModelEnumImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res, _$UnionModerationModelEnumImpl>
    implements _$$UnionModerationModelEnumImplCopyWith<$Res> {
  __$$UnionModerationModelEnumImplCopyWithImpl(
      _$UnionModerationModelEnumImpl _value,
      $Res Function(_$UnionModerationModelEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionModerationModelEnumImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ModerationModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionModerationModelEnumImpl extends _UnionModerationModelEnum {
  const _$UnionModerationModelEnumImpl(this.value, {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$UnionModerationModelEnumImpl.fromJson(Map<String, dynamic> json) =>
      _$$UnionModerationModelEnumImplFromJson(json);

  @override
  final ModerationModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.enumeration(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionModerationModelEnumImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionModerationModelEnumImplCopyWith<_$UnionModerationModelEnumImpl>
      get copyWith => __$$UnionModerationModelEnumImplCopyWithImpl<
          _$UnionModerationModelEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionModerationModelEnum value) enumeration,
    required TResult Function(_UnionModerationModelString value) string,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionModerationModelEnum value)? enumeration,
    TResult? Function(_UnionModerationModelString value)? string,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionModerationModelEnum value)? enumeration,
    TResult Function(_UnionModerationModelString value)? string,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionModerationModelEnumImplToJson(
      this,
    );
  }
}

abstract class _UnionModerationModelEnum extends ModerationModel {
  const factory _UnionModerationModelEnum(final ModerationModels value) =
      _$UnionModerationModelEnumImpl;
  const _UnionModerationModelEnum._() : super._();

  factory _UnionModerationModelEnum.fromJson(Map<String, dynamic> json) =
      _$UnionModerationModelEnumImpl.fromJson;

  @override
  ModerationModels get value;
  @JsonKey(ignore: true)
  _$$UnionModerationModelEnumImplCopyWith<_$UnionModerationModelEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionModerationModelStringImplCopyWith<$Res> {
  factory _$$UnionModerationModelStringImplCopyWith(
          _$UnionModerationModelStringImpl value,
          $Res Function(_$UnionModerationModelStringImpl) then) =
      __$$UnionModerationModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionModerationModelStringImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res,
        _$UnionModerationModelStringImpl>
    implements _$$UnionModerationModelStringImplCopyWith<$Res> {
  __$$UnionModerationModelStringImplCopyWithImpl(
      _$UnionModerationModelStringImpl _value,
      $Res Function(_$UnionModerationModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionModerationModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionModerationModelStringImpl extends _UnionModerationModelString {
  const _$UnionModerationModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionModerationModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionModerationModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionModerationModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionModerationModelStringImplCopyWith<_$UnionModerationModelStringImpl>
      get copyWith => __$$UnionModerationModelStringImplCopyWithImpl<
          _$UnionModerationModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) enumeration,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? enumeration,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? enumeration,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionModerationModelEnum value) enumeration,
    required TResult Function(_UnionModerationModelString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionModerationModelEnum value)? enumeration,
    TResult? Function(_UnionModerationModelString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionModerationModelEnum value)? enumeration,
    TResult Function(_UnionModerationModelString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionModerationModelStringImplToJson(
      this,
    );
  }
}

abstract class _UnionModerationModelString extends ModerationModel {
  const factory _UnionModerationModelString(final String value) =
      _$UnionModerationModelStringImpl;
  const _UnionModerationModelString._() : super._();

  factory _UnionModerationModelString.fromJson(Map<String, dynamic> json) =
      _$UnionModerationModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionModerationModelStringImplCopyWith<_$UnionModerationModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationInput _$ModerationInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'arrayString':
      return _UnionModerationInputArrayString.fromJson(json);
    case 'string':
      return _UnionModerationInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionModerationInputArrayString value)
        arrayString,
    required TResult Function(_UnionModerationInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionModerationInputArrayString value)? arrayString,
    TResult? Function(_UnionModerationInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionModerationInputArrayString value)? arrayString,
    TResult Function(_UnionModerationInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationInputCopyWith<$Res> {
  factory $ModerationInputCopyWith(
          ModerationInput value, $Res Function(ModerationInput) then) =
      _$ModerationInputCopyWithImpl<$Res, ModerationInput>;
}

/// @nodoc
class _$ModerationInputCopyWithImpl<$Res, $Val extends ModerationInput>
    implements $ModerationInputCopyWith<$Res> {
  _$ModerationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnionModerationInputArrayStringImplCopyWith<$Res> {
  factory _$$UnionModerationInputArrayStringImplCopyWith(
          _$UnionModerationInputArrayStringImpl value,
          $Res Function(_$UnionModerationInputArrayStringImpl) then) =
      __$$UnionModerationInputArrayStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$UnionModerationInputArrayStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res,
        _$UnionModerationInputArrayStringImpl>
    implements _$$UnionModerationInputArrayStringImplCopyWith<$Res> {
  __$$UnionModerationInputArrayStringImplCopyWithImpl(
      _$UnionModerationInputArrayStringImpl _value,
      $Res Function(_$UnionModerationInputArrayStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionModerationInputArrayStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionModerationInputArrayStringImpl
    extends _UnionModerationInputArrayString {
  const _$UnionModerationInputArrayStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'arrayString',
        super._();

  factory _$UnionModerationInputArrayStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionModerationInputArrayStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.arrayString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionModerationInputArrayStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionModerationInputArrayStringImplCopyWith<
          _$UnionModerationInputArrayStringImpl>
      get copyWith => __$$UnionModerationInputArrayStringImplCopyWithImpl<
          _$UnionModerationInputArrayStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return arrayString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return arrayString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionModerationInputArrayString value)
        arrayString,
    required TResult Function(_UnionModerationInputString value) string,
  }) {
    return arrayString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionModerationInputArrayString value)? arrayString,
    TResult? Function(_UnionModerationInputString value)? string,
  }) {
    return arrayString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionModerationInputArrayString value)? arrayString,
    TResult Function(_UnionModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (arrayString != null) {
      return arrayString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionModerationInputArrayStringImplToJson(
      this,
    );
  }
}

abstract class _UnionModerationInputArrayString extends ModerationInput {
  const factory _UnionModerationInputArrayString(final List<String> value) =
      _$UnionModerationInputArrayStringImpl;
  const _UnionModerationInputArrayString._() : super._();

  factory _UnionModerationInputArrayString.fromJson(Map<String, dynamic> json) =
      _$UnionModerationInputArrayStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$UnionModerationInputArrayStringImplCopyWith<
          _$UnionModerationInputArrayStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnionModerationInputStringImplCopyWith<$Res> {
  factory _$$UnionModerationInputStringImplCopyWith(
          _$UnionModerationInputStringImpl value,
          $Res Function(_$UnionModerationInputStringImpl) then) =
      __$$UnionModerationInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UnionModerationInputStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res,
        _$UnionModerationInputStringImpl>
    implements _$$UnionModerationInputStringImplCopyWith<$Res> {
  __$$UnionModerationInputStringImplCopyWithImpl(
      _$UnionModerationInputStringImpl _value,
      $Res Function(_$UnionModerationInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UnionModerationInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionModerationInputStringImpl extends _UnionModerationInputString {
  const _$UnionModerationInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$UnionModerationInputStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionModerationInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.string(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionModerationInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionModerationInputStringImplCopyWith<_$UnionModerationInputStringImpl>
      get copyWith => __$$UnionModerationInputStringImplCopyWithImpl<
          _$UnionModerationInputStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) arrayString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? arrayString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? arrayString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnionModerationInputArrayString value)
        arrayString,
    required TResult Function(_UnionModerationInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnionModerationInputArrayString value)? arrayString,
    TResult? Function(_UnionModerationInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnionModerationInputArrayString value)? arrayString,
    TResult Function(_UnionModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionModerationInputStringImplToJson(
      this,
    );
  }
}

abstract class _UnionModerationInputString extends ModerationInput {
  const factory _UnionModerationInputString(final String value) =
      _$UnionModerationInputStringImpl;
  const _UnionModerationInputString._() : super._();

  factory _UnionModerationInputString.fromJson(Map<String, dynamic> json) =
      _$UnionModerationInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UnionModerationInputStringImplCopyWith<_$UnionModerationInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateModerationResponse _$CreateModerationResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationResponse {
  /// The unique identifier for the moderation request.
  String get id => throw _privateConstructorUsedError;

  /// The model used to generate the moderation results.
  String get model => throw _privateConstructorUsedError;

  /// A list of moderation objects.
  List<Moderation> get results => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationResponseCopyWith<CreateModerationResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationResponseCopyWith<$Res> {
  factory $CreateModerationResponseCopyWith(CreateModerationResponse value,
          $Res Function(CreateModerationResponse) then) =
      _$CreateModerationResponseCopyWithImpl<$Res, CreateModerationResponse>;
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class _$CreateModerationResponseCopyWithImpl<$Res,
        $Val extends CreateModerationResponse>
    implements $CreateModerationResponseCopyWith<$Res> {
  _$CreateModerationResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateModerationResponseImplCopyWith<$Res>
    implements $CreateModerationResponseCopyWith<$Res> {
  factory _$$CreateModerationResponseImplCopyWith(
          _$CreateModerationResponseImpl value,
          $Res Function(_$CreateModerationResponseImpl) then) =
      __$$CreateModerationResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class __$$CreateModerationResponseImplCopyWithImpl<$Res>
    extends _$CreateModerationResponseCopyWithImpl<$Res,
        _$CreateModerationResponseImpl>
    implements _$$CreateModerationResponseImplCopyWith<$Res> {
  __$$CreateModerationResponseImplCopyWithImpl(
      _$CreateModerationResponseImpl _value,
      $Res Function(_$CreateModerationResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_$CreateModerationResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationResponseImpl extends _CreateModerationResponse {
  const _$CreateModerationResponseImpl(
      {required this.id,
      required this.model,
      required final List<Moderation> results})
      : _results = results,
        super._();

  factory _$CreateModerationResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationResponseImplFromJson(json);

  /// The unique identifier for the moderation request.
  @override
  final String id;

  /// The model used to generate the moderation results.
  @override
  final String model;

  /// A list of moderation objects.
  final List<Moderation> _results;

  /// A list of moderation objects.
  @override
  List<Moderation> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  @override
  String toString() {
    return 'CreateModerationResponse(id: $id, model: $model, results: $results)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._results, _results));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, model, const DeepCollectionEquality().hash(_results));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => __$$CreateModerationResponseImplCopyWithImpl<
          _$CreateModerationResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationResponse extends CreateModerationResponse {
  const factory _CreateModerationResponse(
          {required final String id,
          required final String model,
          required final List<Moderation> results}) =
      _$CreateModerationResponseImpl;
  const _CreateModerationResponse._() : super._();

  factory _CreateModerationResponse.fromJson(Map<String, dynamic> json) =
      _$CreateModerationResponseImpl.fromJson;

  @override

  /// The unique identifier for the moderation request.
  String get id;
  @override

  /// The model used to generate the moderation results.
  String get model;
  @override

  /// A list of moderation objects.
  List<Moderation> get results;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Moderation _$ModerationFromJson(Map<String, dynamic> json) {
  return _Moderation.fromJson(json);
}

/// @nodoc
mixin _$Moderation {
  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  bool get flagged => throw _privateConstructorUsedError;

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories => throw _privateConstructorUsedError;

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCopyWith<Moderation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCopyWith<$Res> {
  factory $ModerationCopyWith(
          Moderation value, $Res Function(Moderation) then) =
      _$ModerationCopyWithImpl<$Res, Moderation>;
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  $ModerationCategoriesCopyWith<$Res> get categories;
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class _$ModerationCopyWithImpl<$Res, $Val extends Moderation>
    implements $ModerationCopyWith<$Res> {
  _$ModerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_value.copyWith(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesCopyWith<$Res> get categories {
    return $ModerationCategoriesCopyWith<$Res>(_value.categories, (value) {
      return _then(_value.copyWith(categories: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores {
    return $ModerationCategoriesScoresCopyWith<$Res>(_value.categoryScores,
        (value) {
      return _then(_value.copyWith(categoryScores: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModerationImplCopyWith<$Res>
    implements $ModerationCopyWith<$Res> {
  factory _$$ModerationImplCopyWith(
          _$ModerationImpl value, $Res Function(_$ModerationImpl) then) =
      __$$ModerationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  @override
  $ModerationCategoriesCopyWith<$Res> get categories;
  @override
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class __$$ModerationImplCopyWithImpl<$Res>
    extends _$ModerationCopyWithImpl<$Res, _$ModerationImpl>
    implements _$$ModerationImplCopyWith<$Res> {
  __$$ModerationImplCopyWithImpl(
      _$ModerationImpl _value, $Res Function(_$ModerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_$ModerationImpl(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationImpl extends _Moderation {
  const _$ModerationImpl(
      {required this.flagged,
      required this.categories,
      @JsonKey(name: 'category_scores') required this.categoryScores})
      : super._();

  factory _$ModerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationImplFromJson(json);

  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  @override
  final bool flagged;

  /// A list of the categories, and whether they are flagged or not.
  @override
  final ModerationCategories categories;

  /// A list of the categories along with their scores as predicted by model.
  @override
  @JsonKey(name: 'category_scores')
  final ModerationCategoriesScores categoryScores;

  @override
  String toString() {
    return 'Moderation(flagged: $flagged, categories: $categories, categoryScores: $categoryScores)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationImpl &&
            (identical(other.flagged, flagged) || other.flagged == flagged) &&
            (identical(other.categories, categories) ||
                other.categories == categories) &&
            (identical(other.categoryScores, categoryScores) ||
                other.categoryScores == categoryScores));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, flagged, categories, categoryScores);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      __$$ModerationImplCopyWithImpl<_$ModerationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationImplToJson(
      this,
    );
  }
}

abstract class _Moderation extends Moderation {
  const factory _Moderation(
          {required final bool flagged,
          required final ModerationCategories categories,
          @JsonKey(name: 'category_scores')
          required final ModerationCategoriesScores categoryScores}) =
      _$ModerationImpl;
  const _Moderation._() : super._();

  factory _Moderation.fromJson(Map<String, dynamic> json) =
      _$ModerationImpl.fromJson;

  @override

  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  bool get flagged;
  @override

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories;
  @override

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores;
  @override
  @JsonKey(ignore: true)
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModerationCategories _$ModerationCategoriesFromJson(Map<String, dynamic> json) {
  return _ModerationCategories.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategories {
  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harrassment.
  bool get hate => throw _privateConstructorUsedError;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening => throw _privateConstructorUsedError;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment => throw _privateConstructorUsedError;

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening => throw _privateConstructorUsedError;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm => throw _privateConstructorUsedError;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent => throw _privateConstructorUsedError;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions => throw _privateConstructorUsedError;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual => throw _privateConstructorUsedError;

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury.
  bool get violence => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesCopyWith<ModerationCategories> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesCopyWith<$Res> {
  factory $ModerationCategoriesCopyWith(ModerationCategories value,
          $Res Function(ModerationCategories) then) =
      _$ModerationCategoriesCopyWithImpl<$Res, ModerationCategories>;
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesCopyWithImpl<$Res,
        $Val extends ModerationCategories>
    implements $ModerationCategoriesCopyWith<$Res> {
  _$ModerationCategoriesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesImplCopyWith<$Res>
    implements $ModerationCategoriesCopyWith<$Res> {
  factory _$$ModerationCategoriesImplCopyWith(_$ModerationCategoriesImpl value,
          $Res Function(_$ModerationCategoriesImpl) then) =
      __$$ModerationCategoriesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesCopyWithImpl<$Res, _$ModerationCategoriesImpl>
    implements _$$ModerationCategoriesImplCopyWith<$Res> {
  __$$ModerationCategoriesImplCopyWithImpl(_$ModerationCategoriesImpl _value,
      $Res Function(_$ModerationCategoriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesImpl extends _ModerationCategories {
  const _$ModerationCategoriesImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationCategoriesImplFromJson(json);

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harrassment.
  @override
  final bool hate;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @override
  @JsonKey(name: 'hate/threatening')
  final bool hateThreatening;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  @override
  final bool harassment;

  /// Harassment content that also includes violence or serious harm towards any target.
  @override
  @JsonKey(name: 'harassment/threatening')
  final bool harassmentThreatening;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm')
  final bool selfHarm;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm/intent')
  final bool selfHarmIntent;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final bool selfHarmInstructions;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  @override
  final bool sexual;

  /// Sexual content that includes an individual who is under 18 years old.
  @override
  @JsonKey(name: 'sexual/minors')
  final bool sexualMinors;

  /// Content that depicts death, violence, or physical injury.
  @override
  final bool violence;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @override
  @JsonKey(name: 'violence/graphic')
  final bool violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategories(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith =>
          __$$ModerationCategoriesImplCopyWithImpl<_$ModerationCategoriesImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategories extends ModerationCategories {
  const factory _ModerationCategories(
      {required final bool hate,
      @JsonKey(name: 'hate/threatening') required final bool hateThreatening,
      required final bool harassment,
      @JsonKey(name: 'harassment/threatening')
      required final bool harassmentThreatening,
      @JsonKey(name: 'self-harm') required final bool selfHarm,
      @JsonKey(name: 'self-harm/intent') required final bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final bool selfHarmInstructions,
      required final bool sexual,
      @JsonKey(name: 'sexual/minors') required final bool sexualMinors,
      required final bool violence,
      @JsonKey(name: 'violence/graphic')
      required final bool violenceGraphic}) = _$ModerationCategoriesImpl;
  const _ModerationCategories._() : super._();

  factory _ModerationCategories.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesImpl.fromJson;

  @override

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harrassment.
  bool get hate;
  @override

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening;
  @override

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment;
  @override

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening;
  @override

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm;
  @override

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent;
  @override

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions;
  @override

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual;
  @override

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors;
  @override

  /// Content that depicts death, violence, or physical injury.
  bool get violence;
  @override

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationCategoriesScores _$ModerationCategoriesScoresFromJson(
    Map<String, dynamic> json) {
  return _ModerationCategoriesScores.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategoriesScores {
  /// The score for the category 'hate'.
  double get hate => throw _privateConstructorUsedError;

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'harassment'.
  double get harassment => throw _privateConstructorUsedError;

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions => throw _privateConstructorUsedError;

  /// The score for the category 'sexual'.
  double get sexual => throw _privateConstructorUsedError;

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors => throw _privateConstructorUsedError;

  /// The score for the category 'violence'.
  double get violence => throw _privateConstructorUsedError;

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesScoresCopyWith<ModerationCategoriesScores>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesScoresCopyWith<$Res> {
  factory $ModerationCategoriesScoresCopyWith(ModerationCategoriesScores value,
          $Res Function(ModerationCategoriesScores) then) =
      _$ModerationCategoriesScoresCopyWithImpl<$Res,
          ModerationCategoriesScores>;
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesScoresCopyWithImpl<$Res,
        $Val extends ModerationCategoriesScores>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  _$ModerationCategoriesScoresCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesScoresImplCopyWith<$Res>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  factory _$$ModerationCategoriesScoresImplCopyWith(
          _$ModerationCategoriesScoresImpl value,
          $Res Function(_$ModerationCategoriesScoresImpl) then) =
      __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesScoresCopyWithImpl<$Res,
        _$ModerationCategoriesScoresImpl>
    implements _$$ModerationCategoriesScoresImplCopyWith<$Res> {
  __$$ModerationCategoriesScoresImplCopyWithImpl(
      _$ModerationCategoriesScoresImpl _value,
      $Res Function(_$ModerationCategoriesScoresImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesScoresImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesScoresImpl extends _ModerationCategoriesScores {
  const _$ModerationCategoriesScoresImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesScoresImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModerationCategoriesScoresImplFromJson(json);

  /// The score for the category 'hate'.
  @override
  final double hate;

  /// The score for the category 'hate/threatening'.
  @override
  @JsonKey(name: 'hate/threatening')
  final double hateThreatening;

  /// The score for the category 'harassment'.
  @override
  final double harassment;

  /// The score for the category 'harassment/threatening'.
  @override
  @JsonKey(name: 'harassment/threatening')
  final double harassmentThreatening;

  /// The score for the category 'self-harm'.
  @override
  @JsonKey(name: 'self-harm')
  final double selfHarm;

  /// The score for the category 'self-harm/intent'.
  @override
  @JsonKey(name: 'self-harm/intent')
  final double selfHarmIntent;

  /// The score for the category 'self-harm/instructions'.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final double selfHarmInstructions;

  /// The score for the category 'sexual'.
  @override
  final double sexual;

  /// The score for the category 'sexual/minors'.
  @override
  @JsonKey(name: 'sexual/minors')
  final double sexualMinors;

  /// The score for the category 'violence'.
  @override
  final double violence;

  /// The score for the category 'violence/graphic'.
  @override
  @JsonKey(name: 'violence/graphic')
  final double violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategoriesScores(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesScoresImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => __$$ModerationCategoriesScoresImplCopyWithImpl<
          _$ModerationCategoriesScoresImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesScoresImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategoriesScores extends ModerationCategoriesScores {
  const factory _ModerationCategoriesScores(
      {required final double hate,
      @JsonKey(name: 'hate/threatening') required final double hateThreatening,
      required final double harassment,
      @JsonKey(name: 'harassment/threatening')
      required final double harassmentThreatening,
      @JsonKey(name: 'self-harm') required final double selfHarm,
      @JsonKey(name: 'self-harm/intent') required final double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final double selfHarmInstructions,
      required final double sexual,
      @JsonKey(name: 'sexual/minors') required final double sexualMinors,
      required final double violence,
      @JsonKey(name: 'violence/graphic')
      required final double
          violenceGraphic}) = _$ModerationCategoriesScoresImpl;
  const _ModerationCategoriesScores._() : super._();

  factory _ModerationCategoriesScores.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesScoresImpl.fromJson;

  @override

  /// The score for the category 'hate'.
  double get hate;
  @override

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening;
  @override

  /// The score for the category 'harassment'.
  double get harassment;
  @override

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening;
  @override

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm;
  @override

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent;
  @override

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions;
  @override

  /// The score for the category 'sexual'.
  double get sexual;
  @override

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors;
  @override

  /// The score for the category 'violence'.
  double get violence;
  @override

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => throw _privateConstructorUsedError;
}

UnionCompletionNamedToolChoice _$UnionCompletionNamedToolChoiceFromJson(
    Map<String, dynamic> json) {
  return UnionCompletionNamedToolChoiceChat.fromJson(json);
}

/// @nodoc
mixin _$UnionCompletionNamedToolChoice {
  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(includeIfNull: false)
  String? get type => throw _privateConstructorUsedError;

  /// Forces the model to call the specified function.
  @JsonKey(includeIfNull: false)
  ChatCompletionFunctionCallOption? get function =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @JsonKey(includeIfNull: false) String? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionFunctionCallOption? function)
        Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @JsonKey(includeIfNull: false) String? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionFunctionCallOption? function)?
        Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @JsonKey(includeIfNull: false) String? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionFunctionCallOption? function)?
        Chat,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnionCompletionNamedToolChoiceChat value) Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UnionCompletionNamedToolChoiceChat value)? Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnionCompletionNamedToolChoiceChat value)? Chat,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UnionCompletionNamedToolChoiceCopyWith<UnionCompletionNamedToolChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnionCompletionNamedToolChoiceCopyWith<$Res> {
  factory $UnionCompletionNamedToolChoiceCopyWith(
          UnionCompletionNamedToolChoice value,
          $Res Function(UnionCompletionNamedToolChoice) then) =
      _$UnionCompletionNamedToolChoiceCopyWithImpl<$Res,
          UnionCompletionNamedToolChoice>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionFunctionCallOption? function});

  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class _$UnionCompletionNamedToolChoiceCopyWithImpl<$Res,
        $Val extends UnionCompletionNamedToolChoice>
    implements $UnionCompletionNamedToolChoiceCopyWith<$Res> {
  _$UnionCompletionNamedToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.function!,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$UnionCompletionNamedToolChoiceChatImplCopyWith<$Res>
    implements $UnionCompletionNamedToolChoiceCopyWith<$Res> {
  factory _$$UnionCompletionNamedToolChoiceChatImplCopyWith(
          _$UnionCompletionNamedToolChoiceChatImpl value,
          $Res Function(_$UnionCompletionNamedToolChoiceChatImpl) then) =
      __$$UnionCompletionNamedToolChoiceChatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionFunctionCallOption? function});

  @override
  $ChatCompletionFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class __$$UnionCompletionNamedToolChoiceChatImplCopyWithImpl<$Res>
    extends _$UnionCompletionNamedToolChoiceCopyWithImpl<$Res,
        _$UnionCompletionNamedToolChoiceChatImpl>
    implements _$$UnionCompletionNamedToolChoiceChatImplCopyWith<$Res> {
  __$$UnionCompletionNamedToolChoiceChatImplCopyWithImpl(
      _$UnionCompletionNamedToolChoiceChatImpl _value,
      $Res Function(_$UnionCompletionNamedToolChoiceChatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_$UnionCompletionNamedToolChoiceChatImpl(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionNamedToolChoiceChatImpl
    extends UnionCompletionNamedToolChoiceChat {
  const _$UnionCompletionNamedToolChoiceChatImpl(
      {@JsonKey(includeIfNull: false) this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$UnionCompletionNamedToolChoiceChatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionNamedToolChoiceChatImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(includeIfNull: false)
  final String? type;

  /// Forces the model to call the specified function.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionFunctionCallOption? function;

  @override
  String toString() {
    return 'UnionCompletionNamedToolChoice.Chat(type: $type, function: $function)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionNamedToolChoiceChatImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionNamedToolChoiceChatImplCopyWith<
          _$UnionCompletionNamedToolChoiceChatImpl>
      get copyWith => __$$UnionCompletionNamedToolChoiceChatImplCopyWithImpl<
          _$UnionCompletionNamedToolChoiceChatImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @JsonKey(includeIfNull: false) String? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionFunctionCallOption? function)
        Chat,
  }) {
    return Chat(type, function);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @JsonKey(includeIfNull: false) String? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionFunctionCallOption? function)?
        Chat,
  }) {
    return Chat?.call(type, function);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @JsonKey(includeIfNull: false) String? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionFunctionCallOption? function)?
        Chat,
    required TResult orElse(),
  }) {
    if (Chat != null) {
      return Chat(type, function);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnionCompletionNamedToolChoiceChat value) Chat,
  }) {
    return Chat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UnionCompletionNamedToolChoiceChat value)? Chat,
  }) {
    return Chat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnionCompletionNamedToolChoiceChat value)? Chat,
    required TResult orElse(),
  }) {
    if (Chat != null) {
      return Chat(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionNamedToolChoiceChatImplToJson(
      this,
    );
  }
}

abstract class UnionCompletionNamedToolChoiceChat
    extends UnionCompletionNamedToolChoice {
  const factory UnionCompletionNamedToolChoiceChat(
          {@JsonKey(includeIfNull: false) final String? type,
          @JsonKey(includeIfNull: false)
          final ChatCompletionFunctionCallOption? function}) =
      _$UnionCompletionNamedToolChoiceChatImpl;
  const UnionCompletionNamedToolChoiceChat._() : super._();

  factory UnionCompletionNamedToolChoiceChat.fromJson(
          Map<String, dynamic> json) =
      _$UnionCompletionNamedToolChoiceChatImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(includeIfNull: false)
  String? get type;
  @override

  /// Forces the model to call the specified function.
  @JsonKey(includeIfNull: false)
  ChatCompletionFunctionCallOption? get function;
  @override
  @JsonKey(ignore: true)
  _$$UnionCompletionNamedToolChoiceChatImplCopyWith<
          _$UnionCompletionNamedToolChoiceChatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

UnionCompletionFunctionCallOption _$UnionCompletionFunctionCallOptionFromJson(
    Map<String, dynamic> json) {
  return UnionCompletionFunctionCallOptionChat.fromJson(json);
}

/// @nodoc
mixin _$UnionCompletionFunctionCallOption {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name) Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name)? Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name)? Chat,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnionCompletionFunctionCallOptionChat value) Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UnionCompletionFunctionCallOptionChat value)? Chat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnionCompletionFunctionCallOptionChat value)? Chat,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UnionCompletionFunctionCallOptionCopyWith<UnionCompletionFunctionCallOption>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnionCompletionFunctionCallOptionCopyWith<$Res> {
  factory $UnionCompletionFunctionCallOptionCopyWith(
          UnionCompletionFunctionCallOption value,
          $Res Function(UnionCompletionFunctionCallOption) then) =
      _$UnionCompletionFunctionCallOptionCopyWithImpl<$Res,
          UnionCompletionFunctionCallOption>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$UnionCompletionFunctionCallOptionCopyWithImpl<$Res,
        $Val extends UnionCompletionFunctionCallOption>
    implements $UnionCompletionFunctionCallOptionCopyWith<$Res> {
  _$UnionCompletionFunctionCallOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UnionCompletionFunctionCallOptionChatImplCopyWith<$Res>
    implements $UnionCompletionFunctionCallOptionCopyWith<$Res> {
  factory _$$UnionCompletionFunctionCallOptionChatImplCopyWith(
          _$UnionCompletionFunctionCallOptionChatImpl value,
          $Res Function(_$UnionCompletionFunctionCallOptionChatImpl) then) =
      __$$UnionCompletionFunctionCallOptionChatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$UnionCompletionFunctionCallOptionChatImplCopyWithImpl<$Res>
    extends _$UnionCompletionFunctionCallOptionCopyWithImpl<$Res,
        _$UnionCompletionFunctionCallOptionChatImpl>
    implements _$$UnionCompletionFunctionCallOptionChatImplCopyWith<$Res> {
  __$$UnionCompletionFunctionCallOptionChatImplCopyWithImpl(
      _$UnionCompletionFunctionCallOptionChatImpl _value,
      $Res Function(_$UnionCompletionFunctionCallOptionChatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$UnionCompletionFunctionCallOptionChatImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UnionCompletionFunctionCallOptionChatImpl
    extends UnionCompletionFunctionCallOptionChat {
  const _$UnionCompletionFunctionCallOptionChatImpl({required this.name})
      : super._();

  factory _$UnionCompletionFunctionCallOptionChatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$UnionCompletionFunctionCallOptionChatImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'UnionCompletionFunctionCallOption.Chat(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnionCompletionFunctionCallOptionChatImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnionCompletionFunctionCallOptionChatImplCopyWith<
          _$UnionCompletionFunctionCallOptionChatImpl>
      get copyWith => __$$UnionCompletionFunctionCallOptionChatImplCopyWithImpl<
          _$UnionCompletionFunctionCallOptionChatImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name) Chat,
  }) {
    return Chat(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name)? Chat,
  }) {
    return Chat?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name)? Chat,
    required TResult orElse(),
  }) {
    if (Chat != null) {
      return Chat(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnionCompletionFunctionCallOptionChat value) Chat,
  }) {
    return Chat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UnionCompletionFunctionCallOptionChat value)? Chat,
  }) {
    return Chat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnionCompletionFunctionCallOptionChat value)? Chat,
    required TResult orElse(),
  }) {
    if (Chat != null) {
      return Chat(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UnionCompletionFunctionCallOptionChatImplToJson(
      this,
    );
  }
}

abstract class UnionCompletionFunctionCallOptionChat
    extends UnionCompletionFunctionCallOption {
  const factory UnionCompletionFunctionCallOptionChat(
          {required final String name}) =
      _$UnionCompletionFunctionCallOptionChatImpl;
  const UnionCompletionFunctionCallOptionChat._() : super._();

  factory UnionCompletionFunctionCallOptionChat.fromJson(
          Map<String, dynamic> json) =
      _$UnionCompletionFunctionCallOptionChatImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$UnionCompletionFunctionCallOptionChatImplCopyWith<
          _$UnionCompletionFunctionCallOptionChatImpl>
      get copyWith => throw _privateConstructorUsedError;
}
