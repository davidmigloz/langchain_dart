// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schema.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$CreateCompletionRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf;

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// their existing frequency in the text so far, decreasing the model's
  /// likelihood to repeat the same line verbatim.
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// whether they appear in the text so far, increasing the model's likelihood
  /// to talk about new topics.
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @JsonKey(name: 'stream_options', includeIfNull: false)
  ChatCompletionStreamOptions? get streamOptions;

  /// The suffix that comes after a completion of inserted text.
  ///
  /// This parameter is only supported for `gpt-3.5-turbo-instruct`.
  @JsonKey(includeIfNull: false)
  String? get suffix;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// An alternative to sampling with temperature, called nucleus sampling,
  /// where the model considers the results of the tokens with top_p probability
  /// mass. So 0.1 means only the tokens comprising the top 10% probability mass
  /// are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateCompletionRequestCopyWith<CreateCompletionRequest> get copyWith =>
      _$CreateCompletionRequestCopyWithImpl<CreateCompletionRequest>(
          this as CreateCompletionRequest, _$identity);

  /// Serializes this CreateCompletionRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateCompletionRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.bestOf, bestOf) || other.bestOf == bestOf) &&
            (identical(other.echo, echo) || other.echo == echo) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality().equals(other.logitBias, logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.streamOptions, streamOptions) ||
                other.streamOptions == streamOptions) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      prompt,
      bestOf,
      echo,
      frequencyPenalty,
      const DeepCollectionEquality().hash(logitBias),
      logprobs,
      maxTokens,
      n,
      presencePenalty,
      seed,
      stop,
      stream,
      streamOptions,
      suffix,
      temperature,
      topP,
      user);

  @override
  String toString() {
    return 'CreateCompletionRequest(model: $model, prompt: $prompt, bestOf: $bestOf, echo: $echo, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, seed: $seed, stop: $stop, stream: $stream, streamOptions: $streamOptions, suffix: $suffix, temperature: $temperature, topP: $topP, user: $user)';
  }
}

/// @nodoc
abstract mixin class $CreateCompletionRequestCopyWith<$Res> {
  factory $CreateCompletionRequestCopyWith(CreateCompletionRequest value,
          $Res Function(CreateCompletionRequest) _then) =
      _$CreateCompletionRequestCopyWithImpl;
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  $CompletionModelCopyWith<$Res> get model;
  $CompletionPromptCopyWith<$Res>? get prompt;
  $CompletionStopCopyWith<$Res>? get stop;
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
}

/// @nodoc
class _$CreateCompletionRequestCopyWithImpl<$Res>
    implements $CreateCompletionRequestCopyWith<$Res> {
  _$CreateCompletionRequestCopyWithImpl(this._self, this._then);

  final CreateCompletionRequest _self;
  final $Res Function(CreateCompletionRequest) _then;

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_self.copyWith(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _self.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _self.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _self.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _self.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _self.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _self.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _self.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _self.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _self.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _self.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _self.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      suffix: freezed == suffix
          ? _self.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionModelCopyWith<$Res> get model {
    return $CompletionModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionPromptCopyWith<$Res>? get prompt {
    if (_self.prompt == null) {
      return null;
    }

    return $CompletionPromptCopyWith<$Res>(_self.prompt!, (value) {
      return _then(_self.copyWith(prompt: value));
    });
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionStopCopyWith<$Res>? get stop {
    if (_self.stop == null) {
      return null;
    }

    return $CompletionStopCopyWith<$Res>(_self.stop!, (value) {
      return _then(_self.copyWith(stop: value));
    });
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions {
    if (_self.streamOptions == null) {
      return null;
    }

    return $ChatCompletionStreamOptionsCopyWith<$Res>(_self.streamOptions!,
        (value) {
      return _then(_self.copyWith(streamOptions: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateCompletionRequest].
extension CreateCompletionRequestPatterns on CreateCompletionRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateCompletionRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateCompletionRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateCompletionRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @_CompletionModelConverter() CompletionModel model,
            @_CompletionPromptConverter() CompletionPrompt? prompt,
            @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
            @JsonKey(includeIfNull: false) bool? echo,
            @JsonKey(name: 'frequency_penalty', includeIfNull: false)
            double? frequencyPenalty,
            @JsonKey(name: 'logit_bias', includeIfNull: false)
            Map<String, int>? logitBias,
            @JsonKey(includeIfNull: false) int? logprobs,
            @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(name: 'presence_penalty', includeIfNull: false)
            double? presencePenalty,
            @JsonKey(includeIfNull: false) int? seed,
            @_CompletionStopConverter()
            @JsonKey(includeIfNull: false)
            CompletionStop? stop,
            @JsonKey(includeIfNull: false) bool? stream,
            @JsonKey(name: 'stream_options', includeIfNull: false)
            ChatCompletionStreamOptions? streamOptions,
            @JsonKey(includeIfNull: false) String? suffix,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(includeIfNull: false) String? user)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionRequest() when $default != null:
        return $default(
            _that.model,
            _that.prompt,
            _that.bestOf,
            _that.echo,
            _that.frequencyPenalty,
            _that.logitBias,
            _that.logprobs,
            _that.maxTokens,
            _that.n,
            _that.presencePenalty,
            _that.seed,
            _that.stop,
            _that.stream,
            _that.streamOptions,
            _that.suffix,
            _that.temperature,
            _that.topP,
            _that.user);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @_CompletionModelConverter() CompletionModel model,
            @_CompletionPromptConverter() CompletionPrompt? prompt,
            @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
            @JsonKey(includeIfNull: false) bool? echo,
            @JsonKey(name: 'frequency_penalty', includeIfNull: false)
            double? frequencyPenalty,
            @JsonKey(name: 'logit_bias', includeIfNull: false)
            Map<String, int>? logitBias,
            @JsonKey(includeIfNull: false) int? logprobs,
            @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(name: 'presence_penalty', includeIfNull: false)
            double? presencePenalty,
            @JsonKey(includeIfNull: false) int? seed,
            @_CompletionStopConverter()
            @JsonKey(includeIfNull: false)
            CompletionStop? stop,
            @JsonKey(includeIfNull: false) bool? stream,
            @JsonKey(name: 'stream_options', includeIfNull: false)
            ChatCompletionStreamOptions? streamOptions,
            @JsonKey(includeIfNull: false) String? suffix,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(includeIfNull: false) String? user)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionRequest():
        return $default(
            _that.model,
            _that.prompt,
            _that.bestOf,
            _that.echo,
            _that.frequencyPenalty,
            _that.logitBias,
            _that.logprobs,
            _that.maxTokens,
            _that.n,
            _that.presencePenalty,
            _that.seed,
            _that.stop,
            _that.stream,
            _that.streamOptions,
            _that.suffix,
            _that.temperature,
            _that.topP,
            _that.user);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @_CompletionModelConverter() CompletionModel model,
            @_CompletionPromptConverter() CompletionPrompt? prompt,
            @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
            @JsonKey(includeIfNull: false) bool? echo,
            @JsonKey(name: 'frequency_penalty', includeIfNull: false)
            double? frequencyPenalty,
            @JsonKey(name: 'logit_bias', includeIfNull: false)
            Map<String, int>? logitBias,
            @JsonKey(includeIfNull: false) int? logprobs,
            @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(name: 'presence_penalty', includeIfNull: false)
            double? presencePenalty,
            @JsonKey(includeIfNull: false) int? seed,
            @_CompletionStopConverter()
            @JsonKey(includeIfNull: false)
            CompletionStop? stop,
            @JsonKey(includeIfNull: false) bool? stream,
            @JsonKey(name: 'stream_options', includeIfNull: false)
            ChatCompletionStreamOptions? streamOptions,
            @JsonKey(includeIfNull: false) String? suffix,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(includeIfNull: false) String? user)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionRequest() when $default != null:
        return $default(
            _that.model,
            _that.prompt,
            _that.bestOf,
            _that.echo,
            _that.frequencyPenalty,
            _that.logitBias,
            _that.logprobs,
            _that.maxTokens,
            _that.n,
            _that.presencePenalty,
            _that.seed,
            _that.stop,
            _that.stream,
            _that.streamOptions,
            _that.suffix,
            _that.temperature,
            _that.topP,
            _that.user);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateCompletionRequest extends CreateCompletionRequest {
  const _CreateCompletionRequest(
      {@_CompletionModelConverter() required this.model,
      @_CompletionPromptConverter() required this.prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) this.bestOf,
      @JsonKey(includeIfNull: false) this.echo = false,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens = 16,
      @JsonKey(includeIfNull: false) this.n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty,
      @JsonKey(includeIfNull: false) this.seed,
      @_CompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(name: 'stream_options', includeIfNull: false) this.streamOptions,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(includeIfNull: false) this.temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP,
      @JsonKey(includeIfNull: false) this.user})
      : _logitBias = logitBias,
        super._();
  factory _CreateCompletionRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateCompletionRequestFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @override
  @_CompletionModelConverter()
  final CompletionModel model;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @override
  @_CompletionPromptConverter()
  final CompletionPrompt? prompt;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(name: 'best_of', includeIfNull: false)
  final int? bestOf;

  /// Echo back the prompt in addition to the completion
  @override
  @JsonKey(includeIfNull: false)
  final bool? echo;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// their existing frequency in the text so far, decreasing the model's
  /// likelihood to repeat the same line verbatim.
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @override
  @JsonKey(includeIfNull: false)
  final int? logprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// whether they appear in the text so far, increasing the model's likelihood
  /// to talk about new topics.
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @override
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final CompletionStop? stop;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @override
  @JsonKey(name: 'stream_options', includeIfNull: false)
  final ChatCompletionStreamOptions? streamOptions;

  /// The suffix that comes after a completion of inserted text.
  ///
  /// This parameter is only supported for `gpt-3.5-turbo-instruct`.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling,
  /// where the model considers the results of the tokens with top_p probability
  /// mass. So 0.1 means only the tokens comprising the top 10% probability mass
  /// are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateCompletionRequestCopyWith<_CreateCompletionRequest> get copyWith =>
      __$CreateCompletionRequestCopyWithImpl<_CreateCompletionRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateCompletionRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateCompletionRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.bestOf, bestOf) || other.bestOf == bestOf) &&
            (identical(other.echo, echo) || other.echo == echo) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.streamOptions, streamOptions) ||
                other.streamOptions == streamOptions) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      prompt,
      bestOf,
      echo,
      frequencyPenalty,
      const DeepCollectionEquality().hash(_logitBias),
      logprobs,
      maxTokens,
      n,
      presencePenalty,
      seed,
      stop,
      stream,
      streamOptions,
      suffix,
      temperature,
      topP,
      user);

  @override
  String toString() {
    return 'CreateCompletionRequest(model: $model, prompt: $prompt, bestOf: $bestOf, echo: $echo, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, seed: $seed, stop: $stop, stream: $stream, streamOptions: $streamOptions, suffix: $suffix, temperature: $temperature, topP: $topP, user: $user)';
  }
}

/// @nodoc
abstract mixin class _$CreateCompletionRequestCopyWith<$Res>
    implements $CreateCompletionRequestCopyWith<$Res> {
  factory _$CreateCompletionRequestCopyWith(_CreateCompletionRequest value,
          $Res Function(_CreateCompletionRequest) _then) =
      __$CreateCompletionRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CompletionModelCopyWith<$Res> get model;
  @override
  $CompletionPromptCopyWith<$Res>? get prompt;
  @override
  $CompletionStopCopyWith<$Res>? get stop;
  @override
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
}

/// @nodoc
class __$CreateCompletionRequestCopyWithImpl<$Res>
    implements _$CreateCompletionRequestCopyWith<$Res> {
  __$CreateCompletionRequestCopyWithImpl(this._self, this._then);

  final _CreateCompletionRequest _self;
  final $Res Function(_CreateCompletionRequest) _then;

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_CreateCompletionRequest(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _self.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _self.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _self.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _self.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _self._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _self.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _self.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _self.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _self.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _self.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _self.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      suffix: freezed == suffix
          ? _self.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionModelCopyWith<$Res> get model {
    return $CompletionModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionPromptCopyWith<$Res>? get prompt {
    if (_self.prompt == null) {
      return null;
    }

    return $CompletionPromptCopyWith<$Res>(_self.prompt!, (value) {
      return _then(_self.copyWith(prompt: value));
    });
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionStopCopyWith<$Res>? get stop {
    if (_self.stop == null) {
      return null;
    }

    return $CompletionStopCopyWith<$Res>(_self.stop!, (value) {
      return _then(_self.copyWith(stop: value));
    });
  }

  /// Create a copy of CreateCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions {
    if (_self.streamOptions == null) {
      return null;
    }

    return $ChatCompletionStreamOptionsCopyWith<$Res>(_self.streamOptions!,
        (value) {
      return _then(_self.copyWith(streamOptions: value));
    });
  }
}

CompletionModel _$CompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return CompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionModel {
  Object get value;

  /// Serializes this CompletionModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CompletionModel(value: $value)';
  }
}

/// @nodoc
class $CompletionModelCopyWith<$Res> {
  $CompletionModelCopyWith(
      CompletionModel _, $Res Function(CompletionModel) __);
}

/// Adds pattern-matching-related methods to [CompletionModel].
extension CompletionModelPatterns on CompletionModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CompletionModelEnumeration() when model != null:
        return model(_that);
      case CompletionModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionModelEnumeration():
        return model(_that);
      case CompletionModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionModelEnumeration() when model != null:
        return model(_that);
      case CompletionModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CompletionModelEnumeration() when model != null:
        return model(_that.value);
      case CompletionModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionModelEnumeration():
        return model(_that.value);
      case CompletionModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionModelEnumeration() when model != null:
        return model(_that.value);
      case CompletionModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CompletionModelEnumeration extends CompletionModel {
  const CompletionModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory CompletionModelEnumeration.fromJson(Map<String, dynamic> json) =>
      _$CompletionModelEnumerationFromJson(json);

  @override
  final CompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionModelEnumerationCopyWith<CompletionModelEnumeration>
      get copyWith =>
          _$CompletionModelEnumerationCopyWithImpl<CompletionModelEnumeration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CompletionModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionModelEnumerationCopyWith<$Res>
    implements $CompletionModelCopyWith<$Res> {
  factory $CompletionModelEnumerationCopyWith(CompletionModelEnumeration value,
          $Res Function(CompletionModelEnumeration) _then) =
      _$CompletionModelEnumerationCopyWithImpl;
  @useResult
  $Res call({CompletionModels value});
}

/// @nodoc
class _$CompletionModelEnumerationCopyWithImpl<$Res>
    implements $CompletionModelEnumerationCopyWith<$Res> {
  _$CompletionModelEnumerationCopyWithImpl(this._self, this._then);

  final CompletionModelEnumeration _self;
  final $Res Function(CompletionModelEnumeration) _then;

  /// Create a copy of CompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CompletionModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as CompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CompletionModelString extends CompletionModel {
  const CompletionModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory CompletionModelString.fromJson(Map<String, dynamic> json) =>
      _$CompletionModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionModelStringCopyWith<CompletionModelString> get copyWith =>
      _$CompletionModelStringCopyWithImpl<CompletionModelString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CompletionModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionModelStringCopyWith<$Res>
    implements $CompletionModelCopyWith<$Res> {
  factory $CompletionModelStringCopyWith(CompletionModelString value,
          $Res Function(CompletionModelString) _then) =
      _$CompletionModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$CompletionModelStringCopyWithImpl<$Res>
    implements $CompletionModelStringCopyWith<$Res> {
  _$CompletionModelStringCopyWithImpl(this._self, this._then);

  final CompletionModelString _self;
  final $Res Function(CompletionModelString) _then;

  /// Create a copy of CompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CompletionModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

CompletionPrompt _$CompletionPromptFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return CompletionPromptListListInt.fromJson(json);
    case 'tokens':
      return CompletionPromptListInt.fromJson(json);
    case 'listString':
      return CompletionPromptListString.fromJson(json);
    case 'string':
      return CompletionPromptString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionPrompt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionPrompt {
  Object get value;

  /// Serializes this CompletionPrompt to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionPrompt &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CompletionPrompt(value: $value)';
  }
}

/// @nodoc
class $CompletionPromptCopyWith<$Res> {
  $CompletionPromptCopyWith(
      CompletionPrompt _, $Res Function(CompletionPrompt) __);
}

/// Adds pattern-matching-related methods to [CompletionPrompt].
extension CompletionPromptPatterns on CompletionPrompt {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CompletionPromptListListInt() when listTokens != null:
        return listTokens(_that);
      case CompletionPromptListInt() when tokens != null:
        return tokens(_that);
      case CompletionPromptListString() when listString != null:
        return listString(_that);
      case CompletionPromptString() when string != null:
        return string(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionPromptListListInt():
        return listTokens(_that);
      case CompletionPromptListInt():
        return tokens(_that);
      case CompletionPromptListString():
        return listString(_that);
      case CompletionPromptString():
        return string(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionPromptListListInt() when listTokens != null:
        return listTokens(_that);
      case CompletionPromptListInt() when tokens != null:
        return tokens(_that);
      case CompletionPromptListString() when listString != null:
        return listString(_that);
      case CompletionPromptString() when string != null:
        return string(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CompletionPromptListListInt() when listTokens != null:
        return listTokens(_that.value);
      case CompletionPromptListInt() when tokens != null:
        return tokens(_that.value);
      case CompletionPromptListString() when listString != null:
        return listString(_that.value);
      case CompletionPromptString() when string != null:
        return string(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionPromptListListInt():
        return listTokens(_that.value);
      case CompletionPromptListInt():
        return tokens(_that.value);
      case CompletionPromptListString():
        return listString(_that.value);
      case CompletionPromptString():
        return string(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionPromptListListInt() when listTokens != null:
        return listTokens(_that.value);
      case CompletionPromptListInt() when tokens != null:
        return tokens(_that.value);
      case CompletionPromptListString() when listString != null:
        return listString(_that.value);
      case CompletionPromptString() when string != null:
        return string(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CompletionPromptListListInt extends CompletionPrompt {
  const CompletionPromptListListInt(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();
  factory CompletionPromptListListInt.fromJson(Map<String, dynamic> json) =>
      _$CompletionPromptListListIntFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionPromptListListIntCopyWith<CompletionPromptListListInt>
      get copyWith => _$CompletionPromptListListIntCopyWithImpl<
          CompletionPromptListListInt>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionPromptListListIntToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionPromptListListInt &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'CompletionPrompt.listTokens(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionPromptListListIntCopyWith<$Res>
    implements $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptListListIntCopyWith(
          CompletionPromptListListInt value,
          $Res Function(CompletionPromptListListInt) _then) =
      _$CompletionPromptListListIntCopyWithImpl;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class _$CompletionPromptListListIntCopyWithImpl<$Res>
    implements $CompletionPromptListListIntCopyWith<$Res> {
  _$CompletionPromptListListIntCopyWithImpl(this._self, this._then);

  final CompletionPromptListListInt _self;
  final $Res Function(CompletionPromptListListInt) _then;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CompletionPromptListListInt(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CompletionPromptListInt extends CompletionPrompt {
  const CompletionPromptListInt(final List<int> value, {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();
  factory CompletionPromptListInt.fromJson(Map<String, dynamic> json) =>
      _$CompletionPromptListIntFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionPromptListIntCopyWith<CompletionPromptListInt> get copyWith =>
      _$CompletionPromptListIntCopyWithImpl<CompletionPromptListInt>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionPromptListIntToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionPromptListInt &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'CompletionPrompt.tokens(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionPromptListIntCopyWith<$Res>
    implements $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptListIntCopyWith(CompletionPromptListInt value,
          $Res Function(CompletionPromptListInt) _then) =
      _$CompletionPromptListIntCopyWithImpl;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class _$CompletionPromptListIntCopyWithImpl<$Res>
    implements $CompletionPromptListIntCopyWith<$Res> {
  _$CompletionPromptListIntCopyWithImpl(this._self, this._then);

  final CompletionPromptListInt _self;
  final $Res Function(CompletionPromptListInt) _then;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CompletionPromptListInt(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CompletionPromptListString extends CompletionPrompt {
  const CompletionPromptListString(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();
  factory CompletionPromptListString.fromJson(Map<String, dynamic> json) =>
      _$CompletionPromptListStringFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionPromptListStringCopyWith<CompletionPromptListString>
      get copyWith =>
          _$CompletionPromptListStringCopyWithImpl<CompletionPromptListString>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionPromptListStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionPromptListString &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'CompletionPrompt.listString(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionPromptListStringCopyWith<$Res>
    implements $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptListStringCopyWith(CompletionPromptListString value,
          $Res Function(CompletionPromptListString) _then) =
      _$CompletionPromptListStringCopyWithImpl;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class _$CompletionPromptListStringCopyWithImpl<$Res>
    implements $CompletionPromptListStringCopyWith<$Res> {
  _$CompletionPromptListStringCopyWithImpl(this._self, this._then);

  final CompletionPromptListString _self;
  final $Res Function(CompletionPromptListString) _then;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CompletionPromptListString(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CompletionPromptString extends CompletionPrompt {
  const CompletionPromptString(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();
  factory CompletionPromptString.fromJson(Map<String, dynamic> json) =>
      _$CompletionPromptStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionPromptStringCopyWith<CompletionPromptString> get copyWith =>
      _$CompletionPromptStringCopyWithImpl<CompletionPromptString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionPromptStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionPromptString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CompletionPrompt.string(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionPromptStringCopyWith<$Res>
    implements $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptStringCopyWith(CompletionPromptString value,
          $Res Function(CompletionPromptString) _then) =
      _$CompletionPromptStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$CompletionPromptStringCopyWithImpl<$Res>
    implements $CompletionPromptStringCopyWith<$Res> {
  _$CompletionPromptStringCopyWithImpl(this._self, this._then);

  final CompletionPromptString _self;
  final $Res Function(CompletionPromptString) _then;

  /// Create a copy of CompletionPrompt
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CompletionPromptString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

CompletionStop _$CompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return CompletionStopListString.fromJson(json);
    case 'string':
      return CompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionStop {
  Object? get value;

  /// Serializes this CompletionStop to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionStop &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CompletionStop(value: $value)';
  }
}

/// @nodoc
class $CompletionStopCopyWith<$Res> {
  $CompletionStopCopyWith(CompletionStop _, $Res Function(CompletionStop) __);
}

/// Adds pattern-matching-related methods to [CompletionStop].
extension CompletionStopPatterns on CompletionStop {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CompletionStopListString() when listString != null:
        return listString(_that);
      case CompletionStopString() when string != null:
        return string(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionStopListString():
        return listString(_that);
      case CompletionStopString():
        return string(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionStopListString() when listString != null:
        return listString(_that);
      case CompletionStopString() when string != null:
        return string(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CompletionStopListString() when listString != null:
        return listString(_that.value);
      case CompletionStopString() when string != null:
        return string(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionStopListString():
        return listString(_that.value);
      case CompletionStopString():
        return string(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case CompletionStopListString() when listString != null:
        return listString(_that.value);
      case CompletionStopString() when string != null:
        return string(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CompletionStopListString extends CompletionStop {
  const CompletionStopListString(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();
  factory CompletionStopListString.fromJson(Map<String, dynamic> json) =>
      _$CompletionStopListStringFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionStopListStringCopyWith<CompletionStopListString> get copyWith =>
      _$CompletionStopListStringCopyWithImpl<CompletionStopListString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionStopListStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionStopListString &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'CompletionStop.listString(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionStopListStringCopyWith<$Res>
    implements $CompletionStopCopyWith<$Res> {
  factory $CompletionStopListStringCopyWith(CompletionStopListString value,
          $Res Function(CompletionStopListString) _then) =
      _$CompletionStopListStringCopyWithImpl;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class _$CompletionStopListStringCopyWithImpl<$Res>
    implements $CompletionStopListStringCopyWith<$Res> {
  _$CompletionStopListStringCopyWithImpl(this._self, this._then);

  final CompletionStopListString _self;
  final $Res Function(CompletionStopListString) _then;

  /// Create a copy of CompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CompletionStopListString(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CompletionStopString extends CompletionStop {
  const CompletionStopString(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();
  factory CompletionStopString.fromJson(Map<String, dynamic> json) =>
      _$CompletionStopStringFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionStopStringCopyWith<CompletionStopString> get copyWith =>
      _$CompletionStopStringCopyWithImpl<CompletionStopString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionStopStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionStopString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CompletionStop.string(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CompletionStopStringCopyWith<$Res>
    implements $CompletionStopCopyWith<$Res> {
  factory $CompletionStopStringCopyWith(CompletionStopString value,
          $Res Function(CompletionStopString) _then) =
      _$CompletionStopStringCopyWithImpl;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class _$CompletionStopStringCopyWithImpl<$Res>
    implements $CompletionStopStringCopyWith<$Res> {
  _$CompletionStopStringCopyWithImpl(this._self, this._then);

  final CompletionStopString _self;
  final $Res Function(CompletionStopString) _then;

  /// Create a copy of CompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = freezed,
  }) {
    return _then(CompletionStopString(
      freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$CreateCompletionResponse {
  /// A unique identifier for the completion.
  String get id;

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices;

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created;

  /// The model used for completion.
  String get model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;

  /// The object type, which is always "text_completion"
  CreateCompletionResponseObject get object;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;

  /// Create a copy of CreateCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateCompletionResponseCopyWith<CreateCompletionResponse> get copyWith =>
      _$CreateCompletionResponseCopyWithImpl<CreateCompletionResponse>(
          this as CreateCompletionResponse, _$identity);

  /// Serializes this CreateCompletionResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateCompletionResponse &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other.choices, choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @override
  String toString() {
    return 'CreateCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class $CreateCompletionResponseCopyWith<$Res> {
  factory $CreateCompletionResponseCopyWith(CreateCompletionResponse value,
          $Res Function(CreateCompletionResponse) _then) =
      _$CreateCompletionResponseCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateCompletionResponseCopyWithImpl<$Res>
    implements $CreateCompletionResponseCopyWith<$Res> {
  _$CreateCompletionResponseCopyWithImpl(this._self, this._then);

  final CreateCompletionResponse _self;
  final $Res Function(CreateCompletionResponse) _then;

  /// Create a copy of CreateCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _self.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _self.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }

  /// Create a copy of CreateCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateCompletionResponse].
extension CreateCompletionResponsePatterns on CreateCompletionResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateCompletionResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateCompletionResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateCompletionResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            List<CompletionChoice> choices,
            int created,
            String model,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            CreateCompletionResponseObject object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionResponse() when $default != null:
        return $default(_that.id, _that.choices, _that.created, _that.model,
            _that.systemFingerprint, _that.object, _that.usage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            List<CompletionChoice> choices,
            int created,
            String model,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            CreateCompletionResponseObject object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionResponse():
        return $default(_that.id, _that.choices, _that.created, _that.model,
            _that.systemFingerprint, _that.object, _that.usage);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            List<CompletionChoice> choices,
            int created,
            String model,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            CreateCompletionResponseObject object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateCompletionResponse() when $default != null:
        return $default(_that.id, _that.choices, _that.created, _that.model,
            _that.systemFingerprint, _that.object, _that.usage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateCompletionResponse extends CreateCompletionResponse {
  const _CreateCompletionResponse(
      {required this.id,
      required final List<CompletionChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();
  factory _CreateCompletionResponse.fromJson(Map<String, dynamic> json) =>
      _$CreateCompletionResponseFromJson(json);

  /// A unique identifier for the completion.
  @override
  final String id;

  /// The list of completion choices the model generated for the input prompt.
  final List<CompletionChoice> _choices;

  /// The list of completion choices the model generated for the input prompt.
  @override
  List<CompletionChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the completion was created.
  @override
  final int created;

  /// The model used for completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always "text_completion"
  @override
  final CreateCompletionResponseObject object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  /// Create a copy of CreateCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateCompletionResponseCopyWith<_CreateCompletionResponse> get copyWith =>
      __$CreateCompletionResponseCopyWithImpl<_CreateCompletionResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateCompletionResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateCompletionResponse &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @override
  String toString() {
    return 'CreateCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class _$CreateCompletionResponseCopyWith<$Res>
    implements $CreateCompletionResponseCopyWith<$Res> {
  factory _$CreateCompletionResponseCopyWith(_CreateCompletionResponse value,
          $Res Function(_CreateCompletionResponse) _then) =
      __$CreateCompletionResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$CreateCompletionResponseCopyWithImpl<$Res>
    implements _$CreateCompletionResponseCopyWith<$Res> {
  __$CreateCompletionResponseCopyWithImpl(this._self, this._then);

  final _CreateCompletionResponse _self;
  final $Res Function(_CreateCompletionResponse) _then;

  /// Create a copy of CreateCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_CreateCompletionResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _self._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _self.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }

  /// Create a copy of CreateCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// @nodoc
mixin _$CompletionChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason;

  /// The index of the choice in the list of generated choices.
  int get index;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs;

  /// The text of the completion.
  String get text;

  /// Create a copy of CompletionChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionChoiceCopyWith<CompletionChoice> get copyWith =>
      _$CompletionChoiceCopyWithImpl<CompletionChoice>(
          this as CompletionChoice, _$identity);

  /// Serializes this CompletionChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionChoice &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, finishReason, index, logprobs, text);

  @override
  String toString() {
    return 'CompletionChoice(finishReason: $finishReason, index: $index, logprobs: $logprobs, text: $text)';
  }
}

/// @nodoc
abstract mixin class $CompletionChoiceCopyWith<$Res> {
  factory $CompletionChoiceCopyWith(
          CompletionChoice value, $Res Function(CompletionChoice) _then) =
      _$CompletionChoiceCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$CompletionChoiceCopyWithImpl<$Res>
    implements $CompletionChoiceCopyWith<$Res> {
  _$CompletionChoiceCopyWithImpl(this._self, this._then);

  final CompletionChoice _self;
  final $Res Function(CompletionChoice) _then;

  /// Create a copy of CompletionChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_self.copyWith(
      finishReason: freezed == finishReason
          ? _self.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  /// Create a copy of CompletionChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_self.logprobs == null) {
      return null;
    }

    return $CompletionLogprobsCopyWith<$Res>(_self.logprobs!, (value) {
      return _then(_self.copyWith(logprobs: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CompletionChoice].
extension CompletionChoicePatterns on CompletionChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CompletionChoice value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionChoice() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CompletionChoice value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionChoice():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CompletionChoice value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionChoice() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                name: 'finish_reason',
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            CompletionFinishReason? finishReason,
            int index,
            CompletionLogprobs? logprobs,
            String text)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionChoice() when $default != null:
        return $default(
            _that.finishReason, _that.index, _that.logprobs, _that.text);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                name: 'finish_reason',
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            CompletionFinishReason? finishReason,
            int index,
            CompletionLogprobs? logprobs,
            String text)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionChoice():
        return $default(
            _that.finishReason, _that.index, _that.logprobs, _that.text);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(
                name: 'finish_reason',
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            CompletionFinishReason? finishReason,
            int index,
            CompletionLogprobs? logprobs,
            String text)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionChoice() when $default != null:
        return $default(
            _that.finishReason, _that.index, _that.logprobs, _that.text);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CompletionChoice extends CompletionChoice {
  const _CompletionChoice(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index,
      required this.logprobs,
      required this.text})
      : super._();
  factory _CompletionChoice.fromJson(Map<String, dynamic> json) =>
      _$CompletionChoiceFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final CompletionFinishReason? finishReason;

  /// The index of the choice in the list of generated choices.
  @override
  final int index;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  @override
  final CompletionLogprobs? logprobs;

  /// The text of the completion.
  @override
  final String text;

  /// Create a copy of CompletionChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CompletionChoiceCopyWith<_CompletionChoice> get copyWith =>
      __$CompletionChoiceCopyWithImpl<_CompletionChoice>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CompletionChoice &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, finishReason, index, logprobs, text);

  @override
  String toString() {
    return 'CompletionChoice(finishReason: $finishReason, index: $index, logprobs: $logprobs, text: $text)';
  }
}

/// @nodoc
abstract mixin class _$CompletionChoiceCopyWith<$Res>
    implements $CompletionChoiceCopyWith<$Res> {
  factory _$CompletionChoiceCopyWith(
          _CompletionChoice value, $Res Function(_CompletionChoice) _then) =
      __$CompletionChoiceCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  @override
  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$CompletionChoiceCopyWithImpl<$Res>
    implements _$CompletionChoiceCopyWith<$Res> {
  __$CompletionChoiceCopyWithImpl(this._self, this._then);

  final _CompletionChoice _self;
  final $Res Function(_CompletionChoice) _then;

  /// Create a copy of CompletionChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_CompletionChoice(
      finishReason: freezed == finishReason
          ? _self.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  /// Create a copy of CompletionChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_self.logprobs == null) {
      return null;
    }

    return $CompletionLogprobsCopyWith<$Res>(_self.logprobs!, (value) {
      return _then(_self.copyWith(logprobs: value));
    });
  }
}

/// @nodoc
mixin _$CompletionLogprobs {
  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset;

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs;

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens;

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs;

  /// Create a copy of CompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionLogprobsCopyWith<CompletionLogprobs> get copyWith =>
      _$CompletionLogprobsCopyWithImpl<CompletionLogprobs>(
          this as CompletionLogprobs, _$identity);

  /// Serializes this CompletionLogprobs to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionLogprobs &&
            const DeepCollectionEquality()
                .equals(other.textOffset, textOffset) &&
            const DeepCollectionEquality()
                .equals(other.tokenLogprobs, tokenLogprobs) &&
            const DeepCollectionEquality().equals(other.tokens, tokens) &&
            const DeepCollectionEquality()
                .equals(other.topLogprobs, topLogprobs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(textOffset),
      const DeepCollectionEquality().hash(tokenLogprobs),
      const DeepCollectionEquality().hash(tokens),
      const DeepCollectionEquality().hash(topLogprobs));

  @override
  String toString() {
    return 'CompletionLogprobs(textOffset: $textOffset, tokenLogprobs: $tokenLogprobs, tokens: $tokens, topLogprobs: $topLogprobs)';
  }
}

/// @nodoc
abstract mixin class $CompletionLogprobsCopyWith<$Res> {
  factory $CompletionLogprobsCopyWith(
          CompletionLogprobs value, $Res Function(CompletionLogprobs) _then) =
      _$CompletionLogprobsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class _$CompletionLogprobsCopyWithImpl<$Res>
    implements $CompletionLogprobsCopyWith<$Res> {
  _$CompletionLogprobsCopyWithImpl(this._self, this._then);

  final CompletionLogprobs _self;
  final $Res Function(CompletionLogprobs) _then;

  /// Create a copy of CompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_self.copyWith(
      textOffset: freezed == textOffset
          ? _self.textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _self.tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _self.tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _self.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CompletionLogprobs].
extension CompletionLogprobsPatterns on CompletionLogprobs {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CompletionLogprobs value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionLogprobs() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CompletionLogprobs value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionLogprobs():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CompletionLogprobs value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionLogprobs() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'text_offset', includeIfNull: false)
            List<int>? textOffset,
            @JsonKey(name: 'token_logprobs', includeIfNull: false)
            List<double?>? tokenLogprobs,
            @JsonKey(includeIfNull: false) List<String>? tokens,
            @JsonKey(name: 'top_logprobs', includeIfNull: false)
            List<Map<String, double>?>? topLogprobs)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionLogprobs() when $default != null:
        return $default(_that.textOffset, _that.tokenLogprobs, _that.tokens,
            _that.topLogprobs);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'text_offset', includeIfNull: false)
            List<int>? textOffset,
            @JsonKey(name: 'token_logprobs', includeIfNull: false)
            List<double?>? tokenLogprobs,
            @JsonKey(includeIfNull: false) List<String>? tokens,
            @JsonKey(name: 'top_logprobs', includeIfNull: false)
            List<Map<String, double>?>? topLogprobs)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionLogprobs():
        return $default(_that.textOffset, _that.tokenLogprobs, _that.tokens,
            _that.topLogprobs);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'text_offset', includeIfNull: false)
            List<int>? textOffset,
            @JsonKey(name: 'token_logprobs', includeIfNull: false)
            List<double?>? tokenLogprobs,
            @JsonKey(includeIfNull: false) List<String>? tokens,
            @JsonKey(name: 'top_logprobs', includeIfNull: false)
            List<Map<String, double>?>? topLogprobs)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionLogprobs() when $default != null:
        return $default(_that.textOffset, _that.tokenLogprobs, _that.tokens,
            _that.topLogprobs);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CompletionLogprobs extends CompletionLogprobs {
  const _CompletionLogprobs(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      final List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      final List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) final List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      final List<Map<String, double>?>? topLogprobs})
      : _textOffset = textOffset,
        _tokenLogprobs = tokenLogprobs,
        _tokens = tokens,
        _topLogprobs = topLogprobs,
        super._();
  factory _CompletionLogprobs.fromJson(Map<String, dynamic> json) =>
      _$CompletionLogprobsFromJson(json);

  /// The offset of the token from the beginning of the prompt.
  final List<int>? _textOffset;

  /// The offset of the token from the beginning of the prompt.
  @override
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset {
    final value = _textOffset;
    if (value == null) return null;
    if (_textOffset is EqualUnmodifiableListView) return _textOffset;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of tokens in the completion.
  final List<double?>? _tokenLogprobs;

  /// The log probabilities of tokens in the completion.
  @override
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs {
    final value = _tokenLogprobs;
    if (value == null) return null;
    if (_tokenLogprobs is EqualUnmodifiableListView) return _tokenLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The tokens generated by the model converted back to text.
  final List<String>? _tokens;

  /// The tokens generated by the model converted back to text.
  @override
  @JsonKey(includeIfNull: false)
  List<String>? get tokens {
    final value = _tokens;
    if (value == null) return null;
    if (_tokens is EqualUnmodifiableListView) return _tokens;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of the `logprobs` most likely tokens.
  final List<Map<String, double>?>? _topLogprobs;

  /// The log probabilities of the `logprobs` most likely tokens.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs {
    final value = _topLogprobs;
    if (value == null) return null;
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of CompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CompletionLogprobsCopyWith<_CompletionLogprobs> get copyWith =>
      __$CompletionLogprobsCopyWithImpl<_CompletionLogprobs>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionLogprobsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CompletionLogprobs &&
            const DeepCollectionEquality()
                .equals(other._textOffset, _textOffset) &&
            const DeepCollectionEquality()
                .equals(other._tokenLogprobs, _tokenLogprobs) &&
            const DeepCollectionEquality().equals(other._tokens, _tokens) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_textOffset),
      const DeepCollectionEquality().hash(_tokenLogprobs),
      const DeepCollectionEquality().hash(_tokens),
      const DeepCollectionEquality().hash(_topLogprobs));

  @override
  String toString() {
    return 'CompletionLogprobs(textOffset: $textOffset, tokenLogprobs: $tokenLogprobs, tokens: $tokens, topLogprobs: $topLogprobs)';
  }
}

/// @nodoc
abstract mixin class _$CompletionLogprobsCopyWith<$Res>
    implements $CompletionLogprobsCopyWith<$Res> {
  factory _$CompletionLogprobsCopyWith(
          _CompletionLogprobs value, $Res Function(_CompletionLogprobs) _then) =
      __$CompletionLogprobsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class __$CompletionLogprobsCopyWithImpl<$Res>
    implements _$CompletionLogprobsCopyWith<$Res> {
  __$CompletionLogprobsCopyWithImpl(this._self, this._then);

  final _CompletionLogprobs _self;
  final $Res Function(_CompletionLogprobs) _then;

  /// Create a copy of CompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_CompletionLogprobs(
      textOffset: freezed == textOffset
          ? _self._textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _self._tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _self._tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _self._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ));
  }
}

/// @nodoc
mixin _$CreateChatCompletionRequest {
  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models#model-endpoint-compatibility)
  /// table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model;

  /// A list of messages comprising the conversation so far. Depending on the [model](https://platform.openai.com/docs/models) you use,
  /// different message types (modalities) are supported,
  /// like [text](https://platform.openai.com/docs/guides/text-generation),
  /// [images](https://platform.openai.com/docs/guides/vision),
  /// and [audio](https://platform.openai.com/docs/guides/audio).
  List<ChatCompletionMessage> get messages;

  /// Whether or not to store the output of this chat completion request for
  /// use in our [model distillation](https://platform.openai.com/docs/guides/distillation) or
  /// [evals](https://platform.openai.com/docs/guides/evals) products.
  @JsonKey(includeIfNull: false)
  bool? get store;

  /// Constrains effort on reasoning for
  /// [reasoning models](https://platform.openai.com/docs/guides/reasoning).
  /// Currently supported values are `minimal`, `low`, `medium`, and `high`. Reducing
  /// reasoning effort can result in faster responses and fewer tokens used
  /// on reasoning in a response.
  @JsonKey(
      name: 'reasoning_effort',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ReasoningEffort? get reasoningEffort;

  /// Developer-defined tags and values used for filtering completions
  /// in the [dashboard](https://platform.openai.com/chat-completions).
  @JsonKey(includeIfNull: false)
  Map<String, String>? get metadata;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// their existing frequency in the text so far, decreasing the model's
  /// likelihood to repeat the same line verbatim.
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;

  /// Accepts a JSON object that maps tokens (specified by their token ID in the
  /// tokenizer) to an associated bias value from -100 to 100. Mathematically,
  /// the bias is added to the logits generated by the model prior to sampling.
  /// The exact effect will vary per model, but values between -1 and 1 should
  /// decrease or increase likelihood of selection; values like -100 or 100
  /// should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;

  /// Whether to return log probabilities of the output tokens or not. If true,
  /// returns the log probabilities of each output token returned in the
  /// `content` of `message`.
  @JsonKey(includeIfNull: false)
  bool? get logprobs;

  /// An integer between 0 and 20 specifying the number of most likely tokens to
  /// return at each token position, each with an associated log probability.
  /// `logprobs` must be set to `true` if this parameter is used.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  int? get topLogprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the
  /// chat completion. This value can be used to control
  /// [costs](https://openai.com/api/pricing/) for text generated via API.
  ///
  /// This value is now deprecated in favor of `max_completion_tokens`, and is
  /// not compatible with [o1 series models](https://platform.openai.com/docs/guides/reasoning).
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;

  /// An upper bound for the number of tokens that can be generated for a completion, including visible output
  /// tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  int? get maxCompletionTokens;

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on
  /// the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @JsonKey(includeIfNull: false)
  int? get n;

  /// A list of modalities that the model may use to generate the completion.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionModality>? get modalities;

  /// Configuration for a [Predicted Output](https://platform.openai.com/docs/guides/predicted-outputs),
  /// which can greatly improve response times when large parts of the model
  /// response are known ahead of time. This is most common when you are
  /// regenerating a file with only minor changes to most of the content.
  @JsonKey(includeIfNull: false)
  PredictionContent? get prediction;

  /// Parameters for audio output. Required when audio output is requested with `modalities: ["audio"]`.
  /// [Learn more](https://platform.openai.com/docs/guides/audio).
  @JsonKey(includeIfNull: false)
  ChatCompletionAudioOptions? get audio;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// whether they appear in the text so far, increasing the model's likelihood
  /// to talk about new topics.
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;

  /// This tool searches the web for relevant results to use in a response.
  @JsonKey(name: 'web_search_options', includeIfNull: false)
  WebSearchOptions? get webSearchOptions;

  /// An object specifying the format that the model must output.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables
  /// Structured Outputs which ensures the model will match your supplied JSON
  /// schema. Learn more in the [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures
  /// the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model
  /// to produce JSON yourself via a system or user message. Without this, the
  /// model may generate an unending stream of whitespace until the generation
  /// reaches the token limit, resulting in a long-running and seemingly "stuck"
  /// request. Also note that the message content may be partially cut off if
  /// `finish_reason="length"`, which indicates the generation exceeded
  /// `max_tokens` or the conversation exceeded the max context length.
  /// Any of: [ResponseFormatText], [ResponseFormatJsonObject], [ResponseFormatJsonSchema]
  @JsonKey(name: 'response_format', includeIfNull: false)
  ResponseFormat? get responseFormat;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests
  /// with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to
  /// monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;

  /// Specifies the latency tier to use for processing the request. This parameter is relevant for customers
  /// subscribed to the Flex Processing service:
  ///   - If set to 'auto', and the Project is Flex Processing enabled, the system will utilize flex credits
  ///     until they are exhausted.
  ///   - If set to 'auto', and the Project is not Flex Processing enabled, the request will be processed using the
  ///     default service tier with a lower uptime SLA and no latency guarantee.
  ///   - If set to 'default', the request will be processed using the default service tier with a lower uptime
  ///     SLA and no latency guarantee.
  ///   - When not set, the default behavior is 'auto'.
  ///
  ///   When this parameter is set, the response body will include the `service_tier` utilized.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CreateChatCompletionRequestServiceTier? get serviceTier;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only  [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message.  [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @JsonKey(name: 'stream_options', includeIfNull: false)
  ChatCompletionStreamOptions? get streamOptions;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// An alternative to sampling with temperature, called nucleus sampling,
  /// where the model considers the results of the tokens with top_p probability
  /// mass. So 0.1 means only the tokens comprising the top 10% probability mass
  /// are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// A list of tools the model may call. Currently, only functions are supported as a tool.
  /// Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are
  /// supported.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tool and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools.
  /// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the
  /// model to call that tool.
  ///
  /// `none` is the default when no tools are present. `auto` is the default if tools are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  ///
  /// `none` means the model will not call a function and instead generates a
  /// message.
  ///
  /// `auto` means the model can pick between generating a message or calling a
  /// function.
  ///
  /// Specifying a particular function via `{"name": "my_function"}` forces the
  /// model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default
  /// if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions;

  /// Constrains the verbosity of the model's response. Lower values will result in
  /// more concise responses, while higher values will result in more verbose responses.
  /// Currently supported values are `low`, `medium`, and `high`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  Verbosity? get verbosity;

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateChatCompletionRequestCopyWith<CreateChatCompletionRequest>
      get copyWith => _$CreateChatCompletionRequestCopyWithImpl<
              CreateChatCompletionRequest>(
          this as CreateChatCompletionRequest, _$identity);

  /// Serializes this CreateChatCompletionRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateChatCompletionRequest &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other.messages, messages) &&
            (identical(other.store, store) || other.store == store) &&
            (identical(other.reasoningEffort, reasoningEffort) ||
                other.reasoningEffort == reasoningEffort) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality().equals(other.logitBias, logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.topLogprobs, topLogprobs) ||
                other.topLogprobs == topLogprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.n, n) || other.n == n) &&
            const DeepCollectionEquality()
                .equals(other.modalities, modalities) &&
            (identical(other.prediction, prediction) ||
                other.prediction == prediction) &&
            (identical(other.audio, audio) || other.audio == audio) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.webSearchOptions, webSearchOptions) ||
                other.webSearchOptions == webSearchOptions) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.streamOptions, streamOptions) ||
                other.streamOptions == streamOptions) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            const DeepCollectionEquality().equals(other.tools, tools) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality().equals(other.functions, functions) &&
            (identical(other.verbosity, verbosity) ||
                other.verbosity == verbosity));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        model,
        const DeepCollectionEquality().hash(messages),
        store,
        reasoningEffort,
        const DeepCollectionEquality().hash(metadata),
        frequencyPenalty,
        const DeepCollectionEquality().hash(logitBias),
        logprobs,
        topLogprobs,
        maxTokens,
        maxCompletionTokens,
        n,
        const DeepCollectionEquality().hash(modalities),
        prediction,
        audio,
        presencePenalty,
        webSearchOptions,
        responseFormat,
        seed,
        serviceTier,
        stop,
        stream,
        streamOptions,
        temperature,
        topP,
        const DeepCollectionEquality().hash(tools),
        toolChoice,
        parallelToolCalls,
        user,
        functionCall,
        const DeepCollectionEquality().hash(functions),
        verbosity
      ]);

  @override
  String toString() {
    return 'CreateChatCompletionRequest(model: $model, messages: $messages, store: $store, reasoningEffort: $reasoningEffort, metadata: $metadata, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, topLogprobs: $topLogprobs, maxTokens: $maxTokens, maxCompletionTokens: $maxCompletionTokens, n: $n, modalities: $modalities, prediction: $prediction, audio: $audio, presencePenalty: $presencePenalty, webSearchOptions: $webSearchOptions, responseFormat: $responseFormat, seed: $seed, serviceTier: $serviceTier, stop: $stop, stream: $stream, streamOptions: $streamOptions, temperature: $temperature, topP: $topP, tools: $tools, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, user: $user, functionCall: $functionCall, functions: $functions, verbosity: $verbosity)';
  }
}

/// @nodoc
abstract mixin class $CreateChatCompletionRequestCopyWith<$Res> {
  factory $CreateChatCompletionRequestCopyWith(
          CreateChatCompletionRequest value,
          $Res Function(CreateChatCompletionRequest) _then) =
      _$CreateChatCompletionRequestCopyWithImpl;
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(includeIfNull: false) bool? store,
      @JsonKey(
          name: 'reasoning_effort',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ReasoningEffort? reasoningEffort,
      @JsonKey(includeIfNull: false) Map<String, String>? metadata,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(includeIfNull: false) List<ChatCompletionModality>? modalities,
      @JsonKey(includeIfNull: false) PredictionContent? prediction,
      @JsonKey(includeIfNull: false) ChatCompletionAudioOptions? audio,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'web_search_options', includeIfNull: false)
      WebSearchOptions? webSearchOptions,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CreateChatCompletionRequestServiceTier? serviceTier,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      Verbosity? verbosity});

  $ChatCompletionModelCopyWith<$Res> get model;
  $PredictionContentCopyWith<$Res>? get prediction;
  $ChatCompletionAudioOptionsCopyWith<$Res>? get audio;
  $WebSearchOptionsCopyWith<$Res>? get webSearchOptions;
  $ResponseFormatCopyWith<$Res>? get responseFormat;
  $ChatCompletionStopCopyWith<$Res>? get stop;
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$CreateChatCompletionRequestCopyWithImpl<$Res>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  _$CreateChatCompletionRequestCopyWithImpl(this._self, this._then);

  final CreateChatCompletionRequest _self;
  final $Res Function(CreateChatCompletionRequest) _then;

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? store = freezed,
    Object? reasoningEffort = freezed,
    Object? metadata = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? topLogprobs = freezed,
    Object? maxTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? n = freezed,
    Object? modalities = freezed,
    Object? prediction = freezed,
    Object? audio = freezed,
    Object? presencePenalty = freezed,
    Object? webSearchOptions = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? serviceTier = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
    Object? verbosity = freezed,
  }) {
    return _then(_self.copyWith(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _self.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      store: freezed == store
          ? _self.store
          : store // ignore: cast_nullable_to_non_nullable
              as bool?,
      reasoningEffort: freezed == reasoningEffort
          ? _self.reasoningEffort
          : reasoningEffort // ignore: cast_nullable_to_non_nullable
              as ReasoningEffort?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _self.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _self.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as bool?,
      topLogprobs: freezed == topLogprobs
          ? _self.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _self.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _self.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      modalities: freezed == modalities
          ? _self.modalities
          : modalities // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionModality>?,
      prediction: freezed == prediction
          ? _self.prediction
          : prediction // ignore: cast_nullable_to_non_nullable
              as PredictionContent?,
      audio: freezed == audio
          ? _self.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAudioOptions?,
      presencePenalty: freezed == presencePenalty
          ? _self.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      webSearchOptions: freezed == webSearchOptions
          ? _self.webSearchOptions
          : webSearchOptions // ignore: cast_nullable_to_non_nullable
              as WebSearchOptions?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ResponseFormat?,
      seed: freezed == seed
          ? _self.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      serviceTier: freezed == serviceTier
          ? _self.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionRequestServiceTier?,
      stop: freezed == stop
          ? _self.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _self.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _self.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _self.functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
      verbosity: freezed == verbosity
          ? _self.verbosity
          : verbosity // ignore: cast_nullable_to_non_nullable
              as Verbosity?,
    ));
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionModelCopyWith<$Res> get model {
    return $ChatCompletionModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PredictionContentCopyWith<$Res>? get prediction {
    if (_self.prediction == null) {
      return null;
    }

    return $PredictionContentCopyWith<$Res>(_self.prediction!, (value) {
      return _then(_self.copyWith(prediction: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionAudioOptionsCopyWith<$Res>? get audio {
    if (_self.audio == null) {
      return null;
    }

    return $ChatCompletionAudioOptionsCopyWith<$Res>(_self.audio!, (value) {
      return _then(_self.copyWith(audio: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WebSearchOptionsCopyWith<$Res>? get webSearchOptions {
    if (_self.webSearchOptions == null) {
      return null;
    }

    return $WebSearchOptionsCopyWith<$Res>(_self.webSearchOptions!, (value) {
      return _then(_self.copyWith(webSearchOptions: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $ResponseFormatCopyWith<$Res>(_self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStopCopyWith<$Res>? get stop {
    if (_self.stop == null) {
      return null;
    }

    return $ChatCompletionStopCopyWith<$Res>(_self.stop!, (value) {
      return _then(_self.copyWith(stop: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions {
    if (_self.streamOptions == null) {
      return null;
    }

    return $ChatCompletionStreamOptionsCopyWith<$Res>(_self.streamOptions!,
        (value) {
      return _then(_self.copyWith(streamOptions: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $ChatCompletionToolChoiceOptionCopyWith<$Res>(_self.toolChoice!,
        (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall {
    if (_self.functionCall == null) {
      return null;
    }

    return $ChatCompletionFunctionCallCopyWith<$Res>(_self.functionCall!,
        (value) {
      return _then(_self.copyWith(functionCall: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateChatCompletionRequest].
extension CreateChatCompletionRequestPatterns on CreateChatCompletionRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateChatCompletionRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateChatCompletionRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateChatCompletionRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @_ChatCompletionModelConverter() ChatCompletionModel model,
            List<ChatCompletionMessage> messages,
            @JsonKey(includeIfNull: false) bool? store,
            @JsonKey(
                name: 'reasoning_effort',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ReasoningEffort? reasoningEffort,
            @JsonKey(includeIfNull: false) Map<String, String>? metadata,
            @JsonKey(name: 'frequency_penalty', includeIfNull: false)
            double? frequencyPenalty,
            @JsonKey(name: 'logit_bias', includeIfNull: false)
            Map<String, int>? logitBias,
            @JsonKey(includeIfNull: false) bool? logprobs,
            @JsonKey(name: 'top_logprobs', includeIfNull: false)
            int? topLogprobs,
            @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionModality>? modalities,
            @JsonKey(includeIfNull: false) PredictionContent? prediction,
            @JsonKey(includeIfNull: false) ChatCompletionAudioOptions? audio,
            @JsonKey(name: 'presence_penalty', includeIfNull: false)
            double? presencePenalty,
            @JsonKey(name: 'web_search_options', includeIfNull: false)
            WebSearchOptions? webSearchOptions,
            @JsonKey(name: 'response_format', includeIfNull: false)
            ResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) int? seed,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            CreateChatCompletionRequestServiceTier? serviceTier,
            @_ChatCompletionStopConverter()
            @JsonKey(includeIfNull: false)
            ChatCompletionStop? stop,
            @JsonKey(includeIfNull: false) bool? stream,
            @JsonKey(name: 'stream_options', includeIfNull: false)
            ChatCompletionStreamOptions? streamOptions,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
            @_ChatCompletionToolChoiceOptionConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            ChatCompletionToolChoiceOption? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @JsonKey(includeIfNull: false) String? user,
            @_ChatCompletionFunctionCallConverter()
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionFunctionCall? functionCall,
            @JsonKey(includeIfNull: false) List<FunctionObject>? functions,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            Verbosity? verbosity)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionRequest() when $default != null:
        return $default(
            _that.model,
            _that.messages,
            _that.store,
            _that.reasoningEffort,
            _that.metadata,
            _that.frequencyPenalty,
            _that.logitBias,
            _that.logprobs,
            _that.topLogprobs,
            _that.maxTokens,
            _that.maxCompletionTokens,
            _that.n,
            _that.modalities,
            _that.prediction,
            _that.audio,
            _that.presencePenalty,
            _that.webSearchOptions,
            _that.responseFormat,
            _that.seed,
            _that.serviceTier,
            _that.stop,
            _that.stream,
            _that.streamOptions,
            _that.temperature,
            _that.topP,
            _that.tools,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.user,
            _that.functionCall,
            _that.functions,
            _that.verbosity);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @_ChatCompletionModelConverter() ChatCompletionModel model,
            List<ChatCompletionMessage> messages,
            @JsonKey(includeIfNull: false) bool? store,
            @JsonKey(
                name: 'reasoning_effort',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ReasoningEffort? reasoningEffort,
            @JsonKey(includeIfNull: false) Map<String, String>? metadata,
            @JsonKey(name: 'frequency_penalty', includeIfNull: false)
            double? frequencyPenalty,
            @JsonKey(name: 'logit_bias', includeIfNull: false)
            Map<String, int>? logitBias,
            @JsonKey(includeIfNull: false) bool? logprobs,
            @JsonKey(name: 'top_logprobs', includeIfNull: false)
            int? topLogprobs,
            @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionModality>? modalities,
            @JsonKey(includeIfNull: false) PredictionContent? prediction,
            @JsonKey(includeIfNull: false) ChatCompletionAudioOptions? audio,
            @JsonKey(name: 'presence_penalty', includeIfNull: false)
            double? presencePenalty,
            @JsonKey(name: 'web_search_options', includeIfNull: false)
            WebSearchOptions? webSearchOptions,
            @JsonKey(name: 'response_format', includeIfNull: false)
            ResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) int? seed,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            CreateChatCompletionRequestServiceTier? serviceTier,
            @_ChatCompletionStopConverter()
            @JsonKey(includeIfNull: false)
            ChatCompletionStop? stop,
            @JsonKey(includeIfNull: false) bool? stream,
            @JsonKey(name: 'stream_options', includeIfNull: false)
            ChatCompletionStreamOptions? streamOptions,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
            @_ChatCompletionToolChoiceOptionConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            ChatCompletionToolChoiceOption? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @JsonKey(includeIfNull: false) String? user,
            @_ChatCompletionFunctionCallConverter()
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionFunctionCall? functionCall,
            @JsonKey(includeIfNull: false) List<FunctionObject>? functions,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            Verbosity? verbosity)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionRequest():
        return $default(
            _that.model,
            _that.messages,
            _that.store,
            _that.reasoningEffort,
            _that.metadata,
            _that.frequencyPenalty,
            _that.logitBias,
            _that.logprobs,
            _that.topLogprobs,
            _that.maxTokens,
            _that.maxCompletionTokens,
            _that.n,
            _that.modalities,
            _that.prediction,
            _that.audio,
            _that.presencePenalty,
            _that.webSearchOptions,
            _that.responseFormat,
            _that.seed,
            _that.serviceTier,
            _that.stop,
            _that.stream,
            _that.streamOptions,
            _that.temperature,
            _that.topP,
            _that.tools,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.user,
            _that.functionCall,
            _that.functions,
            _that.verbosity);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @_ChatCompletionModelConverter() ChatCompletionModel model,
            List<ChatCompletionMessage> messages,
            @JsonKey(includeIfNull: false) bool? store,
            @JsonKey(
                name: 'reasoning_effort',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ReasoningEffort? reasoningEffort,
            @JsonKey(includeIfNull: false) Map<String, String>? metadata,
            @JsonKey(name: 'frequency_penalty', includeIfNull: false)
            double? frequencyPenalty,
            @JsonKey(name: 'logit_bias', includeIfNull: false)
            Map<String, int>? logitBias,
            @JsonKey(includeIfNull: false) bool? logprobs,
            @JsonKey(name: 'top_logprobs', includeIfNull: false)
            int? topLogprobs,
            @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionModality>? modalities,
            @JsonKey(includeIfNull: false) PredictionContent? prediction,
            @JsonKey(includeIfNull: false) ChatCompletionAudioOptions? audio,
            @JsonKey(name: 'presence_penalty', includeIfNull: false)
            double? presencePenalty,
            @JsonKey(name: 'web_search_options', includeIfNull: false)
            WebSearchOptions? webSearchOptions,
            @JsonKey(name: 'response_format', includeIfNull: false)
            ResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) int? seed,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            CreateChatCompletionRequestServiceTier? serviceTier,
            @_ChatCompletionStopConverter()
            @JsonKey(includeIfNull: false)
            ChatCompletionStop? stop,
            @JsonKey(includeIfNull: false) bool? stream,
            @JsonKey(name: 'stream_options', includeIfNull: false)
            ChatCompletionStreamOptions? streamOptions,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
            @_ChatCompletionToolChoiceOptionConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            ChatCompletionToolChoiceOption? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @JsonKey(includeIfNull: false) String? user,
            @_ChatCompletionFunctionCallConverter()
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionFunctionCall? functionCall,
            @JsonKey(includeIfNull: false) List<FunctionObject>? functions,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            Verbosity? verbosity)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionRequest() when $default != null:
        return $default(
            _that.model,
            _that.messages,
            _that.store,
            _that.reasoningEffort,
            _that.metadata,
            _that.frequencyPenalty,
            _that.logitBias,
            _that.logprobs,
            _that.topLogprobs,
            _that.maxTokens,
            _that.maxCompletionTokens,
            _that.n,
            _that.modalities,
            _that.prediction,
            _that.audio,
            _that.presencePenalty,
            _that.webSearchOptions,
            _that.responseFormat,
            _that.seed,
            _that.serviceTier,
            _that.stop,
            _that.stream,
            _that.streamOptions,
            _that.temperature,
            _that.topP,
            _that.tools,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.user,
            _that.functionCall,
            _that.functions,
            _that.verbosity);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateChatCompletionRequest extends CreateChatCompletionRequest {
  const _CreateChatCompletionRequest(
      {@_ChatCompletionModelConverter() required this.model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(includeIfNull: false) this.store,
      @JsonKey(
          name: 'reasoning_effort',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.reasoningEffort,
      @JsonKey(includeIfNull: false) final Map<String, String>? metadata,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) this.topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      this.maxCompletionTokens,
      @JsonKey(includeIfNull: false) this.n,
      @JsonKey(includeIfNull: false)
      final List<ChatCompletionModality>? modalities,
      @JsonKey(includeIfNull: false) this.prediction,
      @JsonKey(includeIfNull: false) this.audio,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty,
      @JsonKey(name: 'web_search_options', includeIfNull: false)
      this.webSearchOptions,
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.seed,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.serviceTier,
      @_ChatCompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(name: 'stream_options', includeIfNull: false) this.streamOptions,
      @JsonKey(includeIfNull: false) this.temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      this.parallelToolCalls,
      @JsonKey(includeIfNull: false) this.user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      this.functionCall,
      @JsonKey(includeIfNull: false) final List<FunctionObject>? functions,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.verbosity})
      : _messages = messages,
        _metadata = metadata,
        _logitBias = logitBias,
        _modalities = modalities,
        _tools = tools,
        _functions = functions,
        super._();
  factory _CreateChatCompletionRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateChatCompletionRequestFromJson(json);

  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models#model-endpoint-compatibility)
  /// table for details on which models work with the Chat API.
  @override
  @_ChatCompletionModelConverter()
  final ChatCompletionModel model;

  /// A list of messages comprising the conversation so far. Depending on the [model](https://platform.openai.com/docs/models) you use,
  /// different message types (modalities) are supported,
  /// like [text](https://platform.openai.com/docs/guides/text-generation),
  /// [images](https://platform.openai.com/docs/guides/vision),
  /// and [audio](https://platform.openai.com/docs/guides/audio).
  final List<ChatCompletionMessage> _messages;

  /// A list of messages comprising the conversation so far. Depending on the [model](https://platform.openai.com/docs/models) you use,
  /// different message types (modalities) are supported,
  /// like [text](https://platform.openai.com/docs/guides/text-generation),
  /// [images](https://platform.openai.com/docs/guides/vision),
  /// and [audio](https://platform.openai.com/docs/guides/audio).
  @override
  List<ChatCompletionMessage> get messages {
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_messages);
  }

  /// Whether or not to store the output of this chat completion request for
  /// use in our [model distillation](https://platform.openai.com/docs/guides/distillation) or
  /// [evals](https://platform.openai.com/docs/guides/evals) products.
  @override
  @JsonKey(includeIfNull: false)
  final bool? store;

  /// Constrains effort on reasoning for
  /// [reasoning models](https://platform.openai.com/docs/guides/reasoning).
  /// Currently supported values are `minimal`, `low`, `medium`, and `high`. Reducing
  /// reasoning effort can result in faster responses and fewer tokens used
  /// on reasoning in a response.
  @override
  @JsonKey(
      name: 'reasoning_effort',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ReasoningEffort? reasoningEffort;

  /// Developer-defined tags and values used for filtering completions
  /// in the [dashboard](https://platform.openai.com/chat-completions).
  final Map<String, String>? _metadata;

  /// Developer-defined tags and values used for filtering completions
  /// in the [dashboard](https://platform.openai.com/chat-completions).
  @override
  @JsonKey(includeIfNull: false)
  Map<String, String>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// their existing frequency in the text so far, decreasing the model's
  /// likelihood to repeat the same line verbatim.
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Accepts a JSON object that maps tokens (specified by their token ID in the
  /// tokenizer) to an associated bias value from -100 to 100. Mathematically,
  /// the bias is added to the logits generated by the model prior to sampling.
  /// The exact effect will vary per model, but values between -1 and 1 should
  /// decrease or increase likelihood of selection; values like -100 or 100
  /// should result in a ban or exclusive selection of the relevant token.
  final Map<String, int>? _logitBias;

  /// Accepts a JSON object that maps tokens (specified by their token ID in the
  /// tokenizer) to an associated bias value from -100 to 100. Mathematically,
  /// the bias is added to the logits generated by the model prior to sampling.
  /// The exact effect will vary per model, but values between -1 and 1 should
  /// decrease or increase likelihood of selection; values like -100 or 100
  /// should result in a ban or exclusive selection of the relevant token.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Whether to return log probabilities of the output tokens or not. If true,
  /// returns the log probabilities of each output token returned in the
  /// `content` of `message`.
  @override
  @JsonKey(includeIfNull: false)
  final bool? logprobs;

  /// An integer between 0 and 20 specifying the number of most likely tokens to
  /// return at each token position, each with an associated log probability.
  /// `logprobs` must be set to `true` if this parameter is used.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  final int? topLogprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the
  /// chat completion. This value can be used to control
  /// [costs](https://openai.com/api/pricing/) for text generated via API.
  ///
  /// This value is now deprecated in favor of `max_completion_tokens`, and is
  /// not compatible with [o1 series models](https://platform.openai.com/docs/guides/reasoning).
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// An upper bound for the number of tokens that can be generated for a completion, including visible output
  /// tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).
  @override
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  final int? maxCompletionTokens;

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on
  /// the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// A list of modalities that the model may use to generate the completion.
  final List<ChatCompletionModality>? _modalities;

  /// A list of modalities that the model may use to generate the completion.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionModality>? get modalities {
    final value = _modalities;
    if (value == null) return null;
    if (_modalities is EqualUnmodifiableListView) return _modalities;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Configuration for a [Predicted Output](https://platform.openai.com/docs/guides/predicted-outputs),
  /// which can greatly improve response times when large parts of the model
  /// response are known ahead of time. This is most common when you are
  /// regenerating a file with only minor changes to most of the content.
  @override
  @JsonKey(includeIfNull: false)
  final PredictionContent? prediction;

  /// Parameters for audio output. Required when audio output is requested with `modalities: ["audio"]`.
  /// [Learn more](https://platform.openai.com/docs/guides/audio).
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionAudioOptions? audio;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on
  /// whether they appear in the text so far, increasing the model's likelihood
  /// to talk about new topics.
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// This tool searches the web for relevant results to use in a response.
  @override
  @JsonKey(name: 'web_search_options', includeIfNull: false)
  final WebSearchOptions? webSearchOptions;

  /// An object specifying the format that the model must output.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables
  /// Structured Outputs which ensures the model will match your supplied JSON
  /// schema. Learn more in the [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures
  /// the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model
  /// to produce JSON yourself via a system or user message. Without this, the
  /// model may generate an unending stream of whitespace until the generation
  /// reaches the token limit, resulting in a long-running and seemingly "stuck"
  /// request. Also note that the message content may be partially cut off if
  /// `finish_reason="length"`, which indicates the generation exceeded
  /// `max_tokens` or the conversation exceeded the max context length.
  /// Any of: [ResponseFormatText], [ResponseFormatJsonObject], [ResponseFormatJsonSchema]
  @override
  @JsonKey(name: 'response_format', includeIfNull: false)
  final ResponseFormat? responseFormat;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests
  /// with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to
  /// monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Specifies the latency tier to use for processing the request. This parameter is relevant for customers
  /// subscribed to the Flex Processing service:
  ///   - If set to 'auto', and the Project is Flex Processing enabled, the system will utilize flex credits
  ///     until they are exhausted.
  ///   - If set to 'auto', and the Project is not Flex Processing enabled, the request will be processed using the
  ///     default service tier with a lower uptime SLA and no latency guarantee.
  ///   - If set to 'default', the request will be processed using the default service tier with a lower uptime
  ///     SLA and no latency guarantee.
  ///   - When not set, the default behavior is 'auto'.
  ///
  ///   When this parameter is set, the response body will include the `service_tier` utilized.
  @override
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final CreateChatCompletionRequestServiceTier? serviceTier;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @override
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final ChatCompletionStop? stop;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only  [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message.  [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @override
  @JsonKey(name: 'stream_options', includeIfNull: false)
  final ChatCompletionStreamOptions? streamOptions;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling,
  /// where the model considers the results of the tokens with top_p probability
  /// mass. So 0.1 means only the tokens comprising the top 10% probability mass
  /// are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A list of tools the model may call. Currently, only functions are supported as a tool.
  /// Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are
  /// supported.
  final List<ChatCompletionTool>? _tools;

  /// A list of tools the model may call. Currently, only functions are supported as a tool.
  /// Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are
  /// supported.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tool and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools.
  /// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the
  /// model to call that tool.
  ///
  /// `none` is the default when no tools are present. `auto` is the default if tools are present.
  @override
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final ChatCompletionToolChoiceOption? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  final bool? parallelToolCalls;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  ///
  /// `none` means the model will not call a function and instead generates a
  /// message.
  ///
  /// `auto` means the model can pick between generating a message or calling a
  /// function.
  ///
  /// Specifying a particular function via `{"name": "my_function"}` forces the
  /// model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default
  /// if functions are present.
  @override
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionFunctionCall? functionCall;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  final List<FunctionObject>? _functions;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions {
    final value = _functions;
    if (value == null) return null;
    if (_functions is EqualUnmodifiableListView) return _functions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Constrains the verbosity of the model's response. Lower values will result in
  /// more concise responses, while higher values will result in more verbose responses.
  /// Currently supported values are `low`, `medium`, and `high`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final Verbosity? verbosity;

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateChatCompletionRequestCopyWith<_CreateChatCompletionRequest>
      get copyWith => __$CreateChatCompletionRequestCopyWithImpl<
          _CreateChatCompletionRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateChatCompletionRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateChatCompletionRequest &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            (identical(other.store, store) || other.store == store) &&
            (identical(other.reasoningEffort, reasoningEffort) ||
                other.reasoningEffort == reasoningEffort) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.topLogprobs, topLogprobs) ||
                other.topLogprobs == topLogprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.n, n) || other.n == n) &&
            const DeepCollectionEquality()
                .equals(other._modalities, _modalities) &&
            (identical(other.prediction, prediction) ||
                other.prediction == prediction) &&
            (identical(other.audio, audio) || other.audio == audio) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.webSearchOptions, webSearchOptions) ||
                other.webSearchOptions == webSearchOptions) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.streamOptions, streamOptions) ||
                other.streamOptions == streamOptions) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._functions, _functions) &&
            (identical(other.verbosity, verbosity) ||
                other.verbosity == verbosity));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        model,
        const DeepCollectionEquality().hash(_messages),
        store,
        reasoningEffort,
        const DeepCollectionEquality().hash(_metadata),
        frequencyPenalty,
        const DeepCollectionEquality().hash(_logitBias),
        logprobs,
        topLogprobs,
        maxTokens,
        maxCompletionTokens,
        n,
        const DeepCollectionEquality().hash(_modalities),
        prediction,
        audio,
        presencePenalty,
        webSearchOptions,
        responseFormat,
        seed,
        serviceTier,
        stop,
        stream,
        streamOptions,
        temperature,
        topP,
        const DeepCollectionEquality().hash(_tools),
        toolChoice,
        parallelToolCalls,
        user,
        functionCall,
        const DeepCollectionEquality().hash(_functions),
        verbosity
      ]);

  @override
  String toString() {
    return 'CreateChatCompletionRequest(model: $model, messages: $messages, store: $store, reasoningEffort: $reasoningEffort, metadata: $metadata, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, topLogprobs: $topLogprobs, maxTokens: $maxTokens, maxCompletionTokens: $maxCompletionTokens, n: $n, modalities: $modalities, prediction: $prediction, audio: $audio, presencePenalty: $presencePenalty, webSearchOptions: $webSearchOptions, responseFormat: $responseFormat, seed: $seed, serviceTier: $serviceTier, stop: $stop, stream: $stream, streamOptions: $streamOptions, temperature: $temperature, topP: $topP, tools: $tools, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, user: $user, functionCall: $functionCall, functions: $functions, verbosity: $verbosity)';
  }
}

/// @nodoc
abstract mixin class _$CreateChatCompletionRequestCopyWith<$Res>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  factory _$CreateChatCompletionRequestCopyWith(
          _CreateChatCompletionRequest value,
          $Res Function(_CreateChatCompletionRequest) _then) =
      __$CreateChatCompletionRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(includeIfNull: false) bool? store,
      @JsonKey(
          name: 'reasoning_effort',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ReasoningEffort? reasoningEffort,
      @JsonKey(includeIfNull: false) Map<String, String>? metadata,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(includeIfNull: false) List<ChatCompletionModality>? modalities,
      @JsonKey(includeIfNull: false) PredictionContent? prediction,
      @JsonKey(includeIfNull: false) ChatCompletionAudioOptions? audio,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'web_search_options', includeIfNull: false)
      WebSearchOptions? webSearchOptions,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CreateChatCompletionRequestServiceTier? serviceTier,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      Verbosity? verbosity});

  @override
  $ChatCompletionModelCopyWith<$Res> get model;
  @override
  $PredictionContentCopyWith<$Res>? get prediction;
  @override
  $ChatCompletionAudioOptionsCopyWith<$Res>? get audio;
  @override
  $WebSearchOptionsCopyWith<$Res>? get webSearchOptions;
  @override
  $ResponseFormatCopyWith<$Res>? get responseFormat;
  @override
  $ChatCompletionStopCopyWith<$Res>? get stop;
  @override
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
  @override
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  @override
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$CreateChatCompletionRequestCopyWithImpl<$Res>
    implements _$CreateChatCompletionRequestCopyWith<$Res> {
  __$CreateChatCompletionRequestCopyWithImpl(this._self, this._then);

  final _CreateChatCompletionRequest _self;
  final $Res Function(_CreateChatCompletionRequest) _then;

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? store = freezed,
    Object? reasoningEffort = freezed,
    Object? metadata = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? topLogprobs = freezed,
    Object? maxTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? n = freezed,
    Object? modalities = freezed,
    Object? prediction = freezed,
    Object? audio = freezed,
    Object? presencePenalty = freezed,
    Object? webSearchOptions = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? serviceTier = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
    Object? verbosity = freezed,
  }) {
    return _then(_CreateChatCompletionRequest(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _self._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      store: freezed == store
          ? _self.store
          : store // ignore: cast_nullable_to_non_nullable
              as bool?,
      reasoningEffort: freezed == reasoningEffort
          ? _self.reasoningEffort
          : reasoningEffort // ignore: cast_nullable_to_non_nullable
              as ReasoningEffort?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _self.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _self._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as bool?,
      topLogprobs: freezed == topLogprobs
          ? _self.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _self.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _self.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      modalities: freezed == modalities
          ? _self._modalities
          : modalities // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionModality>?,
      prediction: freezed == prediction
          ? _self.prediction
          : prediction // ignore: cast_nullable_to_non_nullable
              as PredictionContent?,
      audio: freezed == audio
          ? _self.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAudioOptions?,
      presencePenalty: freezed == presencePenalty
          ? _self.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      webSearchOptions: freezed == webSearchOptions
          ? _self.webSearchOptions
          : webSearchOptions // ignore: cast_nullable_to_non_nullable
              as WebSearchOptions?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ResponseFormat?,
      seed: freezed == seed
          ? _self.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      serviceTier: freezed == serviceTier
          ? _self.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionRequestServiceTier?,
      stop: freezed == stop
          ? _self.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _self.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _self.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _self._functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
      verbosity: freezed == verbosity
          ? _self.verbosity
          : verbosity // ignore: cast_nullable_to_non_nullable
              as Verbosity?,
    ));
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionModelCopyWith<$Res> get model {
    return $ChatCompletionModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PredictionContentCopyWith<$Res>? get prediction {
    if (_self.prediction == null) {
      return null;
    }

    return $PredictionContentCopyWith<$Res>(_self.prediction!, (value) {
      return _then(_self.copyWith(prediction: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionAudioOptionsCopyWith<$Res>? get audio {
    if (_self.audio == null) {
      return null;
    }

    return $ChatCompletionAudioOptionsCopyWith<$Res>(_self.audio!, (value) {
      return _then(_self.copyWith(audio: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WebSearchOptionsCopyWith<$Res>? get webSearchOptions {
    if (_self.webSearchOptions == null) {
      return null;
    }

    return $WebSearchOptionsCopyWith<$Res>(_self.webSearchOptions!, (value) {
      return _then(_self.copyWith(webSearchOptions: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $ResponseFormatCopyWith<$Res>(_self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStopCopyWith<$Res>? get stop {
    if (_self.stop == null) {
      return null;
    }

    return $ChatCompletionStopCopyWith<$Res>(_self.stop!, (value) {
      return _then(_self.copyWith(stop: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions {
    if (_self.streamOptions == null) {
      return null;
    }

    return $ChatCompletionStreamOptionsCopyWith<$Res>(_self.streamOptions!,
        (value) {
      return _then(_self.copyWith(streamOptions: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $ChatCompletionToolChoiceOptionCopyWith<$Res>(_self.toolChoice!,
        (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of CreateChatCompletionRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall {
    if (_self.functionCall == null) {
      return null;
    }

    return $ChatCompletionFunctionCallCopyWith<$Res>(_self.functionCall!,
        (value) {
      return _then(_self.copyWith(functionCall: value));
    });
  }
}

ChatCompletionModel _$ChatCompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ChatCompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return ChatCompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionModel {
  Object get value;

  /// Serializes this ChatCompletionModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ChatCompletionModel(value: $value)';
  }
}

/// @nodoc
class $ChatCompletionModelCopyWith<$Res> {
  $ChatCompletionModelCopyWith(
      ChatCompletionModel _, $Res Function(ChatCompletionModel) __);
}

/// Adds pattern-matching-related methods to [ChatCompletionModel].
extension ChatCompletionModelPatterns on ChatCompletionModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionModelEnumeration() when model != null:
        return model(_that);
      case ChatCompletionModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionModelEnumeration():
        return model(_that);
      case ChatCompletionModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionModelEnumeration() when model != null:
        return model(_that);
      case ChatCompletionModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionModelEnumeration() when model != null:
        return model(_that.value);
      case ChatCompletionModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionModelEnumeration():
        return model(_that.value);
      case ChatCompletionModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionModelEnumeration() when model != null:
        return model(_that.value);
      case ChatCompletionModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionModelEnumeration extends ChatCompletionModel {
  const ChatCompletionModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory ChatCompletionModelEnumeration.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionModelEnumerationFromJson(json);

  @override
  final ChatCompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionModelEnumerationCopyWith<ChatCompletionModelEnumeration>
      get copyWith => _$ChatCompletionModelEnumerationCopyWithImpl<
          ChatCompletionModelEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionModelEnumerationCopyWith<$Res>
    implements $ChatCompletionModelCopyWith<$Res> {
  factory $ChatCompletionModelEnumerationCopyWith(
          ChatCompletionModelEnumeration value,
          $Res Function(ChatCompletionModelEnumeration) _then) =
      _$ChatCompletionModelEnumerationCopyWithImpl;
  @useResult
  $Res call({ChatCompletionModels value});
}

/// @nodoc
class _$ChatCompletionModelEnumerationCopyWithImpl<$Res>
    implements $ChatCompletionModelEnumerationCopyWith<$Res> {
  _$ChatCompletionModelEnumerationCopyWithImpl(this._self, this._then);

  final ChatCompletionModelEnumeration _self;
  final $Res Function(ChatCompletionModelEnumeration) _then;

  /// Create a copy of ChatCompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionModelString extends ChatCompletionModel {
  const ChatCompletionModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory ChatCompletionModelString.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionModelStringCopyWith<ChatCompletionModelString> get copyWith =>
      _$ChatCompletionModelStringCopyWithImpl<ChatCompletionModelString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionModelStringCopyWith<$Res>
    implements $ChatCompletionModelCopyWith<$Res> {
  factory $ChatCompletionModelStringCopyWith(ChatCompletionModelString value,
          $Res Function(ChatCompletionModelString) _then) =
      _$ChatCompletionModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$ChatCompletionModelStringCopyWithImpl<$Res>
    implements $ChatCompletionModelStringCopyWith<$Res> {
  _$ChatCompletionModelStringCopyWithImpl(this._self, this._then);

  final ChatCompletionModelString _self;
  final $Res Function(ChatCompletionModelString) _then;

  /// Create a copy of ChatCompletionModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

ChatCompletionStop _$ChatCompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return ChatCompletionStopListString.fromJson(json);
    case 'string':
      return ChatCompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionStop {
  Object? get value;

  /// Serializes this ChatCompletionStop to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStop &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ChatCompletionStop(value: $value)';
  }
}

/// @nodoc
class $ChatCompletionStopCopyWith<$Res> {
  $ChatCompletionStopCopyWith(
      ChatCompletionStop _, $Res Function(ChatCompletionStop) __);
}

/// Adds pattern-matching-related methods to [ChatCompletionStop].
extension ChatCompletionStopPatterns on ChatCompletionStop {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionStopListString() when listString != null:
        return listString(_that);
      case ChatCompletionStopString() when string != null:
        return string(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionStopListString():
        return listString(_that);
      case ChatCompletionStopString():
        return string(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionStopListString() when listString != null:
        return listString(_that);
      case ChatCompletionStopString() when string != null:
        return string(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionStopListString() when listString != null:
        return listString(_that.value);
      case ChatCompletionStopString() when string != null:
        return string(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionStopListString():
        return listString(_that.value);
      case ChatCompletionStopString():
        return string(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionStopListString() when listString != null:
        return listString(_that.value);
      case ChatCompletionStopString() when string != null:
        return string(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionStopListString extends ChatCompletionStop {
  const ChatCompletionStopListString(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();
  factory ChatCompletionStopListString.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionStopListStringFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStopListStringCopyWith<ChatCompletionStopListString>
      get copyWith => _$ChatCompletionStopListStringCopyWithImpl<
          ChatCompletionStopListString>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStopListStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStopListString &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'ChatCompletionStop.listString(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStopListStringCopyWith<$Res>
    implements $ChatCompletionStopCopyWith<$Res> {
  factory $ChatCompletionStopListStringCopyWith(
          ChatCompletionStopListString value,
          $Res Function(ChatCompletionStopListString) _then) =
      _$ChatCompletionStopListStringCopyWithImpl;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class _$ChatCompletionStopListStringCopyWithImpl<$Res>
    implements $ChatCompletionStopListStringCopyWith<$Res> {
  _$ChatCompletionStopListStringCopyWithImpl(this._self, this._then);

  final ChatCompletionStopListString _self;
  final $Res Function(ChatCompletionStopListString) _then;

  /// Create a copy of ChatCompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionStopListString(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionStopString extends ChatCompletionStop {
  const ChatCompletionStopString(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();
  factory ChatCompletionStopString.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionStopStringFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStopStringCopyWith<ChatCompletionStopString> get copyWith =>
      _$ChatCompletionStopStringCopyWithImpl<ChatCompletionStopString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStopStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStopString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionStop.string(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStopStringCopyWith<$Res>
    implements $ChatCompletionStopCopyWith<$Res> {
  factory $ChatCompletionStopStringCopyWith(ChatCompletionStopString value,
          $Res Function(ChatCompletionStopString) _then) =
      _$ChatCompletionStopStringCopyWithImpl;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class _$ChatCompletionStopStringCopyWithImpl<$Res>
    implements $ChatCompletionStopStringCopyWith<$Res> {
  _$ChatCompletionStopStringCopyWithImpl(this._self, this._then);

  final ChatCompletionStopString _self;
  final $Res Function(ChatCompletionStopString) _then;

  /// Create a copy of ChatCompletionStop
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = freezed,
  }) {
    return _then(ChatCompletionStopString(
      freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

ChatCompletionToolChoiceOption _$ChatCompletionToolChoiceOptionFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionToolChoiceOptionEnumeration.fromJson(json);
    case 'tool':
      return ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionToolChoiceOption',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionToolChoiceOption {
  Object get value;

  /// Serializes this ChatCompletionToolChoiceOption to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionToolChoiceOption &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption(value: $value)';
  }
}

/// @nodoc
class $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  $ChatCompletionToolChoiceOptionCopyWith(ChatCompletionToolChoiceOption _,
      $Res Function(ChatCompletionToolChoiceOption) __);
}

/// Adds pattern-matching-related methods to [ChatCompletionToolChoiceOption].
extension ChatCompletionToolChoiceOptionPatterns
    on ChatCompletionToolChoiceOption {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionToolChoiceOptionEnumeration() when mode != null:
        return mode(_that);
      case ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice()
          when tool != null:
        return tool(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionToolChoiceOptionEnumeration():
        return mode(_that);
      case ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice():
        return tool(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionToolChoiceOptionEnumeration() when mode != null:
        return mode(_that);
      case ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice()
          when tool != null:
        return tool(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionToolChoiceOptionEnumeration() when mode != null:
        return mode(_that.value);
      case ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice()
          when tool != null:
        return tool(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionToolChoiceOptionEnumeration():
        return mode(_that.value);
      case ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice():
        return tool(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionToolChoiceOptionEnumeration() when mode != null:
        return mode(_that.value);
      case ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice()
          when tool != null:
        return tool(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionToolChoiceOptionEnumeration
    extends ChatCompletionToolChoiceOption {
  const ChatCompletionToolChoiceOptionEnumeration(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory ChatCompletionToolChoiceOptionEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionToolChoiceOptionEnumerationFromJson(json);

  @override
  final ChatCompletionToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionToolChoiceOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionEnumerationCopyWith<
          ChatCompletionToolChoiceOptionEnumeration>
      get copyWith => _$ChatCompletionToolChoiceOptionEnumerationCopyWithImpl<
          ChatCompletionToolChoiceOptionEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionToolChoiceOptionEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionToolChoiceOptionEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionToolChoiceOptionEnumerationCopyWith<$Res>
    implements $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  factory $ChatCompletionToolChoiceOptionEnumerationCopyWith(
          ChatCompletionToolChoiceOptionEnumeration value,
          $Res Function(ChatCompletionToolChoiceOptionEnumeration) _then) =
      _$ChatCompletionToolChoiceOptionEnumerationCopyWithImpl;
  @useResult
  $Res call({ChatCompletionToolChoiceMode value});
}

/// @nodoc
class _$ChatCompletionToolChoiceOptionEnumerationCopyWithImpl<$Res>
    implements $ChatCompletionToolChoiceOptionEnumerationCopyWith<$Res> {
  _$ChatCompletionToolChoiceOptionEnumerationCopyWithImpl(
      this._self, this._then);

  final ChatCompletionToolChoiceOptionEnumeration _self;
  final $Res Function(ChatCompletionToolChoiceOptionEnumeration) _then;

  /// Create a copy of ChatCompletionToolChoiceOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionToolChoiceOptionEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
    extends ChatCompletionToolChoiceOption {
  const ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice(this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();
  factory ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceFromJson(
          json);

  @override
  final ChatCompletionNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionToolChoiceOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWith<
          ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice>
      get copyWith =>
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWithImpl<
                  ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.tool(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWith<
    $Res> implements $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  factory $ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWith(
          ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value,
          $Res Function(
                  ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice)
              _then) =
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWithImpl;
  @useResult
  $Res call({ChatCompletionNamedToolChoice value});

  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWithImpl<
        $Res>
    implements
        $ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWith<
            $Res> {
  _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceCopyWithImpl(
      this._self, this._then);

  final ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice _self;
  final $Res Function(
      ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice) _then;

  /// Create a copy of ChatCompletionToolChoiceOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoice,
    ));
  }

  /// Create a copy of ChatCompletionToolChoiceOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value {
    return $ChatCompletionNamedToolChoiceCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

ChatCompletionFunctionCall _$ChatCompletionFunctionCallFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionFunctionCallEnumeration.fromJson(json);
    case 'function':
      return ChatCompletionFunctionCallChatCompletionFunctionCallOption
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionFunctionCall',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionFunctionCall {
  Object get value;

  /// Serializes this ChatCompletionFunctionCall to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionFunctionCall &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ChatCompletionFunctionCall(value: $value)';
  }
}

/// @nodoc
class $ChatCompletionFunctionCallCopyWith<$Res> {
  $ChatCompletionFunctionCallCopyWith(ChatCompletionFunctionCall _,
      $Res Function(ChatCompletionFunctionCall) __);
}

/// Adds pattern-matching-related methods to [ChatCompletionFunctionCall].
extension ChatCompletionFunctionCallPatterns on ChatCompletionFunctionCall {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionFunctionCallEnumeration() when mode != null:
        return mode(_that);
      case ChatCompletionFunctionCallChatCompletionFunctionCallOption()
          when function != null:
        return function(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionFunctionCallEnumeration():
        return mode(_that);
      case ChatCompletionFunctionCallChatCompletionFunctionCallOption():
        return function(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionFunctionCallEnumeration() when mode != null:
        return mode(_that);
      case ChatCompletionFunctionCallChatCompletionFunctionCallOption()
          when function != null:
        return function(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionFunctionCallEnumeration() when mode != null:
        return mode(_that.value);
      case ChatCompletionFunctionCallChatCompletionFunctionCallOption()
          when function != null:
        return function(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionFunctionCallEnumeration():
        return mode(_that.value);
      case ChatCompletionFunctionCallChatCompletionFunctionCallOption():
        return function(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionFunctionCallEnumeration() when mode != null:
        return mode(_that.value);
      case ChatCompletionFunctionCallChatCompletionFunctionCallOption()
          when function != null:
        return function(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionFunctionCallEnumeration extends ChatCompletionFunctionCall {
  const ChatCompletionFunctionCallEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory ChatCompletionFunctionCallEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionFunctionCallEnumerationFromJson(json);

  @override
  final ChatCompletionFunctionCallMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallEnumerationCopyWith<
          ChatCompletionFunctionCallEnumeration>
      get copyWith => _$ChatCompletionFunctionCallEnumerationCopyWithImpl<
          ChatCompletionFunctionCallEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionFunctionCallEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionFunctionCallEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionFunctionCallEnumerationCopyWith<$Res>
    implements $ChatCompletionFunctionCallCopyWith<$Res> {
  factory $ChatCompletionFunctionCallEnumerationCopyWith(
          ChatCompletionFunctionCallEnumeration value,
          $Res Function(ChatCompletionFunctionCallEnumeration) _then) =
      _$ChatCompletionFunctionCallEnumerationCopyWithImpl;
  @useResult
  $Res call({ChatCompletionFunctionCallMode value});
}

/// @nodoc
class _$ChatCompletionFunctionCallEnumerationCopyWithImpl<$Res>
    implements $ChatCompletionFunctionCallEnumerationCopyWith<$Res> {
  _$ChatCompletionFunctionCallEnumerationCopyWithImpl(this._self, this._then);

  final ChatCompletionFunctionCallEnumeration _self;
  final $Res Function(ChatCompletionFunctionCallEnumeration) _then;

  /// Create a copy of ChatCompletionFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionFunctionCallEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionFunctionCallChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCall {
  const ChatCompletionFunctionCallChatCompletionFunctionCallOption(this.value,
      {final String? $type})
      : $type = $type ?? 'function',
        super._();
  factory ChatCompletionFunctionCallChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionFromJson(
          json);

  @override
  final ChatCompletionFunctionCallOption value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWith<
          ChatCompletionFunctionCallChatCompletionFunctionCallOption>
      get copyWith =>
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWithImpl<
                  ChatCompletionFunctionCallChatCompletionFunctionCallOption>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is ChatCompletionFunctionCallChatCompletionFunctionCallOption &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.function(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWith<
    $Res> implements $ChatCompletionFunctionCallCopyWith<$Res> {
  factory $ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWith(
          ChatCompletionFunctionCallChatCompletionFunctionCallOption value,
          $Res Function(
                  ChatCompletionFunctionCallChatCompletionFunctionCallOption)
              _then) =
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWithImpl;
  @useResult
  $Res call({ChatCompletionFunctionCallOption value});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value;
}

/// @nodoc
class _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWithImpl<
        $Res>
    implements
        $ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWith<
            $Res> {
  _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionCopyWithImpl(
      this._self, this._then);

  final ChatCompletionFunctionCallChatCompletionFunctionCallOption _self;
  final $Res Function(
      ChatCompletionFunctionCallChatCompletionFunctionCallOption) _then;

  /// Create a copy of ChatCompletionFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionFunctionCallChatCompletionFunctionCallOption(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }

  /// Create a copy of ChatCompletionFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_self.value,
        (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionMessageFunctionCall {
  /// The name of the function to call.
  String get name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments;

  /// Create a copy of ChatCompletionMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<ChatCompletionMessageFunctionCall>
      get copyWith => _$ChatCompletionMessageFunctionCallCopyWithImpl<
              ChatCompletionMessageFunctionCall>(
          this as ChatCompletionMessageFunctionCall, _$identity);

  /// Serializes this ChatCompletionMessageFunctionCall to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageFunctionCall &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @override
  String toString() {
    return 'ChatCompletionMessageFunctionCall(name: $name, arguments: $arguments)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionMessageFunctionCallCopyWith(
          ChatCompletionMessageFunctionCall value,
          $Res Function(ChatCompletionMessageFunctionCall) _then) =
      _$ChatCompletionMessageFunctionCallCopyWithImpl;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionMessageFunctionCallCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageFunctionCall _self;
  final $Res Function(ChatCompletionMessageFunctionCall) _then;

  /// Create a copy of ChatCompletionMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionMessageFunctionCall].
extension ChatCompletionMessageFunctionCallPatterns
    on ChatCompletionMessageFunctionCall {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageFunctionCall value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageFunctionCall() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageFunctionCall value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageFunctionCall():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionMessageFunctionCall value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageFunctionCall() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String name, String arguments)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageFunctionCall() when $default != null:
        return $default(_that.name, _that.arguments);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String name, String arguments) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageFunctionCall():
        return $default(_that.name, _that.arguments);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String name, String arguments)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageFunctionCall() when $default != null:
        return $default(_that.name, _that.arguments);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionMessageFunctionCall
    extends ChatCompletionMessageFunctionCall {
  const _ChatCompletionMessageFunctionCall(
      {required this.name, required this.arguments})
      : super._();
  factory _ChatCompletionMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionMessageFunctionCallFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  final String arguments;

  /// Create a copy of ChatCompletionMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionMessageFunctionCallCopyWith<
          _ChatCompletionMessageFunctionCall>
      get copyWith => __$ChatCompletionMessageFunctionCallCopyWithImpl<
          _ChatCompletionMessageFunctionCall>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageFunctionCallToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionMessageFunctionCall &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @override
  String toString() {
    return 'ChatCompletionMessageFunctionCall(name: $name, arguments: $arguments)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionMessageFunctionCallCopyWith<$Res>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory _$ChatCompletionMessageFunctionCallCopyWith(
          _ChatCompletionMessageFunctionCall value,
          $Res Function(_ChatCompletionMessageFunctionCall) _then) =
      __$ChatCompletionMessageFunctionCallCopyWithImpl;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$ChatCompletionMessageFunctionCallCopyWithImpl<$Res>
    implements _$ChatCompletionMessageFunctionCallCopyWith<$Res> {
  __$ChatCompletionMessageFunctionCallCopyWithImpl(this._self, this._then);

  final _ChatCompletionMessageFunctionCall _self;
  final $Res Function(_ChatCompletionMessageFunctionCall) _then;

  /// Create a copy of ChatCompletionMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_ChatCompletionMessageFunctionCall(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionFunctionCallOption {
  /// The name of the function to call.
  String get name;

  /// Create a copy of ChatCompletionFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<ChatCompletionFunctionCallOption>
      get copyWith => _$ChatCompletionFunctionCallOptionCopyWithImpl<
              ChatCompletionFunctionCallOption>(
          this as ChatCompletionFunctionCallOption, _$identity);

  /// Serializes this ChatCompletionFunctionCallOption to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionFunctionCallOption &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @override
  String toString() {
    return 'ChatCompletionFunctionCallOption(name: $name)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory $ChatCompletionFunctionCallOptionCopyWith(
          ChatCompletionFunctionCallOption value,
          $Res Function(ChatCompletionFunctionCallOption) _then) =
      _$ChatCompletionFunctionCallOptionCopyWithImpl;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  _$ChatCompletionFunctionCallOptionCopyWithImpl(this._self, this._then);

  final ChatCompletionFunctionCallOption _self;
  final $Res Function(ChatCompletionFunctionCallOption) _then;

  /// Create a copy of ChatCompletionFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionFunctionCallOption].
extension ChatCompletionFunctionCallOptionPatterns
    on ChatCompletionFunctionCallOption {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionFunctionCallOption value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionFunctionCallOption() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionFunctionCallOption value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionFunctionCallOption():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionFunctionCallOption value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionFunctionCallOption() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String name)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionFunctionCallOption() when $default != null:
        return $default(_that.name);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String name) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionFunctionCallOption():
        return $default(_that.name);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String name)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionFunctionCallOption() when $default != null:
        return $default(_that.name);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCallOption {
  const _ChatCompletionFunctionCallOption({required this.name}) : super._();
  factory _ChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionFunctionCallOptionFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  /// Create a copy of ChatCompletionFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionFunctionCallOptionCopyWith<_ChatCompletionFunctionCallOption>
      get copyWith => __$ChatCompletionFunctionCallOptionCopyWithImpl<
          _ChatCompletionFunctionCallOption>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionFunctionCallOptionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionFunctionCallOption &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @override
  String toString() {
    return 'ChatCompletionFunctionCallOption(name: $name)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionFunctionCallOptionCopyWith<$Res>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory _$ChatCompletionFunctionCallOptionCopyWith(
          _ChatCompletionFunctionCallOption value,
          $Res Function(_ChatCompletionFunctionCallOption) _then) =
      __$ChatCompletionFunctionCallOptionCopyWithImpl;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$ChatCompletionFunctionCallOptionCopyWithImpl<$Res>
    implements _$ChatCompletionFunctionCallOptionCopyWith<$Res> {
  __$ChatCompletionFunctionCallOptionCopyWithImpl(this._self, this._then);

  final _ChatCompletionFunctionCallOption _self;
  final $Res Function(_ChatCompletionFunctionCallOption) _then;

  /// Create a copy of ChatCompletionFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
  }) {
    return _then(_ChatCompletionFunctionCallOption(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$FunctionObject {
  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a
  /// maximum length of 64.
  String get name;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @JsonKey(includeIfNull: false)
  FunctionParameters? get parameters;

  /// Whether to enable strict schema adherence when generating the function call. If set to true, the model will
  /// follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when
  /// `strict` is `true`. Learn more about Structured Outputs in the
  /// [function calling guide](](https://platform.openai.com/docs/guides/function-calling).
  @JsonKey(includeIfNull: false)
  bool? get strict;

  /// Create a copy of FunctionObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<FunctionObject> get copyWith =>
      _$FunctionObjectCopyWithImpl<FunctionObject>(
          this as FunctionObject, _$identity);

  /// Serializes this FunctionObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FunctionObject &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other.parameters, parameters) &&
            (identical(other.strict, strict) || other.strict == strict));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(parameters), strict);

  @override
  String toString() {
    return 'FunctionObject(name: $name, description: $description, parameters: $parameters, strict: $strict)';
  }
}

/// @nodoc
abstract mixin class $FunctionObjectCopyWith<$Res> {
  factory $FunctionObjectCopyWith(
          FunctionObject value, $Res Function(FunctionObject) _then) =
      _$FunctionObjectCopyWithImpl;
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) FunctionParameters? parameters,
      @JsonKey(includeIfNull: false) bool? strict});
}

/// @nodoc
class _$FunctionObjectCopyWithImpl<$Res>
    implements $FunctionObjectCopyWith<$Res> {
  _$FunctionObjectCopyWithImpl(this._self, this._then);

  final FunctionObject _self;
  final $Res Function(FunctionObject) _then;

  /// Create a copy of FunctionObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = freezed,
    Object? strict = freezed,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _self.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as FunctionParameters?,
      strict: freezed == strict
          ? _self.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [FunctionObject].
extension FunctionObjectPatterns on FunctionObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FunctionObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FunctionObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FunctionObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FunctionObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FunctionObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FunctionObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) FunctionParameters? parameters,
            @JsonKey(includeIfNull: false) bool? strict)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FunctionObject() when $default != null:
        return $default(
            _that.name, _that.description, _that.parameters, _that.strict);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) FunctionParameters? parameters,
            @JsonKey(includeIfNull: false) bool? strict)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FunctionObject():
        return $default(
            _that.name, _that.description, _that.parameters, _that.strict);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) FunctionParameters? parameters,
            @JsonKey(includeIfNull: false) bool? strict)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FunctionObject() when $default != null:
        return $default(
            _that.name, _that.description, _that.parameters, _that.strict);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FunctionObject extends FunctionObject {
  const _FunctionObject(
      {required this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) final FunctionParameters? parameters,
      @JsonKey(includeIfNull: false) this.strict = false})
      : _parameters = parameters,
        super._();
  factory _FunctionObject.fromJson(Map<String, dynamic> json) =>
      _$FunctionObjectFromJson(json);

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a
  /// maximum length of 64.
  @override
  final String name;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  final FunctionParameters? _parameters;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @override
  @JsonKey(includeIfNull: false)
  FunctionParameters? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Whether to enable strict schema adherence when generating the function call. If set to true, the model will
  /// follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when
  /// `strict` is `true`. Learn more about Structured Outputs in the
  /// [function calling guide](](https://platform.openai.com/docs/guides/function-calling).
  @override
  @JsonKey(includeIfNull: false)
  final bool? strict;

  /// Create a copy of FunctionObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FunctionObjectCopyWith<_FunctionObject> get copyWith =>
      __$FunctionObjectCopyWithImpl<_FunctionObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FunctionObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FunctionObject &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            (identical(other.strict, strict) || other.strict == strict));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(_parameters), strict);

  @override
  String toString() {
    return 'FunctionObject(name: $name, description: $description, parameters: $parameters, strict: $strict)';
  }
}

/// @nodoc
abstract mixin class _$FunctionObjectCopyWith<$Res>
    implements $FunctionObjectCopyWith<$Res> {
  factory _$FunctionObjectCopyWith(
          _FunctionObject value, $Res Function(_FunctionObject) _then) =
      __$FunctionObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) FunctionParameters? parameters,
      @JsonKey(includeIfNull: false) bool? strict});
}

/// @nodoc
class __$FunctionObjectCopyWithImpl<$Res>
    implements _$FunctionObjectCopyWith<$Res> {
  __$FunctionObjectCopyWithImpl(this._self, this._then);

  final _FunctionObject _self;
  final $Res Function(_FunctionObject) _then;

  /// Create a copy of FunctionObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = freezed,
    Object? strict = freezed,
  }) {
    return _then(_FunctionObject(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _self._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as FunctionParameters?,
      strict: freezed == strict
          ? _self.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$JsonSchemaObject {
  /// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
  /// length of 64.
  String get name;

  /// A description of what the response format is for, used by the model to determine how to respond in the
  /// format.
  @JsonKey(includeIfNull: false)
  String? get description;

  /// The schema for the response format, described as a JSON Schema object.
  Map<String, dynamic> get schema;

  /// Whether to enable strict schema adherence when generating the output. If set to true, the model will always
  /// follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when
  /// `strict` is `true`. To learn more, read the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  @JsonKey(includeIfNull: false)
  bool? get strict;

  /// Create a copy of JsonSchemaObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $JsonSchemaObjectCopyWith<JsonSchemaObject> get copyWith =>
      _$JsonSchemaObjectCopyWithImpl<JsonSchemaObject>(
          this as JsonSchemaObject, _$identity);

  /// Serializes this JsonSchemaObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is JsonSchemaObject &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other.schema, schema) &&
            (identical(other.strict, strict) || other.strict == strict));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(schema), strict);

  @override
  String toString() {
    return 'JsonSchemaObject(name: $name, description: $description, schema: $schema, strict: $strict)';
  }
}

/// @nodoc
abstract mixin class $JsonSchemaObjectCopyWith<$Res> {
  factory $JsonSchemaObjectCopyWith(
          JsonSchemaObject value, $Res Function(JsonSchemaObject) _then) =
      _$JsonSchemaObjectCopyWithImpl;
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      Map<String, dynamic> schema,
      @JsonKey(includeIfNull: false) bool? strict});
}

/// @nodoc
class _$JsonSchemaObjectCopyWithImpl<$Res>
    implements $JsonSchemaObjectCopyWith<$Res> {
  _$JsonSchemaObjectCopyWithImpl(this._self, this._then);

  final JsonSchemaObject _self;
  final $Res Function(JsonSchemaObject) _then;

  /// Create a copy of JsonSchemaObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? schema = null,
    Object? strict = freezed,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: null == schema
          ? _self.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      strict: freezed == strict
          ? _self.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [JsonSchemaObject].
extension JsonSchemaObjectPatterns on JsonSchemaObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_JsonSchemaObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsonSchemaObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_JsonSchemaObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsonSchemaObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_JsonSchemaObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsonSchemaObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String name,
            @JsonKey(includeIfNull: false) String? description,
            Map<String, dynamic> schema,
            @JsonKey(includeIfNull: false) bool? strict)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _JsonSchemaObject() when $default != null:
        return $default(
            _that.name, _that.description, _that.schema, _that.strict);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String name,
            @JsonKey(includeIfNull: false) String? description,
            Map<String, dynamic> schema,
            @JsonKey(includeIfNull: false) bool? strict)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsonSchemaObject():
        return $default(
            _that.name, _that.description, _that.schema, _that.strict);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String name,
            @JsonKey(includeIfNull: false) String? description,
            Map<String, dynamic> schema,
            @JsonKey(includeIfNull: false) bool? strict)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _JsonSchemaObject() when $default != null:
        return $default(
            _that.name, _that.description, _that.schema, _that.strict);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _JsonSchemaObject extends JsonSchemaObject {
  const _JsonSchemaObject(
      {required this.name,
      @JsonKey(includeIfNull: false) this.description,
      required final Map<String, dynamic> schema,
      @JsonKey(includeIfNull: false) this.strict = false})
      : _schema = schema,
        super._();
  factory _JsonSchemaObject.fromJson(Map<String, dynamic> json) =>
      _$JsonSchemaObjectFromJson(json);

  /// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
  /// length of 64.
  @override
  final String name;

  /// A description of what the response format is for, used by the model to determine how to respond in the
  /// format.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The schema for the response format, described as a JSON Schema object.
  final Map<String, dynamic> _schema;

  /// The schema for the response format, described as a JSON Schema object.
  @override
  Map<String, dynamic> get schema {
    if (_schema is EqualUnmodifiableMapView) return _schema;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_schema);
  }

  /// Whether to enable strict schema adherence when generating the output. If set to true, the model will always
  /// follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when
  /// `strict` is `true`. To learn more, read the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  @override
  @JsonKey(includeIfNull: false)
  final bool? strict;

  /// Create a copy of JsonSchemaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$JsonSchemaObjectCopyWith<_JsonSchemaObject> get copyWith =>
      __$JsonSchemaObjectCopyWithImpl<_JsonSchemaObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$JsonSchemaObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _JsonSchemaObject &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._schema, _schema) &&
            (identical(other.strict, strict) || other.strict == strict));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(_schema), strict);

  @override
  String toString() {
    return 'JsonSchemaObject(name: $name, description: $description, schema: $schema, strict: $strict)';
  }
}

/// @nodoc
abstract mixin class _$JsonSchemaObjectCopyWith<$Res>
    implements $JsonSchemaObjectCopyWith<$Res> {
  factory _$JsonSchemaObjectCopyWith(
          _JsonSchemaObject value, $Res Function(_JsonSchemaObject) _then) =
      __$JsonSchemaObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      Map<String, dynamic> schema,
      @JsonKey(includeIfNull: false) bool? strict});
}

/// @nodoc
class __$JsonSchemaObjectCopyWithImpl<$Res>
    implements _$JsonSchemaObjectCopyWith<$Res> {
  __$JsonSchemaObjectCopyWithImpl(this._self, this._then);

  final _JsonSchemaObject _self;
  final $Res Function(_JsonSchemaObject) _then;

  /// Create a copy of JsonSchemaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? schema = null,
    Object? strict = freezed,
  }) {
    return _then(_JsonSchemaObject(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: null == schema
          ? _self._schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      strict: freezed == strict
          ? _self.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionTool {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type;

  /// A function that the model may call.
  FunctionObject get function;

  /// Create a copy of ChatCompletionTool
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionToolCopyWith<ChatCompletionTool> get copyWith =>
      _$ChatCompletionToolCopyWithImpl<ChatCompletionTool>(
          this as ChatCompletionTool, _$identity);

  /// Serializes this ChatCompletionTool to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionTool &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @override
  String toString() {
    return 'ChatCompletionTool(type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionToolCopyWith<$Res> {
  factory $ChatCompletionToolCopyWith(
          ChatCompletionTool value, $Res Function(ChatCompletionTool) _then) =
      _$ChatCompletionToolCopyWithImpl;
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionToolCopyWithImpl<$Res>
    implements $ChatCompletionToolCopyWith<$Res> {
  _$ChatCompletionToolCopyWithImpl(this._self, this._then);

  final ChatCompletionTool _self;
  final $Res Function(ChatCompletionTool) _then;

  /// Create a copy of ChatCompletionTool
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }

  /// Create a copy of ChatCompletionTool
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_self.function, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionTool].
extension ChatCompletionToolPatterns on ChatCompletionTool {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionTool value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTool() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionTool value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTool():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionTool value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTool() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ChatCompletionToolType type, FunctionObject function)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTool() when $default != null:
        return $default(_that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ChatCompletionToolType type, FunctionObject function)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTool():
        return $default(_that.type, _that.function);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(ChatCompletionToolType type, FunctionObject function)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTool() when $default != null:
        return $default(_that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionTool extends ChatCompletionTool {
  const _ChatCompletionTool({required this.type, required this.function})
      : super._();
  factory _ChatCompletionTool.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionToolFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionToolType type;

  /// A function that the model may call.
  @override
  final FunctionObject function;

  /// Create a copy of ChatCompletionTool
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionToolCopyWith<_ChatCompletionTool> get copyWith =>
      __$ChatCompletionToolCopyWithImpl<_ChatCompletionTool>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionToolToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionTool &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @override
  String toString() {
    return 'ChatCompletionTool(type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionToolCopyWith<$Res>
    implements $ChatCompletionToolCopyWith<$Res> {
  factory _$ChatCompletionToolCopyWith(
          _ChatCompletionTool value, $Res Function(_ChatCompletionTool) _then) =
      __$ChatCompletionToolCopyWithImpl;
  @override
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  @override
  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class __$ChatCompletionToolCopyWithImpl<$Res>
    implements _$ChatCompletionToolCopyWith<$Res> {
  __$ChatCompletionToolCopyWithImpl(this._self, this._then);

  final _ChatCompletionTool _self;
  final $Res Function(_ChatCompletionTool) _then;

  /// Create a copy of ChatCompletionTool
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_ChatCompletionTool(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }

  /// Create a copy of ChatCompletionTool
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_self.function, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionNamedToolChoice {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionNamedToolChoiceType get type;

  /// Forces the model to call the specified function.
  ChatCompletionFunctionCallOption get function;

  /// Create a copy of ChatCompletionNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionNamedToolChoiceCopyWith<ChatCompletionNamedToolChoice>
      get copyWith => _$ChatCompletionNamedToolChoiceCopyWithImpl<
              ChatCompletionNamedToolChoice>(
          this as ChatCompletionNamedToolChoice, _$identity);

  /// Serializes this ChatCompletionNamedToolChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionNamedToolChoice &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @override
  String toString() {
    return 'ChatCompletionNamedToolChoice(type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory $ChatCompletionNamedToolChoiceCopyWith(
          ChatCompletionNamedToolChoice value,
          $Res Function(ChatCompletionNamedToolChoice) _then) =
      _$ChatCompletionNamedToolChoiceCopyWithImpl;
  @useResult
  $Res call(
      {ChatCompletionNamedToolChoiceType type,
      ChatCompletionFunctionCallOption function});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  _$ChatCompletionNamedToolChoiceCopyWithImpl(this._self, this._then);

  final ChatCompletionNamedToolChoice _self;
  final $Res Function(ChatCompletionNamedToolChoice) _then;

  /// Create a copy of ChatCompletionNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }

  /// Create a copy of ChatCompletionNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_self.function,
        (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionNamedToolChoice].
extension ChatCompletionNamedToolChoicePatterns
    on ChatCompletionNamedToolChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionNamedToolChoice value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionNamedToolChoice() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionNamedToolChoice value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionNamedToolChoice():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionNamedToolChoice value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionNamedToolChoice() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(ChatCompletionNamedToolChoiceType type,
            ChatCompletionFunctionCallOption function)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionNamedToolChoice() when $default != null:
        return $default(_that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(ChatCompletionNamedToolChoiceType type,
            ChatCompletionFunctionCallOption function)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionNamedToolChoice():
        return $default(_that.type, _that.function);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(ChatCompletionNamedToolChoiceType type,
            ChatCompletionFunctionCallOption function)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionNamedToolChoice() when $default != null:
        return $default(_that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionNamedToolChoice extends ChatCompletionNamedToolChoice {
  const _ChatCompletionNamedToolChoice(
      {required this.type, required this.function})
      : super._();
  factory _ChatCompletionNamedToolChoice.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionNamedToolChoiceFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionNamedToolChoiceType type;

  /// Forces the model to call the specified function.
  @override
  final ChatCompletionFunctionCallOption function;

  /// Create a copy of ChatCompletionNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionNamedToolChoiceCopyWith<_ChatCompletionNamedToolChoice>
      get copyWith => __$ChatCompletionNamedToolChoiceCopyWithImpl<
          _ChatCompletionNamedToolChoice>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionNamedToolChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionNamedToolChoice &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @override
  String toString() {
    return 'ChatCompletionNamedToolChoice(type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionNamedToolChoiceCopyWith<$Res>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory _$ChatCompletionNamedToolChoiceCopyWith(
          _ChatCompletionNamedToolChoice value,
          $Res Function(_ChatCompletionNamedToolChoice) _then) =
      __$ChatCompletionNamedToolChoiceCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionNamedToolChoiceType type,
      ChatCompletionFunctionCallOption function});

  @override
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function;
}

/// @nodoc
class __$ChatCompletionNamedToolChoiceCopyWithImpl<$Res>
    implements _$ChatCompletionNamedToolChoiceCopyWith<$Res> {
  __$ChatCompletionNamedToolChoiceCopyWithImpl(this._self, this._then);

  final _ChatCompletionNamedToolChoice _self;
  final $Res Function(_ChatCompletionNamedToolChoice) _then;

  /// Create a copy of ChatCompletionNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_ChatCompletionNamedToolChoice(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }

  /// Create a copy of ChatCompletionNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_self.function,
        (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionMessageToolCall {
  /// The ID of the tool call.
  String get id;

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type;

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function;

  /// Create a copy of ChatCompletionMessageToolCall
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageToolCallCopyWith<ChatCompletionMessageToolCall>
      get copyWith => _$ChatCompletionMessageToolCallCopyWithImpl<
              ChatCompletionMessageToolCall>(
          this as ChatCompletionMessageToolCall, _$identity);

  /// Serializes this ChatCompletionMessageToolCall to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageToolCall &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @override
  String toString() {
    return 'ChatCompletionMessageToolCall(id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory $ChatCompletionMessageToolCallCopyWith(
          ChatCompletionMessageToolCall value,
          $Res Function(ChatCompletionMessageToolCall) _then) =
      _$ChatCompletionMessageToolCallCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionMessageToolCallCopyWithImpl<$Res>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  _$ChatCompletionMessageToolCallCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageToolCall _self;
  final $Res Function(ChatCompletionMessageToolCall) _then;

  /// Create a copy of ChatCompletionMessageToolCall
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ));
  }

  /// Create a copy of ChatCompletionMessageToolCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function {
    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(_self.function,
        (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionMessageToolCall].
extension ChatCompletionMessageToolCallPatterns
    on ChatCompletionMessageToolCall {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageToolCall value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageToolCall() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageToolCall value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageToolCall():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionMessageToolCall value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageToolCall() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String id, ChatCompletionMessageToolCallType type,
            ChatCompletionMessageFunctionCall function)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageToolCall() when $default != null:
        return $default(_that.id, _that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String id, ChatCompletionMessageToolCallType type,
            ChatCompletionMessageFunctionCall function)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageToolCall():
        return $default(_that.id, _that.type, _that.function);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String id, ChatCompletionMessageToolCallType type,
            ChatCompletionMessageFunctionCall function)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageToolCall() when $default != null:
        return $default(_that.id, _that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionMessageToolCall extends ChatCompletionMessageToolCall {
  const _ChatCompletionMessageToolCall(
      {required this.id, required this.type, required this.function})
      : super._();
  factory _ChatCompletionMessageToolCall.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionMessageToolCallFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionMessageToolCallType type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  final ChatCompletionMessageFunctionCall function;

  /// Create a copy of ChatCompletionMessageToolCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionMessageToolCallCopyWith<_ChatCompletionMessageToolCall>
      get copyWith => __$ChatCompletionMessageToolCallCopyWithImpl<
          _ChatCompletionMessageToolCall>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageToolCallToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionMessageToolCall &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @override
  String toString() {
    return 'ChatCompletionMessageToolCall(id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionMessageToolCallCopyWith<$Res>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory _$ChatCompletionMessageToolCallCopyWith(
          _ChatCompletionMessageToolCall value,
          $Res Function(_ChatCompletionMessageToolCall) _then) =
      __$ChatCompletionMessageToolCallCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  @override
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class __$ChatCompletionMessageToolCallCopyWithImpl<$Res>
    implements _$ChatCompletionMessageToolCallCopyWith<$Res> {
  __$ChatCompletionMessageToolCallCopyWithImpl(this._self, this._then);

  final _ChatCompletionMessageToolCall _self;
  final $Res Function(_ChatCompletionMessageToolCall) _then;

  /// Create a copy of ChatCompletionMessageToolCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_ChatCompletionMessageToolCall(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ));
  }

  /// Create a copy of ChatCompletionMessageToolCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function {
    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(_self.function,
        (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$Annotation {
  /// The type of the URL citation. Always `url_citation`.
  AnnotationType get type;

  /// A URL citation when using web search.
  @JsonKey(name: 'url_citation')
  AnnotationUrlCitation get urlCitation;

  /// Create a copy of Annotation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AnnotationCopyWith<Annotation> get copyWith =>
      _$AnnotationCopyWithImpl<Annotation>(this as Annotation, _$identity);

  /// Serializes this Annotation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Annotation &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.urlCitation, urlCitation) ||
                other.urlCitation == urlCitation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, urlCitation);

  @override
  String toString() {
    return 'Annotation(type: $type, urlCitation: $urlCitation)';
  }
}

/// @nodoc
abstract mixin class $AnnotationCopyWith<$Res> {
  factory $AnnotationCopyWith(
          Annotation value, $Res Function(Annotation) _then) =
      _$AnnotationCopyWithImpl;
  @useResult
  $Res call(
      {AnnotationType type,
      @JsonKey(name: 'url_citation') AnnotationUrlCitation urlCitation});

  $AnnotationUrlCitationCopyWith<$Res> get urlCitation;
}

/// @nodoc
class _$AnnotationCopyWithImpl<$Res> implements $AnnotationCopyWith<$Res> {
  _$AnnotationCopyWithImpl(this._self, this._then);

  final Annotation _self;
  final $Res Function(Annotation) _then;

  /// Create a copy of Annotation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? urlCitation = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as AnnotationType,
      urlCitation: null == urlCitation
          ? _self.urlCitation
          : urlCitation // ignore: cast_nullable_to_non_nullable
              as AnnotationUrlCitation,
    ));
  }

  /// Create a copy of Annotation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AnnotationUrlCitationCopyWith<$Res> get urlCitation {
    return $AnnotationUrlCitationCopyWith<$Res>(_self.urlCitation, (value) {
      return _then(_self.copyWith(urlCitation: value));
    });
  }
}

/// Adds pattern-matching-related methods to [Annotation].
extension AnnotationPatterns on Annotation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Annotation value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Annotation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Annotation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Annotation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Annotation value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Annotation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(AnnotationType type,
            @JsonKey(name: 'url_citation') AnnotationUrlCitation urlCitation)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Annotation() when $default != null:
        return $default(_that.type, _that.urlCitation);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(AnnotationType type,
            @JsonKey(name: 'url_citation') AnnotationUrlCitation urlCitation)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Annotation():
        return $default(_that.type, _that.urlCitation);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(AnnotationType type,
            @JsonKey(name: 'url_citation') AnnotationUrlCitation urlCitation)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Annotation() when $default != null:
        return $default(_that.type, _that.urlCitation);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _Annotation extends Annotation {
  const _Annotation(
      {required this.type,
      @JsonKey(name: 'url_citation') required this.urlCitation})
      : super._();
  factory _Annotation.fromJson(Map<String, dynamic> json) =>
      _$AnnotationFromJson(json);

  /// The type of the URL citation. Always `url_citation`.
  @override
  final AnnotationType type;

  /// A URL citation when using web search.
  @override
  @JsonKey(name: 'url_citation')
  final AnnotationUrlCitation urlCitation;

  /// Create a copy of Annotation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AnnotationCopyWith<_Annotation> get copyWith =>
      __$AnnotationCopyWithImpl<_Annotation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AnnotationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Annotation &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.urlCitation, urlCitation) ||
                other.urlCitation == urlCitation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, urlCitation);

  @override
  String toString() {
    return 'Annotation(type: $type, urlCitation: $urlCitation)';
  }
}

/// @nodoc
abstract mixin class _$AnnotationCopyWith<$Res>
    implements $AnnotationCopyWith<$Res> {
  factory _$AnnotationCopyWith(
          _Annotation value, $Res Function(_Annotation) _then) =
      __$AnnotationCopyWithImpl;
  @override
  @useResult
  $Res call(
      {AnnotationType type,
      @JsonKey(name: 'url_citation') AnnotationUrlCitation urlCitation});

  @override
  $AnnotationUrlCitationCopyWith<$Res> get urlCitation;
}

/// @nodoc
class __$AnnotationCopyWithImpl<$Res> implements _$AnnotationCopyWith<$Res> {
  __$AnnotationCopyWithImpl(this._self, this._then);

  final _Annotation _self;
  final $Res Function(_Annotation) _then;

  /// Create a copy of Annotation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? urlCitation = null,
  }) {
    return _then(_Annotation(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as AnnotationType,
      urlCitation: null == urlCitation
          ? _self.urlCitation
          : urlCitation // ignore: cast_nullable_to_non_nullable
              as AnnotationUrlCitation,
    ));
  }

  /// Create a copy of Annotation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AnnotationUrlCitationCopyWith<$Res> get urlCitation {
    return $AnnotationUrlCitationCopyWith<$Res>(_self.urlCitation, (value) {
      return _then(_self.copyWith(urlCitation: value));
    });
  }
}

/// @nodoc
mixin _$AnnotationUrlCitation {
  /// The index of the last character of the URL citation in the message.
  @JsonKey(name: 'end_index', includeIfNull: false)
  int? get endIndex;

  /// The index of the first character of the URL citation in the message.
  @JsonKey(name: 'start_index', includeIfNull: false)
  int? get startIndex;

  /// The URL of the web resource.
  @JsonKey(includeIfNull: false)
  String? get url;

  /// The title of the web resource.
  @JsonKey(includeIfNull: false)
  String? get title;

  /// Create a copy of AnnotationUrlCitation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AnnotationUrlCitationCopyWith<AnnotationUrlCitation> get copyWith =>
      _$AnnotationUrlCitationCopyWithImpl<AnnotationUrlCitation>(
          this as AnnotationUrlCitation, _$identity);

  /// Serializes this AnnotationUrlCitation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AnnotationUrlCitation &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.title, title) || other.title == title));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, endIndex, startIndex, url, title);

  @override
  String toString() {
    return 'AnnotationUrlCitation(endIndex: $endIndex, startIndex: $startIndex, url: $url, title: $title)';
  }
}

/// @nodoc
abstract mixin class $AnnotationUrlCitationCopyWith<$Res> {
  factory $AnnotationUrlCitationCopyWith(AnnotationUrlCitation value,
          $Res Function(AnnotationUrlCitation) _then) =
      _$AnnotationUrlCitationCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'end_index', includeIfNull: false) int? endIndex,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(includeIfNull: false) String? title});
}

/// @nodoc
class _$AnnotationUrlCitationCopyWithImpl<$Res>
    implements $AnnotationUrlCitationCopyWith<$Res> {
  _$AnnotationUrlCitationCopyWithImpl(this._self, this._then);

  final AnnotationUrlCitation _self;
  final $Res Function(AnnotationUrlCitation) _then;

  /// Create a copy of AnnotationUrlCitation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? endIndex = freezed,
    Object? startIndex = freezed,
    Object? url = freezed,
    Object? title = freezed,
  }) {
    return _then(_self.copyWith(
      endIndex: freezed == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      startIndex: freezed == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [AnnotationUrlCitation].
extension AnnotationUrlCitationPatterns on AnnotationUrlCitation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AnnotationUrlCitation value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AnnotationUrlCitation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AnnotationUrlCitation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AnnotationUrlCitation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AnnotationUrlCitation value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AnnotationUrlCitation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(includeIfNull: false) String? url,
            @JsonKey(includeIfNull: false) String? title)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AnnotationUrlCitation() when $default != null:
        return $default(
            _that.endIndex, _that.startIndex, _that.url, _that.title);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(includeIfNull: false) String? url,
            @JsonKey(includeIfNull: false) String? title)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AnnotationUrlCitation():
        return $default(
            _that.endIndex, _that.startIndex, _that.url, _that.title);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(includeIfNull: false) String? url,
            @JsonKey(includeIfNull: false) String? title)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AnnotationUrlCitation() when $default != null:
        return $default(
            _that.endIndex, _that.startIndex, _that.url, _that.title);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AnnotationUrlCitation extends AnnotationUrlCitation {
  const _AnnotationUrlCitation(
      {@JsonKey(name: 'end_index', includeIfNull: false) this.endIndex,
      @JsonKey(name: 'start_index', includeIfNull: false) this.startIndex,
      @JsonKey(includeIfNull: false) this.url,
      @JsonKey(includeIfNull: false) this.title})
      : super._();
  factory _AnnotationUrlCitation.fromJson(Map<String, dynamic> json) =>
      _$AnnotationUrlCitationFromJson(json);

  /// The index of the last character of the URL citation in the message.
  @override
  @JsonKey(name: 'end_index', includeIfNull: false)
  final int? endIndex;

  /// The index of the first character of the URL citation in the message.
  @override
  @JsonKey(name: 'start_index', includeIfNull: false)
  final int? startIndex;

  /// The URL of the web resource.
  @override
  @JsonKey(includeIfNull: false)
  final String? url;

  /// The title of the web resource.
  @override
  @JsonKey(includeIfNull: false)
  final String? title;

  /// Create a copy of AnnotationUrlCitation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AnnotationUrlCitationCopyWith<_AnnotationUrlCitation> get copyWith =>
      __$AnnotationUrlCitationCopyWithImpl<_AnnotationUrlCitation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AnnotationUrlCitationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AnnotationUrlCitation &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.title, title) || other.title == title));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, endIndex, startIndex, url, title);

  @override
  String toString() {
    return 'AnnotationUrlCitation(endIndex: $endIndex, startIndex: $startIndex, url: $url, title: $title)';
  }
}

/// @nodoc
abstract mixin class _$AnnotationUrlCitationCopyWith<$Res>
    implements $AnnotationUrlCitationCopyWith<$Res> {
  factory _$AnnotationUrlCitationCopyWith(_AnnotationUrlCitation value,
          $Res Function(_AnnotationUrlCitation) _then) =
      __$AnnotationUrlCitationCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'end_index', includeIfNull: false) int? endIndex,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(includeIfNull: false) String? title});
}

/// @nodoc
class __$AnnotationUrlCitationCopyWithImpl<$Res>
    implements _$AnnotationUrlCitationCopyWith<$Res> {
  __$AnnotationUrlCitationCopyWithImpl(this._self, this._then);

  final _AnnotationUrlCitation _self;
  final $Res Function(_AnnotationUrlCitation) _then;

  /// Create a copy of AnnotationUrlCitation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? endIndex = freezed,
    Object? startIndex = freezed,
    Object? url = freezed,
    Object? title = freezed,
  }) {
    return _then(_AnnotationUrlCitation(
      endIndex: freezed == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      startIndex: freezed == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _self.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$PredictionContent {
  /// The type of the predicted content you want to provide. This type is
  /// currently always `content`.
  String get type;

  /// The content that should be matched when generating a model response.
  /// If generated tokens would match this content, the entire model response
  /// can be returned much more quickly.
  @_PredictionContentContentConverter()
  PredictionContentContent get content;

  /// Create a copy of PredictionContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PredictionContentCopyWith<PredictionContent> get copyWith =>
      _$PredictionContentCopyWithImpl<PredictionContent>(
          this as PredictionContent, _$identity);

  /// Serializes this PredictionContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PredictionContent &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, content);

  @override
  String toString() {
    return 'PredictionContent(type: $type, content: $content)';
  }
}

/// @nodoc
abstract mixin class $PredictionContentCopyWith<$Res> {
  factory $PredictionContentCopyWith(
          PredictionContent value, $Res Function(PredictionContent) _then) =
      _$PredictionContentCopyWithImpl;
  @useResult
  $Res call(
      {String type,
      @_PredictionContentContentConverter() PredictionContentContent content});

  $PredictionContentContentCopyWith<$Res> get content;
}

/// @nodoc
class _$PredictionContentCopyWithImpl<$Res>
    implements $PredictionContentCopyWith<$Res> {
  _$PredictionContentCopyWithImpl(this._self, this._then);

  final PredictionContent _self;
  final $Res Function(PredictionContent) _then;

  /// Create a copy of PredictionContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? content = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as PredictionContentContent,
    ));
  }

  /// Create a copy of PredictionContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PredictionContentContentCopyWith<$Res> get content {
    return $PredictionContentContentCopyWith<$Res>(_self.content, (value) {
      return _then(_self.copyWith(content: value));
    });
  }
}

/// Adds pattern-matching-related methods to [PredictionContent].
extension PredictionContentPatterns on PredictionContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_PredictionContent value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PredictionContent() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_PredictionContent value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PredictionContent():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_PredictionContent value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PredictionContent() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String type,
            @_PredictionContentContentConverter()
            PredictionContentContent content)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _PredictionContent() when $default != null:
        return $default(_that.type, _that.content);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String type,
            @_PredictionContentContentConverter()
            PredictionContentContent content)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PredictionContent():
        return $default(_that.type, _that.content);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String type,
            @_PredictionContentContentConverter()
            PredictionContentContent content)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _PredictionContent() when $default != null:
        return $default(_that.type, _that.content);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _PredictionContent extends PredictionContent {
  const _PredictionContent(
      {this.type = 'content',
      @_PredictionContentContentConverter() required this.content})
      : super._();
  factory _PredictionContent.fromJson(Map<String, dynamic> json) =>
      _$PredictionContentFromJson(json);

  /// The type of the predicted content you want to provide. This type is
  /// currently always `content`.
  @override
  @JsonKey()
  final String type;

  /// The content that should be matched when generating a model response.
  /// If generated tokens would match this content, the entire model response
  /// can be returned much more quickly.
  @override
  @_PredictionContentContentConverter()
  final PredictionContentContent content;

  /// Create a copy of PredictionContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$PredictionContentCopyWith<_PredictionContent> get copyWith =>
      __$PredictionContentCopyWithImpl<_PredictionContent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PredictionContentToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PredictionContent &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, content);

  @override
  String toString() {
    return 'PredictionContent(type: $type, content: $content)';
  }
}

/// @nodoc
abstract mixin class _$PredictionContentCopyWith<$Res>
    implements $PredictionContentCopyWith<$Res> {
  factory _$PredictionContentCopyWith(
          _PredictionContent value, $Res Function(_PredictionContent) _then) =
      __$PredictionContentCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @_PredictionContentContentConverter() PredictionContentContent content});

  @override
  $PredictionContentContentCopyWith<$Res> get content;
}

/// @nodoc
class __$PredictionContentCopyWithImpl<$Res>
    implements _$PredictionContentCopyWith<$Res> {
  __$PredictionContentCopyWithImpl(this._self, this._then);

  final _PredictionContent _self;
  final $Res Function(_PredictionContent) _then;

  /// Create a copy of PredictionContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? content = null,
  }) {
    return _then(_PredictionContent(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as PredictionContentContent,
    ));
  }

  /// Create a copy of PredictionContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PredictionContentContentCopyWith<$Res> get content {
    return $PredictionContentContentCopyWith<$Res>(_self.content, (value) {
      return _then(_self.copyWith(content: value));
    });
  }
}

PredictionContentContent _$PredictionContentContentFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'textParts':
      return PredictionContentContentListChatCompletionMessageContentPartText
          .fromJson(json);
    case 'text':
      return PredictionContentContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'PredictionContentContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$PredictionContentContent {
  Object get value;

  /// Serializes this PredictionContentContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PredictionContentContent &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'PredictionContentContent(value: $value)';
  }
}

/// @nodoc
class $PredictionContentContentCopyWith<$Res> {
  $PredictionContentContentCopyWith(
      PredictionContentContent _, $Res Function(PredictionContentContent) __);
}

/// Adds pattern-matching-related methods to [PredictionContentContent].
extension PredictionContentContentPatterns on PredictionContentContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            PredictionContentContentListChatCompletionMessageContentPartText
                value)?
        textParts,
    TResult Function(PredictionContentContentString value)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case PredictionContentContentListChatCompletionMessageContentPartText()
          when textParts != null:
        return textParts(_that);
      case PredictionContentContentString() when text != null:
        return text(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            PredictionContentContentListChatCompletionMessageContentPartText
                value)
        textParts,
    required TResult Function(PredictionContentContentString value) text,
  }) {
    final _that = this;
    switch (_that) {
      case PredictionContentContentListChatCompletionMessageContentPartText():
        return textParts(_that);
      case PredictionContentContentString():
        return text(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            PredictionContentContentListChatCompletionMessageContentPartText
                value)?
        textParts,
    TResult? Function(PredictionContentContentString value)? text,
  }) {
    final _that = this;
    switch (_that) {
      case PredictionContentContentListChatCompletionMessageContentPartText()
          when textParts != null:
        return textParts(_that);
      case PredictionContentContentString() when text != null:
        return text(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPartText> value)?
        textParts,
    TResult Function(String value)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case PredictionContentContentListChatCompletionMessageContentPartText()
          when textParts != null:
        return textParts(_that.value);
      case PredictionContentContentString() when text != null:
        return text(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPartText> value)
        textParts,
    required TResult Function(String value) text,
  }) {
    final _that = this;
    switch (_that) {
      case PredictionContentContentListChatCompletionMessageContentPartText():
        return textParts(_that.value);
      case PredictionContentContentString():
        return text(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPartText> value)?
        textParts,
    TResult? Function(String value)? text,
  }) {
    final _that = this;
    switch (_that) {
      case PredictionContentContentListChatCompletionMessageContentPartText()
          when textParts != null:
        return textParts(_that.value);
      case PredictionContentContentString() when text != null:
        return text(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class PredictionContentContentListChatCompletionMessageContentPartText
    extends PredictionContentContent {
  const PredictionContentContentListChatCompletionMessageContentPartText(
      final List<ChatCompletionMessageContentPartText> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'textParts',
        super._();
  factory PredictionContentContentListChatCompletionMessageContentPartText.fromJson(
          Map<String, dynamic> json) =>
      _$PredictionContentContentListChatCompletionMessageContentPartTextFromJson(
          json);

  final List<ChatCompletionMessageContentPartText> _value;
  @override
  List<ChatCompletionMessageContentPartText> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of PredictionContentContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PredictionContentContentListChatCompletionMessageContentPartTextCopyWith<
          PredictionContentContentListChatCompletionMessageContentPartText>
      get copyWith =>
          _$PredictionContentContentListChatCompletionMessageContentPartTextCopyWithImpl<
                  PredictionContentContentListChatCompletionMessageContentPartText>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PredictionContentContentListChatCompletionMessageContentPartTextToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is PredictionContentContentListChatCompletionMessageContentPartText &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'PredictionContentContent.textParts(value: $value)';
  }
}

/// @nodoc
abstract mixin class $PredictionContentContentListChatCompletionMessageContentPartTextCopyWith<
    $Res> implements $PredictionContentContentCopyWith<$Res> {
  factory $PredictionContentContentListChatCompletionMessageContentPartTextCopyWith(
          PredictionContentContentListChatCompletionMessageContentPartText value,
          $Res Function(
                  PredictionContentContentListChatCompletionMessageContentPartText)
              _then) =
      _$PredictionContentContentListChatCompletionMessageContentPartTextCopyWithImpl;
  @useResult
  $Res call({List<ChatCompletionMessageContentPartText> value});
}

/// @nodoc
class _$PredictionContentContentListChatCompletionMessageContentPartTextCopyWithImpl<
        $Res>
    implements
        $PredictionContentContentListChatCompletionMessageContentPartTextCopyWith<
            $Res> {
  _$PredictionContentContentListChatCompletionMessageContentPartTextCopyWithImpl(
      this._self, this._then);

  final PredictionContentContentListChatCompletionMessageContentPartText _self;
  final $Res Function(
      PredictionContentContentListChatCompletionMessageContentPartText) _then;

  /// Create a copy of PredictionContentContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(
        PredictionContentContentListChatCompletionMessageContentPartText(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageContentPartText>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class PredictionContentContentString extends PredictionContentContent {
  const PredictionContentContentString(this.value, {final String? $type})
      : $type = $type ?? 'text',
        super._();
  factory PredictionContentContentString.fromJson(Map<String, dynamic> json) =>
      _$PredictionContentContentStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of PredictionContentContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $PredictionContentContentStringCopyWith<PredictionContentContentString>
      get copyWith => _$PredictionContentContentStringCopyWithImpl<
          PredictionContentContentString>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$PredictionContentContentStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PredictionContentContentString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'PredictionContentContent.text(value: $value)';
  }
}

/// @nodoc
abstract mixin class $PredictionContentContentStringCopyWith<$Res>
    implements $PredictionContentContentCopyWith<$Res> {
  factory $PredictionContentContentStringCopyWith(
          PredictionContentContentString value,
          $Res Function(PredictionContentContentString) _then) =
      _$PredictionContentContentStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$PredictionContentContentStringCopyWithImpl<$Res>
    implements $PredictionContentContentStringCopyWith<$Res> {
  _$PredictionContentContentStringCopyWithImpl(this._self, this._then);

  final PredictionContentContentString _self;
  final $Res Function(PredictionContentContentString) _then;

  /// Create a copy of PredictionContentContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(PredictionContentContentString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionAudioOptions {
  /// The voice the model uses to respond. Supported voices are `alloy`,
  /// `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, and `verse`.
  ChatCompletionAudioVoice get voice;

  /// Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`, `opus`, or `pcm16`.
  ChatCompletionAudioFormat get format;

  /// Create a copy of ChatCompletionAudioOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionAudioOptionsCopyWith<ChatCompletionAudioOptions>
      get copyWith =>
          _$ChatCompletionAudioOptionsCopyWithImpl<ChatCompletionAudioOptions>(
              this as ChatCompletionAudioOptions, _$identity);

  /// Serializes this ChatCompletionAudioOptions to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionAudioOptions &&
            (identical(other.voice, voice) || other.voice == voice) &&
            (identical(other.format, format) || other.format == format));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, voice, format);

  @override
  String toString() {
    return 'ChatCompletionAudioOptions(voice: $voice, format: $format)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionAudioOptionsCopyWith<$Res> {
  factory $ChatCompletionAudioOptionsCopyWith(ChatCompletionAudioOptions value,
          $Res Function(ChatCompletionAudioOptions) _then) =
      _$ChatCompletionAudioOptionsCopyWithImpl;
  @useResult
  $Res call({ChatCompletionAudioVoice voice, ChatCompletionAudioFormat format});
}

/// @nodoc
class _$ChatCompletionAudioOptionsCopyWithImpl<$Res>
    implements $ChatCompletionAudioOptionsCopyWith<$Res> {
  _$ChatCompletionAudioOptionsCopyWithImpl(this._self, this._then);

  final ChatCompletionAudioOptions _self;
  final $Res Function(ChatCompletionAudioOptions) _then;

  /// Create a copy of ChatCompletionAudioOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? voice = null,
    Object? format = null,
  }) {
    return _then(_self.copyWith(
      voice: null == voice
          ? _self.voice
          : voice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAudioVoice,
      format: null == format
          ? _self.format
          : format // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAudioFormat,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionAudioOptions].
extension ChatCompletionAudioOptionsPatterns on ChatCompletionAudioOptions {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionAudioOptions value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAudioOptions() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionAudioOptions value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAudioOptions():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionAudioOptions value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAudioOptions() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            ChatCompletionAudioVoice voice, ChatCompletionAudioFormat format)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAudioOptions() when $default != null:
        return $default(_that.voice, _that.format);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            ChatCompletionAudioVoice voice, ChatCompletionAudioFormat format)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAudioOptions():
        return $default(_that.voice, _that.format);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            ChatCompletionAudioVoice voice, ChatCompletionAudioFormat format)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAudioOptions() when $default != null:
        return $default(_that.voice, _that.format);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionAudioOptions extends ChatCompletionAudioOptions {
  const _ChatCompletionAudioOptions({required this.voice, required this.format})
      : super._();
  factory _ChatCompletionAudioOptions.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionAudioOptionsFromJson(json);

  /// The voice the model uses to respond. Supported voices are `alloy`,
  /// `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, and `verse`.
  @override
  final ChatCompletionAudioVoice voice;

  /// Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`, `opus`, or `pcm16`.
  @override
  final ChatCompletionAudioFormat format;

  /// Create a copy of ChatCompletionAudioOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionAudioOptionsCopyWith<_ChatCompletionAudioOptions>
      get copyWith => __$ChatCompletionAudioOptionsCopyWithImpl<
          _ChatCompletionAudioOptions>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionAudioOptionsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionAudioOptions &&
            (identical(other.voice, voice) || other.voice == voice) &&
            (identical(other.format, format) || other.format == format));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, voice, format);

  @override
  String toString() {
    return 'ChatCompletionAudioOptions(voice: $voice, format: $format)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionAudioOptionsCopyWith<$Res>
    implements $ChatCompletionAudioOptionsCopyWith<$Res> {
  factory _$ChatCompletionAudioOptionsCopyWith(
          _ChatCompletionAudioOptions value,
          $Res Function(_ChatCompletionAudioOptions) _then) =
      __$ChatCompletionAudioOptionsCopyWithImpl;
  @override
  @useResult
  $Res call({ChatCompletionAudioVoice voice, ChatCompletionAudioFormat format});
}

/// @nodoc
class __$ChatCompletionAudioOptionsCopyWithImpl<$Res>
    implements _$ChatCompletionAudioOptionsCopyWith<$Res> {
  __$ChatCompletionAudioOptionsCopyWithImpl(this._self, this._then);

  final _ChatCompletionAudioOptions _self;
  final $Res Function(_ChatCompletionAudioOptions) _then;

  /// Create a copy of ChatCompletionAudioOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? voice = null,
    Object? format = null,
  }) {
    return _then(_ChatCompletionAudioOptions(
      voice: null == voice
          ? _self.voice
          : voice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAudioVoice,
      format: null == format
          ? _self.format
          : format // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAudioFormat,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionStreamOptions {
  /// If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
  @JsonKey(name: 'include_usage', includeIfNull: false)
  bool? get includeUsage;

  /// Create a copy of ChatCompletionStreamOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamOptionsCopyWith<ChatCompletionStreamOptions>
      get copyWith => _$ChatCompletionStreamOptionsCopyWithImpl<
              ChatCompletionStreamOptions>(
          this as ChatCompletionStreamOptions, _$identity);

  /// Serializes this ChatCompletionStreamOptions to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStreamOptions &&
            (identical(other.includeUsage, includeUsage) ||
                other.includeUsage == includeUsage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, includeUsage);

  @override
  String toString() {
    return 'ChatCompletionStreamOptions(includeUsage: $includeUsage)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStreamOptionsCopyWith<$Res> {
  factory $ChatCompletionStreamOptionsCopyWith(
          ChatCompletionStreamOptions value,
          $Res Function(ChatCompletionStreamOptions) _then) =
      _$ChatCompletionStreamOptionsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'include_usage', includeIfNull: false)
      bool? includeUsage});
}

/// @nodoc
class _$ChatCompletionStreamOptionsCopyWithImpl<$Res>
    implements $ChatCompletionStreamOptionsCopyWith<$Res> {
  _$ChatCompletionStreamOptionsCopyWithImpl(this._self, this._then);

  final ChatCompletionStreamOptions _self;
  final $Res Function(ChatCompletionStreamOptions) _then;

  /// Create a copy of ChatCompletionStreamOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? includeUsage = freezed,
  }) {
    return _then(_self.copyWith(
      includeUsage: freezed == includeUsage
          ? _self.includeUsage
          : includeUsage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionStreamOptions].
extension ChatCompletionStreamOptionsPatterns on ChatCompletionStreamOptions {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamOptions value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamOptions() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamOptions value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamOptions():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionStreamOptions value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamOptions() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'include_usage', includeIfNull: false)
            bool? includeUsage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamOptions() when $default != null:
        return $default(_that.includeUsage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'include_usage', includeIfNull: false)
            bool? includeUsage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamOptions():
        return $default(_that.includeUsage);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'include_usage', includeIfNull: false)
            bool? includeUsage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamOptions() when $default != null:
        return $default(_that.includeUsage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionStreamOptions extends ChatCompletionStreamOptions {
  const _ChatCompletionStreamOptions(
      {@JsonKey(name: 'include_usage', includeIfNull: false) this.includeUsage})
      : super._();
  factory _ChatCompletionStreamOptions.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionStreamOptionsFromJson(json);

  /// If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
  @override
  @JsonKey(name: 'include_usage', includeIfNull: false)
  final bool? includeUsage;

  /// Create a copy of ChatCompletionStreamOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionStreamOptionsCopyWith<_ChatCompletionStreamOptions>
      get copyWith => __$ChatCompletionStreamOptionsCopyWithImpl<
          _ChatCompletionStreamOptions>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStreamOptionsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionStreamOptions &&
            (identical(other.includeUsage, includeUsage) ||
                other.includeUsage == includeUsage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, includeUsage);

  @override
  String toString() {
    return 'ChatCompletionStreamOptions(includeUsage: $includeUsage)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionStreamOptionsCopyWith<$Res>
    implements $ChatCompletionStreamOptionsCopyWith<$Res> {
  factory _$ChatCompletionStreamOptionsCopyWith(
          _ChatCompletionStreamOptions value,
          $Res Function(_ChatCompletionStreamOptions) _then) =
      __$ChatCompletionStreamOptionsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'include_usage', includeIfNull: false)
      bool? includeUsage});
}

/// @nodoc
class __$ChatCompletionStreamOptionsCopyWithImpl<$Res>
    implements _$ChatCompletionStreamOptionsCopyWith<$Res> {
  __$ChatCompletionStreamOptionsCopyWithImpl(this._self, this._then);

  final _ChatCompletionStreamOptions _self;
  final $Res Function(_ChatCompletionStreamOptions) _then;

  /// Create a copy of ChatCompletionStreamOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? includeUsage = freezed,
  }) {
    return _then(_ChatCompletionStreamOptions(
      includeUsage: freezed == includeUsage
          ? _self.includeUsage
          : includeUsage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$CreateChatCompletionResponse {
  /// A unique identifier for the chat completion.
  @JsonKey(includeIfNull: false)
  String? get id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices;

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created;

  /// The model used for the chat completion.
  String get model;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ServiceTier? get serviceTier;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;

  /// The object type, which is always `chat.completion`.
  String get object;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;

  /// Create a copy of CreateChatCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateChatCompletionResponseCopyWith<CreateChatCompletionResponse>
      get copyWith => _$CreateChatCompletionResponseCopyWithImpl<
              CreateChatCompletionResponse>(
          this as CreateChatCompletionResponse, _$identity);

  /// Serializes this CreateChatCompletionResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateChatCompletionResponse &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other.choices, choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(choices),
      created,
      model,
      serviceTier,
      systemFingerprint,
      object,
      usage);

  @override
  String toString() {
    return 'CreateChatCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, serviceTier: $serviceTier, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class $CreateChatCompletionResponseCopyWith<$Res> {
  factory $CreateChatCompletionResponseCopyWith(
          CreateChatCompletionResponse value,
          $Res Function(CreateChatCompletionResponse) _then) =
      _$CreateChatCompletionResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateChatCompletionResponseCopyWithImpl<$Res>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  _$CreateChatCompletionResponseCopyWithImpl(this._self, this._then);

  final CreateChatCompletionResponse _self;
  final $Res Function(CreateChatCompletionResponse) _then;

  /// Create a copy of CreateChatCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _self.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      serviceTier: freezed == serviceTier
          ? _self.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _self.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }

  /// Create a copy of CreateChatCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateChatCompletionResponse].
extension CreateChatCompletionResponsePatterns on CreateChatCompletionResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateChatCompletionResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateChatCompletionResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateChatCompletionResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? id,
            List<ChatCompletionResponseChoice> choices,
            int created,
            String model,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ServiceTier? serviceTier,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            String object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionResponse() when $default != null:
        return $default(
            _that.id,
            _that.choices,
            _that.created,
            _that.model,
            _that.serviceTier,
            _that.systemFingerprint,
            _that.object,
            _that.usage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? id,
            List<ChatCompletionResponseChoice> choices,
            int created,
            String model,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ServiceTier? serviceTier,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            String object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionResponse():
        return $default(
            _that.id,
            _that.choices,
            _that.created,
            _that.model,
            _that.serviceTier,
            _that.systemFingerprint,
            _that.object,
            _that.usage);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? id,
            List<ChatCompletionResponseChoice> choices,
            int created,
            String model,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ServiceTier? serviceTier,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            String object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionResponse() when $default != null:
        return $default(
            _that.id,
            _that.choices,
            _that.created,
            _that.model,
            _that.serviceTier,
            _that.systemFingerprint,
            _that.object,
            _that.usage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateChatCompletionResponse extends CreateChatCompletionResponse {
  const _CreateChatCompletionResponse(
      {@JsonKey(includeIfNull: false) this.id,
      required final List<ChatCompletionResponseChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();
  factory _CreateChatCompletionResponse.fromJson(Map<String, dynamic> json) =>
      _$CreateChatCompletionResponseFromJson(json);

  /// A unique identifier for the chat completion.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  @override
  final int created;

  /// The model used for the chat completion.
  @override
  final String model;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @override
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ServiceTier? serviceTier;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion`.
  @override
  final String object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  /// Create a copy of CreateChatCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateChatCompletionResponseCopyWith<_CreateChatCompletionResponse>
      get copyWith => __$CreateChatCompletionResponseCopyWithImpl<
          _CreateChatCompletionResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateChatCompletionResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateChatCompletionResponse &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      serviceTier,
      systemFingerprint,
      object,
      usage);

  @override
  String toString() {
    return 'CreateChatCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, serviceTier: $serviceTier, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class _$CreateChatCompletionResponseCopyWith<$Res>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  factory _$CreateChatCompletionResponseCopyWith(
          _CreateChatCompletionResponse value,
          $Res Function(_CreateChatCompletionResponse) _then) =
      __$CreateChatCompletionResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$CreateChatCompletionResponseCopyWithImpl<$Res>
    implements _$CreateChatCompletionResponseCopyWith<$Res> {
  __$CreateChatCompletionResponseCopyWithImpl(this._self, this._then);

  final _CreateChatCompletionResponse _self;
  final $Res Function(_CreateChatCompletionResponse) _then;

  /// Create a copy of CreateChatCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_CreateChatCompletionResponse(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _self._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      serviceTier: freezed == serviceTier
          ? _self.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _self.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }

  /// Create a copy of CreateChatCompletionResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionResponseChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index;

  /// An assistant message in a chat conversation.
  ChatCompletionAssistantMessage get message;

  /// Log probability information for the choice.
  ChatCompletionLogprobs? get logprobs;

  /// Create a copy of ChatCompletionResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionResponseChoiceCopyWith<ChatCompletionResponseChoice>
      get copyWith => _$ChatCompletionResponseChoiceCopyWithImpl<
              ChatCompletionResponseChoice>(
          this as ChatCompletionResponseChoice, _$identity);

  /// Serializes this ChatCompletionResponseChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionResponseChoice &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            const DeepCollectionEquality().equals(other.message, message) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, finishReason, index,
      const DeepCollectionEquality().hash(message), logprobs);

  @override
  String toString() {
    return 'ChatCompletionResponseChoice(finishReason: $finishReason, index: $index, message: $message, logprobs: $logprobs)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionResponseChoiceCopyWith(
          ChatCompletionResponseChoice value,
          $Res Function(ChatCompletionResponseChoice) _then) =
      _$ChatCompletionResponseChoiceCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index,
      ChatCompletionAssistantMessage message,
      ChatCompletionLogprobs? logprobs});

  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$ChatCompletionResponseChoiceCopyWithImpl<$Res>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  _$ChatCompletionResponseChoiceCopyWithImpl(this._self, this._then);

  final ChatCompletionResponseChoice _self;
  final $Res Function(ChatCompletionResponseChoice) _then;

  /// Create a copy of ChatCompletionResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = freezed,
    Object? message = freezed,
    Object? logprobs = freezed,
  }) {
    return _then(_self.copyWith(
      finishReason: freezed == finishReason
          ? _self.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionLogprobs?,
    ));
  }

  /// Create a copy of ChatCompletionResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_self.logprobs == null) {
      return null;
    }

    return $ChatCompletionLogprobsCopyWith<$Res>(_self.logprobs!, (value) {
      return _then(_self.copyWith(logprobs: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionResponseChoice].
extension ChatCompletionResponseChoicePatterns on ChatCompletionResponseChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionResponseChoice value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionResponseChoice() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionResponseChoice value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionResponseChoice():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionResponseChoice value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionResponseChoice() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                name: 'finish_reason',
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionFinishReason? finishReason,
            @JsonKey(includeIfNull: false) int? index,
            ChatCompletionAssistantMessage message,
            ChatCompletionLogprobs? logprobs)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionResponseChoice() when $default != null:
        return $default(
            _that.finishReason, _that.index, _that.message, _that.logprobs);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                name: 'finish_reason',
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionFinishReason? finishReason,
            @JsonKey(includeIfNull: false) int? index,
            ChatCompletionAssistantMessage message,
            ChatCompletionLogprobs? logprobs)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionResponseChoice():
        return $default(
            _that.finishReason, _that.index, _that.message, _that.logprobs);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(
                name: 'finish_reason',
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionFinishReason? finishReason,
            @JsonKey(includeIfNull: false) int? index,
            ChatCompletionAssistantMessage message,
            ChatCompletionLogprobs? logprobs)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionResponseChoice() when $default != null:
        return $default(
            _that.finishReason, _that.index, _that.message, _that.logprobs);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionResponseChoice extends ChatCompletionResponseChoice {
  const _ChatCompletionResponseChoice(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      @JsonKey(includeIfNull: false) this.index,
      required this.message,
      required this.logprobs})
      : super._();
  factory _ChatCompletionResponseChoice.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionResponseChoiceFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  /// An assistant message in a chat conversation.
  @override
  final ChatCompletionAssistantMessage message;

  /// Log probability information for the choice.
  @override
  final ChatCompletionLogprobs? logprobs;

  /// Create a copy of ChatCompletionResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionResponseChoiceCopyWith<_ChatCompletionResponseChoice>
      get copyWith => __$ChatCompletionResponseChoiceCopyWithImpl<
          _ChatCompletionResponseChoice>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionResponseChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionResponseChoice &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            const DeepCollectionEquality().equals(other.message, message) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, finishReason, index,
      const DeepCollectionEquality().hash(message), logprobs);

  @override
  String toString() {
    return 'ChatCompletionResponseChoice(finishReason: $finishReason, index: $index, message: $message, logprobs: $logprobs)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionResponseChoiceCopyWith<$Res>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory _$ChatCompletionResponseChoiceCopyWith(
          _ChatCompletionResponseChoice value,
          $Res Function(_ChatCompletionResponseChoice) _then) =
      __$ChatCompletionResponseChoiceCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index,
      ChatCompletionAssistantMessage message,
      ChatCompletionLogprobs? logprobs});

  @override
  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$ChatCompletionResponseChoiceCopyWithImpl<$Res>
    implements _$ChatCompletionResponseChoiceCopyWith<$Res> {
  __$ChatCompletionResponseChoiceCopyWithImpl(this._self, this._then);

  final _ChatCompletionResponseChoice _self;
  final $Res Function(_ChatCompletionResponseChoice) _then;

  /// Create a copy of ChatCompletionResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? finishReason = freezed,
    Object? index = freezed,
    Object? message = freezed,
    Object? logprobs = freezed,
  }) {
    return _then(_ChatCompletionResponseChoice(
      finishReason: freezed == finishReason
          ? _self.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionLogprobs?,
    ));
  }

  /// Create a copy of ChatCompletionResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_self.logprobs == null) {
      return null;
    }

    return $ChatCompletionLogprobsCopyWith<$Res>(_self.logprobs!, (value) {
      return _then(_self.copyWith(logprobs: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionLogprobs {
  /// A list of message content tokens with log probability information.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get content;

  /// A list of message refusal tokens with log probability information.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get refusal;

  /// Create a copy of ChatCompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionLogprobsCopyWith<ChatCompletionLogprobs> get copyWith =>
      _$ChatCompletionLogprobsCopyWithImpl<ChatCompletionLogprobs>(
          this as ChatCompletionLogprobs, _$identity);

  /// Serializes this ChatCompletionLogprobs to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionLogprobs &&
            const DeepCollectionEquality().equals(other.content, content) &&
            const DeepCollectionEquality().equals(other.refusal, refusal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(content),
      const DeepCollectionEquality().hash(refusal));

  @override
  String toString() {
    return 'ChatCompletionLogprobs(content: $content, refusal: $refusal)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionLogprobsCopyWith<$Res> {
  factory $ChatCompletionLogprobsCopyWith(ChatCompletionLogprobs value,
          $Res Function(ChatCompletionLogprobs) _then) =
      _$ChatCompletionLogprobsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<ChatCompletionTokenLogprob>? content,
      @JsonKey(includeIfNull: false)
      List<ChatCompletionTokenLogprob>? refusal});
}

/// @nodoc
class _$ChatCompletionLogprobsCopyWithImpl<$Res>
    implements $ChatCompletionLogprobsCopyWith<$Res> {
  _$ChatCompletionLogprobsCopyWithImpl(this._self, this._then);

  final ChatCompletionLogprobs _self;
  final $Res Function(ChatCompletionLogprobs) _then;

  /// Create a copy of ChatCompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? refusal = freezed,
  }) {
    return _then(_self.copyWith(
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
      refusal: freezed == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionLogprobs].
extension ChatCompletionLogprobsPatterns on ChatCompletionLogprobs {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionLogprobs value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionLogprobs() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionLogprobs value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionLogprobs():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionLogprobs value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionLogprobs() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? content,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? refusal)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionLogprobs() when $default != null:
        return $default(_that.content, _that.refusal);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? content,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? refusal)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionLogprobs():
        return $default(_that.content, _that.refusal);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? content,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? refusal)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionLogprobs() when $default != null:
        return $default(_that.content, _that.refusal);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionLogprobs extends ChatCompletionLogprobs {
  const _ChatCompletionLogprobs(
      {@JsonKey(includeIfNull: false)
      final List<ChatCompletionTokenLogprob>? content,
      @JsonKey(includeIfNull: false)
      final List<ChatCompletionTokenLogprob>? refusal})
      : _content = content,
        _refusal = refusal,
        super._();
  factory _ChatCompletionLogprobs.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionLogprobsFromJson(json);

  /// A list of message content tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _content;

  /// A list of message content tokens with log probability information.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A list of message refusal tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _refusal;

  /// A list of message refusal tokens with log probability information.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get refusal {
    final value = _refusal;
    if (value == null) return null;
    if (_refusal is EqualUnmodifiableListView) return _refusal;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ChatCompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionLogprobsCopyWith<_ChatCompletionLogprobs> get copyWith =>
      __$ChatCompletionLogprobsCopyWithImpl<_ChatCompletionLogprobs>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionLogprobsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionLogprobs &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            const DeepCollectionEquality().equals(other._refusal, _refusal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_content),
      const DeepCollectionEquality().hash(_refusal));

  @override
  String toString() {
    return 'ChatCompletionLogprobs(content: $content, refusal: $refusal)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionLogprobsCopyWith<$Res>
    implements $ChatCompletionLogprobsCopyWith<$Res> {
  factory _$ChatCompletionLogprobsCopyWith(_ChatCompletionLogprobs value,
          $Res Function(_ChatCompletionLogprobs) _then) =
      __$ChatCompletionLogprobsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<ChatCompletionTokenLogprob>? content,
      @JsonKey(includeIfNull: false)
      List<ChatCompletionTokenLogprob>? refusal});
}

/// @nodoc
class __$ChatCompletionLogprobsCopyWithImpl<$Res>
    implements _$ChatCompletionLogprobsCopyWith<$Res> {
  __$ChatCompletionLogprobsCopyWithImpl(this._self, this._then);

  final _ChatCompletionLogprobs _self;
  final $Res Function(_ChatCompletionLogprobs) _then;

  /// Create a copy of ChatCompletionLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = freezed,
    Object? refusal = freezed,
  }) {
    return _then(_ChatCompletionLogprobs(
      content: freezed == content
          ? _self._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
      refusal: freezed == refusal
          ? _self._refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionTokenLogprob {
  /// The token.
  String get token;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  double get logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes;

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs;

  /// Create a copy of ChatCompletionTokenLogprob
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionTokenLogprobCopyWith<ChatCompletionTokenLogprob>
      get copyWith =>
          _$ChatCompletionTokenLogprobCopyWithImpl<ChatCompletionTokenLogprob>(
              this as ChatCompletionTokenLogprob, _$identity);

  /// Serializes this ChatCompletionTokenLogprob to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionTokenLogprob &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other.bytes, bytes) &&
            const DeepCollectionEquality()
                .equals(other.topLogprobs, topLogprobs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      token,
      logprob,
      const DeepCollectionEquality().hash(bytes),
      const DeepCollectionEquality().hash(topLogprobs));

  @override
  String toString() {
    return 'ChatCompletionTokenLogprob(token: $token, logprob: $logprob, bytes: $bytes, topLogprobs: $topLogprobs)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionTokenLogprobCopyWith<$Res> {
  factory $ChatCompletionTokenLogprobCopyWith(ChatCompletionTokenLogprob value,
          $Res Function(ChatCompletionTokenLogprob) _then) =
      _$ChatCompletionTokenLogprobCopyWithImpl;
  @useResult
  $Res call(
      {String token,
      double logprob,
      List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      List<ChatCompletionTokenTopLogprob> topLogprobs});
}

/// @nodoc
class _$ChatCompletionTokenLogprobCopyWithImpl<$Res>
    implements $ChatCompletionTokenLogprobCopyWith<$Res> {
  _$ChatCompletionTokenLogprobCopyWithImpl(this._self, this._then);

  final ChatCompletionTokenLogprob _self;
  final $Res Function(ChatCompletionTokenLogprob) _then;

  /// Create a copy of ChatCompletionTokenLogprob
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
    Object? topLogprobs = null,
  }) {
    return _then(_self.copyWith(
      token: null == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _self.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _self.bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      topLogprobs: null == topLogprobs
          ? _self.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenTopLogprob>,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionTokenLogprob].
extension ChatCompletionTokenLogprobPatterns on ChatCompletionTokenLogprob {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionTokenLogprob value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenLogprob() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionTokenLogprob value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenLogprob():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionTokenLogprob value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenLogprob() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String token,
            double logprob,
            List<int>? bytes,
            @JsonKey(name: 'top_logprobs')
            List<ChatCompletionTokenTopLogprob> topLogprobs)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenLogprob() when $default != null:
        return $default(
            _that.token, _that.logprob, _that.bytes, _that.topLogprobs);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String token,
            double logprob,
            List<int>? bytes,
            @JsonKey(name: 'top_logprobs')
            List<ChatCompletionTokenTopLogprob> topLogprobs)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenLogprob():
        return $default(
            _that.token, _that.logprob, _that.bytes, _that.topLogprobs);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String token,
            double logprob,
            List<int>? bytes,
            @JsonKey(name: 'top_logprobs')
            List<ChatCompletionTokenTopLogprob> topLogprobs)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenLogprob() when $default != null:
        return $default(
            _that.token, _that.logprob, _that.bytes, _that.topLogprobs);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionTokenLogprob extends ChatCompletionTokenLogprob {
  const _ChatCompletionTokenLogprob(
      {required this.token,
      required this.logprob,
      required final List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      required final List<ChatCompletionTokenTopLogprob> topLogprobs})
      : _bytes = bytes,
        _topLogprobs = topLogprobs,
        super._();
  factory _ChatCompletionTokenLogprob.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionTokenLogprobFromJson(json);

  /// The token.
  @override
  final String token;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  @override
  final double logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  final List<int>? _bytes;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  @override
  List<int>? get bytes {
    final value = _bytes;
    if (value == null) return null;
    if (_bytes is EqualUnmodifiableListView) return _bytes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  final List<ChatCompletionTokenTopLogprob> _topLogprobs;

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @override
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs {
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topLogprobs);
  }

  /// Create a copy of ChatCompletionTokenLogprob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionTokenLogprobCopyWith<_ChatCompletionTokenLogprob>
      get copyWith => __$ChatCompletionTokenLogprobCopyWithImpl<
          _ChatCompletionTokenLogprob>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionTokenLogprobToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionTokenLogprob &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other._bytes, _bytes) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      token,
      logprob,
      const DeepCollectionEquality().hash(_bytes),
      const DeepCollectionEquality().hash(_topLogprobs));

  @override
  String toString() {
    return 'ChatCompletionTokenLogprob(token: $token, logprob: $logprob, bytes: $bytes, topLogprobs: $topLogprobs)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionTokenLogprobCopyWith<$Res>
    implements $ChatCompletionTokenLogprobCopyWith<$Res> {
  factory _$ChatCompletionTokenLogprobCopyWith(
          _ChatCompletionTokenLogprob value,
          $Res Function(_ChatCompletionTokenLogprob) _then) =
      __$ChatCompletionTokenLogprobCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String token,
      double logprob,
      List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      List<ChatCompletionTokenTopLogprob> topLogprobs});
}

/// @nodoc
class __$ChatCompletionTokenLogprobCopyWithImpl<$Res>
    implements _$ChatCompletionTokenLogprobCopyWith<$Res> {
  __$ChatCompletionTokenLogprobCopyWithImpl(this._self, this._then);

  final _ChatCompletionTokenLogprob _self;
  final $Res Function(_ChatCompletionTokenLogprob) _then;

  /// Create a copy of ChatCompletionTokenLogprob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
    Object? topLogprobs = null,
  }) {
    return _then(_ChatCompletionTokenLogprob(
      token: null == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _self.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _self._bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      topLogprobs: null == topLogprobs
          ? _self._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenTopLogprob>,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionTokenTopLogprob {
  /// The token.
  String get token;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  double get logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes;

  /// Create a copy of ChatCompletionTokenTopLogprob
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionTokenTopLogprobCopyWith<ChatCompletionTokenTopLogprob>
      get copyWith => _$ChatCompletionTokenTopLogprobCopyWithImpl<
              ChatCompletionTokenTopLogprob>(
          this as ChatCompletionTokenTopLogprob, _$identity);

  /// Serializes this ChatCompletionTokenTopLogprob to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionTokenTopLogprob &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other.bytes, bytes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, token, logprob, const DeepCollectionEquality().hash(bytes));

  @override
  String toString() {
    return 'ChatCompletionTokenTopLogprob(token: $token, logprob: $logprob, bytes: $bytes)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  factory $ChatCompletionTokenTopLogprobCopyWith(
          ChatCompletionTokenTopLogprob value,
          $Res Function(ChatCompletionTokenTopLogprob) _then) =
      _$ChatCompletionTokenTopLogprobCopyWithImpl;
  @useResult
  $Res call({String token, double logprob, List<int>? bytes});
}

/// @nodoc
class _$ChatCompletionTokenTopLogprobCopyWithImpl<$Res>
    implements $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  _$ChatCompletionTokenTopLogprobCopyWithImpl(this._self, this._then);

  final ChatCompletionTokenTopLogprob _self;
  final $Res Function(ChatCompletionTokenTopLogprob) _then;

  /// Create a copy of ChatCompletionTokenTopLogprob
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
  }) {
    return _then(_self.copyWith(
      token: null == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _self.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _self.bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionTokenTopLogprob].
extension ChatCompletionTokenTopLogprobPatterns
    on ChatCompletionTokenTopLogprob {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionTokenTopLogprob value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenTopLogprob() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionTokenTopLogprob value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenTopLogprob():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionTokenTopLogprob value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenTopLogprob() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String token, double logprob, List<int>? bytes)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenTopLogprob() when $default != null:
        return $default(_that.token, _that.logprob, _that.bytes);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String token, double logprob, List<int>? bytes) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenTopLogprob():
        return $default(_that.token, _that.logprob, _that.bytes);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String token, double logprob, List<int>? bytes)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionTokenTopLogprob() when $default != null:
        return $default(_that.token, _that.logprob, _that.bytes);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionTokenTopLogprob extends ChatCompletionTokenTopLogprob {
  const _ChatCompletionTokenTopLogprob(
      {required this.token,
      required this.logprob,
      required final List<int>? bytes})
      : _bytes = bytes,
        super._();
  factory _ChatCompletionTokenTopLogprob.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionTokenTopLogprobFromJson(json);

  /// The token.
  @override
  final String token;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  @override
  final double logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  final List<int>? _bytes;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  @override
  List<int>? get bytes {
    final value = _bytes;
    if (value == null) return null;
    if (_bytes is EqualUnmodifiableListView) return _bytes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ChatCompletionTokenTopLogprob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionTokenTopLogprobCopyWith<_ChatCompletionTokenTopLogprob>
      get copyWith => __$ChatCompletionTokenTopLogprobCopyWithImpl<
          _ChatCompletionTokenTopLogprob>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionTokenTopLogprobToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionTokenTopLogprob &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other._bytes, _bytes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, token, logprob, const DeepCollectionEquality().hash(_bytes));

  @override
  String toString() {
    return 'ChatCompletionTokenTopLogprob(token: $token, logprob: $logprob, bytes: $bytes)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionTokenTopLogprobCopyWith<$Res>
    implements $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  factory _$ChatCompletionTokenTopLogprobCopyWith(
          _ChatCompletionTokenTopLogprob value,
          $Res Function(_ChatCompletionTokenTopLogprob) _then) =
      __$ChatCompletionTokenTopLogprobCopyWithImpl;
  @override
  @useResult
  $Res call({String token, double logprob, List<int>? bytes});
}

/// @nodoc
class __$ChatCompletionTokenTopLogprobCopyWithImpl<$Res>
    implements _$ChatCompletionTokenTopLogprobCopyWith<$Res> {
  __$ChatCompletionTokenTopLogprobCopyWithImpl(this._self, this._then);

  final _ChatCompletionTokenTopLogprob _self;
  final $Res Function(_ChatCompletionTokenTopLogprob) _then;

  /// Create a copy of ChatCompletionTokenTopLogprob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
  }) {
    return _then(_ChatCompletionTokenTopLogprob(
      token: null == token
          ? _self.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _self.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _self._bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// @nodoc
mixin _$CreateChatCompletionStreamResponse {
  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @JsonKey(includeIfNull: false)
  String? get id;

  /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
  /// last chunk if you set `stream_options: {"include_usage": true}`.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionStreamResponseChoice>? get choices;

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @JsonKey(includeIfNull: false)
  int? get created;

  /// The model to generate the completion.
  @JsonKey(includeIfNull: false)
  String? get model;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ServiceTier? get serviceTier;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;

  /// The object type, which is always `chat.completion.chunk`.
  @JsonKey(includeIfNull: false)
  String? get object;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;

  /// Create a copy of CreateChatCompletionStreamResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateChatCompletionStreamResponseCopyWith<
          CreateChatCompletionStreamResponse>
      get copyWith => _$CreateChatCompletionStreamResponseCopyWithImpl<
              CreateChatCompletionStreamResponse>(
          this as CreateChatCompletionStreamResponse, _$identity);

  /// Serializes this CreateChatCompletionStreamResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateChatCompletionStreamResponse &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other.choices, choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(choices),
      created,
      model,
      serviceTier,
      systemFingerprint,
      object,
      usage);

  @override
  String toString() {
    return 'CreateChatCompletionStreamResponse(id: $id, choices: $choices, created: $created, model: $model, serviceTier: $serviceTier, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory $CreateChatCompletionStreamResponseCopyWith(
          CreateChatCompletionStreamResponse value,
          $Res Function(CreateChatCompletionStreamResponse) _then) =
      _$CreateChatCompletionStreamResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      @JsonKey(includeIfNull: false)
      List<ChatCompletionStreamResponseChoice>? choices,
      @JsonKey(includeIfNull: false) int? created,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      @JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateChatCompletionStreamResponseCopyWithImpl<$Res>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  _$CreateChatCompletionStreamResponseCopyWithImpl(this._self, this._then);

  final CreateChatCompletionStreamResponse _self;
  final $Res Function(CreateChatCompletionStreamResponse) _then;

  /// Create a copy of CreateChatCompletionStreamResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = freezed,
    Object? created = freezed,
    Object? model = freezed,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = freezed,
    Object? usage = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: freezed == choices
          ? _self.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>?,
      created: freezed == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceTier: freezed == serviceTier
          ? _self.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _self.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }

  /// Create a copy of CreateChatCompletionStreamResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateChatCompletionStreamResponse].
extension CreateChatCompletionStreamResponsePatterns
    on CreateChatCompletionStreamResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateChatCompletionStreamResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionStreamResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateChatCompletionStreamResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionStreamResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateChatCompletionStreamResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionStreamResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionStreamResponseChoice>? choices,
            @JsonKey(includeIfNull: false) int? created,
            @JsonKey(includeIfNull: false) String? model,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ServiceTier? serviceTier,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            @JsonKey(includeIfNull: false) String? object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionStreamResponse() when $default != null:
        return $default(
            _that.id,
            _that.choices,
            _that.created,
            _that.model,
            _that.serviceTier,
            _that.systemFingerprint,
            _that.object,
            _that.usage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionStreamResponseChoice>? choices,
            @JsonKey(includeIfNull: false) int? created,
            @JsonKey(includeIfNull: false) String? model,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ServiceTier? serviceTier,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            @JsonKey(includeIfNull: false) String? object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionStreamResponse():
        return $default(
            _that.id,
            _that.choices,
            _that.created,
            _that.model,
            _that.serviceTier,
            _that.systemFingerprint,
            _that.object,
            _that.usage);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionStreamResponseChoice>? choices,
            @JsonKey(includeIfNull: false) int? created,
            @JsonKey(includeIfNull: false) String? model,
            @JsonKey(
                name: 'service_tier',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ServiceTier? serviceTier,
            @JsonKey(name: 'system_fingerprint', includeIfNull: false)
            String? systemFingerprint,
            @JsonKey(includeIfNull: false) String? object,
            @JsonKey(includeIfNull: false) CompletionUsage? usage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateChatCompletionStreamResponse() when $default != null:
        return $default(
            _that.id,
            _that.choices,
            _that.created,
            _that.model,
            _that.serviceTier,
            _that.systemFingerprint,
            _that.object,
            _that.usage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateChatCompletionStreamResponse
    extends CreateChatCompletionStreamResponse {
  const _CreateChatCompletionStreamResponse(
      {@JsonKey(includeIfNull: false) this.id,
      @JsonKey(includeIfNull: false)
      final List<ChatCompletionStreamResponseChoice>? choices,
      @JsonKey(includeIfNull: false) this.created,
      @JsonKey(includeIfNull: false) this.model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      @JsonKey(includeIfNull: false) this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();
  factory _CreateChatCompletionStreamResponse.fromJson(
          Map<String, dynamic> json) =>
      _$CreateChatCompletionStreamResponseFromJson(json);

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
  /// last chunk if you set `stream_options: {"include_usage": true}`.
  final List<ChatCompletionStreamResponseChoice>? _choices;

  /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
  /// last chunk if you set `stream_options: {"include_usage": true}`.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionStreamResponseChoice>? get choices {
    final value = _choices;
    if (value == null) return null;
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @override
  @JsonKey(includeIfNull: false)
  final int? created;

  /// The model to generate the completion.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @override
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ServiceTier? serviceTier;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion.chunk`.
  @override
  @JsonKey(includeIfNull: false)
  final String? object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  /// Create a copy of CreateChatCompletionStreamResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateChatCompletionStreamResponseCopyWith<
          _CreateChatCompletionStreamResponse>
      get copyWith => __$CreateChatCompletionStreamResponseCopyWithImpl<
          _CreateChatCompletionStreamResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateChatCompletionStreamResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateChatCompletionStreamResponse &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      serviceTier,
      systemFingerprint,
      object,
      usage);

  @override
  String toString() {
    return 'CreateChatCompletionStreamResponse(id: $id, choices: $choices, created: $created, model: $model, serviceTier: $serviceTier, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class _$CreateChatCompletionStreamResponseCopyWith<$Res>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory _$CreateChatCompletionStreamResponseCopyWith(
          _CreateChatCompletionStreamResponse value,
          $Res Function(_CreateChatCompletionStreamResponse) _then) =
      __$CreateChatCompletionStreamResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      @JsonKey(includeIfNull: false)
      List<ChatCompletionStreamResponseChoice>? choices,
      @JsonKey(includeIfNull: false) int? created,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      @JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$CreateChatCompletionStreamResponseCopyWithImpl<$Res>
    implements _$CreateChatCompletionStreamResponseCopyWith<$Res> {
  __$CreateChatCompletionStreamResponseCopyWithImpl(this._self, this._then);

  final _CreateChatCompletionStreamResponse _self;
  final $Res Function(_CreateChatCompletionStreamResponse) _then;

  /// Create a copy of CreateChatCompletionStreamResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? choices = freezed,
    Object? created = freezed,
    Object? model = freezed,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = freezed,
    Object? usage = freezed,
  }) {
    return _then(_CreateChatCompletionStreamResponse(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: freezed == choices
          ? _self._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>?,
      created: freezed == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceTier: freezed == serviceTier
          ? _self.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _self.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }

  /// Create a copy of CreateChatCompletionStreamResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoice {
  /// A chat completion delta generated by streamed model responses.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamResponseDelta? get delta;

  /// Log probability information for the choice.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamResponseChoiceLogprobs? get logprobs;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index;

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseChoiceCopyWith<
          ChatCompletionStreamResponseChoice>
      get copyWith => _$ChatCompletionStreamResponseChoiceCopyWithImpl<
              ChatCompletionStreamResponseChoice>(
          this as ChatCompletionStreamResponseChoice, _$identity);

  /// Serializes this ChatCompletionStreamResponseChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStreamResponseChoice &&
            (identical(other.delta, delta) || other.delta == delta) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, delta, logprobs, finishReason, index);

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoice(delta: $delta, logprobs: $logprobs, finishReason: $finishReason, index: $index)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceCopyWith(
          ChatCompletionStreamResponseChoice value,
          $Res Function(ChatCompletionStreamResponseChoice) _then) =
      _$ChatCompletionStreamResponseChoiceCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) ChatCompletionStreamResponseDelta? delta,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseChoiceLogprobs? logprobs,
      @JsonKey(
          name: 'finish_reason',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index});

  $ChatCompletionStreamResponseDeltaCopyWith<$Res>? get delta;
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceCopyWithImpl(this._self, this._then);

  final ChatCompletionStreamResponseChoice _self;
  final $Res Function(ChatCompletionStreamResponseChoice) _then;

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = freezed,
    Object? logprobs = freezed,
    Object? finishReason = freezed,
    Object? index = freezed,
  }) {
    return _then(_self.copyWith(
      delta: freezed == delta
          ? _self.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta?,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseChoiceLogprobs?,
      finishReason: freezed == finishReason
          ? _self.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaCopyWith<$Res>? get delta {
    if (_self.delta == null) {
      return null;
    }

    return $ChatCompletionStreamResponseDeltaCopyWith<$Res>(_self.delta!,
        (value) {
      return _then(_self.copyWith(delta: value));
    });
  }

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs {
    if (_self.logprobs == null) {
      return null;
    }

    return $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>(
        _self.logprobs!, (value) {
      return _then(_self.copyWith(logprobs: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionStreamResponseChoice].
extension ChatCompletionStreamResponseChoicePatterns
    on ChatCompletionStreamResponseChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseChoice value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoice() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseChoice value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoice():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionStreamResponseChoice value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoice() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseDelta? delta,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseChoiceLogprobs? logprobs,
            @JsonKey(
                name: 'finish_reason',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionFinishReason? finishReason,
            @JsonKey(includeIfNull: false) int? index)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoice() when $default != null:
        return $default(
            _that.delta, _that.logprobs, _that.finishReason, _that.index);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseDelta? delta,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseChoiceLogprobs? logprobs,
            @JsonKey(
                name: 'finish_reason',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionFinishReason? finishReason,
            @JsonKey(includeIfNull: false) int? index)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoice():
        return $default(
            _that.delta, _that.logprobs, _that.finishReason, _that.index);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseDelta? delta,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseChoiceLogprobs? logprobs,
            @JsonKey(
                name: 'finish_reason',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionFinishReason? finishReason,
            @JsonKey(includeIfNull: false) int? index)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoice() when $default != null:
        return $default(
            _that.delta, _that.logprobs, _that.finishReason, _that.index);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionStreamResponseChoice
    extends ChatCompletionStreamResponseChoice {
  const _ChatCompletionStreamResponseChoice(
      {@JsonKey(includeIfNull: false) this.delta,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(
          name: 'finish_reason',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.finishReason,
      @JsonKey(includeIfNull: false) this.index})
      : super._();
  factory _ChatCompletionStreamResponseChoice.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionStreamResponseChoiceFromJson(json);

  /// A chat completion delta generated by streamed model responses.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamResponseDelta? delta;

  /// Log probability information for the choice.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamResponseChoiceLogprobs? logprobs;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionStreamResponseChoiceCopyWith<
          _ChatCompletionStreamResponseChoice>
      get copyWith => __$ChatCompletionStreamResponseChoiceCopyWithImpl<
          _ChatCompletionStreamResponseChoice>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStreamResponseChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionStreamResponseChoice &&
            (identical(other.delta, delta) || other.delta == delta) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, delta, logprobs, finishReason, index);

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoice(delta: $delta, logprobs: $logprobs, finishReason: $finishReason, index: $index)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionStreamResponseChoiceCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory _$ChatCompletionStreamResponseChoiceCopyWith(
          _ChatCompletionStreamResponseChoice value,
          $Res Function(_ChatCompletionStreamResponseChoice) _then) =
      __$ChatCompletionStreamResponseChoiceCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) ChatCompletionStreamResponseDelta? delta,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseChoiceLogprobs? logprobs,
      @JsonKey(
          name: 'finish_reason',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index});

  @override
  $ChatCompletionStreamResponseDeltaCopyWith<$Res>? get delta;
  @override
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res>
    implements _$ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  __$ChatCompletionStreamResponseChoiceCopyWithImpl(this._self, this._then);

  final _ChatCompletionStreamResponseChoice _self;
  final $Res Function(_ChatCompletionStreamResponseChoice) _then;

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? delta = freezed,
    Object? logprobs = freezed,
    Object? finishReason = freezed,
    Object? index = freezed,
  }) {
    return _then(_ChatCompletionStreamResponseChoice(
      delta: freezed == delta
          ? _self.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta?,
      logprobs: freezed == logprobs
          ? _self.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseChoiceLogprobs?,
      finishReason: freezed == finishReason
          ? _self.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaCopyWith<$Res>? get delta {
    if (_self.delta == null) {
      return null;
    }

    return $ChatCompletionStreamResponseDeltaCopyWith<$Res>(_self.delta!,
        (value) {
      return _then(_self.copyWith(delta: value));
    });
  }

  /// Create a copy of ChatCompletionStreamResponseChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs {
    if (_self.logprobs == null) {
      return null;
    }

    return $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>(
        _self.logprobs!, (value) {
      return _then(_self.copyWith(logprobs: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoiceLogprobs {
  /// A list of message content tokens with log probability information.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get content;

  /// A list of message refusal tokens with log probability information.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get refusal;

  /// Create a copy of ChatCompletionStreamResponseChoiceLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<
          ChatCompletionStreamResponseChoiceLogprobs>
      get copyWith => _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<
              ChatCompletionStreamResponseChoiceLogprobs>(
          this as ChatCompletionStreamResponseChoiceLogprobs, _$identity);

  /// Serializes this ChatCompletionStreamResponseChoiceLogprobs to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStreamResponseChoiceLogprobs &&
            const DeepCollectionEquality().equals(other.content, content) &&
            const DeepCollectionEquality().equals(other.refusal, refusal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(content),
      const DeepCollectionEquality().hash(refusal));

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoiceLogprobs(content: $content, refusal: $refusal)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceLogprobsCopyWith(
          ChatCompletionStreamResponseChoiceLogprobs value,
          $Res Function(ChatCompletionStreamResponseChoiceLogprobs) _then) =
      _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<ChatCompletionTokenLogprob>? content,
      @JsonKey(includeIfNull: false)
      List<ChatCompletionTokenLogprob>? refusal});
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res>
    implements $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl(
      this._self, this._then);

  final ChatCompletionStreamResponseChoiceLogprobs _self;
  final $Res Function(ChatCompletionStreamResponseChoiceLogprobs) _then;

  /// Create a copy of ChatCompletionStreamResponseChoiceLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? refusal = freezed,
  }) {
    return _then(_self.copyWith(
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
      refusal: freezed == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionStreamResponseChoiceLogprobs].
extension ChatCompletionStreamResponseChoiceLogprobsPatterns
    on ChatCompletionStreamResponseChoiceLogprobs {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseChoiceLogprobs value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoiceLogprobs() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseChoiceLogprobs value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoiceLogprobs():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionStreamResponseChoiceLogprobs value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoiceLogprobs() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? content,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? refusal)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoiceLogprobs() when $default != null:
        return $default(_that.content, _that.refusal);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? content,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? refusal)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoiceLogprobs():
        return $default(_that.content, _that.refusal);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? content,
            @JsonKey(includeIfNull: false)
            List<ChatCompletionTokenLogprob>? refusal)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseChoiceLogprobs() when $default != null:
        return $default(_that.content, _that.refusal);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionStreamResponseChoiceLogprobs
    extends ChatCompletionStreamResponseChoiceLogprobs {
  const _ChatCompletionStreamResponseChoiceLogprobs(
      {@JsonKey(includeIfNull: false)
      final List<ChatCompletionTokenLogprob>? content,
      @JsonKey(includeIfNull: false)
      final List<ChatCompletionTokenLogprob>? refusal})
      : _content = content,
        _refusal = refusal,
        super._();
  factory _ChatCompletionStreamResponseChoiceLogprobs.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionStreamResponseChoiceLogprobsFromJson(json);

  /// A list of message content tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _content;

  /// A list of message content tokens with log probability information.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A list of message refusal tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _refusal;

  /// A list of message refusal tokens with log probability information.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTokenLogprob>? get refusal {
    final value = _refusal;
    if (value == null) return null;
    if (_refusal is EqualUnmodifiableListView) return _refusal;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ChatCompletionStreamResponseChoiceLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionStreamResponseChoiceLogprobsCopyWith<
          _ChatCompletionStreamResponseChoiceLogprobs>
      get copyWith => __$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<
          _ChatCompletionStreamResponseChoiceLogprobs>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStreamResponseChoiceLogprobsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionStreamResponseChoiceLogprobs &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            const DeepCollectionEquality().equals(other._refusal, _refusal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_content),
      const DeepCollectionEquality().hash(_refusal));

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoiceLogprobs(content: $content, refusal: $refusal)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  factory _$ChatCompletionStreamResponseChoiceLogprobsCopyWith(
          _ChatCompletionStreamResponseChoiceLogprobs value,
          $Res Function(_ChatCompletionStreamResponseChoiceLogprobs) _then) =
      __$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<ChatCompletionTokenLogprob>? content,
      @JsonKey(includeIfNull: false)
      List<ChatCompletionTokenLogprob>? refusal});
}

/// @nodoc
class __$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res>
    implements _$ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  __$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl(
      this._self, this._then);

  final _ChatCompletionStreamResponseChoiceLogprobs _self;
  final $Res Function(_ChatCompletionStreamResponseChoiceLogprobs) _then;

  /// Create a copy of ChatCompletionStreamResponseChoiceLogprobs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? content = freezed,
    Object? refusal = freezed,
  }) {
    return _then(_ChatCompletionStreamResponseChoiceLogprobs(
      content: freezed == content
          ? _self._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
      refusal: freezed == refusal
          ? _self._refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionStreamResponseDelta {
  /// The role of the messages author.
  /// One of `developer`, `user`, `assistant`, or `tool` (`function` and `system` are deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role;

  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content;

  /// The refusal message generated by the model.
  @JsonKey(includeIfNull: false)
  String? get refusal;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall;

  /// If the audio output modality is requested, this object contains data about the audio response from the model.
  /// [Learn more](https://platform.openai.com/docs/guides/audio).
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamResponseDeltaAudio? get audio;

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaCopyWith<ChatCompletionStreamResponseDelta>
      get copyWith => _$ChatCompletionStreamResponseDeltaCopyWithImpl<
              ChatCompletionStreamResponseDelta>(
          this as ChatCompletionStreamResponseDelta, _$identity);

  /// Serializes this ChatCompletionStreamResponseDelta to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStreamResponseDelta &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.refusal, refusal) || other.refusal == refusal) &&
            const DeepCollectionEquality().equals(other.toolCalls, toolCalls) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            (identical(other.audio, audio) || other.audio == audio));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, refusal,
      const DeepCollectionEquality().hash(toolCalls), functionCall, audio);

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDelta(role: $role, content: $content, refusal: $refusal, toolCalls: $toolCalls, functionCall: $functionCall, audio: $audio)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory $ChatCompletionStreamResponseDeltaCopyWith(
          ChatCompletionStreamResponseDelta value,
          $Res Function(ChatCompletionStreamResponseDelta) _then) =
      _$ChatCompletionStreamResponseDeltaCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role,
      @JsonKey(includeIfNull: false) String? content,
      @JsonKey(includeIfNull: false) String? refusal,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseDeltaAudio? audio});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
  $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res>? get audio;
}

/// @nodoc
class _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  _$ChatCompletionStreamResponseDeltaCopyWithImpl(this._self, this._then);

  final ChatCompletionStreamResponseDelta _self;
  final $Res Function(ChatCompletionStreamResponseDelta) _then;

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = freezed,
    Object? content = freezed,
    Object? refusal = freezed,
    Object? toolCalls = freezed,
    Object? functionCall = freezed,
    Object? audio = freezed,
  }) {
    return _then(_self.copyWith(
      role: freezed == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      refusal: freezed == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _self.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      functionCall: freezed == functionCall
          ? _self.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      audio: freezed == audio
          ? _self.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDeltaAudio?,
    ));
  }

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_self.functionCall == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _self.functionCall!, (value) {
      return _then(_self.copyWith(functionCall: value));
    });
  }

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res>? get audio {
    if (_self.audio == null) {
      return null;
    }

    return $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res>(_self.audio!,
        (value) {
      return _then(_self.copyWith(audio: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionStreamResponseDelta].
extension ChatCompletionStreamResponseDeltaPatterns
    on ChatCompletionStreamResponseDelta {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseDelta value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDelta() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseDelta value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDelta():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionStreamResponseDelta value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDelta() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionMessageRole? role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? refusal,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionStreamMessageFunctionCall? functionCall,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseDeltaAudio? audio)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDelta() when $default != null:
        return $default(_that.role, _that.content, _that.refusal,
            _that.toolCalls, _that.functionCall, _that.audio);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionMessageRole? role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? refusal,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionStreamMessageFunctionCall? functionCall,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseDeltaAudio? audio)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDelta():
        return $default(_that.role, _that.content, _that.refusal,
            _that.toolCalls, _that.functionCall, _that.audio);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionMessageRole? role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? refusal,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionStreamMessageFunctionCall? functionCall,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamResponseDeltaAudio? audio)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDelta() when $default != null:
        return $default(_that.role, _that.content, _that.refusal,
            _that.toolCalls, _that.functionCall, _that.audio);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionStreamResponseDelta
    extends ChatCompletionStreamResponseDelta {
  const _ChatCompletionStreamResponseDelta(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.role,
      @JsonKey(includeIfNull: false) this.content,
      @JsonKey(includeIfNull: false) this.refusal,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall,
      @JsonKey(includeIfNull: false) this.audio})
      : _toolCalls = toolCalls,
        super._();
  factory _ChatCompletionStreamResponseDelta.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionStreamResponseDeltaFromJson(json);

  /// The role of the messages author.
  /// One of `developer`, `user`, `assistant`, or `tool` (`function` and `system` are deprecated).
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionMessageRole? role;

  /// The contents of the chunk message.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// The refusal message generated by the model.
  @override
  @JsonKey(includeIfNull: false)
  final String? refusal;

  /// No Description
  final List<ChatCompletionStreamMessageToolCallChunk>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? functionCall;

  /// If the audio output modality is requested, this object contains data about the audio response from the model.
  /// [Learn more](https://platform.openai.com/docs/guides/audio).
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamResponseDeltaAudio? audio;

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionStreamResponseDeltaCopyWith<
          _ChatCompletionStreamResponseDelta>
      get copyWith => __$ChatCompletionStreamResponseDeltaCopyWithImpl<
          _ChatCompletionStreamResponseDelta>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStreamResponseDeltaToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionStreamResponseDelta &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.refusal, refusal) || other.refusal == refusal) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            (identical(other.audio, audio) || other.audio == audio));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, refusal,
      const DeepCollectionEquality().hash(_toolCalls), functionCall, audio);

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDelta(role: $role, content: $content, refusal: $refusal, toolCalls: $toolCalls, functionCall: $functionCall, audio: $audio)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionStreamResponseDeltaCopyWith<$Res>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory _$ChatCompletionStreamResponseDeltaCopyWith(
          _ChatCompletionStreamResponseDelta value,
          $Res Function(_ChatCompletionStreamResponseDelta) _then) =
      __$ChatCompletionStreamResponseDeltaCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role,
      @JsonKey(includeIfNull: false) String? content,
      @JsonKey(includeIfNull: false) String? refusal,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseDeltaAudio? audio});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
  @override
  $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res>? get audio;
}

/// @nodoc
class __$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res>
    implements _$ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  __$ChatCompletionStreamResponseDeltaCopyWithImpl(this._self, this._then);

  final _ChatCompletionStreamResponseDelta _self;
  final $Res Function(_ChatCompletionStreamResponseDelta) _then;

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = freezed,
    Object? content = freezed,
    Object? refusal = freezed,
    Object? toolCalls = freezed,
    Object? functionCall = freezed,
    Object? audio = freezed,
  }) {
    return _then(_ChatCompletionStreamResponseDelta(
      role: freezed == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      refusal: freezed == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _self._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      functionCall: freezed == functionCall
          ? _self.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      audio: freezed == audio
          ? _self.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDeltaAudio?,
    ));
  }

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_self.functionCall == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _self.functionCall!, (value) {
      return _then(_self.copyWith(functionCall: value));
    });
  }

  /// Create a copy of ChatCompletionStreamResponseDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res>? get audio {
    if (_self.audio == null) {
      return null;
    }

    return $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res>(_self.audio!,
        (value) {
      return _then(_self.copyWith(audio: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionStreamResponseDeltaAudio {
  /// Unique identifier for this audio response.
  @JsonKey(includeIfNull: false)
  String? get id;

  /// The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server
  /// for use in multi-turn conversations.
  @JsonKey(name: 'expires_at', includeIfNull: false)
  int? get expiresAt;

  /// Base64 encoded audio bytes generated by the model, in the format specified in the request.
  @JsonKey(includeIfNull: false)
  String? get data;

  /// Transcript of the audio generated by the model.
  @JsonKey(includeIfNull: false)
  String? get transcript;

  /// Create a copy of ChatCompletionStreamResponseDeltaAudio
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaAudioCopyWith<
          ChatCompletionStreamResponseDeltaAudio>
      get copyWith => _$ChatCompletionStreamResponseDeltaAudioCopyWithImpl<
              ChatCompletionStreamResponseDeltaAudio>(
          this as ChatCompletionStreamResponseDeltaAudio, _$identity);

  /// Serializes this ChatCompletionStreamResponseDeltaAudio to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStreamResponseDeltaAudio &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.transcript, transcript) ||
                other.transcript == transcript));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, expiresAt, data, transcript);

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDeltaAudio(id: $id, expiresAt: $expiresAt, data: $data, transcript: $transcript)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res> {
  factory $ChatCompletionStreamResponseDeltaAudioCopyWith(
          ChatCompletionStreamResponseDeltaAudio value,
          $Res Function(ChatCompletionStreamResponseDeltaAudio) _then) =
      _$ChatCompletionStreamResponseDeltaAudioCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(includeIfNull: false) String? data,
      @JsonKey(includeIfNull: false) String? transcript});
}

/// @nodoc
class _$ChatCompletionStreamResponseDeltaAudioCopyWithImpl<$Res>
    implements $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res> {
  _$ChatCompletionStreamResponseDeltaAudioCopyWithImpl(this._self, this._then);

  final ChatCompletionStreamResponseDeltaAudio _self;
  final $Res Function(ChatCompletionStreamResponseDeltaAudio) _then;

  /// Create a copy of ChatCompletionStreamResponseDeltaAudio
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? expiresAt = freezed,
    Object? data = freezed,
    Object? transcript = freezed,
  }) {
    return _then(_self.copyWith(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      transcript: freezed == transcript
          ? _self.transcript
          : transcript // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionStreamResponseDeltaAudio].
extension ChatCompletionStreamResponseDeltaAudioPatterns
    on ChatCompletionStreamResponseDeltaAudio {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseDeltaAudio value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDeltaAudio() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamResponseDeltaAudio value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDeltaAudio():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionStreamResponseDeltaAudio value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDeltaAudio() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(includeIfNull: false) String? data,
            @JsonKey(includeIfNull: false) String? transcript)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDeltaAudio() when $default != null:
        return $default(
            _that.id, _that.expiresAt, _that.data, _that.transcript);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(includeIfNull: false) String? data,
            @JsonKey(includeIfNull: false) String? transcript)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDeltaAudio():
        return $default(
            _that.id, _that.expiresAt, _that.data, _that.transcript);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(includeIfNull: false) String? data,
            @JsonKey(includeIfNull: false) String? transcript)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamResponseDeltaAudio() when $default != null:
        return $default(
            _that.id, _that.expiresAt, _that.data, _that.transcript);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionStreamResponseDeltaAudio
    extends ChatCompletionStreamResponseDeltaAudio {
  const _ChatCompletionStreamResponseDeltaAudio(
      {@JsonKey(includeIfNull: false) this.id,
      @JsonKey(name: 'expires_at', includeIfNull: false) this.expiresAt,
      @JsonKey(includeIfNull: false) this.data,
      @JsonKey(includeIfNull: false) this.transcript})
      : super._();
  factory _ChatCompletionStreamResponseDeltaAudio.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionStreamResponseDeltaAudioFromJson(json);

  /// Unique identifier for this audio response.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server
  /// for use in multi-turn conversations.
  @override
  @JsonKey(name: 'expires_at', includeIfNull: false)
  final int? expiresAt;

  /// Base64 encoded audio bytes generated by the model, in the format specified in the request.
  @override
  @JsonKey(includeIfNull: false)
  final String? data;

  /// Transcript of the audio generated by the model.
  @override
  @JsonKey(includeIfNull: false)
  final String? transcript;

  /// Create a copy of ChatCompletionStreamResponseDeltaAudio
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionStreamResponseDeltaAudioCopyWith<
          _ChatCompletionStreamResponseDeltaAudio>
      get copyWith => __$ChatCompletionStreamResponseDeltaAudioCopyWithImpl<
          _ChatCompletionStreamResponseDeltaAudio>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStreamResponseDeltaAudioToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionStreamResponseDeltaAudio &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.transcript, transcript) ||
                other.transcript == transcript));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, expiresAt, data, transcript);

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDeltaAudio(id: $id, expiresAt: $expiresAt, data: $data, transcript: $transcript)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionStreamResponseDeltaAudioCopyWith<$Res>
    implements $ChatCompletionStreamResponseDeltaAudioCopyWith<$Res> {
  factory _$ChatCompletionStreamResponseDeltaAudioCopyWith(
          _ChatCompletionStreamResponseDeltaAudio value,
          $Res Function(_ChatCompletionStreamResponseDeltaAudio) _then) =
      __$ChatCompletionStreamResponseDeltaAudioCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(includeIfNull: false) String? data,
      @JsonKey(includeIfNull: false) String? transcript});
}

/// @nodoc
class __$ChatCompletionStreamResponseDeltaAudioCopyWithImpl<$Res>
    implements _$ChatCompletionStreamResponseDeltaAudioCopyWith<$Res> {
  __$ChatCompletionStreamResponseDeltaAudioCopyWithImpl(this._self, this._then);

  final _ChatCompletionStreamResponseDeltaAudio _self;
  final $Res Function(_ChatCompletionStreamResponseDeltaAudio) _then;

  /// Create a copy of ChatCompletionStreamResponseDeltaAudio
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = freezed,
    Object? expiresAt = freezed,
    Object? data = freezed,
    Object? transcript = freezed,
  }) {
    return _then(_ChatCompletionStreamResponseDeltaAudio(
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      transcript: freezed == transcript
          ? _self.transcript
          : transcript // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionStreamMessageFunctionCall {
  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments;

  /// Create a copy of ChatCompletionStreamMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<
          ChatCompletionStreamMessageFunctionCall>
      get copyWith => _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<
              ChatCompletionStreamMessageFunctionCall>(
          this as ChatCompletionStreamMessageFunctionCall, _$identity);

  /// Serializes this ChatCompletionStreamMessageFunctionCall to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStreamMessageFunctionCall &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @override
  String toString() {
    return 'ChatCompletionStreamMessageFunctionCall(name: $name, arguments: $arguments)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionStreamMessageFunctionCallCopyWith(
          ChatCompletionStreamMessageFunctionCall value,
          $Res Function(ChatCompletionStreamMessageFunctionCall) _then) =
      _$ChatCompletionStreamMessageFunctionCallCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionStreamMessageFunctionCallCopyWithImpl(this._self, this._then);

  final ChatCompletionStreamMessageFunctionCall _self;
  final $Res Function(ChatCompletionStreamMessageFunctionCall) _then;

  /// Create a copy of ChatCompletionStreamMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionStreamMessageFunctionCall].
extension ChatCompletionStreamMessageFunctionCallPatterns
    on ChatCompletionStreamMessageFunctionCall {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamMessageFunctionCall value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageFunctionCall() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamMessageFunctionCall value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageFunctionCall():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionStreamMessageFunctionCall value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageFunctionCall() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? arguments)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageFunctionCall() when $default != null:
        return $default(_that.name, _that.arguments);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? arguments)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageFunctionCall():
        return $default(_that.name, _that.arguments);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? arguments)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageFunctionCall() when $default != null:
        return $default(_that.name, _that.arguments);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionStreamMessageFunctionCall
    extends ChatCompletionStreamMessageFunctionCall {
  const _ChatCompletionStreamMessageFunctionCall(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.arguments})
      : super._();
  factory _ChatCompletionStreamMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionStreamMessageFunctionCallFromJson(json);

  /// The name of the function to call.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  @JsonKey(includeIfNull: false)
  final String? arguments;

  /// Create a copy of ChatCompletionStreamMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionStreamMessageFunctionCallCopyWith<
          _ChatCompletionStreamMessageFunctionCall>
      get copyWith => __$ChatCompletionStreamMessageFunctionCallCopyWithImpl<
          _ChatCompletionStreamMessageFunctionCall>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStreamMessageFunctionCallToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionStreamMessageFunctionCall &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @override
  String toString() {
    return 'ChatCompletionStreamMessageFunctionCall(name: $name, arguments: $arguments)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionStreamMessageFunctionCallCopyWith<$Res>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory _$ChatCompletionStreamMessageFunctionCallCopyWith(
          _ChatCompletionStreamMessageFunctionCall value,
          $Res Function(_ChatCompletionStreamMessageFunctionCall) _then) =
      __$ChatCompletionStreamMessageFunctionCallCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class __$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res>
    implements _$ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  __$ChatCompletionStreamMessageFunctionCallCopyWithImpl(
      this._self, this._then);

  final _ChatCompletionStreamMessageFunctionCall _self;
  final $Res Function(_ChatCompletionStreamMessageFunctionCall) _then;

  /// Create a copy of ChatCompletionStreamMessageFunctionCall
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_ChatCompletionStreamMessageFunctionCall(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionStreamMessageToolCallChunk {
  /// No Description
  @JsonKey(includeIfNull: false)
  int? get index;

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id;

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function;

  /// Create a copy of ChatCompletionStreamMessageToolCallChunk
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageToolCallChunkCopyWith<
          ChatCompletionStreamMessageToolCallChunk>
      get copyWith => _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<
              ChatCompletionStreamMessageToolCallChunk>(
          this as ChatCompletionStreamMessageToolCallChunk, _$identity);

  /// Serializes this ChatCompletionStreamMessageToolCallChunk to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionStreamMessageToolCallChunk &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @override
  String toString() {
    return 'ChatCompletionStreamMessageToolCallChunk(index: $index, id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory $ChatCompletionStreamMessageToolCallChunkCopyWith(
          ChatCompletionStreamMessageToolCallChunk value,
          $Res Function(ChatCompletionStreamMessageToolCallChunk) _then) =
      _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) int? index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl(
      this._self, this._then);

  final ChatCompletionStreamMessageToolCallChunk _self;
  final $Res Function(ChatCompletionStreamMessageToolCallChunk) _then;

  /// Create a copy of ChatCompletionStreamMessageToolCallChunk
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = freezed,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_self.copyWith(
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ));
  }

  /// Create a copy of ChatCompletionStreamMessageToolCallChunk
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function {
    if (_self.function == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _self.function!, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionStreamMessageToolCallChunk].
extension ChatCompletionStreamMessageToolCallChunkPatterns
    on ChatCompletionStreamMessageToolCallChunk {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamMessageToolCallChunk value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageToolCallChunk() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionStreamMessageToolCallChunk value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageToolCallChunk():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionStreamMessageToolCallChunk value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageToolCallChunk() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) int? index,
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionStreamMessageToolCallChunkType? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamMessageFunctionCall? function)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageToolCallChunk() when $default != null:
        return $default(_that.index, _that.id, _that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) int? index,
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionStreamMessageToolCallChunkType? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamMessageFunctionCall? function)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageToolCallChunk():
        return $default(_that.index, _that.id, _that.type, _that.function);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) int? index,
            @JsonKey(includeIfNull: false) String? id,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ChatCompletionStreamMessageToolCallChunkType? type,
            @JsonKey(includeIfNull: false)
            ChatCompletionStreamMessageFunctionCall? function)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionStreamMessageToolCallChunk() when $default != null:
        return $default(_that.index, _that.id, _that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionStreamMessageToolCallChunk
    extends ChatCompletionStreamMessageToolCallChunk {
  const _ChatCompletionStreamMessageToolCallChunk(
      {@JsonKey(includeIfNull: false) this.index,
      @JsonKey(includeIfNull: false) this.id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();
  factory _ChatCompletionStreamMessageToolCallChunk.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionStreamMessageToolCallChunkFromJson(json);

  /// No Description
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  /// The ID of the tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionStreamMessageToolCallChunkType? type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? function;

  /// Create a copy of ChatCompletionStreamMessageToolCallChunk
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionStreamMessageToolCallChunkCopyWith<
          _ChatCompletionStreamMessageToolCallChunk>
      get copyWith => __$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<
          _ChatCompletionStreamMessageToolCallChunk>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionStreamMessageToolCallChunkToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionStreamMessageToolCallChunk &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @override
  String toString() {
    return 'ChatCompletionStreamMessageToolCallChunk(index: $index, id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionStreamMessageToolCallChunkCopyWith<$Res>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory _$ChatCompletionStreamMessageToolCallChunkCopyWith(
          _ChatCompletionStreamMessageToolCallChunk value,
          $Res Function(_ChatCompletionStreamMessageToolCallChunk) _then) =
      __$ChatCompletionStreamMessageToolCallChunkCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) int? index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class __$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res>
    implements _$ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  __$ChatCompletionStreamMessageToolCallChunkCopyWithImpl(
      this._self, this._then);

  final _ChatCompletionStreamMessageToolCallChunk _self;
  final $Res Function(_ChatCompletionStreamMessageToolCallChunk) _then;

  /// Create a copy of ChatCompletionStreamMessageToolCallChunk
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = freezed,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_ChatCompletionStreamMessageToolCallChunk(
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ));
  }

  /// Create a copy of ChatCompletionStreamMessageToolCallChunk
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function {
    if (_self.function == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _self.function!, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$ChatCompletionList {
  /// The object type, which is always `list`.
  ChatCompletionListObject get object;

  /// The list of chat completions.
  List<CreateChatCompletionResponse> get data;

  /// The identifier of the first chat completion in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The identifier of the last chat completion in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more chat completions available.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ChatCompletionList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionListCopyWith<ChatCompletionList> get copyWith =>
      _$ChatCompletionListCopyWithImpl<ChatCompletionList>(
          this as ChatCompletionList, _$identity);

  /// Serializes this ChatCompletionList to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionList &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ChatCompletionList(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionListCopyWith<$Res> {
  factory $ChatCompletionListCopyWith(
          ChatCompletionList value, $Res Function(ChatCompletionList) _then) =
      _$ChatCompletionListCopyWithImpl;
  @useResult
  $Res call(
      {ChatCompletionListObject object,
      List<CreateChatCompletionResponse> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ChatCompletionListCopyWithImpl<$Res>
    implements $ChatCompletionListCopyWith<$Res> {
  _$ChatCompletionListCopyWithImpl(this._self, this._then);

  final ChatCompletionList _self;
  final $Res Function(ChatCompletionList) _then;

  /// Create a copy of ChatCompletionList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ChatCompletionListObject,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<CreateChatCompletionResponse>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionList].
extension ChatCompletionListPatterns on ChatCompletionList {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionList value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionList() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionList value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionList():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionList value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionList() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            ChatCompletionListObject object,
            List<CreateChatCompletionResponse> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionList() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            ChatCompletionListObject object,
            List<CreateChatCompletionResponse> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionList():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            ChatCompletionListObject object,
            List<CreateChatCompletionResponse> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionList() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionList extends ChatCompletionList {
  const _ChatCompletionList(
      {required this.object,
      required final List<CreateChatCompletionResponse> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ChatCompletionList.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionListFromJson(json);

  /// The object type, which is always `list`.
  @override
  final ChatCompletionListObject object;

  /// The list of chat completions.
  final List<CreateChatCompletionResponse> _data;

  /// The list of chat completions.
  @override
  List<CreateChatCompletionResponse> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The identifier of the first chat completion in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The identifier of the last chat completion in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more chat completions available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ChatCompletionList
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionListCopyWith<_ChatCompletionList> get copyWith =>
      __$ChatCompletionListCopyWithImpl<_ChatCompletionList>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionListToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionList &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ChatCompletionList(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionListCopyWith<$Res>
    implements $ChatCompletionListCopyWith<$Res> {
  factory _$ChatCompletionListCopyWith(
          _ChatCompletionList value, $Res Function(_ChatCompletionList) _then) =
      __$ChatCompletionListCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionListObject object,
      List<CreateChatCompletionResponse> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ChatCompletionListCopyWithImpl<$Res>
    implements _$ChatCompletionListCopyWith<$Res> {
  __$ChatCompletionListCopyWithImpl(this._self, this._then);

  final _ChatCompletionList _self;
  final $Res Function(_ChatCompletionList) _then;

  /// Create a copy of ChatCompletionList
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ChatCompletionList(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ChatCompletionListObject,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<CreateChatCompletionResponse>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$CompletionUsage {
  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens', includeIfNull: false)
  int? get completionTokens;

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens', includeIfNull: false)
  int? get promptTokens;

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens', includeIfNull: false)
  int? get totalTokens;

  /// Breakdown of tokens used in a completion.
  @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
  CompletionTokensDetails? get completionTokensDetails;

  /// Create a copy of CompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<CompletionUsage> get copyWith =>
      _$CompletionUsageCopyWithImpl<CompletionUsage>(
          this as CompletionUsage, _$identity);

  /// Serializes this CompletionUsage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionUsage &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens) &&
            (identical(
                    other.completionTokensDetails, completionTokensDetails) ||
                other.completionTokensDetails == completionTokensDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, completionTokens, promptTokens,
      totalTokens, completionTokensDetails);

  @override
  String toString() {
    return 'CompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens, completionTokensDetails: $completionTokensDetails)';
  }
}

/// @nodoc
abstract mixin class $CompletionUsageCopyWith<$Res> {
  factory $CompletionUsageCopyWith(
          CompletionUsage value, $Res Function(CompletionUsage) _then) =
      _$CompletionUsageCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens', includeIfNull: false)
      int? completionTokens,
      @JsonKey(name: 'prompt_tokens', includeIfNull: false) int? promptTokens,
      @JsonKey(name: 'total_tokens', includeIfNull: false) int? totalTokens,
      @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
      CompletionTokensDetails? completionTokensDetails});

  $CompletionTokensDetailsCopyWith<$Res>? get completionTokensDetails;
}

/// @nodoc
class _$CompletionUsageCopyWithImpl<$Res>
    implements $CompletionUsageCopyWith<$Res> {
  _$CompletionUsageCopyWithImpl(this._self, this._then);

  final CompletionUsage _self;
  final $Res Function(CompletionUsage) _then;

  /// Create a copy of CompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = freezed,
    Object? totalTokens = freezed,
    Object? completionTokensDetails = freezed,
  }) {
    return _then(_self.copyWith(
      completionTokens: freezed == completionTokens
          ? _self.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: freezed == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      totalTokens: freezed == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      completionTokensDetails: freezed == completionTokensDetails
          ? _self.completionTokensDetails
          : completionTokensDetails // ignore: cast_nullable_to_non_nullable
              as CompletionTokensDetails?,
    ));
  }

  /// Create a copy of CompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionTokensDetailsCopyWith<$Res>? get completionTokensDetails {
    if (_self.completionTokensDetails == null) {
      return null;
    }

    return $CompletionTokensDetailsCopyWith<$Res>(
        _self.completionTokensDetails!, (value) {
      return _then(_self.copyWith(completionTokensDetails: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CompletionUsage].
extension CompletionUsagePatterns on CompletionUsage {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CompletionUsage value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionUsage() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CompletionUsage value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionUsage():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CompletionUsage value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionUsage() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'completion_tokens', includeIfNull: false)
            int? completionTokens,
            @JsonKey(name: 'prompt_tokens', includeIfNull: false)
            int? promptTokens,
            @JsonKey(name: 'total_tokens', includeIfNull: false)
            int? totalTokens,
            @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
            CompletionTokensDetails? completionTokensDetails)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionUsage() when $default != null:
        return $default(_that.completionTokens, _that.promptTokens,
            _that.totalTokens, _that.completionTokensDetails);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'completion_tokens', includeIfNull: false)
            int? completionTokens,
            @JsonKey(name: 'prompt_tokens', includeIfNull: false)
            int? promptTokens,
            @JsonKey(name: 'total_tokens', includeIfNull: false)
            int? totalTokens,
            @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
            CompletionTokensDetails? completionTokensDetails)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionUsage():
        return $default(_that.completionTokens, _that.promptTokens,
            _that.totalTokens, _that.completionTokensDetails);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'completion_tokens', includeIfNull: false)
            int? completionTokens,
            @JsonKey(name: 'prompt_tokens', includeIfNull: false)
            int? promptTokens,
            @JsonKey(name: 'total_tokens', includeIfNull: false)
            int? totalTokens,
            @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
            CompletionTokensDetails? completionTokensDetails)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionUsage() when $default != null:
        return $default(_that.completionTokens, _that.promptTokens,
            _that.totalTokens, _that.completionTokensDetails);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CompletionUsage extends CompletionUsage {
  const _CompletionUsage(
      {@JsonKey(name: 'completion_tokens', includeIfNull: false)
      this.completionTokens,
      @JsonKey(name: 'prompt_tokens', includeIfNull: false) this.promptTokens,
      @JsonKey(name: 'total_tokens', includeIfNull: false) this.totalTokens,
      @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
      this.completionTokensDetails})
      : super._();
  factory _CompletionUsage.fromJson(Map<String, dynamic> json) =>
      _$CompletionUsageFromJson(json);

  /// Number of tokens in the generated completion.
  @override
  @JsonKey(name: 'completion_tokens', includeIfNull: false)
  final int? completionTokens;

  /// Number of tokens in the prompt.
  @override
  @JsonKey(name: 'prompt_tokens', includeIfNull: false)
  final int? promptTokens;

  /// Total number of tokens used in the request (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens', includeIfNull: false)
  final int? totalTokens;

  /// Breakdown of tokens used in a completion.
  @override
  @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
  final CompletionTokensDetails? completionTokensDetails;

  /// Create a copy of CompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CompletionUsageCopyWith<_CompletionUsage> get copyWith =>
      __$CompletionUsageCopyWithImpl<_CompletionUsage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionUsageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CompletionUsage &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens) &&
            (identical(
                    other.completionTokensDetails, completionTokensDetails) ||
                other.completionTokensDetails == completionTokensDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, completionTokens, promptTokens,
      totalTokens, completionTokensDetails);

  @override
  String toString() {
    return 'CompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens, completionTokensDetails: $completionTokensDetails)';
  }
}

/// @nodoc
abstract mixin class _$CompletionUsageCopyWith<$Res>
    implements $CompletionUsageCopyWith<$Res> {
  factory _$CompletionUsageCopyWith(
          _CompletionUsage value, $Res Function(_CompletionUsage) _then) =
      __$CompletionUsageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens', includeIfNull: false)
      int? completionTokens,
      @JsonKey(name: 'prompt_tokens', includeIfNull: false) int? promptTokens,
      @JsonKey(name: 'total_tokens', includeIfNull: false) int? totalTokens,
      @JsonKey(name: 'completion_tokens_details', includeIfNull: false)
      CompletionTokensDetails? completionTokensDetails});

  @override
  $CompletionTokensDetailsCopyWith<$Res>? get completionTokensDetails;
}

/// @nodoc
class __$CompletionUsageCopyWithImpl<$Res>
    implements _$CompletionUsageCopyWith<$Res> {
  __$CompletionUsageCopyWithImpl(this._self, this._then);

  final _CompletionUsage _self;
  final $Res Function(_CompletionUsage) _then;

  /// Create a copy of CompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = freezed,
    Object? totalTokens = freezed,
    Object? completionTokensDetails = freezed,
  }) {
    return _then(_CompletionUsage(
      completionTokens: freezed == completionTokens
          ? _self.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: freezed == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      totalTokens: freezed == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      completionTokensDetails: freezed == completionTokensDetails
          ? _self.completionTokensDetails
          : completionTokensDetails // ignore: cast_nullable_to_non_nullable
              as CompletionTokensDetails?,
    ));
  }

  /// Create a copy of CompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CompletionTokensDetailsCopyWith<$Res>? get completionTokensDetails {
    if (_self.completionTokensDetails == null) {
      return null;
    }

    return $CompletionTokensDetailsCopyWith<$Res>(
        _self.completionTokensDetails!, (value) {
      return _then(_self.copyWith(completionTokensDetails: value));
    });
  }
}

/// @nodoc
mixin _$CompletionTokensDetails {
  /// When using Predicted Outputs, the number of tokens in the
  /// prediction that appeared in the completion.
  @JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
  int? get acceptedPredictionTokens;

  /// Audio input tokens generated by the model.
  @JsonKey(name: 'audio_tokens', includeIfNull: false)
  int? get audioTokens;

  /// Tokens generated by the model for reasoning.
  @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
  int? get reasoningTokens;

  /// When using Predicted Outputs, the number of tokens in the
  /// prediction that did not appear in the completion. However, like
  /// reasoning tokens, these tokens are still counted in the total
  /// completion tokens for purposes of billing, output, and context window
  /// limits.
  @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
  int? get rejectedPredictionTokens;

  /// Create a copy of CompletionTokensDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CompletionTokensDetailsCopyWith<CompletionTokensDetails> get copyWith =>
      _$CompletionTokensDetailsCopyWithImpl<CompletionTokensDetails>(
          this as CompletionTokensDetails, _$identity);

  /// Serializes this CompletionTokensDetails to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CompletionTokensDetails &&
            (identical(
                    other.acceptedPredictionTokens, acceptedPredictionTokens) ||
                other.acceptedPredictionTokens == acceptedPredictionTokens) &&
            (identical(other.audioTokens, audioTokens) ||
                other.audioTokens == audioTokens) &&
            (identical(other.reasoningTokens, reasoningTokens) ||
                other.reasoningTokens == reasoningTokens) &&
            (identical(
                    other.rejectedPredictionTokens, rejectedPredictionTokens) ||
                other.rejectedPredictionTokens == rejectedPredictionTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, acceptedPredictionTokens,
      audioTokens, reasoningTokens, rejectedPredictionTokens);

  @override
  String toString() {
    return 'CompletionTokensDetails(acceptedPredictionTokens: $acceptedPredictionTokens, audioTokens: $audioTokens, reasoningTokens: $reasoningTokens, rejectedPredictionTokens: $rejectedPredictionTokens)';
  }
}

/// @nodoc
abstract mixin class $CompletionTokensDetailsCopyWith<$Res> {
  factory $CompletionTokensDetailsCopyWith(CompletionTokensDetails value,
          $Res Function(CompletionTokensDetails) _then) =
      _$CompletionTokensDetailsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
      int? acceptedPredictionTokens,
      @JsonKey(name: 'audio_tokens', includeIfNull: false) int? audioTokens,
      @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
      int? reasoningTokens,
      @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
      int? rejectedPredictionTokens});
}

/// @nodoc
class _$CompletionTokensDetailsCopyWithImpl<$Res>
    implements $CompletionTokensDetailsCopyWith<$Res> {
  _$CompletionTokensDetailsCopyWithImpl(this._self, this._then);

  final CompletionTokensDetails _self;
  final $Res Function(CompletionTokensDetails) _then;

  /// Create a copy of CompletionTokensDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? acceptedPredictionTokens = freezed,
    Object? audioTokens = freezed,
    Object? reasoningTokens = freezed,
    Object? rejectedPredictionTokens = freezed,
  }) {
    return _then(_self.copyWith(
      acceptedPredictionTokens: freezed == acceptedPredictionTokens
          ? _self.acceptedPredictionTokens
          : acceptedPredictionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      audioTokens: freezed == audioTokens
          ? _self.audioTokens
          : audioTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      reasoningTokens: freezed == reasoningTokens
          ? _self.reasoningTokens
          : reasoningTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      rejectedPredictionTokens: freezed == rejectedPredictionTokens
          ? _self.rejectedPredictionTokens
          : rejectedPredictionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CompletionTokensDetails].
extension CompletionTokensDetailsPatterns on CompletionTokensDetails {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CompletionTokensDetails value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionTokensDetails() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CompletionTokensDetails value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionTokensDetails():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CompletionTokensDetails value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionTokensDetails() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
            int? acceptedPredictionTokens,
            @JsonKey(name: 'audio_tokens', includeIfNull: false)
            int? audioTokens,
            @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
            int? reasoningTokens,
            @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
            int? rejectedPredictionTokens)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CompletionTokensDetails() when $default != null:
        return $default(_that.acceptedPredictionTokens, _that.audioTokens,
            _that.reasoningTokens, _that.rejectedPredictionTokens);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
            int? acceptedPredictionTokens,
            @JsonKey(name: 'audio_tokens', includeIfNull: false)
            int? audioTokens,
            @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
            int? reasoningTokens,
            @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
            int? rejectedPredictionTokens)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionTokensDetails():
        return $default(_that.acceptedPredictionTokens, _that.audioTokens,
            _that.reasoningTokens, _that.rejectedPredictionTokens);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
            int? acceptedPredictionTokens,
            @JsonKey(name: 'audio_tokens', includeIfNull: false)
            int? audioTokens,
            @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
            int? reasoningTokens,
            @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
            int? rejectedPredictionTokens)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CompletionTokensDetails() when $default != null:
        return $default(_that.acceptedPredictionTokens, _that.audioTokens,
            _that.reasoningTokens, _that.rejectedPredictionTokens);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CompletionTokensDetails extends CompletionTokensDetails {
  const _CompletionTokensDetails(
      {@JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
      this.acceptedPredictionTokens,
      @JsonKey(name: 'audio_tokens', includeIfNull: false) this.audioTokens,
      @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
      this.reasoningTokens,
      @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
      this.rejectedPredictionTokens})
      : super._();
  factory _CompletionTokensDetails.fromJson(Map<String, dynamic> json) =>
      _$CompletionTokensDetailsFromJson(json);

  /// When using Predicted Outputs, the number of tokens in the
  /// prediction that appeared in the completion.
  @override
  @JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
  final int? acceptedPredictionTokens;

  /// Audio input tokens generated by the model.
  @override
  @JsonKey(name: 'audio_tokens', includeIfNull: false)
  final int? audioTokens;

  /// Tokens generated by the model for reasoning.
  @override
  @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
  final int? reasoningTokens;

  /// When using Predicted Outputs, the number of tokens in the
  /// prediction that did not appear in the completion. However, like
  /// reasoning tokens, these tokens are still counted in the total
  /// completion tokens for purposes of billing, output, and context window
  /// limits.
  @override
  @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
  final int? rejectedPredictionTokens;

  /// Create a copy of CompletionTokensDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CompletionTokensDetailsCopyWith<_CompletionTokensDetails> get copyWith =>
      __$CompletionTokensDetailsCopyWithImpl<_CompletionTokensDetails>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CompletionTokensDetailsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CompletionTokensDetails &&
            (identical(
                    other.acceptedPredictionTokens, acceptedPredictionTokens) ||
                other.acceptedPredictionTokens == acceptedPredictionTokens) &&
            (identical(other.audioTokens, audioTokens) ||
                other.audioTokens == audioTokens) &&
            (identical(other.reasoningTokens, reasoningTokens) ||
                other.reasoningTokens == reasoningTokens) &&
            (identical(
                    other.rejectedPredictionTokens, rejectedPredictionTokens) ||
                other.rejectedPredictionTokens == rejectedPredictionTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, acceptedPredictionTokens,
      audioTokens, reasoningTokens, rejectedPredictionTokens);

  @override
  String toString() {
    return 'CompletionTokensDetails(acceptedPredictionTokens: $acceptedPredictionTokens, audioTokens: $audioTokens, reasoningTokens: $reasoningTokens, rejectedPredictionTokens: $rejectedPredictionTokens)';
  }
}

/// @nodoc
abstract mixin class _$CompletionTokensDetailsCopyWith<$Res>
    implements $CompletionTokensDetailsCopyWith<$Res> {
  factory _$CompletionTokensDetailsCopyWith(_CompletionTokensDetails value,
          $Res Function(_CompletionTokensDetails) _then) =
      __$CompletionTokensDetailsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'accepted_prediction_tokens', includeIfNull: false)
      int? acceptedPredictionTokens,
      @JsonKey(name: 'audio_tokens', includeIfNull: false) int? audioTokens,
      @JsonKey(name: 'reasoning_tokens', includeIfNull: false)
      int? reasoningTokens,
      @JsonKey(name: 'rejected_prediction_tokens', includeIfNull: false)
      int? rejectedPredictionTokens});
}

/// @nodoc
class __$CompletionTokensDetailsCopyWithImpl<$Res>
    implements _$CompletionTokensDetailsCopyWith<$Res> {
  __$CompletionTokensDetailsCopyWithImpl(this._self, this._then);

  final _CompletionTokensDetails _self;
  final $Res Function(_CompletionTokensDetails) _then;

  /// Create a copy of CompletionTokensDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? acceptedPredictionTokens = freezed,
    Object? audioTokens = freezed,
    Object? reasoningTokens = freezed,
    Object? rejectedPredictionTokens = freezed,
  }) {
    return _then(_CompletionTokensDetails(
      acceptedPredictionTokens: freezed == acceptedPredictionTokens
          ? _self.acceptedPredictionTokens
          : acceptedPredictionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      audioTokens: freezed == audioTokens
          ? _self.audioTokens
          : audioTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      reasoningTokens: freezed == reasoningTokens
          ? _self.reasoningTokens
          : reasoningTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      rejectedPredictionTokens: freezed == rejectedPredictionTokens
          ? _self.rejectedPredictionTokens
          : rejectedPredictionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$CreateEmbeddingRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat;

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @JsonKey(includeIfNull: false)
  int? get dimensions;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateEmbeddingRequestCopyWith<CreateEmbeddingRequest> get copyWith =>
      _$CreateEmbeddingRequestCopyWithImpl<CreateEmbeddingRequest>(
          this as CreateEmbeddingRequest, _$identity);

  /// Serializes this CreateEmbeddingRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateEmbeddingRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.encodingFormat, encodingFormat) ||
                other.encodingFormat == encodingFormat) &&
            (identical(other.dimensions, dimensions) ||
                other.dimensions == dimensions) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, model, input, encodingFormat, dimensions, user);

  @override
  String toString() {
    return 'CreateEmbeddingRequest(model: $model, input: $input, encodingFormat: $encodingFormat, dimensions: $dimensions, user: $user)';
  }
}

/// @nodoc
abstract mixin class $CreateEmbeddingRequestCopyWith<$Res> {
  factory $CreateEmbeddingRequestCopyWith(CreateEmbeddingRequest value,
          $Res Function(CreateEmbeddingRequest) _then) =
      _$CreateEmbeddingRequestCopyWithImpl;
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) int? dimensions,
      @JsonKey(includeIfNull: false) String? user});

  $EmbeddingModelCopyWith<$Res> get model;
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateEmbeddingRequestCopyWithImpl<$Res>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  _$CreateEmbeddingRequestCopyWithImpl(this._self, this._then);

  final CreateEmbeddingRequest _self;
  final $Res Function(CreateEmbeddingRequest) _then;

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? dimensions = freezed,
    Object? user = freezed,
  }) {
    return _then(_self.copyWith(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _self.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      dimensions: freezed == dimensions
          ? _self.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as int?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingModelCopyWith<$Res> get model {
    return $EmbeddingModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingInputCopyWith<$Res> get input {
    return $EmbeddingInputCopyWith<$Res>(_self.input, (value) {
      return _then(_self.copyWith(input: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateEmbeddingRequest].
extension CreateEmbeddingRequestPatterns on CreateEmbeddingRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateEmbeddingRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateEmbeddingRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateEmbeddingRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @_EmbeddingModelConverter() EmbeddingModel model,
            @_EmbeddingInputConverter() EmbeddingInput input,
            @JsonKey(name: 'encoding_format')
            EmbeddingEncodingFormat encodingFormat,
            @JsonKey(includeIfNull: false) int? dimensions,
            @JsonKey(includeIfNull: false) String? user)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingRequest() when $default != null:
        return $default(_that.model, _that.input, _that.encodingFormat,
            _that.dimensions, _that.user);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @_EmbeddingModelConverter() EmbeddingModel model,
            @_EmbeddingInputConverter() EmbeddingInput input,
            @JsonKey(name: 'encoding_format')
            EmbeddingEncodingFormat encodingFormat,
            @JsonKey(includeIfNull: false) int? dimensions,
            @JsonKey(includeIfNull: false) String? user)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingRequest():
        return $default(_that.model, _that.input, _that.encodingFormat,
            _that.dimensions, _that.user);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @_EmbeddingModelConverter() EmbeddingModel model,
            @_EmbeddingInputConverter() EmbeddingInput input,
            @JsonKey(name: 'encoding_format')
            EmbeddingEncodingFormat encodingFormat,
            @JsonKey(includeIfNull: false) int? dimensions,
            @JsonKey(includeIfNull: false) String? user)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingRequest() when $default != null:
        return $default(_that.model, _that.input, _that.encodingFormat,
            _that.dimensions, _that.user);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateEmbeddingRequest extends CreateEmbeddingRequest {
  const _CreateEmbeddingRequest(
      {@_EmbeddingModelConverter() required this.model,
      @_EmbeddingInputConverter() required this.input,
      @JsonKey(name: 'encoding_format')
      this.encodingFormat = EmbeddingEncodingFormat.float,
      @JsonKey(includeIfNull: false) this.dimensions,
      @JsonKey(includeIfNull: false) this.user})
      : super._();
  factory _CreateEmbeddingRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateEmbeddingRequestFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @override
  @_EmbeddingModelConverter()
  final EmbeddingModel model;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @_EmbeddingInputConverter()
  final EmbeddingInput input;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @override
  @JsonKey(name: 'encoding_format')
  final EmbeddingEncodingFormat encodingFormat;

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @override
  @JsonKey(includeIfNull: false)
  final int? dimensions;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateEmbeddingRequestCopyWith<_CreateEmbeddingRequest> get copyWith =>
      __$CreateEmbeddingRequestCopyWithImpl<_CreateEmbeddingRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateEmbeddingRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateEmbeddingRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.encodingFormat, encodingFormat) ||
                other.encodingFormat == encodingFormat) &&
            (identical(other.dimensions, dimensions) ||
                other.dimensions == dimensions) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, model, input, encodingFormat, dimensions, user);

  @override
  String toString() {
    return 'CreateEmbeddingRequest(model: $model, input: $input, encodingFormat: $encodingFormat, dimensions: $dimensions, user: $user)';
  }
}

/// @nodoc
abstract mixin class _$CreateEmbeddingRequestCopyWith<$Res>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  factory _$CreateEmbeddingRequestCopyWith(_CreateEmbeddingRequest value,
          $Res Function(_CreateEmbeddingRequest) _then) =
      __$CreateEmbeddingRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) int? dimensions,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $EmbeddingModelCopyWith<$Res> get model;
  @override
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class __$CreateEmbeddingRequestCopyWithImpl<$Res>
    implements _$CreateEmbeddingRequestCopyWith<$Res> {
  __$CreateEmbeddingRequestCopyWithImpl(this._self, this._then);

  final _CreateEmbeddingRequest _self;
  final $Res Function(_CreateEmbeddingRequest) _then;

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? dimensions = freezed,
    Object? user = freezed,
  }) {
    return _then(_CreateEmbeddingRequest(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _self.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      dimensions: freezed == dimensions
          ? _self.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as int?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingModelCopyWith<$Res> get model {
    return $EmbeddingModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateEmbeddingRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingInputCopyWith<$Res> get input {
    return $EmbeddingInputCopyWith<$Res>(_self.input, (value) {
      return _then(_self.copyWith(input: value));
    });
  }
}

EmbeddingModel _$EmbeddingModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return EmbeddingModelEnumeration.fromJson(json);
    case 'modelId':
      return EmbeddingModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingModel {
  Object get value;

  /// Serializes this EmbeddingModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'EmbeddingModel(value: $value)';
  }
}

/// @nodoc
class $EmbeddingModelCopyWith<$Res> {
  $EmbeddingModelCopyWith(EmbeddingModel _, $Res Function(EmbeddingModel) __);
}

/// Adds pattern-matching-related methods to [EmbeddingModel].
extension EmbeddingModelPatterns on EmbeddingModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingModelEnumeration() when model != null:
        return model(_that);
      case EmbeddingModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingModelEnumeration():
        return model(_that);
      case EmbeddingModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingModelEnumeration() when model != null:
        return model(_that);
      case EmbeddingModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingModelEnumeration() when model != null:
        return model(_that.value);
      case EmbeddingModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingModelEnumeration():
        return model(_that.value);
      case EmbeddingModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingModelEnumeration() when model != null:
        return model(_that.value);
      case EmbeddingModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingModelEnumeration extends EmbeddingModel {
  const EmbeddingModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory EmbeddingModelEnumeration.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingModelEnumerationFromJson(json);

  @override
  final EmbeddingModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingModelEnumerationCopyWith<EmbeddingModelEnumeration> get copyWith =>
      _$EmbeddingModelEnumerationCopyWithImpl<EmbeddingModelEnumeration>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'EmbeddingModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingModelEnumerationCopyWith<$Res>
    implements $EmbeddingModelCopyWith<$Res> {
  factory $EmbeddingModelEnumerationCopyWith(EmbeddingModelEnumeration value,
          $Res Function(EmbeddingModelEnumeration) _then) =
      _$EmbeddingModelEnumerationCopyWithImpl;
  @useResult
  $Res call({EmbeddingModels value});
}

/// @nodoc
class _$EmbeddingModelEnumerationCopyWithImpl<$Res>
    implements $EmbeddingModelEnumerationCopyWith<$Res> {
  _$EmbeddingModelEnumerationCopyWithImpl(this._self, this._then);

  final EmbeddingModelEnumeration _self;
  final $Res Function(EmbeddingModelEnumeration) _then;

  /// Create a copy of EmbeddingModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as EmbeddingModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingModelString extends EmbeddingModel {
  const EmbeddingModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory EmbeddingModelString.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingModelStringCopyWith<EmbeddingModelString> get copyWith =>
      _$EmbeddingModelStringCopyWithImpl<EmbeddingModelString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'EmbeddingModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingModelStringCopyWith<$Res>
    implements $EmbeddingModelCopyWith<$Res> {
  factory $EmbeddingModelStringCopyWith(EmbeddingModelString value,
          $Res Function(EmbeddingModelString) _then) =
      _$EmbeddingModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$EmbeddingModelStringCopyWithImpl<$Res>
    implements $EmbeddingModelStringCopyWith<$Res> {
  _$EmbeddingModelStringCopyWithImpl(this._self, this._then);

  final EmbeddingModelString _self;
  final $Res Function(EmbeddingModelString) _then;

  /// Create a copy of EmbeddingModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

EmbeddingInput _$EmbeddingInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return EmbeddingInputListListInt.fromJson(json);
    case 'tokens':
      return EmbeddingInputListInt.fromJson(json);
    case 'listString':
      return EmbeddingInputListString.fromJson(json);
    case 'string':
      return EmbeddingInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingInput {
  Object get value;

  /// Serializes this EmbeddingInput to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingInput &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'EmbeddingInput(value: $value)';
  }
}

/// @nodoc
class $EmbeddingInputCopyWith<$Res> {
  $EmbeddingInputCopyWith(EmbeddingInput _, $Res Function(EmbeddingInput) __);
}

/// Adds pattern-matching-related methods to [EmbeddingInput].
extension EmbeddingInputPatterns on EmbeddingInput {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingInputListListInt() when listTokens != null:
        return listTokens(_that);
      case EmbeddingInputListInt() when tokens != null:
        return tokens(_that);
      case EmbeddingInputListString() when listString != null:
        return listString(_that);
      case EmbeddingInputString() when string != null:
        return string(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingInputListListInt():
        return listTokens(_that);
      case EmbeddingInputListInt():
        return tokens(_that);
      case EmbeddingInputListString():
        return listString(_that);
      case EmbeddingInputString():
        return string(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingInputListListInt() when listTokens != null:
        return listTokens(_that);
      case EmbeddingInputListInt() when tokens != null:
        return tokens(_that);
      case EmbeddingInputListString() when listString != null:
        return listString(_that);
      case EmbeddingInputString() when string != null:
        return string(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingInputListListInt() when listTokens != null:
        return listTokens(_that.value);
      case EmbeddingInputListInt() when tokens != null:
        return tokens(_that.value);
      case EmbeddingInputListString() when listString != null:
        return listString(_that.value);
      case EmbeddingInputString() when string != null:
        return string(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingInputListListInt():
        return listTokens(_that.value);
      case EmbeddingInputListInt():
        return tokens(_that.value);
      case EmbeddingInputListString():
        return listString(_that.value);
      case EmbeddingInputString():
        return string(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingInputListListInt() when listTokens != null:
        return listTokens(_that.value);
      case EmbeddingInputListInt() when tokens != null:
        return tokens(_that.value);
      case EmbeddingInputListString() when listString != null:
        return listString(_that.value);
      case EmbeddingInputString() when string != null:
        return string(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingInputListListInt extends EmbeddingInput {
  const EmbeddingInputListListInt(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();
  factory EmbeddingInputListListInt.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingInputListListIntFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingInputListListIntCopyWith<EmbeddingInputListListInt> get copyWith =>
      _$EmbeddingInputListListIntCopyWithImpl<EmbeddingInputListListInt>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingInputListListIntToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingInputListListInt &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'EmbeddingInput.listTokens(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingInputListListIntCopyWith<$Res>
    implements $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputListListIntCopyWith(EmbeddingInputListListInt value,
          $Res Function(EmbeddingInputListListInt) _then) =
      _$EmbeddingInputListListIntCopyWithImpl;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class _$EmbeddingInputListListIntCopyWithImpl<$Res>
    implements $EmbeddingInputListListIntCopyWith<$Res> {
  _$EmbeddingInputListListIntCopyWithImpl(this._self, this._then);

  final EmbeddingInputListListInt _self;
  final $Res Function(EmbeddingInputListListInt) _then;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingInputListListInt(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingInputListInt extends EmbeddingInput {
  const EmbeddingInputListInt(final List<int> value, {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();
  factory EmbeddingInputListInt.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingInputListIntFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingInputListIntCopyWith<EmbeddingInputListInt> get copyWith =>
      _$EmbeddingInputListIntCopyWithImpl<EmbeddingInputListInt>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingInputListIntToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingInputListInt &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'EmbeddingInput.tokens(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingInputListIntCopyWith<$Res>
    implements $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputListIntCopyWith(EmbeddingInputListInt value,
          $Res Function(EmbeddingInputListInt) _then) =
      _$EmbeddingInputListIntCopyWithImpl;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class _$EmbeddingInputListIntCopyWithImpl<$Res>
    implements $EmbeddingInputListIntCopyWith<$Res> {
  _$EmbeddingInputListIntCopyWithImpl(this._self, this._then);

  final EmbeddingInputListInt _self;
  final $Res Function(EmbeddingInputListInt) _then;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingInputListInt(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingInputListString extends EmbeddingInput {
  const EmbeddingInputListString(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();
  factory EmbeddingInputListString.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingInputListStringFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingInputListStringCopyWith<EmbeddingInputListString> get copyWith =>
      _$EmbeddingInputListStringCopyWithImpl<EmbeddingInputListString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingInputListStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingInputListString &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'EmbeddingInput.listString(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingInputListStringCopyWith<$Res>
    implements $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputListStringCopyWith(EmbeddingInputListString value,
          $Res Function(EmbeddingInputListString) _then) =
      _$EmbeddingInputListStringCopyWithImpl;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class _$EmbeddingInputListStringCopyWithImpl<$Res>
    implements $EmbeddingInputListStringCopyWith<$Res> {
  _$EmbeddingInputListStringCopyWithImpl(this._self, this._then);

  final EmbeddingInputListString _self;
  final $Res Function(EmbeddingInputListString) _then;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingInputListString(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingInputString extends EmbeddingInput {
  const EmbeddingInputString(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();
  factory EmbeddingInputString.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingInputStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingInputStringCopyWith<EmbeddingInputString> get copyWith =>
      _$EmbeddingInputStringCopyWithImpl<EmbeddingInputString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingInputStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingInputString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'EmbeddingInput.string(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingInputStringCopyWith<$Res>
    implements $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputStringCopyWith(EmbeddingInputString value,
          $Res Function(EmbeddingInputString) _then) =
      _$EmbeddingInputStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$EmbeddingInputStringCopyWithImpl<$Res>
    implements $EmbeddingInputStringCopyWith<$Res> {
  _$EmbeddingInputStringCopyWithImpl(this._self, this._then);

  final EmbeddingInputString _self;
  final $Res Function(EmbeddingInputString) _then;

  /// Create a copy of EmbeddingInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingInputString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$CreateEmbeddingResponse {
  /// The list of embeddings generated by the model.
  List<Embedding> get data;

  /// The name of the model used to generate the embedding.
  String get model;

  /// The object type, which is always "list".
  CreateEmbeddingResponseObject get object;

  /// The usage information for the request.
  @JsonKey(includeIfNull: false)
  EmbeddingUsage? get usage;

  /// Create a copy of CreateEmbeddingResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateEmbeddingResponseCopyWith<CreateEmbeddingResponse> get copyWith =>
      _$CreateEmbeddingResponseCopyWithImpl<CreateEmbeddingResponse>(
          this as CreateEmbeddingResponse, _$identity);

  /// Serializes this CreateEmbeddingResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateEmbeddingResponse &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(data), model, object, usage);

  @override
  String toString() {
    return 'CreateEmbeddingResponse(data: $data, model: $model, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class $CreateEmbeddingResponseCopyWith<$Res> {
  factory $CreateEmbeddingResponseCopyWith(CreateEmbeddingResponse value,
          $Res Function(CreateEmbeddingResponse) _then) =
      _$CreateEmbeddingResponseCopyWithImpl;
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      @JsonKey(includeIfNull: false) EmbeddingUsage? usage});

  $EmbeddingUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateEmbeddingResponseCopyWithImpl<$Res>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  _$CreateEmbeddingResponseCopyWithImpl(this._self, this._then);

  final CreateEmbeddingResponse _self;
  final $Res Function(CreateEmbeddingResponse) _then;

  /// Create a copy of CreateEmbeddingResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_self.copyWith(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage?,
    ));
  }

  /// Create a copy of CreateEmbeddingResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $EmbeddingUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateEmbeddingResponse].
extension CreateEmbeddingResponsePatterns on CreateEmbeddingResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateEmbeddingResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateEmbeddingResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateEmbeddingResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            List<Embedding> data,
            String model,
            CreateEmbeddingResponseObject object,
            @JsonKey(includeIfNull: false) EmbeddingUsage? usage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingResponse() when $default != null:
        return $default(_that.data, _that.model, _that.object, _that.usage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            List<Embedding> data,
            String model,
            CreateEmbeddingResponseObject object,
            @JsonKey(includeIfNull: false) EmbeddingUsage? usage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingResponse():
        return $default(_that.data, _that.model, _that.object, _that.usage);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            List<Embedding> data,
            String model,
            CreateEmbeddingResponseObject object,
            @JsonKey(includeIfNull: false) EmbeddingUsage? usage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateEmbeddingResponse() when $default != null:
        return $default(_that.data, _that.model, _that.object, _that.usage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateEmbeddingResponse extends CreateEmbeddingResponse {
  const _CreateEmbeddingResponse(
      {required final List<Embedding> data,
      required this.model,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _data = data,
        super._();
  factory _CreateEmbeddingResponse.fromJson(Map<String, dynamic> json) =>
      _$CreateEmbeddingResponseFromJson(json);

  /// The list of embeddings generated by the model.
  final List<Embedding> _data;

  /// The list of embeddings generated by the model.
  @override
  List<Embedding> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The name of the model used to generate the embedding.
  @override
  final String model;

  /// The object type, which is always "list".
  @override
  final CreateEmbeddingResponseObject object;

  /// The usage information for the request.
  @override
  @JsonKey(includeIfNull: false)
  final EmbeddingUsage? usage;

  /// Create a copy of CreateEmbeddingResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateEmbeddingResponseCopyWith<_CreateEmbeddingResponse> get copyWith =>
      __$CreateEmbeddingResponseCopyWithImpl<_CreateEmbeddingResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateEmbeddingResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateEmbeddingResponse &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_data), model, object, usage);

  @override
  String toString() {
    return 'CreateEmbeddingResponse(data: $data, model: $model, object: $object, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class _$CreateEmbeddingResponseCopyWith<$Res>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  factory _$CreateEmbeddingResponseCopyWith(_CreateEmbeddingResponse value,
          $Res Function(_CreateEmbeddingResponse) _then) =
      __$CreateEmbeddingResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      @JsonKey(includeIfNull: false) EmbeddingUsage? usage});

  @override
  $EmbeddingUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$CreateEmbeddingResponseCopyWithImpl<$Res>
    implements _$CreateEmbeddingResponseCopyWith<$Res> {
  __$CreateEmbeddingResponseCopyWithImpl(this._self, this._then);

  final _CreateEmbeddingResponse _self;
  final $Res Function(_CreateEmbeddingResponse) _then;

  /// Create a copy of CreateEmbeddingResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_CreateEmbeddingResponse(
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage?,
    ));
  }

  /// Create a copy of CreateEmbeddingResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $EmbeddingUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// @nodoc
mixin _$Embedding {
  /// The index of the embedding in the list of embeddings.
  @JsonKey(includeIfNull: false)
  int? get index;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding;

  /// The object type, which is always "embedding".
  EmbeddingObject get object;

  /// Create a copy of Embedding
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingCopyWith<Embedding> get copyWith =>
      _$EmbeddingCopyWithImpl<Embedding>(this as Embedding, _$identity);

  /// Serializes this Embedding to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Embedding &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.embedding, embedding) ||
                other.embedding == embedding) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, embedding, object);

  @override
  String toString() {
    return 'Embedding(index: $index, embedding: $embedding, object: $object)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingCopyWith<$Res> {
  factory $EmbeddingCopyWith(Embedding value, $Res Function(Embedding) _then) =
      _$EmbeddingCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) int? index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class _$EmbeddingCopyWithImpl<$Res> implements $EmbeddingCopyWith<$Res> {
  _$EmbeddingCopyWithImpl(this._self, this._then);

  final Embedding _self;
  final $Res Function(Embedding) _then;

  /// Create a copy of Embedding
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = freezed,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      embedding: null == embedding
          ? _self.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ));
  }

  /// Create a copy of Embedding
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingVectorCopyWith<$Res> get embedding {
    return $EmbeddingVectorCopyWith<$Res>(_self.embedding, (value) {
      return _then(_self.copyWith(embedding: value));
    });
  }
}

/// Adds pattern-matching-related methods to [Embedding].
extension EmbeddingPatterns on Embedding {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Embedding value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Embedding() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Embedding value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Embedding():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Embedding value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Embedding() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) int? index,
            @_EmbeddingVectorConverter() EmbeddingVector embedding,
            EmbeddingObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Embedding() when $default != null:
        return $default(_that.index, _that.embedding, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) int? index,
            @_EmbeddingVectorConverter() EmbeddingVector embedding,
            EmbeddingObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Embedding():
        return $default(_that.index, _that.embedding, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) int? index,
            @_EmbeddingVectorConverter() EmbeddingVector embedding,
            EmbeddingObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Embedding() when $default != null:
        return $default(_that.index, _that.embedding, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _Embedding extends Embedding {
  const _Embedding(
      {@JsonKey(includeIfNull: false) this.index,
      @_EmbeddingVectorConverter() required this.embedding,
      required this.object})
      : super._();
  factory _Embedding.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingFromJson(json);

  /// The index of the embedding in the list of embeddings.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @override
  @_EmbeddingVectorConverter()
  final EmbeddingVector embedding;

  /// The object type, which is always "embedding".
  @override
  final EmbeddingObject object;

  /// Create a copy of Embedding
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EmbeddingCopyWith<_Embedding> get copyWith =>
      __$EmbeddingCopyWithImpl<_Embedding>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Embedding &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.embedding, embedding) ||
                other.embedding == embedding) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, embedding, object);

  @override
  String toString() {
    return 'Embedding(index: $index, embedding: $embedding, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$EmbeddingCopyWith<$Res>
    implements $EmbeddingCopyWith<$Res> {
  factory _$EmbeddingCopyWith(
          _Embedding value, $Res Function(_Embedding) _then) =
      __$EmbeddingCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) int? index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  @override
  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class __$EmbeddingCopyWithImpl<$Res> implements _$EmbeddingCopyWith<$Res> {
  __$EmbeddingCopyWithImpl(this._self, this._then);

  final _Embedding _self;
  final $Res Function(_Embedding) _then;

  /// Create a copy of Embedding
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = freezed,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_Embedding(
      index: freezed == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      embedding: null == embedding
          ? _self.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ));
  }

  /// Create a copy of Embedding
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbeddingVectorCopyWith<$Res> get embedding {
    return $EmbeddingVectorCopyWith<$Res>(_self.embedding, (value) {
      return _then(_self.copyWith(embedding: value));
    });
  }
}

EmbeddingVector _$EmbeddingVectorFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'vector':
      return EmbeddingVectorListDouble.fromJson(json);
    case 'vectorBase64':
      return EmbeddingVectorString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingVector',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingVector {
  Object get value;

  /// Serializes this EmbeddingVector to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingVector &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'EmbeddingVector(value: $value)';
  }
}

/// @nodoc
class $EmbeddingVectorCopyWith<$Res> {
  $EmbeddingVectorCopyWith(
      EmbeddingVector _, $Res Function(EmbeddingVector) __);
}

/// Adds pattern-matching-related methods to [EmbeddingVector].
extension EmbeddingVectorPatterns on EmbeddingVector {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingVectorListDouble() when vector != null:
        return vector(_that);
      case EmbeddingVectorString() when vectorBase64 != null:
        return vectorBase64(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingVectorListDouble():
        return vector(_that);
      case EmbeddingVectorString():
        return vectorBase64(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingVectorListDouble() when vector != null:
        return vector(_that);
      case EmbeddingVectorString() when vectorBase64 != null:
        return vectorBase64(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingVectorListDouble() when vector != null:
        return vector(_that.value);
      case EmbeddingVectorString() when vectorBase64 != null:
        return vectorBase64(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingVectorListDouble():
        return vector(_that.value);
      case EmbeddingVectorString():
        return vectorBase64(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) {
    final _that = this;
    switch (_that) {
      case EmbeddingVectorListDouble() when vector != null:
        return vector(_that.value);
      case EmbeddingVectorString() when vectorBase64 != null:
        return vectorBase64(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingVectorListDouble extends EmbeddingVector {
  const EmbeddingVectorListDouble(final List<double> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'vector',
        super._();
  factory EmbeddingVectorListDouble.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingVectorListDoubleFromJson(json);

  final List<double> _value;
  @override
  List<double> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingVector
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingVectorListDoubleCopyWith<EmbeddingVectorListDouble> get copyWith =>
      _$EmbeddingVectorListDoubleCopyWithImpl<EmbeddingVectorListDouble>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingVectorListDoubleToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingVectorListDouble &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'EmbeddingVector.vector(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingVectorListDoubleCopyWith<$Res>
    implements $EmbeddingVectorCopyWith<$Res> {
  factory $EmbeddingVectorListDoubleCopyWith(EmbeddingVectorListDouble value,
          $Res Function(EmbeddingVectorListDouble) _then) =
      _$EmbeddingVectorListDoubleCopyWithImpl;
  @useResult
  $Res call({List<double> value});
}

/// @nodoc
class _$EmbeddingVectorListDoubleCopyWithImpl<$Res>
    implements $EmbeddingVectorListDoubleCopyWith<$Res> {
  _$EmbeddingVectorListDoubleCopyWithImpl(this._self, this._then);

  final EmbeddingVectorListDouble _self;
  final $Res Function(EmbeddingVectorListDouble) _then;

  /// Create a copy of EmbeddingVector
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingVectorListDouble(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<double>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class EmbeddingVectorString extends EmbeddingVector {
  const EmbeddingVectorString(this.value, {final String? $type})
      : $type = $type ?? 'vectorBase64',
        super._();
  factory EmbeddingVectorString.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingVectorStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of EmbeddingVector
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingVectorStringCopyWith<EmbeddingVectorString> get copyWith =>
      _$EmbeddingVectorStringCopyWithImpl<EmbeddingVectorString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingVectorStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingVectorString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'EmbeddingVector.vectorBase64(value: $value)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingVectorStringCopyWith<$Res>
    implements $EmbeddingVectorCopyWith<$Res> {
  factory $EmbeddingVectorStringCopyWith(EmbeddingVectorString value,
          $Res Function(EmbeddingVectorString) _then) =
      _$EmbeddingVectorStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$EmbeddingVectorStringCopyWithImpl<$Res>
    implements $EmbeddingVectorStringCopyWith<$Res> {
  _$EmbeddingVectorStringCopyWithImpl(this._self, this._then);

  final EmbeddingVectorString _self;
  final $Res Function(EmbeddingVectorString) _then;

  /// Create a copy of EmbeddingVector
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(EmbeddingVectorString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$EmbeddingUsage {
  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens;

  /// Create a copy of EmbeddingUsage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmbeddingUsageCopyWith<EmbeddingUsage> get copyWith =>
      _$EmbeddingUsageCopyWithImpl<EmbeddingUsage>(
          this as EmbeddingUsage, _$identity);

  /// Serializes this EmbeddingUsage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmbeddingUsage &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, promptTokens, totalTokens);

  @override
  String toString() {
    return 'EmbeddingUsage(promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }
}

/// @nodoc
abstract mixin class $EmbeddingUsageCopyWith<$Res> {
  factory $EmbeddingUsageCopyWith(
          EmbeddingUsage value, $Res Function(EmbeddingUsage) _then) =
      _$EmbeddingUsageCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$EmbeddingUsageCopyWithImpl<$Res>
    implements $EmbeddingUsageCopyWith<$Res> {
  _$EmbeddingUsageCopyWithImpl(this._self, this._then);

  final EmbeddingUsage _self;
  final $Res Function(EmbeddingUsage) _then;

  /// Create a copy of EmbeddingUsage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_self.copyWith(
      promptTokens: null == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [EmbeddingUsage].
extension EmbeddingUsagePatterns on EmbeddingUsage {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_EmbeddingUsage value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EmbeddingUsage() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_EmbeddingUsage value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmbeddingUsage():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_EmbeddingUsage value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmbeddingUsage() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _EmbeddingUsage() when $default != null:
        return $default(_that.promptTokens, _that.totalTokens);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmbeddingUsage():
        return $default(_that.promptTokens, _that.totalTokens);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _EmbeddingUsage() when $default != null:
        return $default(_that.promptTokens, _that.totalTokens);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _EmbeddingUsage extends EmbeddingUsage {
  const _EmbeddingUsage(
      {@JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();
  factory _EmbeddingUsage.fromJson(Map<String, dynamic> json) =>
      _$EmbeddingUsageFromJson(json);

  /// The number of tokens used by the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// The total number of tokens used by the request.
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  /// Create a copy of EmbeddingUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$EmbeddingUsageCopyWith<_EmbeddingUsage> get copyWith =>
      __$EmbeddingUsageCopyWithImpl<_EmbeddingUsage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmbeddingUsageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EmbeddingUsage &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, promptTokens, totalTokens);

  @override
  String toString() {
    return 'EmbeddingUsage(promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }
}

/// @nodoc
abstract mixin class _$EmbeddingUsageCopyWith<$Res>
    implements $EmbeddingUsageCopyWith<$Res> {
  factory _$EmbeddingUsageCopyWith(
          _EmbeddingUsage value, $Res Function(_EmbeddingUsage) _then) =
      __$EmbeddingUsageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$EmbeddingUsageCopyWithImpl<$Res>
    implements _$EmbeddingUsageCopyWith<$Res> {
  __$EmbeddingUsageCopyWithImpl(this._self, this._then);

  final _EmbeddingUsage _self;
  final $Res Function(_EmbeddingUsage) _then;

  /// Create a copy of EmbeddingUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_EmbeddingUsage(
      promptTokens: null == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$CreateFineTuningJobRequest {
  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning#what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose
  /// `fine-tune`.
  ///
  /// The contents of the file should differ depending on if the model uses the
  /// [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input),
  /// [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
  /// format, or if the fine-tuning method uses the
  /// [preference](https://platform.openai.com/docs/api-reference/fine-tuning/preference-input) format.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile;

  /// The hyperparameters used for the fine-tuning job. This value will only be returned when running
  /// `supervised` jobs.
  ///
  /// This value is now deprecated in favor of `method`, and should be passed in under the `method`
  /// parameter.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters;

  /// A string of up to 64 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile;

  /// A list of integrations to enable for your fine-tuning job.
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations;

  /// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
  /// If a seed is not specified, one will be generated for you.
  @JsonKey(includeIfNull: false)
  int? get seed;

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateFineTuningJobRequestCopyWith<CreateFineTuningJobRequest>
      get copyWith =>
          _$CreateFineTuningJobRequestCopyWithImpl<CreateFineTuningJobRequest>(
              this as CreateFineTuningJobRequest, _$identity);

  /// Serializes this CreateFineTuningJobRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateFineTuningJobRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile) &&
            const DeepCollectionEquality()
                .equals(other.integrations, integrations) &&
            (identical(other.seed, seed) || other.seed == seed));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      trainingFile,
      hyperparameters,
      suffix,
      validationFile,
      const DeepCollectionEquality().hash(integrations),
      seed);

  @override
  String toString() {
    return 'CreateFineTuningJobRequest(model: $model, trainingFile: $trainingFile, hyperparameters: $hyperparameters, suffix: $suffix, validationFile: $validationFile, integrations: $integrations, seed: $seed)';
  }
}

/// @nodoc
abstract mixin class $CreateFineTuningJobRequestCopyWith<$Res> {
  factory $CreateFineTuningJobRequestCopyWith(CreateFineTuningJobRequest value,
          $Res Function(CreateFineTuningJobRequest) _then) =
      _$CreateFineTuningJobRequestCopyWithImpl;
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile,
      @JsonKey(includeIfNull: false) List<FineTuningIntegration>? integrations,
      @JsonKey(includeIfNull: false) int? seed});

  $FineTuningModelCopyWith<$Res> get model;
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class _$CreateFineTuningJobRequestCopyWithImpl<$Res>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  _$CreateFineTuningJobRequestCopyWithImpl(this._self, this._then);

  final CreateFineTuningJobRequest _self;
  final $Res Function(CreateFineTuningJobRequest) _then;

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
    Object? integrations = freezed,
    Object? seed = freezed,
  }) {
    return _then(_self.copyWith(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _self.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _self.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _self.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _self.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _self.integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
      seed: freezed == seed
          ? _self.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningModelCopyWith<$Res> get model {
    return $FineTuningModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters {
    if (_self.hyperparameters == null) {
      return null;
    }

    return $FineTuningJobHyperparametersCopyWith<$Res>(_self.hyperparameters!,
        (value) {
      return _then(_self.copyWith(hyperparameters: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateFineTuningJobRequest].
extension CreateFineTuningJobRequestPatterns on CreateFineTuningJobRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateFineTuningJobRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateFineTuningJobRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateFineTuningJobRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateFineTuningJobRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateFineTuningJobRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateFineTuningJobRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @_FineTuningModelConverter() FineTuningModel model,
            @JsonKey(name: 'training_file') String trainingFile,
            @JsonKey(includeIfNull: false)
            FineTuningJobHyperparameters? hyperparameters,
            @JsonKey(includeIfNull: false) String? suffix,
            @JsonKey(name: 'validation_file', includeIfNull: false)
            String? validationFile,
            @JsonKey(includeIfNull: false)
            List<FineTuningIntegration>? integrations,
            @JsonKey(includeIfNull: false) int? seed)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateFineTuningJobRequest() when $default != null:
        return $default(_that.model, _that.trainingFile, _that.hyperparameters,
            _that.suffix, _that.validationFile, _that.integrations, _that.seed);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @_FineTuningModelConverter() FineTuningModel model,
            @JsonKey(name: 'training_file') String trainingFile,
            @JsonKey(includeIfNull: false)
            FineTuningJobHyperparameters? hyperparameters,
            @JsonKey(includeIfNull: false) String? suffix,
            @JsonKey(name: 'validation_file', includeIfNull: false)
            String? validationFile,
            @JsonKey(includeIfNull: false)
            List<FineTuningIntegration>? integrations,
            @JsonKey(includeIfNull: false) int? seed)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateFineTuningJobRequest():
        return $default(_that.model, _that.trainingFile, _that.hyperparameters,
            _that.suffix, _that.validationFile, _that.integrations, _that.seed);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @_FineTuningModelConverter() FineTuningModel model,
            @JsonKey(name: 'training_file') String trainingFile,
            @JsonKey(includeIfNull: false)
            FineTuningJobHyperparameters? hyperparameters,
            @JsonKey(includeIfNull: false) String? suffix,
            @JsonKey(name: 'validation_file', includeIfNull: false)
            String? validationFile,
            @JsonKey(includeIfNull: false)
            List<FineTuningIntegration>? integrations,
            @JsonKey(includeIfNull: false) int? seed)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateFineTuningJobRequest() when $default != null:
        return $default(_that.model, _that.trainingFile, _that.hyperparameters,
            _that.suffix, _that.validationFile, _that.integrations, _that.seed);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateFineTuningJobRequest extends CreateFineTuningJobRequest {
  const _CreateFineTuningJobRequest(
      {@_FineTuningModelConverter() required this.model,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(includeIfNull: false) this.hyperparameters,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      this.validationFile,
      @JsonKey(includeIfNull: false)
      final List<FineTuningIntegration>? integrations,
      @JsonKey(includeIfNull: false) this.seed})
      : _integrations = integrations,
        super._();
  factory _CreateFineTuningJobRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateFineTuningJobRequestFromJson(json);

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning#what-models-can-be-fine-tuned).
  @override
  @_FineTuningModelConverter()
  final FineTuningModel model;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose
  /// `fine-tune`.
  ///
  /// The contents of the file should differ depending on if the model uses the
  /// [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input),
  /// [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
  /// format, or if the fine-tuning method uses the
  /// [preference](https://platform.openai.com/docs/api-reference/fine-tuning/preference-input) format.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The hyperparameters used for the fine-tuning job. This value will only be returned when running
  /// `supervised` jobs.
  ///
  /// This value is now deprecated in favor of `method`, and should be passed in under the `method`
  /// parameter.
  @override
  @JsonKey(includeIfNull: false)
  final FineTuningJobHyperparameters? hyperparameters;

  /// A string of up to 64 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'validation_file', includeIfNull: false)
  final String? validationFile;

  /// A list of integrations to enable for your fine-tuning job.
  final List<FineTuningIntegration>? _integrations;

  /// A list of integrations to enable for your fine-tuning job.
  @override
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations {
    final value = _integrations;
    if (value == null) return null;
    if (_integrations is EqualUnmodifiableListView) return _integrations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
  /// If a seed is not specified, one will be generated for you.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateFineTuningJobRequestCopyWith<_CreateFineTuningJobRequest>
      get copyWith => __$CreateFineTuningJobRequestCopyWithImpl<
          _CreateFineTuningJobRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateFineTuningJobRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateFineTuningJobRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile) &&
            const DeepCollectionEquality()
                .equals(other._integrations, _integrations) &&
            (identical(other.seed, seed) || other.seed == seed));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      trainingFile,
      hyperparameters,
      suffix,
      validationFile,
      const DeepCollectionEquality().hash(_integrations),
      seed);

  @override
  String toString() {
    return 'CreateFineTuningJobRequest(model: $model, trainingFile: $trainingFile, hyperparameters: $hyperparameters, suffix: $suffix, validationFile: $validationFile, integrations: $integrations, seed: $seed)';
  }
}

/// @nodoc
abstract mixin class _$CreateFineTuningJobRequestCopyWith<$Res>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  factory _$CreateFineTuningJobRequestCopyWith(
          _CreateFineTuningJobRequest value,
          $Res Function(_CreateFineTuningJobRequest) _then) =
      __$CreateFineTuningJobRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile,
      @JsonKey(includeIfNull: false) List<FineTuningIntegration>? integrations,
      @JsonKey(includeIfNull: false) int? seed});

  @override
  $FineTuningModelCopyWith<$Res> get model;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class __$CreateFineTuningJobRequestCopyWithImpl<$Res>
    implements _$CreateFineTuningJobRequestCopyWith<$Res> {
  __$CreateFineTuningJobRequestCopyWithImpl(this._self, this._then);

  final _CreateFineTuningJobRequest _self;
  final $Res Function(_CreateFineTuningJobRequest) _then;

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
    Object? integrations = freezed,
    Object? seed = freezed,
  }) {
    return _then(_CreateFineTuningJobRequest(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _self.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _self.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _self.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _self.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _self._integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
      seed: freezed == seed
          ? _self.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningModelCopyWith<$Res> get model {
    return $FineTuningModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateFineTuningJobRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters {
    if (_self.hyperparameters == null) {
      return null;
    }

    return $FineTuningJobHyperparametersCopyWith<$Res>(_self.hyperparameters!,
        (value) {
      return _then(_self.copyWith(hyperparameters: value));
    });
  }
}

FineTuningModel _$FineTuningModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return FineTuningModelEnumeration.fromJson(json);
    case 'modelId':
      return FineTuningModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningModel {
  Object get value;

  /// Serializes this FineTuningModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'FineTuningModel(value: $value)';
  }
}

/// @nodoc
class $FineTuningModelCopyWith<$Res> {
  $FineTuningModelCopyWith(
      FineTuningModel _, $Res Function(FineTuningModel) __);
}

/// Adds pattern-matching-related methods to [FineTuningModel].
extension FineTuningModelPatterns on FineTuningModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningModelEnumeration() when model != null:
        return model(_that);
      case FineTuningModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningModelEnumeration():
        return model(_that);
      case FineTuningModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningModelEnumeration() when model != null:
        return model(_that);
      case FineTuningModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningModelEnumeration() when model != null:
        return model(_that.value);
      case FineTuningModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningModelEnumeration():
        return model(_that.value);
      case FineTuningModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningModelEnumeration() when model != null:
        return model(_that.value);
      case FineTuningModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class FineTuningModelEnumeration extends FineTuningModel {
  const FineTuningModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory FineTuningModelEnumeration.fromJson(Map<String, dynamic> json) =>
      _$FineTuningModelEnumerationFromJson(json);

  @override
  final FineTuningModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of FineTuningModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningModelEnumerationCopyWith<FineTuningModelEnumeration>
      get copyWith =>
          _$FineTuningModelEnumerationCopyWithImpl<FineTuningModelEnumeration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'FineTuningModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $FineTuningModelEnumerationCopyWith<$Res>
    implements $FineTuningModelCopyWith<$Res> {
  factory $FineTuningModelEnumerationCopyWith(FineTuningModelEnumeration value,
          $Res Function(FineTuningModelEnumeration) _then) =
      _$FineTuningModelEnumerationCopyWithImpl;
  @useResult
  $Res call({FineTuningModels value});
}

/// @nodoc
class _$FineTuningModelEnumerationCopyWithImpl<$Res>
    implements $FineTuningModelEnumerationCopyWith<$Res> {
  _$FineTuningModelEnumerationCopyWithImpl(this._self, this._then);

  final FineTuningModelEnumeration _self;
  final $Res Function(FineTuningModelEnumeration) _then;

  /// Create a copy of FineTuningModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(FineTuningModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class FineTuningModelString extends FineTuningModel {
  const FineTuningModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory FineTuningModelString.fromJson(Map<String, dynamic> json) =>
      _$FineTuningModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of FineTuningModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningModelStringCopyWith<FineTuningModelString> get copyWith =>
      _$FineTuningModelStringCopyWithImpl<FineTuningModelString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'FineTuningModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $FineTuningModelStringCopyWith<$Res>
    implements $FineTuningModelCopyWith<$Res> {
  factory $FineTuningModelStringCopyWith(FineTuningModelString value,
          $Res Function(FineTuningModelString) _then) =
      _$FineTuningModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$FineTuningModelStringCopyWithImpl<$Res>
    implements $FineTuningModelStringCopyWith<$Res> {
  _$FineTuningModelStringCopyWithImpl(this._self, this._then);

  final FineTuningModelString _self;
  final $Res Function(FineTuningModelString) _then;

  /// Create a copy of FineTuningModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(FineTuningModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$FineTuningJob {
  /// The object identifier, which can be referenced in the API endpoints.
  String get id;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt;

  /// The hyperparameters used for the fine-tuning job. This value will only be returned when running
  /// `supervised` jobs.
  ///
  /// This value is now deprecated in favor of `method`, and should be passed in under the `method`
  /// parameter.
  FineTuningJobHyperparameters get hyperparameters;

  /// The base model that is being fine-tuned.
  String get model;

  /// The object type, which is always "fine_tuning.job".
  FineTuningJobObject get object;

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles;

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile;

  /// A list of integrations to enable for this fine-tuning job.
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations;

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningJobCopyWith<FineTuningJob> get copyWith =>
      _$FineTuningJobCopyWithImpl<FineTuningJob>(
          this as FineTuningJob, _$identity);

  /// Serializes this FineTuningJob to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningJob &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.fineTunedModel, fineTunedModel) ||
                other.fineTunedModel == fineTunedModel) &&
            (identical(other.finishedAt, finishedAt) ||
                other.finishedAt == finishedAt) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.organizationId, organizationId) ||
                other.organizationId == organizationId) &&
            const DeepCollectionEquality()
                .equals(other.resultFiles, resultFiles) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.trainedTokens, trainedTokens) ||
                other.trainedTokens == trainedTokens) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile) &&
            const DeepCollectionEquality()
                .equals(other.integrations, integrations));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      createdAt,
      error,
      fineTunedModel,
      finishedAt,
      hyperparameters,
      model,
      object,
      organizationId,
      const DeepCollectionEquality().hash(resultFiles),
      status,
      trainedTokens,
      trainingFile,
      validationFile,
      const DeepCollectionEquality().hash(integrations));

  @override
  String toString() {
    return 'FineTuningJob(id: $id, createdAt: $createdAt, error: $error, fineTunedModel: $fineTunedModel, finishedAt: $finishedAt, hyperparameters: $hyperparameters, model: $model, object: $object, organizationId: $organizationId, resultFiles: $resultFiles, status: $status, trainedTokens: $trainedTokens, trainingFile: $trainingFile, validationFile: $validationFile, integrations: $integrations)';
  }
}

/// @nodoc
abstract mixin class $FineTuningJobCopyWith<$Res> {
  factory $FineTuningJobCopyWith(
          FineTuningJob value, $Res Function(FineTuningJob) _then) =
      _$FineTuningJobCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile,
      @JsonKey(includeIfNull: false)
      List<FineTuningIntegration>? integrations});

  $FineTuningJobErrorCopyWith<$Res>? get error;
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class _$FineTuningJobCopyWithImpl<$Res>
    implements $FineTuningJobCopyWith<$Res> {
  _$FineTuningJobCopyWithImpl(this._self, this._then);

  final FineTuningJob _self;
  final $Res Function(FineTuningJob) _then;

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
    Object? integrations = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _self.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _self.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _self.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _self.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _self.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _self.resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _self.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _self.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _self.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _self.integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
    ));
  }

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobErrorCopyWith<$Res>? get error {
    if (_self.error == null) {
      return null;
    }

    return $FineTuningJobErrorCopyWith<$Res>(_self.error!, (value) {
      return _then(_self.copyWith(error: value));
    });
  }

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters {
    return $FineTuningJobHyperparametersCopyWith<$Res>(_self.hyperparameters,
        (value) {
      return _then(_self.copyWith(hyperparameters: value));
    });
  }
}

/// Adds pattern-matching-related methods to [FineTuningJob].
extension FineTuningJobPatterns on FineTuningJob {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningJob value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJob() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningJob value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJob():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningJob value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJob() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            FineTuningJobError? error,
            @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
            @JsonKey(name: 'finished_at') int? finishedAt,
            FineTuningJobHyperparameters hyperparameters,
            String model,
            FineTuningJobObject object,
            @JsonKey(name: 'organization_id') String organizationId,
            @JsonKey(name: 'result_files') List<String> resultFiles,
            FineTuningJobStatus status,
            @JsonKey(name: 'trained_tokens') int? trainedTokens,
            @JsonKey(name: 'training_file') String trainingFile,
            @JsonKey(name: 'validation_file') String? validationFile,
            @JsonKey(includeIfNull: false)
            List<FineTuningIntegration>? integrations)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJob() when $default != null:
        return $default(
            _that.id,
            _that.createdAt,
            _that.error,
            _that.fineTunedModel,
            _that.finishedAt,
            _that.hyperparameters,
            _that.model,
            _that.object,
            _that.organizationId,
            _that.resultFiles,
            _that.status,
            _that.trainedTokens,
            _that.trainingFile,
            _that.validationFile,
            _that.integrations);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            FineTuningJobError? error,
            @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
            @JsonKey(name: 'finished_at') int? finishedAt,
            FineTuningJobHyperparameters hyperparameters,
            String model,
            FineTuningJobObject object,
            @JsonKey(name: 'organization_id') String organizationId,
            @JsonKey(name: 'result_files') List<String> resultFiles,
            FineTuningJobStatus status,
            @JsonKey(name: 'trained_tokens') int? trainedTokens,
            @JsonKey(name: 'training_file') String trainingFile,
            @JsonKey(name: 'validation_file') String? validationFile,
            @JsonKey(includeIfNull: false)
            List<FineTuningIntegration>? integrations)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJob():
        return $default(
            _that.id,
            _that.createdAt,
            _that.error,
            _that.fineTunedModel,
            _that.finishedAt,
            _that.hyperparameters,
            _that.model,
            _that.object,
            _that.organizationId,
            _that.resultFiles,
            _that.status,
            _that.trainedTokens,
            _that.trainingFile,
            _that.validationFile,
            _that.integrations);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            FineTuningJobError? error,
            @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
            @JsonKey(name: 'finished_at') int? finishedAt,
            FineTuningJobHyperparameters hyperparameters,
            String model,
            FineTuningJobObject object,
            @JsonKey(name: 'organization_id') String organizationId,
            @JsonKey(name: 'result_files') List<String> resultFiles,
            FineTuningJobStatus status,
            @JsonKey(name: 'trained_tokens') int? trainedTokens,
            @JsonKey(name: 'training_file') String trainingFile,
            @JsonKey(name: 'validation_file') String? validationFile,
            @JsonKey(includeIfNull: false)
            List<FineTuningIntegration>? integrations)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJob() when $default != null:
        return $default(
            _that.id,
            _that.createdAt,
            _that.error,
            _that.fineTunedModel,
            _that.finishedAt,
            _that.hyperparameters,
            _that.model,
            _that.object,
            _that.organizationId,
            _that.resultFiles,
            _that.status,
            _that.trainedTokens,
            _that.trainingFile,
            _that.validationFile,
            _that.integrations);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningJob extends FineTuningJob {
  const _FineTuningJob(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.error,
      @JsonKey(name: 'fine_tuned_model') required this.fineTunedModel,
      @JsonKey(name: 'finished_at') required this.finishedAt,
      required this.hyperparameters,
      required this.model,
      required this.object,
      @JsonKey(name: 'organization_id') required this.organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required this.status,
      @JsonKey(name: 'trained_tokens') required this.trainedTokens,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(name: 'validation_file') required this.validationFile,
      @JsonKey(includeIfNull: false)
      final List<FineTuningIntegration>? integrations})
      : _resultFiles = resultFiles,
        _integrations = integrations,
        super._();
  factory _FineTuningJob.fromJson(Map<String, dynamic> json) =>
      _$FineTuningJobFromJson(json);

  /// The object identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  @override
  final FineTuningJobError? error;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'fine_tuned_model')
  final String? fineTunedModel;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'finished_at')
  final int? finishedAt;

  /// The hyperparameters used for the fine-tuning job. This value will only be returned when running
  /// `supervised` jobs.
  ///
  /// This value is now deprecated in favor of `method`, and should be passed in under the `method`
  /// parameter.
  @override
  final FineTuningJobHyperparameters hyperparameters;

  /// The base model that is being fine-tuned.
  @override
  final String model;

  /// The object type, which is always "fine_tuning.job".
  @override
  final FineTuningJobObject object;

  /// The organization that owns the fine-tuning job.
  @override
  @JsonKey(name: 'organization_id')
  final String organizationId;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  final List<String> _resultFiles;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'result_files')
  List<String> get resultFiles {
    if (_resultFiles is EqualUnmodifiableListView) return _resultFiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_resultFiles);
  }

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  @override
  final FineTuningJobStatus status;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'trained_tokens')
  final int? trainedTokens;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'validation_file')
  final String? validationFile;

  /// A list of integrations to enable for this fine-tuning job.
  final List<FineTuningIntegration>? _integrations;

  /// A list of integrations to enable for this fine-tuning job.
  @override
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations {
    final value = _integrations;
    if (value == null) return null;
    if (_integrations is EqualUnmodifiableListView) return _integrations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningJobCopyWith<_FineTuningJob> get copyWith =>
      __$FineTuningJobCopyWithImpl<_FineTuningJob>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningJobToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningJob &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.fineTunedModel, fineTunedModel) ||
                other.fineTunedModel == fineTunedModel) &&
            (identical(other.finishedAt, finishedAt) ||
                other.finishedAt == finishedAt) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.organizationId, organizationId) ||
                other.organizationId == organizationId) &&
            const DeepCollectionEquality()
                .equals(other._resultFiles, _resultFiles) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.trainedTokens, trainedTokens) ||
                other.trainedTokens == trainedTokens) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile) &&
            const DeepCollectionEquality()
                .equals(other._integrations, _integrations));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      createdAt,
      error,
      fineTunedModel,
      finishedAt,
      hyperparameters,
      model,
      object,
      organizationId,
      const DeepCollectionEquality().hash(_resultFiles),
      status,
      trainedTokens,
      trainingFile,
      validationFile,
      const DeepCollectionEquality().hash(_integrations));

  @override
  String toString() {
    return 'FineTuningJob(id: $id, createdAt: $createdAt, error: $error, fineTunedModel: $fineTunedModel, finishedAt: $finishedAt, hyperparameters: $hyperparameters, model: $model, object: $object, organizationId: $organizationId, resultFiles: $resultFiles, status: $status, trainedTokens: $trainedTokens, trainingFile: $trainingFile, validationFile: $validationFile, integrations: $integrations)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningJobCopyWith<$Res>
    implements $FineTuningJobCopyWith<$Res> {
  factory _$FineTuningJobCopyWith(
          _FineTuningJob value, $Res Function(_FineTuningJob) _then) =
      __$FineTuningJobCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile,
      @JsonKey(includeIfNull: false)
      List<FineTuningIntegration>? integrations});

  @override
  $FineTuningJobErrorCopyWith<$Res>? get error;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class __$FineTuningJobCopyWithImpl<$Res>
    implements _$FineTuningJobCopyWith<$Res> {
  __$FineTuningJobCopyWithImpl(this._self, this._then);

  final _FineTuningJob _self;
  final $Res Function(_FineTuningJob) _then;

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
    Object? integrations = freezed,
  }) {
    return _then(_FineTuningJob(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _self.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _self.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _self.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _self.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _self.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _self._resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _self.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _self.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _self.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _self._integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
    ));
  }

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobErrorCopyWith<$Res>? get error {
    if (_self.error == null) {
      return null;
    }

    return $FineTuningJobErrorCopyWith<$Res>(_self.error!, (value) {
      return _then(_self.copyWith(error: value));
    });
  }

  /// Create a copy of FineTuningJob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters {
    return $FineTuningJobHyperparametersCopyWith<$Res>(_self.hyperparameters,
        (value) {
      return _then(_self.copyWith(hyperparameters: value));
    });
  }
}

/// @nodoc
mixin _$FineTuningIntegration {
  /// The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
  FineTuningIntegrationType get type;

  /// The settings for your integration with Weights and Biases. This payload specifies the project that
  /// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
  /// to your run, and set a default entity (team, username, etc) to be associated with your run.
  FineTuningIntegrationWandb get wandb;

  /// Create a copy of FineTuningIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningIntegrationCopyWith<FineTuningIntegration> get copyWith =>
      _$FineTuningIntegrationCopyWithImpl<FineTuningIntegration>(
          this as FineTuningIntegration, _$identity);

  /// Serializes this FineTuningIntegration to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningIntegration &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.wandb, wandb) || other.wandb == wandb));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, wandb);

  @override
  String toString() {
    return 'FineTuningIntegration(type: $type, wandb: $wandb)';
  }
}

/// @nodoc
abstract mixin class $FineTuningIntegrationCopyWith<$Res> {
  factory $FineTuningIntegrationCopyWith(FineTuningIntegration value,
          $Res Function(FineTuningIntegration) _then) =
      _$FineTuningIntegrationCopyWithImpl;
  @useResult
  $Res call({FineTuningIntegrationType type, FineTuningIntegrationWandb wandb});

  $FineTuningIntegrationWandbCopyWith<$Res> get wandb;
}

/// @nodoc
class _$FineTuningIntegrationCopyWithImpl<$Res>
    implements $FineTuningIntegrationCopyWith<$Res> {
  _$FineTuningIntegrationCopyWithImpl(this._self, this._then);

  final FineTuningIntegration _self;
  final $Res Function(FineTuningIntegration) _then;

  /// Create a copy of FineTuningIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? wandb = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationType,
      wandb: null == wandb
          ? _self.wandb
          : wandb // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationWandb,
    ));
  }

  /// Create a copy of FineTuningIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningIntegrationWandbCopyWith<$Res> get wandb {
    return $FineTuningIntegrationWandbCopyWith<$Res>(_self.wandb, (value) {
      return _then(_self.copyWith(wandb: value));
    });
  }
}

/// Adds pattern-matching-related methods to [FineTuningIntegration].
extension FineTuningIntegrationPatterns on FineTuningIntegration {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningIntegration value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegration() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningIntegration value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegration():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningIntegration value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegration() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            FineTuningIntegrationType type, FineTuningIntegrationWandb wandb)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegration() when $default != null:
        return $default(_that.type, _that.wandb);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            FineTuningIntegrationType type, FineTuningIntegrationWandb wandb)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegration():
        return $default(_that.type, _that.wandb);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            FineTuningIntegrationType type, FineTuningIntegrationWandb wandb)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegration() when $default != null:
        return $default(_that.type, _that.wandb);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningIntegration extends FineTuningIntegration {
  const _FineTuningIntegration({required this.type, required this.wandb})
      : super._();
  factory _FineTuningIntegration.fromJson(Map<String, dynamic> json) =>
      _$FineTuningIntegrationFromJson(json);

  /// The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
  @override
  final FineTuningIntegrationType type;

  /// The settings for your integration with Weights and Biases. This payload specifies the project that
  /// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
  /// to your run, and set a default entity (team, username, etc) to be associated with your run.
  @override
  final FineTuningIntegrationWandb wandb;

  /// Create a copy of FineTuningIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningIntegrationCopyWith<_FineTuningIntegration> get copyWith =>
      __$FineTuningIntegrationCopyWithImpl<_FineTuningIntegration>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningIntegrationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningIntegration &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.wandb, wandb) || other.wandb == wandb));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, wandb);

  @override
  String toString() {
    return 'FineTuningIntegration(type: $type, wandb: $wandb)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningIntegrationCopyWith<$Res>
    implements $FineTuningIntegrationCopyWith<$Res> {
  factory _$FineTuningIntegrationCopyWith(_FineTuningIntegration value,
          $Res Function(_FineTuningIntegration) _then) =
      __$FineTuningIntegrationCopyWithImpl;
  @override
  @useResult
  $Res call({FineTuningIntegrationType type, FineTuningIntegrationWandb wandb});

  @override
  $FineTuningIntegrationWandbCopyWith<$Res> get wandb;
}

/// @nodoc
class __$FineTuningIntegrationCopyWithImpl<$Res>
    implements _$FineTuningIntegrationCopyWith<$Res> {
  __$FineTuningIntegrationCopyWithImpl(this._self, this._then);

  final _FineTuningIntegration _self;
  final $Res Function(_FineTuningIntegration) _then;

  /// Create a copy of FineTuningIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? wandb = null,
  }) {
    return _then(_FineTuningIntegration(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationType,
      wandb: null == wandb
          ? _self.wandb
          : wandb // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationWandb,
    ));
  }

  /// Create a copy of FineTuningIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningIntegrationWandbCopyWith<$Res> get wandb {
    return $FineTuningIntegrationWandbCopyWith<$Res>(_self.wandb, (value) {
      return _then(_self.copyWith(wandb: value));
    });
  }
}

/// @nodoc
mixin _$FineTuningIntegrationWandb {
  /// The name of the project that the new run will be created under.
  String get project;

  /// A display name to set for the run. If not set, we will use the Job ID as the name.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// The entity to use for the run. This allows you to set the team or username of the WandB user that you would
  /// like associated with the run. If not set, the default entity for the registered WandB API key is used.
  @JsonKey(includeIfNull: false)
  String? get entity;

  /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
  /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
  @JsonKey(includeIfNull: false)
  List<String>? get tags;

  /// Create a copy of FineTuningIntegrationWandb
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningIntegrationWandbCopyWith<FineTuningIntegrationWandb>
      get copyWith =>
          _$FineTuningIntegrationWandbCopyWithImpl<FineTuningIntegrationWandb>(
              this as FineTuningIntegrationWandb, _$identity);

  /// Serializes this FineTuningIntegrationWandb to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningIntegrationWandb &&
            (identical(other.project, project) || other.project == project) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.entity, entity) || other.entity == entity) &&
            const DeepCollectionEquality().equals(other.tags, tags));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, project, name, entity,
      const DeepCollectionEquality().hash(tags));

  @override
  String toString() {
    return 'FineTuningIntegrationWandb(project: $project, name: $name, entity: $entity, tags: $tags)';
  }
}

/// @nodoc
abstract mixin class $FineTuningIntegrationWandbCopyWith<$Res> {
  factory $FineTuningIntegrationWandbCopyWith(FineTuningIntegrationWandb value,
          $Res Function(FineTuningIntegrationWandb) _then) =
      _$FineTuningIntegrationWandbCopyWithImpl;
  @useResult
  $Res call(
      {String project,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? entity,
      @JsonKey(includeIfNull: false) List<String>? tags});
}

/// @nodoc
class _$FineTuningIntegrationWandbCopyWithImpl<$Res>
    implements $FineTuningIntegrationWandbCopyWith<$Res> {
  _$FineTuningIntegrationWandbCopyWithImpl(this._self, this._then);

  final FineTuningIntegrationWandb _self;
  final $Res Function(FineTuningIntegrationWandb) _then;

  /// Create a copy of FineTuningIntegrationWandb
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? project = null,
    Object? name = freezed,
    Object? entity = freezed,
    Object? tags = freezed,
  }) {
    return _then(_self.copyWith(
      project: null == project
          ? _self.project
          : project // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      entity: freezed == entity
          ? _self.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: freezed == tags
          ? _self.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [FineTuningIntegrationWandb].
extension FineTuningIntegrationWandbPatterns on FineTuningIntegrationWandb {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningIntegrationWandb value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegrationWandb() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningIntegrationWandb value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegrationWandb():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningIntegrationWandb value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegrationWandb() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String project,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? entity,
            @JsonKey(includeIfNull: false) List<String>? tags)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegrationWandb() when $default != null:
        return $default(_that.project, _that.name, _that.entity, _that.tags);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String project,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? entity,
            @JsonKey(includeIfNull: false) List<String>? tags)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegrationWandb():
        return $default(_that.project, _that.name, _that.entity, _that.tags);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String project,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? entity,
            @JsonKey(includeIfNull: false) List<String>? tags)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningIntegrationWandb() when $default != null:
        return $default(_that.project, _that.name, _that.entity, _that.tags);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningIntegrationWandb extends FineTuningIntegrationWandb {
  const _FineTuningIntegrationWandb(
      {required this.project,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.entity,
      @JsonKey(includeIfNull: false) final List<String>? tags})
      : _tags = tags,
        super._();
  factory _FineTuningIntegrationWandb.fromJson(Map<String, dynamic> json) =>
      _$FineTuningIntegrationWandbFromJson(json);

  /// The name of the project that the new run will be created under.
  @override
  final String project;

  /// A display name to set for the run. If not set, we will use the Job ID as the name.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The entity to use for the run. This allows you to set the team or username of the WandB user that you would
  /// like associated with the run. If not set, the default entity for the registered WandB API key is used.
  @override
  @JsonKey(includeIfNull: false)
  final String? entity;

  /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
  /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
  final List<String>? _tags;

  /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
  /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
  @override
  @JsonKey(includeIfNull: false)
  List<String>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of FineTuningIntegrationWandb
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningIntegrationWandbCopyWith<_FineTuningIntegrationWandb>
      get copyWith => __$FineTuningIntegrationWandbCopyWithImpl<
          _FineTuningIntegrationWandb>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningIntegrationWandbToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningIntegrationWandb &&
            (identical(other.project, project) || other.project == project) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.entity, entity) || other.entity == entity) &&
            const DeepCollectionEquality().equals(other._tags, _tags));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, project, name, entity,
      const DeepCollectionEquality().hash(_tags));

  @override
  String toString() {
    return 'FineTuningIntegrationWandb(project: $project, name: $name, entity: $entity, tags: $tags)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningIntegrationWandbCopyWith<$Res>
    implements $FineTuningIntegrationWandbCopyWith<$Res> {
  factory _$FineTuningIntegrationWandbCopyWith(
          _FineTuningIntegrationWandb value,
          $Res Function(_FineTuningIntegrationWandb) _then) =
      __$FineTuningIntegrationWandbCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String project,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? entity,
      @JsonKey(includeIfNull: false) List<String>? tags});
}

/// @nodoc
class __$FineTuningIntegrationWandbCopyWithImpl<$Res>
    implements _$FineTuningIntegrationWandbCopyWith<$Res> {
  __$FineTuningIntegrationWandbCopyWithImpl(this._self, this._then);

  final _FineTuningIntegrationWandb _self;
  final $Res Function(_FineTuningIntegrationWandb) _then;

  /// Create a copy of FineTuningIntegrationWandb
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? project = null,
    Object? name = freezed,
    Object? entity = freezed,
    Object? tags = freezed,
  }) {
    return _then(_FineTuningIntegrationWandb(
      project: null == project
          ? _self.project
          : project // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      entity: freezed == entity
          ? _self.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: freezed == tags
          ? _self._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
mixin _$FineTuningJobError {
  /// A machine-readable error code.
  String get code;

  /// A human-readable error message.
  String get message;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param;

  /// Create a copy of FineTuningJobError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningJobErrorCopyWith<FineTuningJobError> get copyWith =>
      _$FineTuningJobErrorCopyWithImpl<FineTuningJobError>(
          this as FineTuningJobError, _$identity);

  /// Serializes this FineTuningJobError to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningJobError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param);

  @override
  String toString() {
    return 'FineTuningJobError(code: $code, message: $message, param: $param)';
  }
}

/// @nodoc
abstract mixin class $FineTuningJobErrorCopyWith<$Res> {
  factory $FineTuningJobErrorCopyWith(
          FineTuningJobError value, $Res Function(FineTuningJobError) _then) =
      _$FineTuningJobErrorCopyWithImpl;
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class _$FineTuningJobErrorCopyWithImpl<$Res>
    implements $FineTuningJobErrorCopyWith<$Res> {
  _$FineTuningJobErrorCopyWithImpl(this._self, this._then);

  final FineTuningJobError _self;
  final $Res Function(FineTuningJobError) _then;

  /// Create a copy of FineTuningJobError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_self.copyWith(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _self.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [FineTuningJobError].
extension FineTuningJobErrorPatterns on FineTuningJobError {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningJobError value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobError() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningJobError value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobError():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningJobError value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobError() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String code, String message, String? param)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobError() when $default != null:
        return $default(_that.code, _that.message, _that.param);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String code, String message, String? param) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobError():
        return $default(_that.code, _that.message, _that.param);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String code, String message, String? param)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobError() when $default != null:
        return $default(_that.code, _that.message, _that.param);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningJobError extends FineTuningJobError {
  const _FineTuningJobError(
      {required this.code, required this.message, required this.param})
      : super._();
  factory _FineTuningJobError.fromJson(Map<String, dynamic> json) =>
      _$FineTuningJobErrorFromJson(json);

  /// A machine-readable error code.
  @override
  final String code;

  /// A human-readable error message.
  @override
  final String message;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  @override
  final String? param;

  /// Create a copy of FineTuningJobError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningJobErrorCopyWith<_FineTuningJobError> get copyWith =>
      __$FineTuningJobErrorCopyWithImpl<_FineTuningJobError>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningJobErrorToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningJobError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param);

  @override
  String toString() {
    return 'FineTuningJobError(code: $code, message: $message, param: $param)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningJobErrorCopyWith<$Res>
    implements $FineTuningJobErrorCopyWith<$Res> {
  factory _$FineTuningJobErrorCopyWith(
          _FineTuningJobError value, $Res Function(_FineTuningJobError) _then) =
      __$FineTuningJobErrorCopyWithImpl;
  @override
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class __$FineTuningJobErrorCopyWithImpl<$Res>
    implements _$FineTuningJobErrorCopyWith<$Res> {
  __$FineTuningJobErrorCopyWithImpl(this._self, this._then);

  final _FineTuningJobError _self;
  final $Res Function(_FineTuningJobError) _then;

  /// Create a copy of FineTuningJobError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_FineTuningJobError(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _self.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$FineTuningJobHyperparameters {
  /// The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.
  ///
  /// "auto" decides the optimal number of epochs based on the size of the dataset. If setting the number
  /// manually, we support any number between 1 and 50 epochs.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs;

  /// Create a copy of FineTuningJobHyperparameters
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<FineTuningJobHyperparameters>
      get copyWith => _$FineTuningJobHyperparametersCopyWithImpl<
              FineTuningJobHyperparameters>(
          this as FineTuningJobHyperparameters, _$identity);

  /// Serializes this FineTuningJobHyperparameters to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningJobHyperparameters &&
            (identical(other.nEpochs, nEpochs) || other.nEpochs == nEpochs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, nEpochs);

  @override
  String toString() {
    return 'FineTuningJobHyperparameters(nEpochs: $nEpochs)';
  }
}

/// @nodoc
abstract mixin class $FineTuningJobHyperparametersCopyWith<$Res> {
  factory $FineTuningJobHyperparametersCopyWith(
          FineTuningJobHyperparameters value,
          $Res Function(FineTuningJobHyperparameters) _then) =
      _$FineTuningJobHyperparametersCopyWithImpl;
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class _$FineTuningJobHyperparametersCopyWithImpl<$Res>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  _$FineTuningJobHyperparametersCopyWithImpl(this._self, this._then);

  final FineTuningJobHyperparameters _self;
  final $Res Function(FineTuningJobHyperparameters) _then;

  /// Create a copy of FineTuningJobHyperparameters
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_self.copyWith(
      nEpochs: null == nEpochs
          ? _self.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ));
  }

  /// Create a copy of FineTuningJobHyperparameters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsCopyWith<$Res> get nEpochs {
    return $FineTuningNEpochsCopyWith<$Res>(_self.nEpochs, (value) {
      return _then(_self.copyWith(nEpochs: value));
    });
  }
}

/// Adds pattern-matching-related methods to [FineTuningJobHyperparameters].
extension FineTuningJobHyperparametersPatterns on FineTuningJobHyperparameters {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningJobHyperparameters value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobHyperparameters() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningJobHyperparameters value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobHyperparameters():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningJobHyperparameters value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobHyperparameters() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @_FineTuningNEpochsConverter()
            @JsonKey(name: 'n_epochs')
            FineTuningNEpochs nEpochs)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobHyperparameters() when $default != null:
        return $default(_that.nEpochs);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @_FineTuningNEpochsConverter()
            @JsonKey(name: 'n_epochs')
            FineTuningNEpochs nEpochs)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobHyperparameters():
        return $default(_that.nEpochs);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @_FineTuningNEpochsConverter()
            @JsonKey(name: 'n_epochs')
            FineTuningNEpochs nEpochs)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobHyperparameters() when $default != null:
        return $default(_that.nEpochs);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningJobHyperparameters extends FineTuningJobHyperparameters {
  const _FineTuningJobHyperparameters(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      required this.nEpochs})
      : super._();
  factory _FineTuningJobHyperparameters.fromJson(Map<String, dynamic> json) =>
      _$FineTuningJobHyperparametersFromJson(json);

  /// The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.
  ///
  /// "auto" decides the optimal number of epochs based on the size of the dataset. If setting the number
  /// manually, we support any number between 1 and 50 epochs.
  @override
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  final FineTuningNEpochs nEpochs;

  /// Create a copy of FineTuningJobHyperparameters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningJobHyperparametersCopyWith<_FineTuningJobHyperparameters>
      get copyWith => __$FineTuningJobHyperparametersCopyWithImpl<
          _FineTuningJobHyperparameters>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningJobHyperparametersToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningJobHyperparameters &&
            (identical(other.nEpochs, nEpochs) || other.nEpochs == nEpochs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, nEpochs);

  @override
  String toString() {
    return 'FineTuningJobHyperparameters(nEpochs: $nEpochs)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningJobHyperparametersCopyWith<$Res>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  factory _$FineTuningJobHyperparametersCopyWith(
          _FineTuningJobHyperparameters value,
          $Res Function(_FineTuningJobHyperparameters) _then) =
      __$FineTuningJobHyperparametersCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  @override
  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class __$FineTuningJobHyperparametersCopyWithImpl<$Res>
    implements _$FineTuningJobHyperparametersCopyWith<$Res> {
  __$FineTuningJobHyperparametersCopyWithImpl(this._self, this._then);

  final _FineTuningJobHyperparameters _self;
  final $Res Function(_FineTuningJobHyperparameters) _then;

  /// Create a copy of FineTuningJobHyperparameters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_FineTuningJobHyperparameters(
      nEpochs: null == nEpochs
          ? _self.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ));
  }

  /// Create a copy of FineTuningJobHyperparameters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsCopyWith<$Res> get nEpochs {
    return $FineTuningNEpochsCopyWith<$Res>(_self.nEpochs, (value) {
      return _then(_self.copyWith(nEpochs: value));
    });
  }
}

FineTuningNEpochs _$FineTuningNEpochsFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return FineTuningNEpochsEnumeration.fromJson(json);
    case 'number':
      return FineTuningNEpochsInt.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningNEpochs',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningNEpochs {
  Object get value;

  /// Serializes this FineTuningNEpochs to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningNEpochs &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'FineTuningNEpochs(value: $value)';
  }
}

/// @nodoc
class $FineTuningNEpochsCopyWith<$Res> {
  $FineTuningNEpochsCopyWith(
      FineTuningNEpochs _, $Res Function(FineTuningNEpochs) __);
}

/// Adds pattern-matching-related methods to [FineTuningNEpochs].
extension FineTuningNEpochsPatterns on FineTuningNEpochs {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningNEpochsEnumeration() when mode != null:
        return mode(_that);
      case FineTuningNEpochsInt() when number != null:
        return number(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningNEpochsEnumeration():
        return mode(_that);
      case FineTuningNEpochsInt():
        return number(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningNEpochsEnumeration() when mode != null:
        return mode(_that);
      case FineTuningNEpochsInt() when number != null:
        return number(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningNEpochsEnumeration() when mode != null:
        return mode(_that.value);
      case FineTuningNEpochsInt() when number != null:
        return number(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningNEpochsEnumeration():
        return mode(_that.value);
      case FineTuningNEpochsInt():
        return number(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) {
    final _that = this;
    switch (_that) {
      case FineTuningNEpochsEnumeration() when mode != null:
        return mode(_that.value);
      case FineTuningNEpochsInt() when number != null:
        return number(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class FineTuningNEpochsEnumeration extends FineTuningNEpochs {
  const FineTuningNEpochsEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory FineTuningNEpochsEnumeration.fromJson(Map<String, dynamic> json) =>
      _$FineTuningNEpochsEnumerationFromJson(json);

  @override
  final FineTuningNEpochsOptions value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of FineTuningNEpochs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsEnumerationCopyWith<FineTuningNEpochsEnumeration>
      get copyWith => _$FineTuningNEpochsEnumerationCopyWithImpl<
          FineTuningNEpochsEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningNEpochsEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningNEpochsEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'FineTuningNEpochs.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $FineTuningNEpochsEnumerationCopyWith<$Res>
    implements $FineTuningNEpochsCopyWith<$Res> {
  factory $FineTuningNEpochsEnumerationCopyWith(
          FineTuningNEpochsEnumeration value,
          $Res Function(FineTuningNEpochsEnumeration) _then) =
      _$FineTuningNEpochsEnumerationCopyWithImpl;
  @useResult
  $Res call({FineTuningNEpochsOptions value});
}

/// @nodoc
class _$FineTuningNEpochsEnumerationCopyWithImpl<$Res>
    implements $FineTuningNEpochsEnumerationCopyWith<$Res> {
  _$FineTuningNEpochsEnumerationCopyWithImpl(this._self, this._then);

  final FineTuningNEpochsEnumeration _self;
  final $Res Function(FineTuningNEpochsEnumeration) _then;

  /// Create a copy of FineTuningNEpochs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(FineTuningNEpochsEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochsOptions,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class FineTuningNEpochsInt extends FineTuningNEpochs {
  const FineTuningNEpochsInt(this.value, {final String? $type})
      : $type = $type ?? 'number',
        super._();
  factory FineTuningNEpochsInt.fromJson(Map<String, dynamic> json) =>
      _$FineTuningNEpochsIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of FineTuningNEpochs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsIntCopyWith<FineTuningNEpochsInt> get copyWith =>
      _$FineTuningNEpochsIntCopyWithImpl<FineTuningNEpochsInt>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningNEpochsIntToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningNEpochsInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'FineTuningNEpochs.number(value: $value)';
  }
}

/// @nodoc
abstract mixin class $FineTuningNEpochsIntCopyWith<$Res>
    implements $FineTuningNEpochsCopyWith<$Res> {
  factory $FineTuningNEpochsIntCopyWith(FineTuningNEpochsInt value,
          $Res Function(FineTuningNEpochsInt) _then) =
      _$FineTuningNEpochsIntCopyWithImpl;
  @useResult
  $Res call({int value});
}

/// @nodoc
class _$FineTuningNEpochsIntCopyWithImpl<$Res>
    implements $FineTuningNEpochsIntCopyWith<$Res> {
  _$FineTuningNEpochsIntCopyWithImpl(this._self, this._then);

  final FineTuningNEpochsInt _self;
  final $Res Function(FineTuningNEpochsInt) _then;

  /// Create a copy of FineTuningNEpochs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(FineTuningNEpochsInt(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$ListPaginatedFineTuningJobsResponse {
  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data;

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// The object type, which is always "list".
  ListPaginatedFineTuningJobsResponseObject get object;

  /// Create a copy of ListPaginatedFineTuningJobsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListPaginatedFineTuningJobsResponseCopyWith<
          ListPaginatedFineTuningJobsResponse>
      get copyWith => _$ListPaginatedFineTuningJobsResponseCopyWithImpl<
              ListPaginatedFineTuningJobsResponse>(
          this as ListPaginatedFineTuningJobsResponse, _$identity);

  /// Serializes this ListPaginatedFineTuningJobsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListPaginatedFineTuningJobsResponse &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(data), hasMore, object);

  @override
  String toString() {
    return 'ListPaginatedFineTuningJobsResponse(data: $data, hasMore: $hasMore, object: $object)';
  }
}

/// @nodoc
abstract mixin class $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory $ListPaginatedFineTuningJobsResponseCopyWith(
          ListPaginatedFineTuningJobsResponse value,
          $Res Function(ListPaginatedFineTuningJobsResponse) _then) =
      _$ListPaginatedFineTuningJobsResponseCopyWithImpl;
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  _$ListPaginatedFineTuningJobsResponseCopyWithImpl(this._self, this._then);

  final ListPaginatedFineTuningJobsResponse _self;
  final $Res Function(ListPaginatedFineTuningJobsResponse) _then;

  /// Create a copy of ListPaginatedFineTuningJobsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListPaginatedFineTuningJobsResponse].
extension ListPaginatedFineTuningJobsResponsePatterns
    on ListPaginatedFineTuningJobsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListPaginatedFineTuningJobsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListPaginatedFineTuningJobsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListPaginatedFineTuningJobsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListPaginatedFineTuningJobsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListPaginatedFineTuningJobsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListPaginatedFineTuningJobsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            List<FineTuningJob> data,
            @JsonKey(name: 'has_more') bool hasMore,
            ListPaginatedFineTuningJobsResponseObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListPaginatedFineTuningJobsResponse() when $default != null:
        return $default(_that.data, _that.hasMore, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            List<FineTuningJob> data,
            @JsonKey(name: 'has_more') bool hasMore,
            ListPaginatedFineTuningJobsResponseObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListPaginatedFineTuningJobsResponse():
        return $default(_that.data, _that.hasMore, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            List<FineTuningJob> data,
            @JsonKey(name: 'has_more') bool hasMore,
            ListPaginatedFineTuningJobsResponseObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListPaginatedFineTuningJobsResponse() when $default != null:
        return $default(_that.data, _that.hasMore, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListPaginatedFineTuningJobsResponse
    extends ListPaginatedFineTuningJobsResponse {
  const _ListPaginatedFineTuningJobsResponse(
      {required final List<FineTuningJob> data,
      @JsonKey(name: 'has_more') required this.hasMore,
      required this.object})
      : _data = data,
        super._();
  factory _ListPaginatedFineTuningJobsResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ListPaginatedFineTuningJobsResponseFromJson(json);

  /// The list of fine-tuning jobs.
  final List<FineTuningJob> _data;

  /// The list of fine-tuning jobs.
  @override
  List<FineTuningJob> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// Whether there are more fine-tuning jobs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// The object type, which is always "list".
  @override
  final ListPaginatedFineTuningJobsResponseObject object;

  /// Create a copy of ListPaginatedFineTuningJobsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListPaginatedFineTuningJobsResponseCopyWith<
          _ListPaginatedFineTuningJobsResponse>
      get copyWith => __$ListPaginatedFineTuningJobsResponseCopyWithImpl<
          _ListPaginatedFineTuningJobsResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListPaginatedFineTuningJobsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListPaginatedFineTuningJobsResponse &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), hasMore, object);

  @override
  String toString() {
    return 'ListPaginatedFineTuningJobsResponse(data: $data, hasMore: $hasMore, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$ListPaginatedFineTuningJobsResponseCopyWith<$Res>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory _$ListPaginatedFineTuningJobsResponseCopyWith(
          _ListPaginatedFineTuningJobsResponse value,
          $Res Function(_ListPaginatedFineTuningJobsResponse) _then) =
      __$ListPaginatedFineTuningJobsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class __$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res>
    implements _$ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  __$ListPaginatedFineTuningJobsResponseCopyWithImpl(this._self, this._then);

  final _ListPaginatedFineTuningJobsResponse _self;
  final $Res Function(_ListPaginatedFineTuningJobsResponse) _then;

  /// Create a copy of ListPaginatedFineTuningJobsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_ListPaginatedFineTuningJobsResponse(
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ));
  }
}

/// @nodoc
mixin _$ListFineTuningJobEventsResponse {
  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data;

  /// The object type, which is always "list".
  ListFineTuningJobEventsResponseObject get object;

  /// Create a copy of ListFineTuningJobEventsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListFineTuningJobEventsResponseCopyWith<ListFineTuningJobEventsResponse>
      get copyWith => _$ListFineTuningJobEventsResponseCopyWithImpl<
              ListFineTuningJobEventsResponse>(
          this as ListFineTuningJobEventsResponse, _$identity);

  /// Serializes this ListFineTuningJobEventsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListFineTuningJobEventsResponse &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(data), object);

  @override
  String toString() {
    return 'ListFineTuningJobEventsResponse(data: $data, object: $object)';
  }
}

/// @nodoc
abstract mixin class $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory $ListFineTuningJobEventsResponseCopyWith(
          ListFineTuningJobEventsResponse value,
          $Res Function(ListFineTuningJobEventsResponse) _then) =
      _$ListFineTuningJobEventsResponseCopyWithImpl;
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class _$ListFineTuningJobEventsResponseCopyWithImpl<$Res>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  _$ListFineTuningJobEventsResponseCopyWithImpl(this._self, this._then);

  final ListFineTuningJobEventsResponse _self;
  final $Res Function(ListFineTuningJobEventsResponse) _then;

  /// Create a copy of ListFineTuningJobEventsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListFineTuningJobEventsResponse].
extension ListFineTuningJobEventsResponsePatterns
    on ListFineTuningJobEventsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListFineTuningJobEventsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobEventsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListFineTuningJobEventsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobEventsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListFineTuningJobEventsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobEventsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<FineTuningJobEvent> data,
            ListFineTuningJobEventsResponseObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobEventsResponse() when $default != null:
        return $default(_that.data, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<FineTuningJobEvent> data,
            ListFineTuningJobEventsResponseObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobEventsResponse():
        return $default(_that.data, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(List<FineTuningJobEvent> data,
            ListFineTuningJobEventsResponseObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobEventsResponse() when $default != null:
        return $default(_that.data, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListFineTuningJobEventsResponse extends ListFineTuningJobEventsResponse {
  const _ListFineTuningJobEventsResponse(
      {required final List<FineTuningJobEvent> data, required this.object})
      : _data = data,
        super._();
  factory _ListFineTuningJobEventsResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ListFineTuningJobEventsResponseFromJson(json);

  /// The list of fine-tuning job events.
  final List<FineTuningJobEvent> _data;

  /// The list of fine-tuning job events.
  @override
  List<FineTuningJobEvent> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The object type, which is always "list".
  @override
  final ListFineTuningJobEventsResponseObject object;

  /// Create a copy of ListFineTuningJobEventsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListFineTuningJobEventsResponseCopyWith<_ListFineTuningJobEventsResponse>
      get copyWith => __$ListFineTuningJobEventsResponseCopyWithImpl<
          _ListFineTuningJobEventsResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListFineTuningJobEventsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListFineTuningJobEventsResponse &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), object);

  @override
  String toString() {
    return 'ListFineTuningJobEventsResponse(data: $data, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$ListFineTuningJobEventsResponseCopyWith<$Res>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory _$ListFineTuningJobEventsResponseCopyWith(
          _ListFineTuningJobEventsResponse value,
          $Res Function(_ListFineTuningJobEventsResponse) _then) =
      __$ListFineTuningJobEventsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class __$ListFineTuningJobEventsResponseCopyWithImpl<$Res>
    implements _$ListFineTuningJobEventsResponseCopyWith<$Res> {
  __$ListFineTuningJobEventsResponseCopyWithImpl(this._self, this._then);

  final _ListFineTuningJobEventsResponse _self;
  final $Res Function(_ListFineTuningJobEventsResponse) _then;

  /// Create a copy of ListFineTuningJobEventsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_ListFineTuningJobEventsResponse(
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ));
  }
}

/// @nodoc
mixin _$ListFineTuningJobCheckpointsResponse {
  /// The list of fine-tuning job checkpoints.
  List<FineTuningJobCheckpoint> get data;

  /// The object type, which is always "list".
  ListFineTuningJobCheckpointsResponseObject get object;

  /// The ID of the first checkpoint in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last checkpoint in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more checkpoints to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListFineTuningJobCheckpointsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListFineTuningJobCheckpointsResponseCopyWith<
          ListFineTuningJobCheckpointsResponse>
      get copyWith => _$ListFineTuningJobCheckpointsResponseCopyWithImpl<
              ListFineTuningJobCheckpointsResponse>(
          this as ListFineTuningJobCheckpointsResponse, _$identity);

  /// Serializes this ListFineTuningJobCheckpointsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListFineTuningJobCheckpointsResponse &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(data),
      object,
      firstId,
      lastId,
      hasMore);

  @override
  String toString() {
    return 'ListFineTuningJobCheckpointsResponse(data: $data, object: $object, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListFineTuningJobCheckpointsResponseCopyWith<$Res> {
  factory $ListFineTuningJobCheckpointsResponseCopyWith(
          ListFineTuningJobCheckpointsResponse value,
          $Res Function(ListFineTuningJobCheckpointsResponse) _then) =
      _$ListFineTuningJobCheckpointsResponseCopyWithImpl;
  @useResult
  $Res call(
      {List<FineTuningJobCheckpoint> data,
      ListFineTuningJobCheckpointsResponseObject object,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListFineTuningJobCheckpointsResponseCopyWithImpl<$Res>
    implements $ListFineTuningJobCheckpointsResponseCopyWith<$Res> {
  _$ListFineTuningJobCheckpointsResponseCopyWithImpl(this._self, this._then);

  final ListFineTuningJobCheckpointsResponse _self;
  final $Res Function(ListFineTuningJobCheckpointsResponse) _then;

  /// Create a copy of ListFineTuningJobCheckpointsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobCheckpoint>,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobCheckpointsResponseObject,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListFineTuningJobCheckpointsResponse].
extension ListFineTuningJobCheckpointsResponsePatterns
    on ListFineTuningJobCheckpointsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListFineTuningJobCheckpointsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobCheckpointsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListFineTuningJobCheckpointsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobCheckpointsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListFineTuningJobCheckpointsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobCheckpointsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            List<FineTuningJobCheckpoint> data,
            ListFineTuningJobCheckpointsResponseObject object,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobCheckpointsResponse() when $default != null:
        return $default(_that.data, _that.object, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            List<FineTuningJobCheckpoint> data,
            ListFineTuningJobCheckpointsResponseObject object,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobCheckpointsResponse():
        return $default(_that.data, _that.object, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            List<FineTuningJobCheckpoint> data,
            ListFineTuningJobCheckpointsResponseObject object,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListFineTuningJobCheckpointsResponse() when $default != null:
        return $default(_that.data, _that.object, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListFineTuningJobCheckpointsResponse
    extends ListFineTuningJobCheckpointsResponse {
  const _ListFineTuningJobCheckpointsResponse(
      {required final List<FineTuningJobCheckpoint> data,
      required this.object,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListFineTuningJobCheckpointsResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ListFineTuningJobCheckpointsResponseFromJson(json);

  /// The list of fine-tuning job checkpoints.
  final List<FineTuningJobCheckpoint> _data;

  /// The list of fine-tuning job checkpoints.
  @override
  List<FineTuningJobCheckpoint> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The object type, which is always "list".
  @override
  final ListFineTuningJobCheckpointsResponseObject object;

  /// The ID of the first checkpoint in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last checkpoint in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more checkpoints to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListFineTuningJobCheckpointsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListFineTuningJobCheckpointsResponseCopyWith<
          _ListFineTuningJobCheckpointsResponse>
      get copyWith => __$ListFineTuningJobCheckpointsResponseCopyWithImpl<
          _ListFineTuningJobCheckpointsResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListFineTuningJobCheckpointsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListFineTuningJobCheckpointsResponse &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_data),
      object,
      firstId,
      lastId,
      hasMore);

  @override
  String toString() {
    return 'ListFineTuningJobCheckpointsResponse(data: $data, object: $object, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListFineTuningJobCheckpointsResponseCopyWith<$Res>
    implements $ListFineTuningJobCheckpointsResponseCopyWith<$Res> {
  factory _$ListFineTuningJobCheckpointsResponseCopyWith(
          _ListFineTuningJobCheckpointsResponse value,
          $Res Function(_ListFineTuningJobCheckpointsResponse) _then) =
      __$ListFineTuningJobCheckpointsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {List<FineTuningJobCheckpoint> data,
      ListFineTuningJobCheckpointsResponseObject object,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListFineTuningJobCheckpointsResponseCopyWithImpl<$Res>
    implements _$ListFineTuningJobCheckpointsResponseCopyWith<$Res> {
  __$ListFineTuningJobCheckpointsResponseCopyWithImpl(this._self, this._then);

  final _ListFineTuningJobCheckpointsResponse _self;
  final $Res Function(_ListFineTuningJobCheckpointsResponse) _then;

  /// Create a copy of ListFineTuningJobCheckpointsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
    Object? object = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListFineTuningJobCheckpointsResponse(
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobCheckpoint>,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobCheckpointsResponseObject,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$FineTuningJobEvent {
  /// The event identifier, which can be referenced in the API endpoints.
  String get id;

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The log level of the event.
  FineTuningJobEventLevel get level;

  /// The message of the event.
  String get message;

  /// The object type, which is always "fine_tuning.job.event".
  FineTuningJobEventObject get object;

  /// Create a copy of FineTuningJobEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningJobEventCopyWith<FineTuningJobEvent> get copyWith =>
      _$FineTuningJobEventCopyWithImpl<FineTuningJobEvent>(
          this as FineTuningJobEvent, _$identity);

  /// Serializes this FineTuningJobEvent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningJobEvent &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, createdAt, level, message, object);

  @override
  String toString() {
    return 'FineTuningJobEvent(id: $id, createdAt: $createdAt, level: $level, message: $message, object: $object)';
  }
}

/// @nodoc
abstract mixin class $FineTuningJobEventCopyWith<$Res> {
  factory $FineTuningJobEventCopyWith(
          FineTuningJobEvent value, $Res Function(FineTuningJobEvent) _then) =
      _$FineTuningJobEventCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class _$FineTuningJobEventCopyWithImpl<$Res>
    implements $FineTuningJobEventCopyWith<$Res> {
  _$FineTuningJobEventCopyWithImpl(this._self, this._then);

  final FineTuningJobEvent _self;
  final $Res Function(FineTuningJobEvent) _then;

  /// Create a copy of FineTuningJobEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _self.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ));
  }
}

/// Adds pattern-matching-related methods to [FineTuningJobEvent].
extension FineTuningJobEventPatterns on FineTuningJobEvent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningJobEvent value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobEvent() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningJobEvent value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobEvent():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningJobEvent value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobEvent() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            FineTuningJobEventLevel level,
            String message,
            FineTuningJobEventObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobEvent() when $default != null:
        return $default(_that.id, _that.createdAt, _that.level, _that.message,
            _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            FineTuningJobEventLevel level,
            String message,
            FineTuningJobEventObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobEvent():
        return $default(_that.id, _that.createdAt, _that.level, _that.message,
            _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            FineTuningJobEventLevel level,
            String message,
            FineTuningJobEventObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobEvent() when $default != null:
        return $default(_that.id, _that.createdAt, _that.level, _that.message,
            _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningJobEvent extends FineTuningJobEvent {
  const _FineTuningJobEvent(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.level,
      required this.message,
      required this.object})
      : super._();
  factory _FineTuningJobEvent.fromJson(Map<String, dynamic> json) =>
      _$FineTuningJobEventFromJson(json);

  /// The event identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the event was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The log level of the event.
  @override
  final FineTuningJobEventLevel level;

  /// The message of the event.
  @override
  final String message;

  /// The object type, which is always "fine_tuning.job.event".
  @override
  final FineTuningJobEventObject object;

  /// Create a copy of FineTuningJobEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningJobEventCopyWith<_FineTuningJobEvent> get copyWith =>
      __$FineTuningJobEventCopyWithImpl<_FineTuningJobEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningJobEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningJobEvent &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, createdAt, level, message, object);

  @override
  String toString() {
    return 'FineTuningJobEvent(id: $id, createdAt: $createdAt, level: $level, message: $message, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningJobEventCopyWith<$Res>
    implements $FineTuningJobEventCopyWith<$Res> {
  factory _$FineTuningJobEventCopyWith(
          _FineTuningJobEvent value, $Res Function(_FineTuningJobEvent) _then) =
      __$FineTuningJobEventCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class __$FineTuningJobEventCopyWithImpl<$Res>
    implements _$FineTuningJobEventCopyWith<$Res> {
  __$FineTuningJobEventCopyWithImpl(this._self, this._then);

  final _FineTuningJobEvent _self;
  final $Res Function(_FineTuningJobEvent) _then;

  /// Create a copy of FineTuningJobEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_FineTuningJobEvent(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _self.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ));
  }
}

/// @nodoc
mixin _$FineTuningJobCheckpoint {
  /// The checkpoint identifier, which can be referenced in the API endpoints.
  String get id;

  /// The Unix timestamp (in seconds) for when the checkpoint was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The name of the fine-tuned checkpoint model that is created.
  @JsonKey(name: 'fine_tuned_model_checkpoint')
  String get fineTunedModelCheckpoint;

  /// The step number that the checkpoint was created at.
  @JsonKey(name: 'step_number')
  int get stepNumber;

  /// Metrics at the step number during the fine-tuning job.
  FineTuningJobCheckpointMetrics get metrics;

  /// The name of the fine-tuning job that this checkpoint was created from.
  @JsonKey(name: 'fine_tuning_job_id')
  String get fineTuningJobId;

  /// The object type, which is always "fine_tuning.job.checkpoint".
  FineTuningJobCheckpointObject get object;

  /// Create a copy of FineTuningJobCheckpoint
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningJobCheckpointCopyWith<FineTuningJobCheckpoint> get copyWith =>
      _$FineTuningJobCheckpointCopyWithImpl<FineTuningJobCheckpoint>(
          this as FineTuningJobCheckpoint, _$identity);

  /// Serializes this FineTuningJobCheckpoint to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningJobCheckpoint &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(
                    other.fineTunedModelCheckpoint, fineTunedModelCheckpoint) ||
                other.fineTunedModelCheckpoint == fineTunedModelCheckpoint) &&
            (identical(other.stepNumber, stepNumber) ||
                other.stepNumber == stepNumber) &&
            (identical(other.metrics, metrics) || other.metrics == metrics) &&
            (identical(other.fineTuningJobId, fineTuningJobId) ||
                other.fineTuningJobId == fineTuningJobId) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, createdAt,
      fineTunedModelCheckpoint, stepNumber, metrics, fineTuningJobId, object);

  @override
  String toString() {
    return 'FineTuningJobCheckpoint(id: $id, createdAt: $createdAt, fineTunedModelCheckpoint: $fineTunedModelCheckpoint, stepNumber: $stepNumber, metrics: $metrics, fineTuningJobId: $fineTuningJobId, object: $object)';
  }
}

/// @nodoc
abstract mixin class $FineTuningJobCheckpointCopyWith<$Res> {
  factory $FineTuningJobCheckpointCopyWith(FineTuningJobCheckpoint value,
          $Res Function(FineTuningJobCheckpoint) _then) =
      _$FineTuningJobCheckpointCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'fine_tuned_model_checkpoint')
      String fineTunedModelCheckpoint,
      @JsonKey(name: 'step_number') int stepNumber,
      FineTuningJobCheckpointMetrics metrics,
      @JsonKey(name: 'fine_tuning_job_id') String fineTuningJobId,
      FineTuningJobCheckpointObject object});

  $FineTuningJobCheckpointMetricsCopyWith<$Res> get metrics;
}

/// @nodoc
class _$FineTuningJobCheckpointCopyWithImpl<$Res>
    implements $FineTuningJobCheckpointCopyWith<$Res> {
  _$FineTuningJobCheckpointCopyWithImpl(this._self, this._then);

  final FineTuningJobCheckpoint _self;
  final $Res Function(FineTuningJobCheckpoint) _then;

  /// Create a copy of FineTuningJobCheckpoint
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? fineTunedModelCheckpoint = null,
    Object? stepNumber = null,
    Object? metrics = null,
    Object? fineTuningJobId = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      fineTunedModelCheckpoint: null == fineTunedModelCheckpoint
          ? _self.fineTunedModelCheckpoint
          : fineTunedModelCheckpoint // ignore: cast_nullable_to_non_nullable
              as String,
      stepNumber: null == stepNumber
          ? _self.stepNumber
          : stepNumber // ignore: cast_nullable_to_non_nullable
              as int,
      metrics: null == metrics
          ? _self.metrics
          : metrics // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointMetrics,
      fineTuningJobId: null == fineTuningJobId
          ? _self.fineTuningJobId
          : fineTuningJobId // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointObject,
    ));
  }

  /// Create a copy of FineTuningJobCheckpoint
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobCheckpointMetricsCopyWith<$Res> get metrics {
    return $FineTuningJobCheckpointMetricsCopyWith<$Res>(_self.metrics,
        (value) {
      return _then(_self.copyWith(metrics: value));
    });
  }
}

/// Adds pattern-matching-related methods to [FineTuningJobCheckpoint].
extension FineTuningJobCheckpointPatterns on FineTuningJobCheckpoint {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningJobCheckpoint value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpoint() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningJobCheckpoint value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpoint():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningJobCheckpoint value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpoint() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'fine_tuned_model_checkpoint')
            String fineTunedModelCheckpoint,
            @JsonKey(name: 'step_number') int stepNumber,
            FineTuningJobCheckpointMetrics metrics,
            @JsonKey(name: 'fine_tuning_job_id') String fineTuningJobId,
            FineTuningJobCheckpointObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpoint() when $default != null:
        return $default(
            _that.id,
            _that.createdAt,
            _that.fineTunedModelCheckpoint,
            _that.stepNumber,
            _that.metrics,
            _that.fineTuningJobId,
            _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'fine_tuned_model_checkpoint')
            String fineTunedModelCheckpoint,
            @JsonKey(name: 'step_number') int stepNumber,
            FineTuningJobCheckpointMetrics metrics,
            @JsonKey(name: 'fine_tuning_job_id') String fineTuningJobId,
            FineTuningJobCheckpointObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpoint():
        return $default(
            _that.id,
            _that.createdAt,
            _that.fineTunedModelCheckpoint,
            _that.stepNumber,
            _that.metrics,
            _that.fineTuningJobId,
            _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'fine_tuned_model_checkpoint')
            String fineTunedModelCheckpoint,
            @JsonKey(name: 'step_number') int stepNumber,
            FineTuningJobCheckpointMetrics metrics,
            @JsonKey(name: 'fine_tuning_job_id') String fineTuningJobId,
            FineTuningJobCheckpointObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpoint() when $default != null:
        return $default(
            _that.id,
            _that.createdAt,
            _that.fineTunedModelCheckpoint,
            _that.stepNumber,
            _that.metrics,
            _that.fineTuningJobId,
            _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningJobCheckpoint extends FineTuningJobCheckpoint {
  const _FineTuningJobCheckpoint(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'fine_tuned_model_checkpoint')
      required this.fineTunedModelCheckpoint,
      @JsonKey(name: 'step_number') required this.stepNumber,
      required this.metrics,
      @JsonKey(name: 'fine_tuning_job_id') required this.fineTuningJobId,
      required this.object})
      : super._();
  factory _FineTuningJobCheckpoint.fromJson(Map<String, dynamic> json) =>
      _$FineTuningJobCheckpointFromJson(json);

  /// The checkpoint identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the checkpoint was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The name of the fine-tuned checkpoint model that is created.
  @override
  @JsonKey(name: 'fine_tuned_model_checkpoint')
  final String fineTunedModelCheckpoint;

  /// The step number that the checkpoint was created at.
  @override
  @JsonKey(name: 'step_number')
  final int stepNumber;

  /// Metrics at the step number during the fine-tuning job.
  @override
  final FineTuningJobCheckpointMetrics metrics;

  /// The name of the fine-tuning job that this checkpoint was created from.
  @override
  @JsonKey(name: 'fine_tuning_job_id')
  final String fineTuningJobId;

  /// The object type, which is always "fine_tuning.job.checkpoint".
  @override
  final FineTuningJobCheckpointObject object;

  /// Create a copy of FineTuningJobCheckpoint
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningJobCheckpointCopyWith<_FineTuningJobCheckpoint> get copyWith =>
      __$FineTuningJobCheckpointCopyWithImpl<_FineTuningJobCheckpoint>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningJobCheckpointToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningJobCheckpoint &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(
                    other.fineTunedModelCheckpoint, fineTunedModelCheckpoint) ||
                other.fineTunedModelCheckpoint == fineTunedModelCheckpoint) &&
            (identical(other.stepNumber, stepNumber) ||
                other.stepNumber == stepNumber) &&
            (identical(other.metrics, metrics) || other.metrics == metrics) &&
            (identical(other.fineTuningJobId, fineTuningJobId) ||
                other.fineTuningJobId == fineTuningJobId) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, createdAt,
      fineTunedModelCheckpoint, stepNumber, metrics, fineTuningJobId, object);

  @override
  String toString() {
    return 'FineTuningJobCheckpoint(id: $id, createdAt: $createdAt, fineTunedModelCheckpoint: $fineTunedModelCheckpoint, stepNumber: $stepNumber, metrics: $metrics, fineTuningJobId: $fineTuningJobId, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningJobCheckpointCopyWith<$Res>
    implements $FineTuningJobCheckpointCopyWith<$Res> {
  factory _$FineTuningJobCheckpointCopyWith(_FineTuningJobCheckpoint value,
          $Res Function(_FineTuningJobCheckpoint) _then) =
      __$FineTuningJobCheckpointCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'fine_tuned_model_checkpoint')
      String fineTunedModelCheckpoint,
      @JsonKey(name: 'step_number') int stepNumber,
      FineTuningJobCheckpointMetrics metrics,
      @JsonKey(name: 'fine_tuning_job_id') String fineTuningJobId,
      FineTuningJobCheckpointObject object});

  @override
  $FineTuningJobCheckpointMetricsCopyWith<$Res> get metrics;
}

/// @nodoc
class __$FineTuningJobCheckpointCopyWithImpl<$Res>
    implements _$FineTuningJobCheckpointCopyWith<$Res> {
  __$FineTuningJobCheckpointCopyWithImpl(this._self, this._then);

  final _FineTuningJobCheckpoint _self;
  final $Res Function(_FineTuningJobCheckpoint) _then;

  /// Create a copy of FineTuningJobCheckpoint
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? fineTunedModelCheckpoint = null,
    Object? stepNumber = null,
    Object? metrics = null,
    Object? fineTuningJobId = null,
    Object? object = null,
  }) {
    return _then(_FineTuningJobCheckpoint(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      fineTunedModelCheckpoint: null == fineTunedModelCheckpoint
          ? _self.fineTunedModelCheckpoint
          : fineTunedModelCheckpoint // ignore: cast_nullable_to_non_nullable
              as String,
      stepNumber: null == stepNumber
          ? _self.stepNumber
          : stepNumber // ignore: cast_nullable_to_non_nullable
              as int,
      metrics: null == metrics
          ? _self.metrics
          : metrics // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointMetrics,
      fineTuningJobId: null == fineTuningJobId
          ? _self.fineTuningJobId
          : fineTuningJobId // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointObject,
    ));
  }

  /// Create a copy of FineTuningJobCheckpoint
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobCheckpointMetricsCopyWith<$Res> get metrics {
    return $FineTuningJobCheckpointMetricsCopyWith<$Res>(_self.metrics,
        (value) {
      return _then(_self.copyWith(metrics: value));
    });
  }
}

/// @nodoc
mixin _$FineTuningJobCheckpointMetrics {
  /// The step number that the metrics were recorded at.
  @JsonKey(includeIfNull: false)
  double? get step;

  /// The training loss at the step number.
  @JsonKey(name: 'train_loss', includeIfNull: false)
  double? get trainLoss;

  /// The training mean token accuracy at the step number.
  @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
  double? get trainMeanTokenAccuracy;

  /// The validation loss at the step number.
  @JsonKey(name: 'valid_loss', includeIfNull: false)
  double? get validLoss;

  /// The validation mean token accuracy at the step number.
  @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
  double? get validMeanTokenAccuracy;

  /// The full validation loss at the step number.
  @JsonKey(name: 'full_valid_loss', includeIfNull: false)
  double? get fullValidLoss;

  /// The full validation mean token accuracy at the step number.
  @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
  double? get fullValidMeanTokenAccuracy;

  /// Create a copy of FineTuningJobCheckpointMetrics
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FineTuningJobCheckpointMetricsCopyWith<FineTuningJobCheckpointMetrics>
      get copyWith => _$FineTuningJobCheckpointMetricsCopyWithImpl<
              FineTuningJobCheckpointMetrics>(
          this as FineTuningJobCheckpointMetrics, _$identity);

  /// Serializes this FineTuningJobCheckpointMetrics to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FineTuningJobCheckpointMetrics &&
            (identical(other.step, step) || other.step == step) &&
            (identical(other.trainLoss, trainLoss) ||
                other.trainLoss == trainLoss) &&
            (identical(other.trainMeanTokenAccuracy, trainMeanTokenAccuracy) ||
                other.trainMeanTokenAccuracy == trainMeanTokenAccuracy) &&
            (identical(other.validLoss, validLoss) ||
                other.validLoss == validLoss) &&
            (identical(other.validMeanTokenAccuracy, validMeanTokenAccuracy) ||
                other.validMeanTokenAccuracy == validMeanTokenAccuracy) &&
            (identical(other.fullValidLoss, fullValidLoss) ||
                other.fullValidLoss == fullValidLoss) &&
            (identical(other.fullValidMeanTokenAccuracy,
                    fullValidMeanTokenAccuracy) ||
                other.fullValidMeanTokenAccuracy ==
                    fullValidMeanTokenAccuracy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      step,
      trainLoss,
      trainMeanTokenAccuracy,
      validLoss,
      validMeanTokenAccuracy,
      fullValidLoss,
      fullValidMeanTokenAccuracy);

  @override
  String toString() {
    return 'FineTuningJobCheckpointMetrics(step: $step, trainLoss: $trainLoss, trainMeanTokenAccuracy: $trainMeanTokenAccuracy, validLoss: $validLoss, validMeanTokenAccuracy: $validMeanTokenAccuracy, fullValidLoss: $fullValidLoss, fullValidMeanTokenAccuracy: $fullValidMeanTokenAccuracy)';
  }
}

/// @nodoc
abstract mixin class $FineTuningJobCheckpointMetricsCopyWith<$Res> {
  factory $FineTuningJobCheckpointMetricsCopyWith(
          FineTuningJobCheckpointMetrics value,
          $Res Function(FineTuningJobCheckpointMetrics) _then) =
      _$FineTuningJobCheckpointMetricsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) double? step,
      @JsonKey(name: 'train_loss', includeIfNull: false) double? trainLoss,
      @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
      double? trainMeanTokenAccuracy,
      @JsonKey(name: 'valid_loss', includeIfNull: false) double? validLoss,
      @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
      double? validMeanTokenAccuracy,
      @JsonKey(name: 'full_valid_loss', includeIfNull: false)
      double? fullValidLoss,
      @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
      double? fullValidMeanTokenAccuracy});
}

/// @nodoc
class _$FineTuningJobCheckpointMetricsCopyWithImpl<$Res>
    implements $FineTuningJobCheckpointMetricsCopyWith<$Res> {
  _$FineTuningJobCheckpointMetricsCopyWithImpl(this._self, this._then);

  final FineTuningJobCheckpointMetrics _self;
  final $Res Function(FineTuningJobCheckpointMetrics) _then;

  /// Create a copy of FineTuningJobCheckpointMetrics
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = freezed,
    Object? trainLoss = freezed,
    Object? trainMeanTokenAccuracy = freezed,
    Object? validLoss = freezed,
    Object? validMeanTokenAccuracy = freezed,
    Object? fullValidLoss = freezed,
    Object? fullValidMeanTokenAccuracy = freezed,
  }) {
    return _then(_self.copyWith(
      step: freezed == step
          ? _self.step
          : step // ignore: cast_nullable_to_non_nullable
              as double?,
      trainLoss: freezed == trainLoss
          ? _self.trainLoss
          : trainLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      trainMeanTokenAccuracy: freezed == trainMeanTokenAccuracy
          ? _self.trainMeanTokenAccuracy
          : trainMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      validLoss: freezed == validLoss
          ? _self.validLoss
          : validLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      validMeanTokenAccuracy: freezed == validMeanTokenAccuracy
          ? _self.validMeanTokenAccuracy
          : validMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidLoss: freezed == fullValidLoss
          ? _self.fullValidLoss
          : fullValidLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidMeanTokenAccuracy: freezed == fullValidMeanTokenAccuracy
          ? _self.fullValidMeanTokenAccuracy
          : fullValidMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// Adds pattern-matching-related methods to [FineTuningJobCheckpointMetrics].
extension FineTuningJobCheckpointMetricsPatterns
    on FineTuningJobCheckpointMetrics {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FineTuningJobCheckpointMetrics value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpointMetrics() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FineTuningJobCheckpointMetrics value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpointMetrics():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FineTuningJobCheckpointMetrics value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpointMetrics() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) double? step,
            @JsonKey(name: 'train_loss', includeIfNull: false)
            double? trainLoss,
            @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
            double? trainMeanTokenAccuracy,
            @JsonKey(name: 'valid_loss', includeIfNull: false)
            double? validLoss,
            @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
            double? validMeanTokenAccuracy,
            @JsonKey(name: 'full_valid_loss', includeIfNull: false)
            double? fullValidLoss,
            @JsonKey(
                name: 'full_valid_mean_token_accuracy', includeIfNull: false)
            double? fullValidMeanTokenAccuracy)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpointMetrics() when $default != null:
        return $default(
            _that.step,
            _that.trainLoss,
            _that.trainMeanTokenAccuracy,
            _that.validLoss,
            _that.validMeanTokenAccuracy,
            _that.fullValidLoss,
            _that.fullValidMeanTokenAccuracy);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) double? step,
            @JsonKey(name: 'train_loss', includeIfNull: false)
            double? trainLoss,
            @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
            double? trainMeanTokenAccuracy,
            @JsonKey(name: 'valid_loss', includeIfNull: false)
            double? validLoss,
            @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
            double? validMeanTokenAccuracy,
            @JsonKey(name: 'full_valid_loss', includeIfNull: false)
            double? fullValidLoss,
            @JsonKey(
                name: 'full_valid_mean_token_accuracy', includeIfNull: false)
            double? fullValidMeanTokenAccuracy)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpointMetrics():
        return $default(
            _that.step,
            _that.trainLoss,
            _that.trainMeanTokenAccuracy,
            _that.validLoss,
            _that.validMeanTokenAccuracy,
            _that.fullValidLoss,
            _that.fullValidMeanTokenAccuracy);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) double? step,
            @JsonKey(name: 'train_loss', includeIfNull: false)
            double? trainLoss,
            @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
            double? trainMeanTokenAccuracy,
            @JsonKey(name: 'valid_loss', includeIfNull: false)
            double? validLoss,
            @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
            double? validMeanTokenAccuracy,
            @JsonKey(name: 'full_valid_loss', includeIfNull: false)
            double? fullValidLoss,
            @JsonKey(
                name: 'full_valid_mean_token_accuracy', includeIfNull: false)
            double? fullValidMeanTokenAccuracy)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FineTuningJobCheckpointMetrics() when $default != null:
        return $default(
            _that.step,
            _that.trainLoss,
            _that.trainMeanTokenAccuracy,
            _that.validLoss,
            _that.validMeanTokenAccuracy,
            _that.fullValidLoss,
            _that.fullValidMeanTokenAccuracy);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FineTuningJobCheckpointMetrics extends FineTuningJobCheckpointMetrics {
  const _FineTuningJobCheckpointMetrics(
      {@JsonKey(includeIfNull: false) this.step,
      @JsonKey(name: 'train_loss', includeIfNull: false) this.trainLoss,
      @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
      this.trainMeanTokenAccuracy,
      @JsonKey(name: 'valid_loss', includeIfNull: false) this.validLoss,
      @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
      this.validMeanTokenAccuracy,
      @JsonKey(name: 'full_valid_loss', includeIfNull: false)
      this.fullValidLoss,
      @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
      this.fullValidMeanTokenAccuracy})
      : super._();
  factory _FineTuningJobCheckpointMetrics.fromJson(Map<String, dynamic> json) =>
      _$FineTuningJobCheckpointMetricsFromJson(json);

  /// The step number that the metrics were recorded at.
  @override
  @JsonKey(includeIfNull: false)
  final double? step;

  /// The training loss at the step number.
  @override
  @JsonKey(name: 'train_loss', includeIfNull: false)
  final double? trainLoss;

  /// The training mean token accuracy at the step number.
  @override
  @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
  final double? trainMeanTokenAccuracy;

  /// The validation loss at the step number.
  @override
  @JsonKey(name: 'valid_loss', includeIfNull: false)
  final double? validLoss;

  /// The validation mean token accuracy at the step number.
  @override
  @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
  final double? validMeanTokenAccuracy;

  /// The full validation loss at the step number.
  @override
  @JsonKey(name: 'full_valid_loss', includeIfNull: false)
  final double? fullValidLoss;

  /// The full validation mean token accuracy at the step number.
  @override
  @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
  final double? fullValidMeanTokenAccuracy;

  /// Create a copy of FineTuningJobCheckpointMetrics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FineTuningJobCheckpointMetricsCopyWith<_FineTuningJobCheckpointMetrics>
      get copyWith => __$FineTuningJobCheckpointMetricsCopyWithImpl<
          _FineTuningJobCheckpointMetrics>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FineTuningJobCheckpointMetricsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FineTuningJobCheckpointMetrics &&
            (identical(other.step, step) || other.step == step) &&
            (identical(other.trainLoss, trainLoss) ||
                other.trainLoss == trainLoss) &&
            (identical(other.trainMeanTokenAccuracy, trainMeanTokenAccuracy) ||
                other.trainMeanTokenAccuracy == trainMeanTokenAccuracy) &&
            (identical(other.validLoss, validLoss) ||
                other.validLoss == validLoss) &&
            (identical(other.validMeanTokenAccuracy, validMeanTokenAccuracy) ||
                other.validMeanTokenAccuracy == validMeanTokenAccuracy) &&
            (identical(other.fullValidLoss, fullValidLoss) ||
                other.fullValidLoss == fullValidLoss) &&
            (identical(other.fullValidMeanTokenAccuracy,
                    fullValidMeanTokenAccuracy) ||
                other.fullValidMeanTokenAccuracy ==
                    fullValidMeanTokenAccuracy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      step,
      trainLoss,
      trainMeanTokenAccuracy,
      validLoss,
      validMeanTokenAccuracy,
      fullValidLoss,
      fullValidMeanTokenAccuracy);

  @override
  String toString() {
    return 'FineTuningJobCheckpointMetrics(step: $step, trainLoss: $trainLoss, trainMeanTokenAccuracy: $trainMeanTokenAccuracy, validLoss: $validLoss, validMeanTokenAccuracy: $validMeanTokenAccuracy, fullValidLoss: $fullValidLoss, fullValidMeanTokenAccuracy: $fullValidMeanTokenAccuracy)';
  }
}

/// @nodoc
abstract mixin class _$FineTuningJobCheckpointMetricsCopyWith<$Res>
    implements $FineTuningJobCheckpointMetricsCopyWith<$Res> {
  factory _$FineTuningJobCheckpointMetricsCopyWith(
          _FineTuningJobCheckpointMetrics value,
          $Res Function(_FineTuningJobCheckpointMetrics) _then) =
      __$FineTuningJobCheckpointMetricsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) double? step,
      @JsonKey(name: 'train_loss', includeIfNull: false) double? trainLoss,
      @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
      double? trainMeanTokenAccuracy,
      @JsonKey(name: 'valid_loss', includeIfNull: false) double? validLoss,
      @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
      double? validMeanTokenAccuracy,
      @JsonKey(name: 'full_valid_loss', includeIfNull: false)
      double? fullValidLoss,
      @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
      double? fullValidMeanTokenAccuracy});
}

/// @nodoc
class __$FineTuningJobCheckpointMetricsCopyWithImpl<$Res>
    implements _$FineTuningJobCheckpointMetricsCopyWith<$Res> {
  __$FineTuningJobCheckpointMetricsCopyWithImpl(this._self, this._then);

  final _FineTuningJobCheckpointMetrics _self;
  final $Res Function(_FineTuningJobCheckpointMetrics) _then;

  /// Create a copy of FineTuningJobCheckpointMetrics
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? step = freezed,
    Object? trainLoss = freezed,
    Object? trainMeanTokenAccuracy = freezed,
    Object? validLoss = freezed,
    Object? validMeanTokenAccuracy = freezed,
    Object? fullValidLoss = freezed,
    Object? fullValidMeanTokenAccuracy = freezed,
  }) {
    return _then(_FineTuningJobCheckpointMetrics(
      step: freezed == step
          ? _self.step
          : step // ignore: cast_nullable_to_non_nullable
              as double?,
      trainLoss: freezed == trainLoss
          ? _self.trainLoss
          : trainLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      trainMeanTokenAccuracy: freezed == trainMeanTokenAccuracy
          ? _self.trainMeanTokenAccuracy
          : trainMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      validLoss: freezed == validLoss
          ? _self.validLoss
          : validLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      validMeanTokenAccuracy: freezed == validMeanTokenAccuracy
          ? _self.validMeanTokenAccuracy
          : validMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidLoss: freezed == fullValidLoss
          ? _self.fullValidLoss
          : fullValidLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidMeanTokenAccuracy: freezed == fullValidMeanTokenAccuracy
          ? _self.fullValidMeanTokenAccuracy
          : fullValidMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
mixin _$CreateImageRequest {
  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  String get prompt;

  /// The model to use for image generation. One of `dall-e-2`, `dall-e-3`, or `gpt-image-1`. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used.
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateImageRequestModel? get model;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @JsonKey(includeIfNull: false)
  int? get n;

  /// The quality of the image that will be generated.
  ///
  /// - `auto` (default value) will automatically select the best quality for the given model.
  /// - `high`, `medium` and `low` are supported for `gpt-image-1`.
  /// - `hd` and `standard` are supported for `dall-e-3`.
  /// - `standard` is the only option for `dall-e-2`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageQuality? get quality;

  /// The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat;

  /// The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`.
  @JsonKey(
      name: 'output_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageOutputFormat? get outputFormat;

  /// The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats, and defaults to 100.
  @JsonKey(name: 'output_compression', includeIfNull: false)
  int? get outputCompression;

  /// The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size;

  /// Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageModeration? get moderation;

  /// Allows to set transparency for the background of the generated image(s).
  /// This parameter is only supported for `gpt-image-1`. Must be one of
  /// `transparent`, `opaque` or `auto` (default value). When `auto` is used, the
  /// model will automatically determine the best background for the image.
  ///
  /// If `transparent`, the output format needs to support transparency, so it
  /// should be set to either `png` (default value) or `webp`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageBackground? get background;

  /// The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageStyle? get style;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;

  /// Create a copy of CreateImageRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateImageRequestCopyWith<CreateImageRequest> get copyWith =>
      _$CreateImageRequestCopyWithImpl<CreateImageRequest>(
          this as CreateImageRequest, _$identity);

  /// Serializes this CreateImageRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateImageRequest &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.outputFormat, outputFormat) ||
                other.outputFormat == outputFormat) &&
            (identical(other.outputCompression, outputCompression) ||
                other.outputCompression == outputCompression) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.moderation, moderation) ||
                other.moderation == moderation) &&
            (identical(other.background, background) ||
                other.background == background) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      prompt,
      model,
      n,
      quality,
      responseFormat,
      outputFormat,
      outputCompression,
      size,
      moderation,
      background,
      style,
      user);

  @override
  String toString() {
    return 'CreateImageRequest(prompt: $prompt, model: $model, n: $n, quality: $quality, responseFormat: $responseFormat, outputFormat: $outputFormat, outputCompression: $outputCompression, size: $size, moderation: $moderation, background: $background, style: $style, user: $user)';
  }
}

/// @nodoc
abstract mixin class $CreateImageRequestCopyWith<$Res> {
  factory $CreateImageRequestCopyWith(
          CreateImageRequest value, $Res Function(CreateImageRequest) _then) =
      _$CreateImageRequestCopyWithImpl;
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageQuality? quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          name: 'output_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageOutputFormat? outputFormat,
      @JsonKey(name: 'output_compression', includeIfNull: false)
      int? outputCompression,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageModeration? moderation,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageBackground? background,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class _$CreateImageRequestCopyWithImpl<$Res>
    implements $CreateImageRequestCopyWith<$Res> {
  _$CreateImageRequestCopyWithImpl(this._self, this._then);

  final CreateImageRequest _self;
  final $Res Function(CreateImageRequest) _then;

  /// Create a copy of CreateImageRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = freezed,
    Object? responseFormat = freezed,
    Object? outputFormat = freezed,
    Object? outputCompression = freezed,
    Object? size = freezed,
    Object? moderation = freezed,
    Object? background = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_self.copyWith(
      prompt: null == prompt
          ? _self.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _self.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: freezed == quality
          ? _self.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      outputFormat: freezed == outputFormat
          ? _self.outputFormat
          : outputFormat // ignore: cast_nullable_to_non_nullable
              as ImageOutputFormat?,
      outputCompression: freezed == outputCompression
          ? _self.outputCompression
          : outputCompression // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      moderation: freezed == moderation
          ? _self.moderation
          : moderation // ignore: cast_nullable_to_non_nullable
              as ImageModeration?,
      background: freezed == background
          ? _self.background
          : background // ignore: cast_nullable_to_non_nullable
              as ImageBackground?,
      style: freezed == style
          ? _self.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of CreateImageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateImageRequestModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $CreateImageRequestModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateImageRequest].
extension CreateImageRequestPatterns on CreateImageRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateImageRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateImageRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateImageRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateImageRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateImageRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateImageRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String prompt,
            @_CreateImageRequestModelConverter()
            @JsonKey(includeIfNull: false)
            CreateImageRequestModel? model,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageQuality? quality,
            @JsonKey(
                name: 'response_format',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageResponseFormat? responseFormat,
            @JsonKey(
                name: 'output_format',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageOutputFormat? outputFormat,
            @JsonKey(name: 'output_compression', includeIfNull: false)
            int? outputCompression,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageSize? size,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageModeration? moderation,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageBackground? background,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageStyle? style,
            @JsonKey(includeIfNull: false) String? user)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateImageRequest() when $default != null:
        return $default(
            _that.prompt,
            _that.model,
            _that.n,
            _that.quality,
            _that.responseFormat,
            _that.outputFormat,
            _that.outputCompression,
            _that.size,
            _that.moderation,
            _that.background,
            _that.style,
            _that.user);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String prompt,
            @_CreateImageRequestModelConverter()
            @JsonKey(includeIfNull: false)
            CreateImageRequestModel? model,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageQuality? quality,
            @JsonKey(
                name: 'response_format',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageResponseFormat? responseFormat,
            @JsonKey(
                name: 'output_format',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageOutputFormat? outputFormat,
            @JsonKey(name: 'output_compression', includeIfNull: false)
            int? outputCompression,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageSize? size,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageModeration? moderation,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageBackground? background,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageStyle? style,
            @JsonKey(includeIfNull: false) String? user)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateImageRequest():
        return $default(
            _that.prompt,
            _that.model,
            _that.n,
            _that.quality,
            _that.responseFormat,
            _that.outputFormat,
            _that.outputCompression,
            _that.size,
            _that.moderation,
            _that.background,
            _that.style,
            _that.user);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String prompt,
            @_CreateImageRequestModelConverter()
            @JsonKey(includeIfNull: false)
            CreateImageRequestModel? model,
            @JsonKey(includeIfNull: false) int? n,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageQuality? quality,
            @JsonKey(
                name: 'response_format',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageResponseFormat? responseFormat,
            @JsonKey(
                name: 'output_format',
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageOutputFormat? outputFormat,
            @JsonKey(name: 'output_compression', includeIfNull: false)
            int? outputCompression,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageSize? size,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageModeration? moderation,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageBackground? background,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ImageStyle? style,
            @JsonKey(includeIfNull: false) String? user)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateImageRequest() when $default != null:
        return $default(
            _that.prompt,
            _that.model,
            _that.n,
            _that.quality,
            _that.responseFormat,
            _that.outputFormat,
            _that.outputCompression,
            _that.size,
            _that.moderation,
            _that.background,
            _that.style,
            _that.user);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateImageRequest extends CreateImageRequest {
  const _CreateImageRequest(
      {required this.prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      this.model,
      @JsonKey(includeIfNull: false) this.n,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.responseFormat,
      @JsonKey(
          name: 'output_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.outputFormat,
      @JsonKey(name: 'output_compression', includeIfNull: false)
      this.outputCompression,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.moderation,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.background,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.style,
      @JsonKey(includeIfNull: false) this.user})
      : super._();
  factory _CreateImageRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateImageRequestFromJson(json);

  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  @override
  final String prompt;

  /// The model to use for image generation. One of `dall-e-2`, `dall-e-3`, or `gpt-image-1`. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used.
  @override
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  final CreateImageRequestModel? model;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// The quality of the image that will be generated.
  ///
  /// - `auto` (default value) will automatically select the best quality for the given model.
  /// - `high`, `medium` and `low` are supported for `gpt-image-1`.
  /// - `hd` and `standard` are supported for `dall-e-3`.
  /// - `standard` is the only option for `dall-e-2`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageQuality? quality;

  /// The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images.
  @override
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageResponseFormat? responseFormat;

  /// The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`.
  @override
  @JsonKey(
      name: 'output_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageOutputFormat? outputFormat;

  /// The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats, and defaults to 100.
  @override
  @JsonKey(name: 'output_compression', includeIfNull: false)
  final int? outputCompression;

  /// The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageSize? size;

  /// Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value).
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageModeration? moderation;

  /// Allows to set transparency for the background of the generated image(s).
  /// This parameter is only supported for `gpt-image-1`. Must be one of
  /// `transparent`, `opaque` or `auto` (default value). When `auto` is used, the
  /// model will automatically determine the best background for the image.
  ///
  /// If `transparent`, the output format needs to support transparency, so it
  /// should be set to either `png` (default value) or `webp`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageBackground? background;

  /// The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageStyle? style;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Create a copy of CreateImageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateImageRequestCopyWith<_CreateImageRequest> get copyWith =>
      __$CreateImageRequestCopyWithImpl<_CreateImageRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateImageRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateImageRequest &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.outputFormat, outputFormat) ||
                other.outputFormat == outputFormat) &&
            (identical(other.outputCompression, outputCompression) ||
                other.outputCompression == outputCompression) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.moderation, moderation) ||
                other.moderation == moderation) &&
            (identical(other.background, background) ||
                other.background == background) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      prompt,
      model,
      n,
      quality,
      responseFormat,
      outputFormat,
      outputCompression,
      size,
      moderation,
      background,
      style,
      user);

  @override
  String toString() {
    return 'CreateImageRequest(prompt: $prompt, model: $model, n: $n, quality: $quality, responseFormat: $responseFormat, outputFormat: $outputFormat, outputCompression: $outputCompression, size: $size, moderation: $moderation, background: $background, style: $style, user: $user)';
  }
}

/// @nodoc
abstract mixin class _$CreateImageRequestCopyWith<$Res>
    implements $CreateImageRequestCopyWith<$Res> {
  factory _$CreateImageRequestCopyWith(
          _CreateImageRequest value, $Res Function(_CreateImageRequest) _then) =
      __$CreateImageRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageQuality? quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          name: 'output_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageOutputFormat? outputFormat,
      @JsonKey(name: 'output_compression', includeIfNull: false)
      int? outputCompression,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageModeration? moderation,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageBackground? background,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class __$CreateImageRequestCopyWithImpl<$Res>
    implements _$CreateImageRequestCopyWith<$Res> {
  __$CreateImageRequestCopyWithImpl(this._self, this._then);

  final _CreateImageRequest _self;
  final $Res Function(_CreateImageRequest) _then;

  /// Create a copy of CreateImageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = freezed,
    Object? responseFormat = freezed,
    Object? outputFormat = freezed,
    Object? outputCompression = freezed,
    Object? size = freezed,
    Object? moderation = freezed,
    Object? background = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_CreateImageRequest(
      prompt: null == prompt
          ? _self.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _self.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: freezed == quality
          ? _self.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      outputFormat: freezed == outputFormat
          ? _self.outputFormat
          : outputFormat // ignore: cast_nullable_to_non_nullable
              as ImageOutputFormat?,
      outputCompression: freezed == outputCompression
          ? _self.outputCompression
          : outputCompression // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _self.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      moderation: freezed == moderation
          ? _self.moderation
          : moderation // ignore: cast_nullable_to_non_nullable
              as ImageModeration?,
      background: freezed == background
          ? _self.background
          : background // ignore: cast_nullable_to_non_nullable
              as ImageBackground?,
      style: freezed == style
          ? _self.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _self.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of CreateImageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateImageRequestModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $CreateImageRequestModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }
}

CreateImageRequestModel _$CreateImageRequestModelFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CreateImageRequestModelEnumeration.fromJson(json);
    case 'modelId':
      return CreateImageRequestModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateImageRequestModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateImageRequestModel {
  Object get value;

  /// Serializes this CreateImageRequestModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateImageRequestModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateImageRequestModel(value: $value)';
  }
}

/// @nodoc
class $CreateImageRequestModelCopyWith<$Res> {
  $CreateImageRequestModelCopyWith(
      CreateImageRequestModel _, $Res Function(CreateImageRequestModel) __);
}

/// Adds pattern-matching-related methods to [CreateImageRequestModel].
extension CreateImageRequestModelPatterns on CreateImageRequestModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateImageRequestModelEnumeration() when model != null:
        return model(_that);
      case CreateImageRequestModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateImageRequestModelEnumeration():
        return model(_that);
      case CreateImageRequestModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateImageRequestModelEnumeration() when model != null:
        return model(_that);
      case CreateImageRequestModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateImageRequestModelEnumeration() when model != null:
        return model(_that.value);
      case CreateImageRequestModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateImageRequestModelEnumeration():
        return model(_that.value);
      case CreateImageRequestModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateImageRequestModelEnumeration() when model != null:
        return model(_that.value);
      case CreateImageRequestModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateImageRequestModelEnumeration extends CreateImageRequestModel {
  const CreateImageRequestModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory CreateImageRequestModelEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$CreateImageRequestModelEnumerationFromJson(json);

  @override
  final ImageModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateImageRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateImageRequestModelEnumerationCopyWith<
          CreateImageRequestModelEnumeration>
      get copyWith => _$CreateImageRequestModelEnumerationCopyWithImpl<
          CreateImageRequestModelEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateImageRequestModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateImageRequestModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateImageRequestModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateImageRequestModelEnumerationCopyWith<$Res>
    implements $CreateImageRequestModelCopyWith<$Res> {
  factory $CreateImageRequestModelEnumerationCopyWith(
          CreateImageRequestModelEnumeration value,
          $Res Function(CreateImageRequestModelEnumeration) _then) =
      _$CreateImageRequestModelEnumerationCopyWithImpl;
  @useResult
  $Res call({ImageModels value});
}

/// @nodoc
class _$CreateImageRequestModelEnumerationCopyWithImpl<$Res>
    implements $CreateImageRequestModelEnumerationCopyWith<$Res> {
  _$CreateImageRequestModelEnumerationCopyWithImpl(this._self, this._then);

  final CreateImageRequestModelEnumeration _self;
  final $Res Function(CreateImageRequestModelEnumeration) _then;

  /// Create a copy of CreateImageRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateImageRequestModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ImageModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateImageRequestModelString extends CreateImageRequestModel {
  const CreateImageRequestModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory CreateImageRequestModelString.fromJson(Map<String, dynamic> json) =>
      _$CreateImageRequestModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateImageRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateImageRequestModelStringCopyWith<CreateImageRequestModelString>
      get copyWith => _$CreateImageRequestModelStringCopyWithImpl<
          CreateImageRequestModelString>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateImageRequestModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateImageRequestModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateImageRequestModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateImageRequestModelStringCopyWith<$Res>
    implements $CreateImageRequestModelCopyWith<$Res> {
  factory $CreateImageRequestModelStringCopyWith(
          CreateImageRequestModelString value,
          $Res Function(CreateImageRequestModelString) _then) =
      _$CreateImageRequestModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$CreateImageRequestModelStringCopyWithImpl<$Res>
    implements $CreateImageRequestModelStringCopyWith<$Res> {
  _$CreateImageRequestModelStringCopyWithImpl(this._self, this._then);

  final CreateImageRequestModelString _self;
  final $Res Function(CreateImageRequestModelString) _then;

  /// Create a copy of CreateImageRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateImageRequestModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ImagesResponse {
  /// The Unix timestamp (in seconds) when the image was created.
  int get created;

  /// The list of images generated by the model.
  List<Image> get data;

  /// Create a copy of ImagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ImagesResponseCopyWith<ImagesResponse> get copyWith =>
      _$ImagesResponseCopyWithImpl<ImagesResponse>(
          this as ImagesResponse, _$identity);

  /// Serializes this ImagesResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ImagesResponse &&
            (identical(other.created, created) || other.created == created) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, created, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'ImagesResponse(created: $created, data: $data)';
  }
}

/// @nodoc
abstract mixin class $ImagesResponseCopyWith<$Res> {
  factory $ImagesResponseCopyWith(
          ImagesResponse value, $Res Function(ImagesResponse) _then) =
      _$ImagesResponseCopyWithImpl;
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class _$ImagesResponseCopyWithImpl<$Res>
    implements $ImagesResponseCopyWith<$Res> {
  _$ImagesResponseCopyWithImpl(this._self, this._then);

  final ImagesResponse _self;
  final $Res Function(ImagesResponse) _then;

  /// Create a copy of ImagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_self.copyWith(
      created: null == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ));
  }
}

/// Adds pattern-matching-related methods to [ImagesResponse].
extension ImagesResponsePatterns on ImagesResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ImagesResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImagesResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ImagesResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagesResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ImagesResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagesResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int created, List<Image> data)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ImagesResponse() when $default != null:
        return $default(_that.created, _that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int created, List<Image> data) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagesResponse():
        return $default(_that.created, _that.data);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(int created, List<Image> data)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ImagesResponse() when $default != null:
        return $default(_that.created, _that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ImagesResponse extends ImagesResponse {
  const _ImagesResponse(
      {required this.created, required final List<Image> data})
      : _data = data,
        super._();
  factory _ImagesResponse.fromJson(Map<String, dynamic> json) =>
      _$ImagesResponseFromJson(json);

  /// The Unix timestamp (in seconds) when the image was created.
  @override
  final int created;

  /// The list of images generated by the model.
  final List<Image> _data;

  /// The list of images generated by the model.
  @override
  List<Image> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// Create a copy of ImagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ImagesResponseCopyWith<_ImagesResponse> get copyWith =>
      __$ImagesResponseCopyWithImpl<_ImagesResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ImagesResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImagesResponse &&
            (identical(other.created, created) || other.created == created) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, created, const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'ImagesResponse(created: $created, data: $data)';
  }
}

/// @nodoc
abstract mixin class _$ImagesResponseCopyWith<$Res>
    implements $ImagesResponseCopyWith<$Res> {
  factory _$ImagesResponseCopyWith(
          _ImagesResponse value, $Res Function(_ImagesResponse) _then) =
      __$ImagesResponseCopyWithImpl;
  @override
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class __$ImagesResponseCopyWithImpl<$Res>
    implements _$ImagesResponseCopyWith<$Res> {
  __$ImagesResponseCopyWithImpl(this._self, this._then);

  final _ImagesResponse _self;
  final $Res Function(_ImagesResponse) _then;

  /// Create a copy of ImagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_ImagesResponse(
      created: null == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ));
  }
}

/// @nodoc
mixin _$Image {
  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  String? get revisedPrompt;

  /// Create a copy of Image
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ImageCopyWith<Image> get copyWith =>
      _$ImageCopyWithImpl<Image>(this as Image, _$identity);

  /// Serializes this Image to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Image &&
            (identical(other.b64Json, b64Json) || other.b64Json == b64Json) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.revisedPrompt, revisedPrompt) ||
                other.revisedPrompt == revisedPrompt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, b64Json, url, revisedPrompt);

  @override
  String toString() {
    return 'Image(b64Json: $b64Json, url: $url, revisedPrompt: $revisedPrompt)';
  }
}

/// @nodoc
abstract mixin class $ImageCopyWith<$Res> {
  factory $ImageCopyWith(Image value, $Res Function(Image) _then) =
      _$ImageCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class _$ImageCopyWithImpl<$Res> implements $ImageCopyWith<$Res> {
  _$ImageCopyWithImpl(this._self, this._then);

  final Image _self;
  final $Res Function(Image) _then;

  /// Create a copy of Image
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_self.copyWith(
      b64Json: freezed == b64Json
          ? _self.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _self.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [Image].
extension ImagePatterns on Image {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Image value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Image() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Image value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Image():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Image value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Image() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
            @JsonKey(includeIfNull: false) String? url,
            @JsonKey(name: 'revised_prompt', includeIfNull: false)
            String? revisedPrompt)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Image() when $default != null:
        return $default(_that.b64Json, _that.url, _that.revisedPrompt);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
            @JsonKey(includeIfNull: false) String? url,
            @JsonKey(name: 'revised_prompt', includeIfNull: false)
            String? revisedPrompt)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Image():
        return $default(_that.b64Json, _that.url, _that.revisedPrompt);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
            @JsonKey(includeIfNull: false) String? url,
            @JsonKey(name: 'revised_prompt', includeIfNull: false)
            String? revisedPrompt)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Image() when $default != null:
        return $default(_that.b64Json, _that.url, _that.revisedPrompt);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _Image extends Image {
  const _Image(
      {@JsonKey(name: 'b64_json', includeIfNull: false) this.b64Json,
      @JsonKey(includeIfNull: false) this.url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      this.revisedPrompt})
      : super._();
  factory _Image.fromJson(Map<String, dynamic> json) => _$ImageFromJson(json);

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @override
  @JsonKey(name: 'b64_json', includeIfNull: false)
  final String? b64Json;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @override
  @JsonKey(includeIfNull: false)
  final String? url;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @override
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  final String? revisedPrompt;

  /// Create a copy of Image
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ImageCopyWith<_Image> get copyWith =>
      __$ImageCopyWithImpl<_Image>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ImageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Image &&
            (identical(other.b64Json, b64Json) || other.b64Json == b64Json) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.revisedPrompt, revisedPrompt) ||
                other.revisedPrompt == revisedPrompt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, b64Json, url, revisedPrompt);

  @override
  String toString() {
    return 'Image(b64Json: $b64Json, url: $url, revisedPrompt: $revisedPrompt)';
  }
}

/// @nodoc
abstract mixin class _$ImageCopyWith<$Res> implements $ImageCopyWith<$Res> {
  factory _$ImageCopyWith(_Image value, $Res Function(_Image) _then) =
      __$ImageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class __$ImageCopyWithImpl<$Res> implements _$ImageCopyWith<$Res> {
  __$ImageCopyWithImpl(this._self, this._then);

  final _Image _self;
  final $Res Function(_Image) _then;

  /// Create a copy of Image
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_Image(
      b64Json: freezed == b64Json
          ? _self.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _self.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$Model {
  /// The model identifier, which can be referenced in the API endpoints.
  String get id;

  /// The Unix timestamp (in seconds) when the model was created.
  @JsonKey(includeIfNull: false)
  int? get created;

  /// The object type, which is always "model".
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ModelObject? get object;

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by', includeIfNull: false)
  String? get ownedBy;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModelCopyWith<Model> get copyWith =>
      _$ModelCopyWithImpl<Model>(this as Model, _$identity);

  /// Serializes this Model to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Model &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.ownedBy, ownedBy) || other.ownedBy == ownedBy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, created, object, ownedBy);

  @override
  String toString() {
    return 'Model(id: $id, created: $created, object: $object, ownedBy: $ownedBy)';
  }
}

/// @nodoc
abstract mixin class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) _then) =
      _$ModelCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      @JsonKey(includeIfNull: false) int? created,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ModelObject? object,
      @JsonKey(name: 'owned_by', includeIfNull: false) String? ownedBy});
}

/// @nodoc
class _$ModelCopyWithImpl<$Res> implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._self, this._then);

  final Model _self;
  final $Res Function(Model) _then;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = freezed,
    Object? object = freezed,
    Object? ownedBy = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: freezed == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject?,
      ownedBy: freezed == ownedBy
          ? _self.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [Model].
extension ModelPatterns on Model {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Model value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Model() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Model value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Model():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Model value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Model() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(includeIfNull: false) int? created,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ModelObject? object,
            @JsonKey(name: 'owned_by', includeIfNull: false) String? ownedBy)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Model() when $default != null:
        return $default(_that.id, _that.created, _that.object, _that.ownedBy);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            @JsonKey(includeIfNull: false) int? created,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ModelObject? object,
            @JsonKey(name: 'owned_by', includeIfNull: false) String? ownedBy)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Model():
        return $default(_that.id, _that.created, _that.object, _that.ownedBy);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            @JsonKey(includeIfNull: false) int? created,
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ModelObject? object,
            @JsonKey(name: 'owned_by', includeIfNull: false) String? ownedBy)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Model() when $default != null:
        return $default(_that.id, _that.created, _that.object, _that.ownedBy);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _Model extends Model {
  const _Model(
      {required this.id,
      @JsonKey(includeIfNull: false) this.created,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.object,
      @JsonKey(name: 'owned_by', includeIfNull: false) this.ownedBy})
      : super._();
  factory _Model.fromJson(Map<String, dynamic> json) => _$ModelFromJson(json);

  /// The model identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) when the model was created.
  @override
  @JsonKey(includeIfNull: false)
  final int? created;

  /// The object type, which is always "model".
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ModelObject? object;

  /// The organization that owns the model.
  @override
  @JsonKey(name: 'owned_by', includeIfNull: false)
  final String? ownedBy;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModelCopyWith<_Model> get copyWith =>
      __$ModelCopyWithImpl<_Model>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModelToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Model &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.ownedBy, ownedBy) || other.ownedBy == ownedBy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, created, object, ownedBy);

  @override
  String toString() {
    return 'Model(id: $id, created: $created, object: $object, ownedBy: $ownedBy)';
  }
}

/// @nodoc
abstract mixin class _$ModelCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$ModelCopyWith(_Model value, $Res Function(_Model) _then) =
      __$ModelCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(includeIfNull: false) int? created,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ModelObject? object,
      @JsonKey(name: 'owned_by', includeIfNull: false) String? ownedBy});
}

/// @nodoc
class __$ModelCopyWithImpl<$Res> implements _$ModelCopyWith<$Res> {
  __$ModelCopyWithImpl(this._self, this._then);

  final _Model _self;
  final $Res Function(_Model) _then;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? created = freezed,
    Object? object = freezed,
    Object? ownedBy = freezed,
  }) {
    return _then(_Model(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: freezed == created
          ? _self.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject?,
      ownedBy: freezed == ownedBy
          ? _self.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$ListModelsResponse {
  /// The object type, which is always "list".
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ListModelsResponseObject? get object;

  /// The list of models.
  List<Model> get data;

  /// Create a copy of ListModelsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListModelsResponseCopyWith<ListModelsResponse> get copyWith =>
      _$ListModelsResponseCopyWithImpl<ListModelsResponse>(
          this as ListModelsResponse, _$identity);

  /// Serializes this ListModelsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListModelsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'ListModelsResponse(object: $object, data: $data)';
  }
}

/// @nodoc
abstract mixin class $ListModelsResponseCopyWith<$Res> {
  factory $ListModelsResponseCopyWith(
          ListModelsResponse value, $Res Function(ListModelsResponse) _then) =
      _$ListModelsResponseCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ListModelsResponseObject? object,
      List<Model> data});
}

/// @nodoc
class _$ListModelsResponseCopyWithImpl<$Res>
    implements $ListModelsResponseCopyWith<$Res> {
  _$ListModelsResponseCopyWithImpl(this._self, this._then);

  final ListModelsResponse _self;
  final $Res Function(ListModelsResponse) _then;

  /// Create a copy of ListModelsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = freezed,
    Object? data = null,
  }) {
    return _then(_self.copyWith(
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject?,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListModelsResponse].
extension ListModelsResponsePatterns on ListModelsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListModelsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListModelsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListModelsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListModelsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListModelsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListModelsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ListModelsResponseObject? object,
            List<Model> data)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListModelsResponse() when $default != null:
        return $default(_that.object, _that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ListModelsResponseObject? object,
            List<Model> data)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListModelsResponse():
        return $default(_that.object, _that.data);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            ListModelsResponseObject? object,
            List<Model> data)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListModelsResponse() when $default != null:
        return $default(_that.object, _that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListModelsResponse extends ListModelsResponse {
  const _ListModelsResponse(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.object,
      required final List<Model> data})
      : _data = data,
        super._();
  factory _ListModelsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListModelsResponseFromJson(json);

  /// The object type, which is always "list".
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ListModelsResponseObject? object;

  /// The list of models.
  final List<Model> _data;

  /// The list of models.
  @override
  List<Model> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// Create a copy of ListModelsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListModelsResponseCopyWith<_ListModelsResponse> get copyWith =>
      __$ListModelsResponseCopyWithImpl<_ListModelsResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListModelsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListModelsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'ListModelsResponse(object: $object, data: $data)';
  }
}

/// @nodoc
abstract mixin class _$ListModelsResponseCopyWith<$Res>
    implements $ListModelsResponseCopyWith<$Res> {
  factory _$ListModelsResponseCopyWith(
          _ListModelsResponse value, $Res Function(_ListModelsResponse) _then) =
      __$ListModelsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ListModelsResponseObject? object,
      List<Model> data});
}

/// @nodoc
class __$ListModelsResponseCopyWithImpl<$Res>
    implements _$ListModelsResponseCopyWith<$Res> {
  __$ListModelsResponseCopyWithImpl(this._self, this._then);

  final _ListModelsResponse _self;
  final $Res Function(_ListModelsResponse) _then;

  /// Create a copy of ListModelsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = freezed,
    Object? data = null,
  }) {
    return _then(_ListModelsResponse(
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject?,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ));
  }
}

/// @nodoc
mixin _$DeleteModelResponse {
  /// The model identifier.
  String get id;

  /// Whether the model was deleted.
  bool get deleted;

  /// The object type, which is always "model".
  String get object;

  /// Create a copy of DeleteModelResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DeleteModelResponseCopyWith<DeleteModelResponse> get copyWith =>
      _$DeleteModelResponseCopyWithImpl<DeleteModelResponse>(
          this as DeleteModelResponse, _$identity);

  /// Serializes this DeleteModelResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteModelResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteModelResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class $DeleteModelResponseCopyWith<$Res> {
  factory $DeleteModelResponseCopyWith(
          DeleteModelResponse value, $Res Function(DeleteModelResponse) _then) =
      _$DeleteModelResponseCopyWithImpl;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteModelResponseCopyWithImpl<$Res>
    implements $DeleteModelResponseCopyWith<$Res> {
  _$DeleteModelResponseCopyWithImpl(this._self, this._then);

  final DeleteModelResponse _self;
  final $Res Function(DeleteModelResponse) _then;

  /// Create a copy of DeleteModelResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [DeleteModelResponse].
extension DeleteModelResponsePatterns on DeleteModelResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DeleteModelResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteModelResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DeleteModelResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteModelResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DeleteModelResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteModelResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String id, bool deleted, String object)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteModelResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String id, bool deleted, String object) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteModelResponse():
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String id, bool deleted, String object)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteModelResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DeleteModelResponse extends DeleteModelResponse {
  const _DeleteModelResponse(
      {required this.id, required this.deleted, required this.object})
      : super._();
  factory _DeleteModelResponse.fromJson(Map<String, dynamic> json) =>
      _$DeleteModelResponseFromJson(json);

  /// The model identifier.
  @override
  final String id;

  /// Whether the model was deleted.
  @override
  final bool deleted;

  /// The object type, which is always "model".
  @override
  final String object;

  /// Create a copy of DeleteModelResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DeleteModelResponseCopyWith<_DeleteModelResponse> get copyWith =>
      __$DeleteModelResponseCopyWithImpl<_DeleteModelResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DeleteModelResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DeleteModelResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteModelResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$DeleteModelResponseCopyWith<$Res>
    implements $DeleteModelResponseCopyWith<$Res> {
  factory _$DeleteModelResponseCopyWith(_DeleteModelResponse value,
          $Res Function(_DeleteModelResponse) _then) =
      __$DeleteModelResponseCopyWithImpl;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$DeleteModelResponseCopyWithImpl<$Res>
    implements _$DeleteModelResponseCopyWith<$Res> {
  __$DeleteModelResponseCopyWithImpl(this._self, this._then);

  final _DeleteModelResponse _self;
  final $Res Function(_DeleteModelResponse) _then;

  /// Create a copy of DeleteModelResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_DeleteModelResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$CreateModerationRequest {
  /// The content moderation model you would like to use. Learn more in
  /// [the moderation guide](https://platform.openai.com/docs/guides/moderation), and learn about
  /// available models [here](https://platform.openai.com//docs/models/moderation).
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model;

  /// Input (or inputs) to classify. Can be a single string, an array of strings, or
  /// an array of multi-modal input objects similar to other models.
  @_ModerationInputConverter()
  ModerationInput get input;

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateModerationRequestCopyWith<CreateModerationRequest> get copyWith =>
      _$CreateModerationRequestCopyWithImpl<CreateModerationRequest>(
          this as CreateModerationRequest, _$identity);

  /// Serializes this CreateModerationRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateModerationRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, model, input);

  @override
  String toString() {
    return 'CreateModerationRequest(model: $model, input: $input)';
  }
}

/// @nodoc
abstract mixin class $CreateModerationRequestCopyWith<$Res> {
  factory $CreateModerationRequestCopyWith(CreateModerationRequest value,
          $Res Function(CreateModerationRequest) _then) =
      _$CreateModerationRequestCopyWithImpl;
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  $ModerationModelCopyWith<$Res>? get model;
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateModerationRequestCopyWithImpl<$Res>
    implements $CreateModerationRequestCopyWith<$Res> {
  _$CreateModerationRequestCopyWithImpl(this._self, this._then);

  final CreateModerationRequest _self;
  final $Res Function(CreateModerationRequest) _then;

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_self.copyWith(
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ));
  }

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $ModerationModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationInputCopyWith<$Res> get input {
    return $ModerationInputCopyWith<$Res>(_self.input, (value) {
      return _then(_self.copyWith(input: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateModerationRequest].
extension CreateModerationRequestPatterns on CreateModerationRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateModerationRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateModerationRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateModerationRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateModerationRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @_ModerationModelConverter()
            @JsonKey(includeIfNull: false)
            ModerationModel? model,
            @_ModerationInputConverter() ModerationInput input)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateModerationRequest() when $default != null:
        return $default(_that.model, _that.input);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @_ModerationModelConverter()
            @JsonKey(includeIfNull: false)
            ModerationModel? model,
            @_ModerationInputConverter() ModerationInput input)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationRequest():
        return $default(_that.model, _that.input);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @_ModerationModelConverter()
            @JsonKey(includeIfNull: false)
            ModerationModel? model,
            @_ModerationInputConverter() ModerationInput input)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationRequest() when $default != null:
        return $default(_that.model, _that.input);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateModerationRequest extends CreateModerationRequest {
  const _CreateModerationRequest(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const ModerationModelString('omni-moderation-latest'),
      @_ModerationInputConverter() required this.input})
      : super._();
  factory _CreateModerationRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateModerationRequestFromJson(json);

  /// The content moderation model you would like to use. Learn more in
  /// [the moderation guide](https://platform.openai.com/docs/guides/moderation), and learn about
  /// available models [here](https://platform.openai.com//docs/models/moderation).
  @override
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  final ModerationModel? model;

  /// Input (or inputs) to classify. Can be a single string, an array of strings, or
  /// an array of multi-modal input objects similar to other models.
  @override
  @_ModerationInputConverter()
  final ModerationInput input;

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateModerationRequestCopyWith<_CreateModerationRequest> get copyWith =>
      __$CreateModerationRequestCopyWithImpl<_CreateModerationRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateModerationRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateModerationRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, model, input);

  @override
  String toString() {
    return 'CreateModerationRequest(model: $model, input: $input)';
  }
}

/// @nodoc
abstract mixin class _$CreateModerationRequestCopyWith<$Res>
    implements $CreateModerationRequestCopyWith<$Res> {
  factory _$CreateModerationRequestCopyWith(_CreateModerationRequest value,
          $Res Function(_CreateModerationRequest) _then) =
      __$CreateModerationRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  @override
  $ModerationModelCopyWith<$Res>? get model;
  @override
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class __$CreateModerationRequestCopyWithImpl<$Res>
    implements _$CreateModerationRequestCopyWith<$Res> {
  __$CreateModerationRequestCopyWithImpl(this._self, this._then);

  final _CreateModerationRequest _self;
  final $Res Function(_CreateModerationRequest) _then;

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_CreateModerationRequest(
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ));
  }

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $ModerationModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateModerationRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationInputCopyWith<$Res> get input {
    return $ModerationInputCopyWith<$Res>(_self.input, (value) {
      return _then(_self.copyWith(input: value));
    });
  }
}

ModerationModel _$ModerationModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ModerationModelEnumeration.fromJson(json);
    case 'modelId':
      return ModerationModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationModel {
  Object get value;

  /// Serializes this ModerationModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ModerationModel(value: $value)';
  }
}

/// @nodoc
class $ModerationModelCopyWith<$Res> {
  $ModerationModelCopyWith(
      ModerationModel _, $Res Function(ModerationModel) __);
}

/// Adds pattern-matching-related methods to [ModerationModel].
extension ModerationModelPatterns on ModerationModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModerationModelEnumeration() when model != null:
        return model(_that);
      case ModerationModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationModelEnumeration():
        return model(_that);
      case ModerationModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationModelEnumeration() when model != null:
        return model(_that);
      case ModerationModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModerationModelEnumeration() when model != null:
        return model(_that.value);
      case ModerationModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationModelEnumeration():
        return model(_that.value);
      case ModerationModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationModelEnumeration() when model != null:
        return model(_that.value);
      case ModerationModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ModerationModelEnumeration extends ModerationModel {
  const ModerationModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory ModerationModelEnumeration.fromJson(Map<String, dynamic> json) =>
      _$ModerationModelEnumerationFromJson(json);

  @override
  final ModerationModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ModerationModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationModelEnumerationCopyWith<ModerationModelEnumeration>
      get copyWith =>
          _$ModerationModelEnumerationCopyWithImpl<ModerationModelEnumeration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ModerationModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ModerationModelEnumerationCopyWith<$Res>
    implements $ModerationModelCopyWith<$Res> {
  factory $ModerationModelEnumerationCopyWith(ModerationModelEnumeration value,
          $Res Function(ModerationModelEnumeration) _then) =
      _$ModerationModelEnumerationCopyWithImpl;
  @useResult
  $Res call({ModerationModels value});
}

/// @nodoc
class _$ModerationModelEnumerationCopyWithImpl<$Res>
    implements $ModerationModelEnumerationCopyWith<$Res> {
  _$ModerationModelEnumerationCopyWithImpl(this._self, this._then);

  final ModerationModelEnumeration _self;
  final $Res Function(ModerationModelEnumeration) _then;

  /// Create a copy of ModerationModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ModerationModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ModerationModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ModerationModelString extends ModerationModel {
  const ModerationModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory ModerationModelString.fromJson(Map<String, dynamic> json) =>
      _$ModerationModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ModerationModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationModelStringCopyWith<ModerationModelString> get copyWith =>
      _$ModerationModelStringCopyWithImpl<ModerationModelString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ModerationModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ModerationModelStringCopyWith<$Res>
    implements $ModerationModelCopyWith<$Res> {
  factory $ModerationModelStringCopyWith(ModerationModelString value,
          $Res Function(ModerationModelString) _then) =
      _$ModerationModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$ModerationModelStringCopyWithImpl<$Res>
    implements $ModerationModelStringCopyWith<$Res> {
  _$ModerationModelStringCopyWithImpl(this._self, this._then);

  final ModerationModelString _self;
  final $Res Function(ModerationModelString) _then;

  /// Create a copy of ModerationModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ModerationModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

ModerationInput _$ModerationInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listModerationInputObject':
      return ModerationInputListModerationInputObject.fromJson(json);
    case 'listString':
      return ModerationInputListString.fromJson(json);
    case 'string':
      return ModerationInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationInput {
  Object get value;

  /// Serializes this ModerationInput to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInput &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ModerationInput(value: $value)';
  }
}

/// @nodoc
class $ModerationInputCopyWith<$Res> {
  $ModerationInputCopyWith(
      ModerationInput _, $Res Function(ModerationInput) __);
}

/// Adds pattern-matching-related methods to [ModerationInput].
extension ModerationInputPatterns on ModerationInput {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListModerationInputObject value)?
        listModerationInputObject,
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputListModerationInputObject()
          when listModerationInputObject != null:
        return listModerationInputObject(_that);
      case ModerationInputListString() when listString != null:
        return listString(_that);
      case ModerationInputString() when string != null:
        return string(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListModerationInputObject value)
        listModerationInputObject,
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputListModerationInputObject():
        return listModerationInputObject(_that);
      case ModerationInputListString():
        return listString(_that);
      case ModerationInputString():
        return string(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListModerationInputObject value)?
        listModerationInputObject,
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputListModerationInputObject()
          when listModerationInputObject != null:
        return listModerationInputObject(_that);
      case ModerationInputListString() when listString != null:
        return listString(_that);
      case ModerationInputString() when string != null:
        return string(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ModerationInputObject> value)?
        listModerationInputObject,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputListModerationInputObject()
          when listModerationInputObject != null:
        return listModerationInputObject(_that.value);
      case ModerationInputListString() when listString != null:
        return listString(_that.value);
      case ModerationInputString() when string != null:
        return string(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ModerationInputObject> value)
        listModerationInputObject,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputListModerationInputObject():
        return listModerationInputObject(_that.value);
      case ModerationInputListString():
        return listString(_that.value);
      case ModerationInputString():
        return string(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ModerationInputObject> value)?
        listModerationInputObject,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputListModerationInputObject()
          when listModerationInputObject != null:
        return listModerationInputObject(_that.value);
      case ModerationInputListString() when listString != null:
        return listString(_that.value);
      case ModerationInputString() when string != null:
        return string(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ModerationInputListModerationInputObject extends ModerationInput {
  const ModerationInputListModerationInputObject(
      final List<ModerationInputObject> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listModerationInputObject',
        super._();
  factory ModerationInputListModerationInputObject.fromJson(
          Map<String, dynamic> json) =>
      _$ModerationInputListModerationInputObjectFromJson(json);

  final List<ModerationInputObject> _value;
  @override
  List<ModerationInputObject> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ModerationInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationInputListModerationInputObjectCopyWith<
          ModerationInputListModerationInputObject>
      get copyWith => _$ModerationInputListModerationInputObjectCopyWithImpl<
          ModerationInputListModerationInputObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationInputListModerationInputObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInputListModerationInputObject &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'ModerationInput.listModerationInputObject(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ModerationInputListModerationInputObjectCopyWith<$Res>
    implements $ModerationInputCopyWith<$Res> {
  factory $ModerationInputListModerationInputObjectCopyWith(
          ModerationInputListModerationInputObject value,
          $Res Function(ModerationInputListModerationInputObject) _then) =
      _$ModerationInputListModerationInputObjectCopyWithImpl;
  @useResult
  $Res call({List<ModerationInputObject> value});
}

/// @nodoc
class _$ModerationInputListModerationInputObjectCopyWithImpl<$Res>
    implements $ModerationInputListModerationInputObjectCopyWith<$Res> {
  _$ModerationInputListModerationInputObjectCopyWithImpl(
      this._self, this._then);

  final ModerationInputListModerationInputObject _self;
  final $Res Function(ModerationInputListModerationInputObject) _then;

  /// Create a copy of ModerationInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ModerationInputListModerationInputObject(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<ModerationInputObject>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ModerationInputListString extends ModerationInput {
  const ModerationInputListString(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();
  factory ModerationInputListString.fromJson(Map<String, dynamic> json) =>
      _$ModerationInputListStringFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ModerationInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationInputListStringCopyWith<ModerationInputListString> get copyWith =>
      _$ModerationInputListStringCopyWithImpl<ModerationInputListString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationInputListStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInputListString &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'ModerationInput.listString(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ModerationInputListStringCopyWith<$Res>
    implements $ModerationInputCopyWith<$Res> {
  factory $ModerationInputListStringCopyWith(ModerationInputListString value,
          $Res Function(ModerationInputListString) _then) =
      _$ModerationInputListStringCopyWithImpl;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class _$ModerationInputListStringCopyWithImpl<$Res>
    implements $ModerationInputListStringCopyWith<$Res> {
  _$ModerationInputListStringCopyWithImpl(this._self, this._then);

  final ModerationInputListString _self;
  final $Res Function(ModerationInputListString) _then;

  /// Create a copy of ModerationInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ModerationInputListString(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ModerationInputString extends ModerationInput {
  const ModerationInputString(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();
  factory ModerationInputString.fromJson(Map<String, dynamic> json) =>
      _$ModerationInputStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ModerationInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationInputStringCopyWith<ModerationInputString> get copyWith =>
      _$ModerationInputStringCopyWithImpl<ModerationInputString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationInputStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInputString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ModerationInput.string(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ModerationInputStringCopyWith<$Res>
    implements $ModerationInputCopyWith<$Res> {
  factory $ModerationInputStringCopyWith(ModerationInputString value,
          $Res Function(ModerationInputString) _then) =
      _$ModerationInputStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$ModerationInputStringCopyWithImpl<$Res>
    implements $ModerationInputStringCopyWith<$Res> {
  _$ModerationInputStringCopyWithImpl(this._self, this._then);

  final ModerationInputString _self;
  final $Res Function(ModerationInputString) _then;

  /// Create a copy of ModerationInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ModerationInputString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$CreateModerationResponse {
  /// The unique identifier for the moderation request.
  String get id;

  /// The model used to generate the moderation results.
  String get model;

  /// A list of moderation objects.
  List<Moderation> get results;

  /// Create a copy of CreateModerationResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateModerationResponseCopyWith<CreateModerationResponse> get copyWith =>
      _$CreateModerationResponseCopyWithImpl<CreateModerationResponse>(
          this as CreateModerationResponse, _$identity);

  /// Serializes this CreateModerationResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateModerationResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other.results, results));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, model, const DeepCollectionEquality().hash(results));

  @override
  String toString() {
    return 'CreateModerationResponse(id: $id, model: $model, results: $results)';
  }
}

/// @nodoc
abstract mixin class $CreateModerationResponseCopyWith<$Res> {
  factory $CreateModerationResponseCopyWith(CreateModerationResponse value,
          $Res Function(CreateModerationResponse) _then) =
      _$CreateModerationResponseCopyWithImpl;
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class _$CreateModerationResponseCopyWithImpl<$Res>
    implements $CreateModerationResponseCopyWith<$Res> {
  _$CreateModerationResponseCopyWithImpl(this._self, this._then);

  final CreateModerationResponse _self;
  final $Res Function(CreateModerationResponse) _then;

  /// Create a copy of CreateModerationResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _self.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ));
  }
}

/// Adds pattern-matching-related methods to [CreateModerationResponse].
extension CreateModerationResponsePatterns on CreateModerationResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateModerationResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateModerationResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateModerationResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateModerationResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String id, String model, List<Moderation> results)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateModerationResponse() when $default != null:
        return $default(_that.id, _that.model, _that.results);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String id, String model, List<Moderation> results)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationResponse():
        return $default(_that.id, _that.model, _that.results);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String id, String model, List<Moderation> results)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateModerationResponse() when $default != null:
        return $default(_that.id, _that.model, _that.results);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateModerationResponse extends CreateModerationResponse {
  const _CreateModerationResponse(
      {required this.id,
      required this.model,
      required final List<Moderation> results})
      : _results = results,
        super._();
  factory _CreateModerationResponse.fromJson(Map<String, dynamic> json) =>
      _$CreateModerationResponseFromJson(json);

  /// The unique identifier for the moderation request.
  @override
  final String id;

  /// The model used to generate the moderation results.
  @override
  final String model;

  /// A list of moderation objects.
  final List<Moderation> _results;

  /// A list of moderation objects.
  @override
  List<Moderation> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  /// Create a copy of CreateModerationResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateModerationResponseCopyWith<_CreateModerationResponse> get copyWith =>
      __$CreateModerationResponseCopyWithImpl<_CreateModerationResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateModerationResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateModerationResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._results, _results));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, model, const DeepCollectionEquality().hash(_results));

  @override
  String toString() {
    return 'CreateModerationResponse(id: $id, model: $model, results: $results)';
  }
}

/// @nodoc
abstract mixin class _$CreateModerationResponseCopyWith<$Res>
    implements $CreateModerationResponseCopyWith<$Res> {
  factory _$CreateModerationResponseCopyWith(_CreateModerationResponse value,
          $Res Function(_CreateModerationResponse) _then) =
      __$CreateModerationResponseCopyWithImpl;
  @override
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class __$CreateModerationResponseCopyWithImpl<$Res>
    implements _$CreateModerationResponseCopyWith<$Res> {
  __$CreateModerationResponseCopyWithImpl(this._self, this._then);

  final _CreateModerationResponse _self;
  final $Res Function(_CreateModerationResponse) _then;

  /// Create a copy of CreateModerationResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_CreateModerationResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _self._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ));
  }
}

/// @nodoc
mixin _$Moderation {
  /// Whether any of the below categories are flagged.
  bool get flagged;

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories;

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores;

  /// A list of the categories along with the input type(s) that the score applies to.
  @JsonKey(name: 'category_applied_input_types')
  ModerationCategoriesAppliedInputTypes get categoryAppliedInputTypes;

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationCopyWith<Moderation> get copyWith =>
      _$ModerationCopyWithImpl<Moderation>(this as Moderation, _$identity);

  /// Serializes this Moderation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Moderation &&
            (identical(other.flagged, flagged) || other.flagged == flagged) &&
            (identical(other.categories, categories) ||
                other.categories == categories) &&
            (identical(other.categoryScores, categoryScores) ||
                other.categoryScores == categoryScores) &&
            (identical(other.categoryAppliedInputTypes,
                    categoryAppliedInputTypes) ||
                other.categoryAppliedInputTypes == categoryAppliedInputTypes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, flagged, categories,
      categoryScores, categoryAppliedInputTypes);

  @override
  String toString() {
    return 'Moderation(flagged: $flagged, categories: $categories, categoryScores: $categoryScores, categoryAppliedInputTypes: $categoryAppliedInputTypes)';
  }
}

/// @nodoc
abstract mixin class $ModerationCopyWith<$Res> {
  factory $ModerationCopyWith(
          Moderation value, $Res Function(Moderation) _then) =
      _$ModerationCopyWithImpl;
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores,
      @JsonKey(name: 'category_applied_input_types')
      ModerationCategoriesAppliedInputTypes categoryAppliedInputTypes});

  $ModerationCategoriesCopyWith<$Res> get categories;
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
  $ModerationCategoriesAppliedInputTypesCopyWith<$Res>
      get categoryAppliedInputTypes;
}

/// @nodoc
class _$ModerationCopyWithImpl<$Res> implements $ModerationCopyWith<$Res> {
  _$ModerationCopyWithImpl(this._self, this._then);

  final Moderation _self;
  final $Res Function(Moderation) _then;

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
    Object? categoryAppliedInputTypes = null,
  }) {
    return _then(_self.copyWith(
      flagged: null == flagged
          ? _self.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _self.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _self.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
      categoryAppliedInputTypes: null == categoryAppliedInputTypes
          ? _self.categoryAppliedInputTypes
          : categoryAppliedInputTypes // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesAppliedInputTypes,
    ));
  }

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesCopyWith<$Res> get categories {
    return $ModerationCategoriesCopyWith<$Res>(_self.categories, (value) {
      return _then(_self.copyWith(categories: value));
    });
  }

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores {
    return $ModerationCategoriesScoresCopyWith<$Res>(_self.categoryScores,
        (value) {
      return _then(_self.copyWith(categoryScores: value));
    });
  }

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesAppliedInputTypesCopyWith<$Res>
      get categoryAppliedInputTypes {
    return $ModerationCategoriesAppliedInputTypesCopyWith<$Res>(
        _self.categoryAppliedInputTypes, (value) {
      return _then(_self.copyWith(categoryAppliedInputTypes: value));
    });
  }
}

/// Adds pattern-matching-related methods to [Moderation].
extension ModerationPatterns on Moderation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Moderation value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Moderation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Moderation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Moderation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Moderation value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Moderation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            bool flagged,
            ModerationCategories categories,
            @JsonKey(name: 'category_scores')
            ModerationCategoriesScores categoryScores,
            @JsonKey(name: 'category_applied_input_types')
            ModerationCategoriesAppliedInputTypes categoryAppliedInputTypes)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Moderation() when $default != null:
        return $default(_that.flagged, _that.categories, _that.categoryScores,
            _that.categoryAppliedInputTypes);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            bool flagged,
            ModerationCategories categories,
            @JsonKey(name: 'category_scores')
            ModerationCategoriesScores categoryScores,
            @JsonKey(name: 'category_applied_input_types')
            ModerationCategoriesAppliedInputTypes categoryAppliedInputTypes)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Moderation():
        return $default(_that.flagged, _that.categories, _that.categoryScores,
            _that.categoryAppliedInputTypes);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            bool flagged,
            ModerationCategories categories,
            @JsonKey(name: 'category_scores')
            ModerationCategoriesScores categoryScores,
            @JsonKey(name: 'category_applied_input_types')
            ModerationCategoriesAppliedInputTypes categoryAppliedInputTypes)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Moderation() when $default != null:
        return $default(_that.flagged, _that.categories, _that.categoryScores,
            _that.categoryAppliedInputTypes);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _Moderation extends Moderation {
  const _Moderation(
      {required this.flagged,
      required this.categories,
      @JsonKey(name: 'category_scores') required this.categoryScores,
      @JsonKey(name: 'category_applied_input_types')
      required this.categoryAppliedInputTypes})
      : super._();
  factory _Moderation.fromJson(Map<String, dynamic> json) =>
      _$ModerationFromJson(json);

  /// Whether any of the below categories are flagged.
  @override
  final bool flagged;

  /// A list of the categories, and whether they are flagged or not.
  @override
  final ModerationCategories categories;

  /// A list of the categories along with their scores as predicted by model.
  @override
  @JsonKey(name: 'category_scores')
  final ModerationCategoriesScores categoryScores;

  /// A list of the categories along with the input type(s) that the score applies to.
  @override
  @JsonKey(name: 'category_applied_input_types')
  final ModerationCategoriesAppliedInputTypes categoryAppliedInputTypes;

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModerationCopyWith<_Moderation> get copyWith =>
      __$ModerationCopyWithImpl<_Moderation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Moderation &&
            (identical(other.flagged, flagged) || other.flagged == flagged) &&
            (identical(other.categories, categories) ||
                other.categories == categories) &&
            (identical(other.categoryScores, categoryScores) ||
                other.categoryScores == categoryScores) &&
            (identical(other.categoryAppliedInputTypes,
                    categoryAppliedInputTypes) ||
                other.categoryAppliedInputTypes == categoryAppliedInputTypes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, flagged, categories,
      categoryScores, categoryAppliedInputTypes);

  @override
  String toString() {
    return 'Moderation(flagged: $flagged, categories: $categories, categoryScores: $categoryScores, categoryAppliedInputTypes: $categoryAppliedInputTypes)';
  }
}

/// @nodoc
abstract mixin class _$ModerationCopyWith<$Res>
    implements $ModerationCopyWith<$Res> {
  factory _$ModerationCopyWith(
          _Moderation value, $Res Function(_Moderation) _then) =
      __$ModerationCopyWithImpl;
  @override
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores,
      @JsonKey(name: 'category_applied_input_types')
      ModerationCategoriesAppliedInputTypes categoryAppliedInputTypes});

  @override
  $ModerationCategoriesCopyWith<$Res> get categories;
  @override
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
  @override
  $ModerationCategoriesAppliedInputTypesCopyWith<$Res>
      get categoryAppliedInputTypes;
}

/// @nodoc
class __$ModerationCopyWithImpl<$Res> implements _$ModerationCopyWith<$Res> {
  __$ModerationCopyWithImpl(this._self, this._then);

  final _Moderation _self;
  final $Res Function(_Moderation) _then;

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
    Object? categoryAppliedInputTypes = null,
  }) {
    return _then(_Moderation(
      flagged: null == flagged
          ? _self.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _self.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _self.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
      categoryAppliedInputTypes: null == categoryAppliedInputTypes
          ? _self.categoryAppliedInputTypes
          : categoryAppliedInputTypes // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesAppliedInputTypes,
    ));
  }

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesCopyWith<$Res> get categories {
    return $ModerationCategoriesCopyWith<$Res>(_self.categories, (value) {
      return _then(_self.copyWith(categories: value));
    });
  }

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores {
    return $ModerationCategoriesScoresCopyWith<$Res>(_self.categoryScores,
        (value) {
      return _then(_self.copyWith(categoryScores: value));
    });
  }

  /// Create a copy of Moderation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesAppliedInputTypesCopyWith<$Res>
      get categoryAppliedInputTypes {
    return $ModerationCategoriesAppliedInputTypesCopyWith<$Res>(
        _self.categoryAppliedInputTypes, (value) {
      return _then(_self.copyWith(categoryAppliedInputTypes: value));
    });
  }
}

/// @nodoc
mixin _$ModerationCategories {
  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  bool get hate;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment;

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening;

  /// Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, "how to shoplift" would fit this category.
  bool get illicit;

  /// Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon.
  @JsonKey(name: 'illicit/violent')
  bool get illicitViolent;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual;

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors;

  /// Content that depicts death, violence, or physical injury.
  bool get violence;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic;

  /// Create a copy of ModerationCategories
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationCategoriesCopyWith<ModerationCategories> get copyWith =>
      _$ModerationCategoriesCopyWithImpl<ModerationCategories>(
          this as ModerationCategories, _$identity);

  /// Serializes this ModerationCategories to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationCategories &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.illicit, illicit) || other.illicit == illicit) &&
            (identical(other.illicitViolent, illicitViolent) ||
                other.illicitViolent == illicitViolent) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      illicit,
      illicitViolent,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @override
  String toString() {
    return 'ModerationCategories(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, illicit: $illicit, illicitViolent: $illicitViolent, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }
}

/// @nodoc
abstract mixin class $ModerationCategoriesCopyWith<$Res> {
  factory $ModerationCategoriesCopyWith(ModerationCategories value,
          $Res Function(ModerationCategories) _then) =
      _$ModerationCategoriesCopyWithImpl;
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      bool illicit,
      @JsonKey(name: 'illicit/violent') bool illicitViolent,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesCopyWithImpl<$Res>
    implements $ModerationCategoriesCopyWith<$Res> {
  _$ModerationCategoriesCopyWithImpl(this._self, this._then);

  final ModerationCategories _self;
  final $Res Function(ModerationCategories) _then;

  /// Create a copy of ModerationCategories
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? illicit = null,
    Object? illicitViolent = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_self.copyWith(
      hate: null == hate
          ? _self.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _self.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _self.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _self.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      illicit: null == illicit
          ? _self.illicit
          : illicit // ignore: cast_nullable_to_non_nullable
              as bool,
      illicitViolent: null == illicitViolent
          ? _self.illicitViolent
          : illicitViolent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _self.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _self.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _self.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _self.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _self.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _self.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _self.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ModerationCategories].
extension ModerationCategoriesPatterns on ModerationCategories {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModerationCategories value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationCategories() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModerationCategories value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategories():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModerationCategories value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategories() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            bool hate,
            @JsonKey(name: 'hate/threatening') bool hateThreatening,
            bool harassment,
            @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
            bool illicit,
            @JsonKey(name: 'illicit/violent') bool illicitViolent,
            @JsonKey(name: 'self-harm') bool selfHarm,
            @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
            bool sexual,
            @JsonKey(name: 'sexual/minors') bool sexualMinors,
            bool violence,
            @JsonKey(name: 'violence/graphic') bool violenceGraphic)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationCategories() when $default != null:
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            bool hate,
            @JsonKey(name: 'hate/threatening') bool hateThreatening,
            bool harassment,
            @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
            bool illicit,
            @JsonKey(name: 'illicit/violent') bool illicitViolent,
            @JsonKey(name: 'self-harm') bool selfHarm,
            @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
            bool sexual,
            @JsonKey(name: 'sexual/minors') bool sexualMinors,
            bool violence,
            @JsonKey(name: 'violence/graphic') bool violenceGraphic)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategories():
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            bool hate,
            @JsonKey(name: 'hate/threatening') bool hateThreatening,
            bool harassment,
            @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
            bool illicit,
            @JsonKey(name: 'illicit/violent') bool illicitViolent,
            @JsonKey(name: 'self-harm') bool selfHarm,
            @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
            bool sexual,
            @JsonKey(name: 'sexual/minors') bool sexualMinors,
            bool violence,
            @JsonKey(name: 'violence/graphic') bool violenceGraphic)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategories() when $default != null:
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModerationCategories extends ModerationCategories {
  const _ModerationCategories(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      required this.illicit,
      @JsonKey(name: 'illicit/violent') required this.illicitViolent,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();
  factory _ModerationCategories.fromJson(Map<String, dynamic> json) =>
      _$ModerationCategoriesFromJson(json);

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  @override
  final bool hate;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @override
  @JsonKey(name: 'hate/threatening')
  final bool hateThreatening;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  @override
  final bool harassment;

  /// Harassment content that also includes violence or serious harm towards any target.
  @override
  @JsonKey(name: 'harassment/threatening')
  final bool harassmentThreatening;

  /// Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, "how to shoplift" would fit this category.
  @override
  final bool illicit;

  /// Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon.
  @override
  @JsonKey(name: 'illicit/violent')
  final bool illicitViolent;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm')
  final bool selfHarm;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm/intent')
  final bool selfHarmIntent;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final bool selfHarmInstructions;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  @override
  final bool sexual;

  /// Sexual content that includes an individual who is under 18 years old.
  @override
  @JsonKey(name: 'sexual/minors')
  final bool sexualMinors;

  /// Content that depicts death, violence, or physical injury.
  @override
  final bool violence;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @override
  @JsonKey(name: 'violence/graphic')
  final bool violenceGraphic;

  /// Create a copy of ModerationCategories
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModerationCategoriesCopyWith<_ModerationCategories> get copyWith =>
      __$ModerationCategoriesCopyWithImpl<_ModerationCategories>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationCategoriesToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModerationCategories &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.illicit, illicit) || other.illicit == illicit) &&
            (identical(other.illicitViolent, illicitViolent) ||
                other.illicitViolent == illicitViolent) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      illicit,
      illicitViolent,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @override
  String toString() {
    return 'ModerationCategories(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, illicit: $illicit, illicitViolent: $illicitViolent, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }
}

/// @nodoc
abstract mixin class _$ModerationCategoriesCopyWith<$Res>
    implements $ModerationCategoriesCopyWith<$Res> {
  factory _$ModerationCategoriesCopyWith(_ModerationCategories value,
          $Res Function(_ModerationCategories) _then) =
      __$ModerationCategoriesCopyWithImpl;
  @override
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      bool illicit,
      @JsonKey(name: 'illicit/violent') bool illicitViolent,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class __$ModerationCategoriesCopyWithImpl<$Res>
    implements _$ModerationCategoriesCopyWith<$Res> {
  __$ModerationCategoriesCopyWithImpl(this._self, this._then);

  final _ModerationCategories _self;
  final $Res Function(_ModerationCategories) _then;

  /// Create a copy of ModerationCategories
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? illicit = null,
    Object? illicitViolent = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_ModerationCategories(
      hate: null == hate
          ? _self.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _self.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _self.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _self.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      illicit: null == illicit
          ? _self.illicit
          : illicit // ignore: cast_nullable_to_non_nullable
              as bool,
      illicitViolent: null == illicitViolent
          ? _self.illicitViolent
          : illicitViolent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _self.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _self.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _self.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _self.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _self.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _self.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _self.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$ModerationCategoriesScores {
  /// The score for the category 'hate'.
  double get hate;

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening;

  /// The score for the category 'harassment'.
  double get harassment;

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening;

  /// The score for the category 'illicit'.
  double get illicit;

  /// The score for the category 'illicit/violent'.
  @JsonKey(name: 'illicit/violent')
  double get illicitViolent;

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm;

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent;

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions;

  /// The score for the category 'sexual'.
  double get sexual;

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors;

  /// The score for the category 'violence'.
  double get violence;

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic;

  /// Create a copy of ModerationCategoriesScores
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationCategoriesScoresCopyWith<ModerationCategoriesScores>
      get copyWith =>
          _$ModerationCategoriesScoresCopyWithImpl<ModerationCategoriesScores>(
              this as ModerationCategoriesScores, _$identity);

  /// Serializes this ModerationCategoriesScores to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationCategoriesScores &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.illicit, illicit) || other.illicit == illicit) &&
            (identical(other.illicitViolent, illicitViolent) ||
                other.illicitViolent == illicitViolent) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      illicit,
      illicitViolent,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @override
  String toString() {
    return 'ModerationCategoriesScores(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, illicit: $illicit, illicitViolent: $illicitViolent, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }
}

/// @nodoc
abstract mixin class $ModerationCategoriesScoresCopyWith<$Res> {
  factory $ModerationCategoriesScoresCopyWith(ModerationCategoriesScores value,
          $Res Function(ModerationCategoriesScores) _then) =
      _$ModerationCategoriesScoresCopyWithImpl;
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      double illicit,
      @JsonKey(name: 'illicit/violent') double illicitViolent,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesScoresCopyWithImpl<$Res>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  _$ModerationCategoriesScoresCopyWithImpl(this._self, this._then);

  final ModerationCategoriesScores _self;
  final $Res Function(ModerationCategoriesScores) _then;

  /// Create a copy of ModerationCategoriesScores
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? illicit = null,
    Object? illicitViolent = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_self.copyWith(
      hate: null == hate
          ? _self.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _self.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _self.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _self.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      illicit: null == illicit
          ? _self.illicit
          : illicit // ignore: cast_nullable_to_non_nullable
              as double,
      illicitViolent: null == illicitViolent
          ? _self.illicitViolent
          : illicitViolent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _self.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _self.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _self.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _self.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _self.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _self.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _self.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// Adds pattern-matching-related methods to [ModerationCategoriesScores].
extension ModerationCategoriesScoresPatterns on ModerationCategoriesScores {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModerationCategoriesScores value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesScores() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModerationCategoriesScores value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesScores():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModerationCategoriesScores value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesScores() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            double hate,
            @JsonKey(name: 'hate/threatening') double hateThreatening,
            double harassment,
            @JsonKey(name: 'harassment/threatening')
            double harassmentThreatening,
            double illicit,
            @JsonKey(name: 'illicit/violent') double illicitViolent,
            @JsonKey(name: 'self-harm') double selfHarm,
            @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions')
            double selfHarmInstructions,
            double sexual,
            @JsonKey(name: 'sexual/minors') double sexualMinors,
            double violence,
            @JsonKey(name: 'violence/graphic') double violenceGraphic)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesScores() when $default != null:
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            double hate,
            @JsonKey(name: 'hate/threatening') double hateThreatening,
            double harassment,
            @JsonKey(name: 'harassment/threatening')
            double harassmentThreatening,
            double illicit,
            @JsonKey(name: 'illicit/violent') double illicitViolent,
            @JsonKey(name: 'self-harm') double selfHarm,
            @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions')
            double selfHarmInstructions,
            double sexual,
            @JsonKey(name: 'sexual/minors') double sexualMinors,
            double violence,
            @JsonKey(name: 'violence/graphic') double violenceGraphic)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesScores():
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            double hate,
            @JsonKey(name: 'hate/threatening') double hateThreatening,
            double harassment,
            @JsonKey(name: 'harassment/threatening')
            double harassmentThreatening,
            double illicit,
            @JsonKey(name: 'illicit/violent') double illicitViolent,
            @JsonKey(name: 'self-harm') double selfHarm,
            @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions')
            double selfHarmInstructions,
            double sexual,
            @JsonKey(name: 'sexual/minors') double sexualMinors,
            double violence,
            @JsonKey(name: 'violence/graphic') double violenceGraphic)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesScores() when $default != null:
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModerationCategoriesScores extends ModerationCategoriesScores {
  const _ModerationCategoriesScores(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      required this.illicit,
      @JsonKey(name: 'illicit/violent') required this.illicitViolent,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();
  factory _ModerationCategoriesScores.fromJson(Map<String, dynamic> json) =>
      _$ModerationCategoriesScoresFromJson(json);

  /// The score for the category 'hate'.
  @override
  final double hate;

  /// The score for the category 'hate/threatening'.
  @override
  @JsonKey(name: 'hate/threatening')
  final double hateThreatening;

  /// The score for the category 'harassment'.
  @override
  final double harassment;

  /// The score for the category 'harassment/threatening'.
  @override
  @JsonKey(name: 'harassment/threatening')
  final double harassmentThreatening;

  /// The score for the category 'illicit'.
  @override
  final double illicit;

  /// The score for the category 'illicit/violent'.
  @override
  @JsonKey(name: 'illicit/violent')
  final double illicitViolent;

  /// The score for the category 'self-harm'.
  @override
  @JsonKey(name: 'self-harm')
  final double selfHarm;

  /// The score for the category 'self-harm/intent'.
  @override
  @JsonKey(name: 'self-harm/intent')
  final double selfHarmIntent;

  /// The score for the category 'self-harm/instructions'.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final double selfHarmInstructions;

  /// The score for the category 'sexual'.
  @override
  final double sexual;

  /// The score for the category 'sexual/minors'.
  @override
  @JsonKey(name: 'sexual/minors')
  final double sexualMinors;

  /// The score for the category 'violence'.
  @override
  final double violence;

  /// The score for the category 'violence/graphic'.
  @override
  @JsonKey(name: 'violence/graphic')
  final double violenceGraphic;

  /// Create a copy of ModerationCategoriesScores
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModerationCategoriesScoresCopyWith<_ModerationCategoriesScores>
      get copyWith => __$ModerationCategoriesScoresCopyWithImpl<
          _ModerationCategoriesScores>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationCategoriesScoresToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModerationCategoriesScores &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.illicit, illicit) || other.illicit == illicit) &&
            (identical(other.illicitViolent, illicitViolent) ||
                other.illicitViolent == illicitViolent) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      illicit,
      illicitViolent,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @override
  String toString() {
    return 'ModerationCategoriesScores(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, illicit: $illicit, illicitViolent: $illicitViolent, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }
}

/// @nodoc
abstract mixin class _$ModerationCategoriesScoresCopyWith<$Res>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  factory _$ModerationCategoriesScoresCopyWith(
          _ModerationCategoriesScores value,
          $Res Function(_ModerationCategoriesScores) _then) =
      __$ModerationCategoriesScoresCopyWithImpl;
  @override
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      double illicit,
      @JsonKey(name: 'illicit/violent') double illicitViolent,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class __$ModerationCategoriesScoresCopyWithImpl<$Res>
    implements _$ModerationCategoriesScoresCopyWith<$Res> {
  __$ModerationCategoriesScoresCopyWithImpl(this._self, this._then);

  final _ModerationCategoriesScores _self;
  final $Res Function(_ModerationCategoriesScores) _then;

  /// Create a copy of ModerationCategoriesScores
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? illicit = null,
    Object? illicitViolent = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_ModerationCategoriesScores(
      hate: null == hate
          ? _self.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _self.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _self.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _self.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      illicit: null == illicit
          ? _self.illicit
          : illicit // ignore: cast_nullable_to_non_nullable
              as double,
      illicitViolent: null == illicitViolent
          ? _self.illicitViolent
          : illicitViolent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _self.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _self.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _self.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _self.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _self.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _self.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _self.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
mixin _$ModerationCategoriesAppliedInputTypes {
  /// The applied input type(s) for the category 'hate'.
  List<String> get hate;

  /// The applied input type(s) for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  List<String> get hateThreatening;

  /// The applied input type(s) for the category 'harassment'.
  List<String> get harassment;

  /// The applied input type(s) for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  List<String> get harassmentThreatening;

  /// The applied input type(s) for the category 'illicit'.
  List<String> get illicit;

  /// The applied input type(s) for the category 'illicit/violent'.
  @JsonKey(name: 'illicit/violent')
  List<String> get illicitViolent;

  /// The applied input type(s) for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  List<String> get selfHarm;

  /// The applied input type(s) for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  List<String> get selfHarmIntent;

  /// The applied input type(s) for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  List<String> get selfHarmInstructions;

  /// The applied input type(s) for the category 'sexual'.
  List<String> get sexual;

  /// The applied input type(s) for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  List<String> get sexualMinors;

  /// The applied input type(s) for the category 'violence'.
  List<String> get violence;

  /// The applied input type(s) for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  List<String> get violenceGraphic;

  /// Create a copy of ModerationCategoriesAppliedInputTypes
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationCategoriesAppliedInputTypesCopyWith<
          ModerationCategoriesAppliedInputTypes>
      get copyWith => _$ModerationCategoriesAppliedInputTypesCopyWithImpl<
              ModerationCategoriesAppliedInputTypes>(
          this as ModerationCategoriesAppliedInputTypes, _$identity);

  /// Serializes this ModerationCategoriesAppliedInputTypes to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationCategoriesAppliedInputTypes &&
            const DeepCollectionEquality().equals(other.hate, hate) &&
            const DeepCollectionEquality()
                .equals(other.hateThreatening, hateThreatening) &&
            const DeepCollectionEquality()
                .equals(other.harassment, harassment) &&
            const DeepCollectionEquality()
                .equals(other.harassmentThreatening, harassmentThreatening) &&
            const DeepCollectionEquality().equals(other.illicit, illicit) &&
            const DeepCollectionEquality()
                .equals(other.illicitViolent, illicitViolent) &&
            const DeepCollectionEquality().equals(other.selfHarm, selfHarm) &&
            const DeepCollectionEquality()
                .equals(other.selfHarmIntent, selfHarmIntent) &&
            const DeepCollectionEquality()
                .equals(other.selfHarmInstructions, selfHarmInstructions) &&
            const DeepCollectionEquality().equals(other.sexual, sexual) &&
            const DeepCollectionEquality()
                .equals(other.sexualMinors, sexualMinors) &&
            const DeepCollectionEquality().equals(other.violence, violence) &&
            const DeepCollectionEquality()
                .equals(other.violenceGraphic, violenceGraphic));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(hate),
      const DeepCollectionEquality().hash(hateThreatening),
      const DeepCollectionEquality().hash(harassment),
      const DeepCollectionEquality().hash(harassmentThreatening),
      const DeepCollectionEquality().hash(illicit),
      const DeepCollectionEquality().hash(illicitViolent),
      const DeepCollectionEquality().hash(selfHarm),
      const DeepCollectionEquality().hash(selfHarmIntent),
      const DeepCollectionEquality().hash(selfHarmInstructions),
      const DeepCollectionEquality().hash(sexual),
      const DeepCollectionEquality().hash(sexualMinors),
      const DeepCollectionEquality().hash(violence),
      const DeepCollectionEquality().hash(violenceGraphic));

  @override
  String toString() {
    return 'ModerationCategoriesAppliedInputTypes(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, illicit: $illicit, illicitViolent: $illicitViolent, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }
}

/// @nodoc
abstract mixin class $ModerationCategoriesAppliedInputTypesCopyWith<$Res> {
  factory $ModerationCategoriesAppliedInputTypesCopyWith(
          ModerationCategoriesAppliedInputTypes value,
          $Res Function(ModerationCategoriesAppliedInputTypes) _then) =
      _$ModerationCategoriesAppliedInputTypesCopyWithImpl;
  @useResult
  $Res call(
      {List<String> hate,
      @JsonKey(name: 'hate/threatening') List<String> hateThreatening,
      List<String> harassment,
      @JsonKey(name: 'harassment/threatening')
      List<String> harassmentThreatening,
      List<String> illicit,
      @JsonKey(name: 'illicit/violent') List<String> illicitViolent,
      @JsonKey(name: 'self-harm') List<String> selfHarm,
      @JsonKey(name: 'self-harm/intent') List<String> selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      List<String> selfHarmInstructions,
      List<String> sexual,
      @JsonKey(name: 'sexual/minors') List<String> sexualMinors,
      List<String> violence,
      @JsonKey(name: 'violence/graphic') List<String> violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesAppliedInputTypesCopyWithImpl<$Res>
    implements $ModerationCategoriesAppliedInputTypesCopyWith<$Res> {
  _$ModerationCategoriesAppliedInputTypesCopyWithImpl(this._self, this._then);

  final ModerationCategoriesAppliedInputTypes _self;
  final $Res Function(ModerationCategoriesAppliedInputTypes) _then;

  /// Create a copy of ModerationCategoriesAppliedInputTypes
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? illicit = null,
    Object? illicitViolent = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_self.copyWith(
      hate: null == hate
          ? _self.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as List<String>,
      hateThreatening: null == hateThreatening
          ? _self.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as List<String>,
      harassment: null == harassment
          ? _self.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as List<String>,
      harassmentThreatening: null == harassmentThreatening
          ? _self.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as List<String>,
      illicit: null == illicit
          ? _self.illicit
          : illicit // ignore: cast_nullable_to_non_nullable
              as List<String>,
      illicitViolent: null == illicitViolent
          ? _self.illicitViolent
          : illicitViolent // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selfHarm: null == selfHarm
          ? _self.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selfHarmIntent: null == selfHarmIntent
          ? _self.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selfHarmInstructions: null == selfHarmInstructions
          ? _self.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sexual: null == sexual
          ? _self.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sexualMinors: null == sexualMinors
          ? _self.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as List<String>,
      violence: null == violence
          ? _self.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as List<String>,
      violenceGraphic: null == violenceGraphic
          ? _self.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// Adds pattern-matching-related methods to [ModerationCategoriesAppliedInputTypes].
extension ModerationCategoriesAppliedInputTypesPatterns
    on ModerationCategoriesAppliedInputTypes {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModerationCategoriesAppliedInputTypes value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesAppliedInputTypes() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModerationCategoriesAppliedInputTypes value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesAppliedInputTypes():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModerationCategoriesAppliedInputTypes value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesAppliedInputTypes() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            List<String> hate,
            @JsonKey(name: 'hate/threatening') List<String> hateThreatening,
            List<String> harassment,
            @JsonKey(name: 'harassment/threatening')
            List<String> harassmentThreatening,
            List<String> illicit,
            @JsonKey(name: 'illicit/violent') List<String> illicitViolent,
            @JsonKey(name: 'self-harm') List<String> selfHarm,
            @JsonKey(name: 'self-harm/intent') List<String> selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions')
            List<String> selfHarmInstructions,
            List<String> sexual,
            @JsonKey(name: 'sexual/minors') List<String> sexualMinors,
            List<String> violence,
            @JsonKey(name: 'violence/graphic') List<String> violenceGraphic)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesAppliedInputTypes() when $default != null:
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            List<String> hate,
            @JsonKey(name: 'hate/threatening') List<String> hateThreatening,
            List<String> harassment,
            @JsonKey(name: 'harassment/threatening')
            List<String> harassmentThreatening,
            List<String> illicit,
            @JsonKey(name: 'illicit/violent') List<String> illicitViolent,
            @JsonKey(name: 'self-harm') List<String> selfHarm,
            @JsonKey(name: 'self-harm/intent') List<String> selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions')
            List<String> selfHarmInstructions,
            List<String> sexual,
            @JsonKey(name: 'sexual/minors') List<String> sexualMinors,
            List<String> violence,
            @JsonKey(name: 'violence/graphic') List<String> violenceGraphic)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesAppliedInputTypes():
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            List<String> hate,
            @JsonKey(name: 'hate/threatening') List<String> hateThreatening,
            List<String> harassment,
            @JsonKey(name: 'harassment/threatening')
            List<String> harassmentThreatening,
            List<String> illicit,
            @JsonKey(name: 'illicit/violent') List<String> illicitViolent,
            @JsonKey(name: 'self-harm') List<String> selfHarm,
            @JsonKey(name: 'self-harm/intent') List<String> selfHarmIntent,
            @JsonKey(name: 'self-harm/instructions')
            List<String> selfHarmInstructions,
            List<String> sexual,
            @JsonKey(name: 'sexual/minors') List<String> sexualMinors,
            List<String> violence,
            @JsonKey(name: 'violence/graphic') List<String> violenceGraphic)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationCategoriesAppliedInputTypes() when $default != null:
        return $default(
            _that.hate,
            _that.hateThreatening,
            _that.harassment,
            _that.harassmentThreatening,
            _that.illicit,
            _that.illicitViolent,
            _that.selfHarm,
            _that.selfHarmIntent,
            _that.selfHarmInstructions,
            _that.sexual,
            _that.sexualMinors,
            _that.violence,
            _that.violenceGraphic);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModerationCategoriesAppliedInputTypes
    extends ModerationCategoriesAppliedInputTypes {
  const _ModerationCategoriesAppliedInputTypes(
      {required final List<String> hate,
      @JsonKey(name: 'hate/threatening')
      required final List<String> hateThreatening,
      required final List<String> harassment,
      @JsonKey(name: 'harassment/threatening')
      required final List<String> harassmentThreatening,
      required final List<String> illicit,
      @JsonKey(name: 'illicit/violent')
      required final List<String> illicitViolent,
      @JsonKey(name: 'self-harm') required final List<String> selfHarm,
      @JsonKey(name: 'self-harm/intent')
      required final List<String> selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final List<String> selfHarmInstructions,
      required final List<String> sexual,
      @JsonKey(name: 'sexual/minors') required final List<String> sexualMinors,
      required final List<String> violence,
      @JsonKey(name: 'violence/graphic')
      required final List<String> violenceGraphic})
      : _hate = hate,
        _hateThreatening = hateThreatening,
        _harassment = harassment,
        _harassmentThreatening = harassmentThreatening,
        _illicit = illicit,
        _illicitViolent = illicitViolent,
        _selfHarm = selfHarm,
        _selfHarmIntent = selfHarmIntent,
        _selfHarmInstructions = selfHarmInstructions,
        _sexual = sexual,
        _sexualMinors = sexualMinors,
        _violence = violence,
        _violenceGraphic = violenceGraphic,
        super._();
  factory _ModerationCategoriesAppliedInputTypes.fromJson(
          Map<String, dynamic> json) =>
      _$ModerationCategoriesAppliedInputTypesFromJson(json);

  /// The applied input type(s) for the category 'hate'.
  final List<String> _hate;

  /// The applied input type(s) for the category 'hate'.
  @override
  List<String> get hate {
    if (_hate is EqualUnmodifiableListView) return _hate;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_hate);
  }

  /// The applied input type(s) for the category 'hate/threatening'.
  final List<String> _hateThreatening;

  /// The applied input type(s) for the category 'hate/threatening'.
  @override
  @JsonKey(name: 'hate/threatening')
  List<String> get hateThreatening {
    if (_hateThreatening is EqualUnmodifiableListView) return _hateThreatening;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_hateThreatening);
  }

  /// The applied input type(s) for the category 'harassment'.
  final List<String> _harassment;

  /// The applied input type(s) for the category 'harassment'.
  @override
  List<String> get harassment {
    if (_harassment is EqualUnmodifiableListView) return _harassment;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_harassment);
  }

  /// The applied input type(s) for the category 'harassment/threatening'.
  final List<String> _harassmentThreatening;

  /// The applied input type(s) for the category 'harassment/threatening'.
  @override
  @JsonKey(name: 'harassment/threatening')
  List<String> get harassmentThreatening {
    if (_harassmentThreatening is EqualUnmodifiableListView)
      return _harassmentThreatening;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_harassmentThreatening);
  }

  /// The applied input type(s) for the category 'illicit'.
  final List<String> _illicit;

  /// The applied input type(s) for the category 'illicit'.
  @override
  List<String> get illicit {
    if (_illicit is EqualUnmodifiableListView) return _illicit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_illicit);
  }

  /// The applied input type(s) for the category 'illicit/violent'.
  final List<String> _illicitViolent;

  /// The applied input type(s) for the category 'illicit/violent'.
  @override
  @JsonKey(name: 'illicit/violent')
  List<String> get illicitViolent {
    if (_illicitViolent is EqualUnmodifiableListView) return _illicitViolent;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_illicitViolent);
  }

  /// The applied input type(s) for the category 'self-harm'.
  final List<String> _selfHarm;

  /// The applied input type(s) for the category 'self-harm'.
  @override
  @JsonKey(name: 'self-harm')
  List<String> get selfHarm {
    if (_selfHarm is EqualUnmodifiableListView) return _selfHarm;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_selfHarm);
  }

  /// The applied input type(s) for the category 'self-harm/intent'.
  final List<String> _selfHarmIntent;

  /// The applied input type(s) for the category 'self-harm/intent'.
  @override
  @JsonKey(name: 'self-harm/intent')
  List<String> get selfHarmIntent {
    if (_selfHarmIntent is EqualUnmodifiableListView) return _selfHarmIntent;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_selfHarmIntent);
  }

  /// The applied input type(s) for the category 'self-harm/instructions'.
  final List<String> _selfHarmInstructions;

  /// The applied input type(s) for the category 'self-harm/instructions'.
  @override
  @JsonKey(name: 'self-harm/instructions')
  List<String> get selfHarmInstructions {
    if (_selfHarmInstructions is EqualUnmodifiableListView)
      return _selfHarmInstructions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_selfHarmInstructions);
  }

  /// The applied input type(s) for the category 'sexual'.
  final List<String> _sexual;

  /// The applied input type(s) for the category 'sexual'.
  @override
  List<String> get sexual {
    if (_sexual is EqualUnmodifiableListView) return _sexual;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sexual);
  }

  /// The applied input type(s) for the category 'sexual/minors'.
  final List<String> _sexualMinors;

  /// The applied input type(s) for the category 'sexual/minors'.
  @override
  @JsonKey(name: 'sexual/minors')
  List<String> get sexualMinors {
    if (_sexualMinors is EqualUnmodifiableListView) return _sexualMinors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sexualMinors);
  }

  /// The applied input type(s) for the category 'violence'.
  final List<String> _violence;

  /// The applied input type(s) for the category 'violence'.
  @override
  List<String> get violence {
    if (_violence is EqualUnmodifiableListView) return _violence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_violence);
  }

  /// The applied input type(s) for the category 'violence/graphic'.
  final List<String> _violenceGraphic;

  /// The applied input type(s) for the category 'violence/graphic'.
  @override
  @JsonKey(name: 'violence/graphic')
  List<String> get violenceGraphic {
    if (_violenceGraphic is EqualUnmodifiableListView) return _violenceGraphic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_violenceGraphic);
  }

  /// Create a copy of ModerationCategoriesAppliedInputTypes
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModerationCategoriesAppliedInputTypesCopyWith<
          _ModerationCategoriesAppliedInputTypes>
      get copyWith => __$ModerationCategoriesAppliedInputTypesCopyWithImpl<
          _ModerationCategoriesAppliedInputTypes>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationCategoriesAppliedInputTypesToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModerationCategoriesAppliedInputTypes &&
            const DeepCollectionEquality().equals(other._hate, _hate) &&
            const DeepCollectionEquality()
                .equals(other._hateThreatening, _hateThreatening) &&
            const DeepCollectionEquality()
                .equals(other._harassment, _harassment) &&
            const DeepCollectionEquality()
                .equals(other._harassmentThreatening, _harassmentThreatening) &&
            const DeepCollectionEquality().equals(other._illicit, _illicit) &&
            const DeepCollectionEquality()
                .equals(other._illicitViolent, _illicitViolent) &&
            const DeepCollectionEquality().equals(other._selfHarm, _selfHarm) &&
            const DeepCollectionEquality()
                .equals(other._selfHarmIntent, _selfHarmIntent) &&
            const DeepCollectionEquality()
                .equals(other._selfHarmInstructions, _selfHarmInstructions) &&
            const DeepCollectionEquality().equals(other._sexual, _sexual) &&
            const DeepCollectionEquality()
                .equals(other._sexualMinors, _sexualMinors) &&
            const DeepCollectionEquality().equals(other._violence, _violence) &&
            const DeepCollectionEquality()
                .equals(other._violenceGraphic, _violenceGraphic));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_hate),
      const DeepCollectionEquality().hash(_hateThreatening),
      const DeepCollectionEquality().hash(_harassment),
      const DeepCollectionEquality().hash(_harassmentThreatening),
      const DeepCollectionEquality().hash(_illicit),
      const DeepCollectionEquality().hash(_illicitViolent),
      const DeepCollectionEquality().hash(_selfHarm),
      const DeepCollectionEquality().hash(_selfHarmIntent),
      const DeepCollectionEquality().hash(_selfHarmInstructions),
      const DeepCollectionEquality().hash(_sexual),
      const DeepCollectionEquality().hash(_sexualMinors),
      const DeepCollectionEquality().hash(_violence),
      const DeepCollectionEquality().hash(_violenceGraphic));

  @override
  String toString() {
    return 'ModerationCategoriesAppliedInputTypes(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, illicit: $illicit, illicitViolent: $illicitViolent, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }
}

/// @nodoc
abstract mixin class _$ModerationCategoriesAppliedInputTypesCopyWith<$Res>
    implements $ModerationCategoriesAppliedInputTypesCopyWith<$Res> {
  factory _$ModerationCategoriesAppliedInputTypesCopyWith(
          _ModerationCategoriesAppliedInputTypes value,
          $Res Function(_ModerationCategoriesAppliedInputTypes) _then) =
      __$ModerationCategoriesAppliedInputTypesCopyWithImpl;
  @override
  @useResult
  $Res call(
      {List<String> hate,
      @JsonKey(name: 'hate/threatening') List<String> hateThreatening,
      List<String> harassment,
      @JsonKey(name: 'harassment/threatening')
      List<String> harassmentThreatening,
      List<String> illicit,
      @JsonKey(name: 'illicit/violent') List<String> illicitViolent,
      @JsonKey(name: 'self-harm') List<String> selfHarm,
      @JsonKey(name: 'self-harm/intent') List<String> selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      List<String> selfHarmInstructions,
      List<String> sexual,
      @JsonKey(name: 'sexual/minors') List<String> sexualMinors,
      List<String> violence,
      @JsonKey(name: 'violence/graphic') List<String> violenceGraphic});
}

/// @nodoc
class __$ModerationCategoriesAppliedInputTypesCopyWithImpl<$Res>
    implements _$ModerationCategoriesAppliedInputTypesCopyWith<$Res> {
  __$ModerationCategoriesAppliedInputTypesCopyWithImpl(this._self, this._then);

  final _ModerationCategoriesAppliedInputTypes _self;
  final $Res Function(_ModerationCategoriesAppliedInputTypes) _then;

  /// Create a copy of ModerationCategoriesAppliedInputTypes
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? illicit = null,
    Object? illicitViolent = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_ModerationCategoriesAppliedInputTypes(
      hate: null == hate
          ? _self._hate
          : hate // ignore: cast_nullable_to_non_nullable
              as List<String>,
      hateThreatening: null == hateThreatening
          ? _self._hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as List<String>,
      harassment: null == harassment
          ? _self._harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as List<String>,
      harassmentThreatening: null == harassmentThreatening
          ? _self._harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as List<String>,
      illicit: null == illicit
          ? _self._illicit
          : illicit // ignore: cast_nullable_to_non_nullable
              as List<String>,
      illicitViolent: null == illicitViolent
          ? _self._illicitViolent
          : illicitViolent // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selfHarm: null == selfHarm
          ? _self._selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selfHarmIntent: null == selfHarmIntent
          ? _self._selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selfHarmInstructions: null == selfHarmInstructions
          ? _self._selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sexual: null == sexual
          ? _self._sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sexualMinors: null == sexualMinors
          ? _self._sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as List<String>,
      violence: null == violence
          ? _self._violence
          : violence // ignore: cast_nullable_to_non_nullable
              as List<String>,
      violenceGraphic: null == violenceGraphic
          ? _self._violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
mixin _$AssistantObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `assistant`.
  AssistantObjectObject get object;

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The name of the assistant. The maximum length is 256 characters.
  String? get name;

  /// The description of the assistant. The maximum length is 512 characters.
  String? get description;

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  String get model;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  String? get instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  Map<String, dynamic>? get metadata;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_AssistantObjectResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  AssistantObjectResponseFormat? get responseFormat;

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantObjectCopyWith<AssistantObject> get copyWith =>
      _$AssistantObjectCopyWithImpl<AssistantObject>(
          this as AssistantObject, _$identity);

  /// Serializes this AssistantObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other.tools, tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      name,
      description,
      model,
      instructions,
      const DeepCollectionEquality().hash(tools),
      toolResources,
      const DeepCollectionEquality().hash(metadata),
      temperature,
      topP,
      responseFormat);

  @override
  String toString() {
    return 'AssistantObject(id: $id, object: $object, createdAt: $createdAt, name: $name, description: $description, model: $model, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class $AssistantObjectCopyWith<$Res> {
  factory $AssistantObjectCopyWith(
          AssistantObject value, $Res Function(AssistantObject) _then) =
      _$AssistantObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      AssistantObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      String? description,
      String model,
      String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_AssistantObjectResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      AssistantObjectResponseFormat? responseFormat});

  $ToolResourcesCopyWith<$Res>? get toolResources;
  $AssistantObjectResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$AssistantObjectCopyWithImpl<$Res>
    implements $AssistantObjectCopyWith<$Res> {
  _$AssistantObjectCopyWithImpl(this._self, this._then);

  final AssistantObject _self;
  final $Res Function(AssistantObject) _then;

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? model = null,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as AssistantObjectResponseFormat?,
    ));
  }

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantObjectResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $AssistantObjectResponseFormatCopyWith<$Res>(_self.responseFormat!,
        (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AssistantObject].
extension AssistantObjectPatterns on AssistantObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AssistantObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AssistantObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AssistantObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            AssistantObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            String? name,
            String? description,
            String model,
            String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_AssistantObjectResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            AssistantObjectResponseFormat? responseFormat)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.name,
            _that.description,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            AssistantObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            String? name,
            String? description,
            String model,
            String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_AssistantObjectResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            AssistantObjectResponseFormat? responseFormat)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantObject():
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.name,
            _that.description,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            AssistantObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            String? name,
            String? description,
            String model,
            String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_AssistantObjectResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            AssistantObjectResponseFormat? responseFormat)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.name,
            _that.description,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AssistantObject extends AssistantObject {
  const _AssistantObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.name,
      required this.description,
      required this.model,
      required this.instructions,
      required final List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      required final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @_AssistantObjectResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat})
      : _tools = tools,
        _metadata = metadata,
        super._();
  factory _AssistantObject.fromJson(Map<String, dynamic> json) =>
      _$AssistantObjectFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `assistant`.
  @override
  final AssistantObjectObject object;

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  final String? description;

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @override
  final String model;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @override
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  @override
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_AssistantObjectResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final AssistantObjectResponseFormat? responseFormat;

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AssistantObjectCopyWith<_AssistantObject> get copyWith =>
      __$AssistantObjectCopyWithImpl<_AssistantObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AssistantObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      name,
      description,
      model,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      responseFormat);

  @override
  String toString() {
    return 'AssistantObject(id: $id, object: $object, createdAt: $createdAt, name: $name, description: $description, model: $model, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class _$AssistantObjectCopyWith<$Res>
    implements $AssistantObjectCopyWith<$Res> {
  factory _$AssistantObjectCopyWith(
          _AssistantObject value, $Res Function(_AssistantObject) _then) =
      __$AssistantObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      AssistantObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      String? description,
      String model,
      String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_AssistantObjectResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      AssistantObjectResponseFormat? responseFormat});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $AssistantObjectResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$AssistantObjectCopyWithImpl<$Res>
    implements _$AssistantObjectCopyWith<$Res> {
  __$AssistantObjectCopyWithImpl(this._self, this._then);

  final _AssistantObject _self;
  final $Res Function(_AssistantObject) _then;

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? model = null,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_AssistantObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as AssistantObjectResponseFormat?,
    ));
  }

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of AssistantObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantObjectResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $AssistantObjectResponseFormatCopyWith<$Res>(_self.responseFormat!,
        (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

AssistantObjectResponseFormat _$AssistantObjectResponseFormatFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return AssistantObjectResponseFormatEnumeration.fromJson(json);
    case 'responseFormat':
      return AssistantObjectResponseFormatResponseFormat.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'AssistantObjectResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$AssistantObjectResponseFormat {
  Object get value;

  /// Serializes this AssistantObjectResponseFormat to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantObjectResponseFormat &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'AssistantObjectResponseFormat(value: $value)';
  }
}

/// @nodoc
class $AssistantObjectResponseFormatCopyWith<$Res> {
  $AssistantObjectResponseFormatCopyWith(AssistantObjectResponseFormat _,
      $Res Function(AssistantObjectResponseFormat) __);
}

/// Adds pattern-matching-related methods to [AssistantObjectResponseFormat].
extension AssistantObjectResponseFormatPatterns
    on AssistantObjectResponseFormat {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantObjectResponseFormatEnumeration value)? mode,
    TResult Function(AssistantObjectResponseFormatResponseFormat value)?
        responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AssistantObjectResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case AssistantObjectResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantObjectResponseFormatEnumeration value)
        mode,
    required TResult Function(AssistantObjectResponseFormatResponseFormat value)
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantObjectResponseFormatEnumeration():
        return mode(_that);
      case AssistantObjectResponseFormatResponseFormat():
        return responseFormat(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantObjectResponseFormatEnumeration value)? mode,
    TResult? Function(AssistantObjectResponseFormatResponseFormat value)?
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantObjectResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case AssistantObjectResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantResponseFormatMode value)? mode,
    TResult Function(ResponseFormat value)? responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AssistantObjectResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case AssistantObjectResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantResponseFormatMode value) mode,
    required TResult Function(ResponseFormat value) responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantObjectResponseFormatEnumeration():
        return mode(_that.value);
      case AssistantObjectResponseFormatResponseFormat():
        return responseFormat(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantResponseFormatMode value)? mode,
    TResult? Function(ResponseFormat value)? responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantObjectResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case AssistantObjectResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class AssistantObjectResponseFormatEnumeration
    extends AssistantObjectResponseFormat {
  const AssistantObjectResponseFormatEnumeration(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory AssistantObjectResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$AssistantObjectResponseFormatEnumerationFromJson(json);

  @override
  final AssistantResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of AssistantObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantObjectResponseFormatEnumerationCopyWith<
          AssistantObjectResponseFormatEnumeration>
      get copyWith => _$AssistantObjectResponseFormatEnumerationCopyWithImpl<
          AssistantObjectResponseFormatEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantObjectResponseFormatEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantObjectResponseFormatEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'AssistantObjectResponseFormat.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $AssistantObjectResponseFormatEnumerationCopyWith<$Res>
    implements $AssistantObjectResponseFormatCopyWith<$Res> {
  factory $AssistantObjectResponseFormatEnumerationCopyWith(
          AssistantObjectResponseFormatEnumeration value,
          $Res Function(AssistantObjectResponseFormatEnumeration) _then) =
      _$AssistantObjectResponseFormatEnumerationCopyWithImpl;
  @useResult
  $Res call({AssistantResponseFormatMode value});
}

/// @nodoc
class _$AssistantObjectResponseFormatEnumerationCopyWithImpl<$Res>
    implements $AssistantObjectResponseFormatEnumerationCopyWith<$Res> {
  _$AssistantObjectResponseFormatEnumerationCopyWithImpl(
      this._self, this._then);

  final AssistantObjectResponseFormatEnumeration _self;
  final $Res Function(AssistantObjectResponseFormatEnumeration) _then;

  /// Create a copy of AssistantObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(AssistantObjectResponseFormatEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class AssistantObjectResponseFormatResponseFormat
    extends AssistantObjectResponseFormat {
  const AssistantObjectResponseFormatResponseFormat(this.value,
      {final String? $type})
      : $type = $type ?? 'responseFormat',
        super._();
  factory AssistantObjectResponseFormatResponseFormat.fromJson(
          Map<String, dynamic> json) =>
      _$AssistantObjectResponseFormatResponseFormatFromJson(json);

  @override
  final ResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of AssistantObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantObjectResponseFormatResponseFormatCopyWith<
          AssistantObjectResponseFormatResponseFormat>
      get copyWith => _$AssistantObjectResponseFormatResponseFormatCopyWithImpl<
          AssistantObjectResponseFormatResponseFormat>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantObjectResponseFormatResponseFormatToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantObjectResponseFormatResponseFormat &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'AssistantObjectResponseFormat.responseFormat(value: $value)';
  }
}

/// @nodoc
abstract mixin class $AssistantObjectResponseFormatResponseFormatCopyWith<$Res>
    implements $AssistantObjectResponseFormatCopyWith<$Res> {
  factory $AssistantObjectResponseFormatResponseFormatCopyWith(
          AssistantObjectResponseFormatResponseFormat value,
          $Res Function(AssistantObjectResponseFormatResponseFormat) _then) =
      _$AssistantObjectResponseFormatResponseFormatCopyWithImpl;
  @useResult
  $Res call({ResponseFormat value});

  $ResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class _$AssistantObjectResponseFormatResponseFormatCopyWithImpl<$Res>
    implements $AssistantObjectResponseFormatResponseFormatCopyWith<$Res> {
  _$AssistantObjectResponseFormatResponseFormatCopyWithImpl(
      this._self, this._then);

  final AssistantObjectResponseFormatResponseFormat _self;
  final $Res Function(AssistantObjectResponseFormatResponseFormat) _then;

  /// Create a copy of AssistantObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(AssistantObjectResponseFormatResponseFormat(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ResponseFormat,
    ));
  }

  /// Create a copy of AssistantObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res> get value {
    return $ResponseFormatCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

/// @nodoc
mixin _$CreateAssistantRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @_AssistantModelConverter()
  AssistantModel get model;

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateAssistantRequestResponseFormat? get responseFormat;

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateAssistantRequestCopyWith<CreateAssistantRequest> get copyWith =>
      _$CreateAssistantRequestCopyWithImpl<CreateAssistantRequest>(
          this as CreateAssistantRequest, _$identity);

  /// Serializes this CreateAssistantRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateAssistantRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other.tools, tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(tools),
      toolResources,
      const DeepCollectionEquality().hash(metadata),
      temperature,
      topP,
      responseFormat);

  @override
  String toString() {
    return 'CreateAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class $CreateAssistantRequestCopyWith<$Res> {
  factory $CreateAssistantRequestCopyWith(CreateAssistantRequest value,
          $Res Function(CreateAssistantRequest) _then) =
      _$CreateAssistantRequestCopyWithImpl;
  @useResult
  $Res call(
      {@_AssistantModelConverter() AssistantModel model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_CreateAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateAssistantRequestResponseFormat? responseFormat});

  $AssistantModelCopyWith<$Res> get model;
  $ToolResourcesCopyWith<$Res>? get toolResources;
  $CreateAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$CreateAssistantRequestCopyWithImpl<$Res>
    implements $CreateAssistantRequestCopyWith<$Res> {
  _$CreateAssistantRequestCopyWithImpl(this._self, this._then);

  final CreateAssistantRequest _self;
  final $Res Function(CreateAssistantRequest) _then;

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_self.copyWith(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as AssistantModel,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateAssistantRequestResponseFormat?,
    ));
  }

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantModelCopyWith<$Res> get model {
    return $AssistantModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $CreateAssistantRequestResponseFormatCopyWith<$Res>(
        _self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateAssistantRequest].
extension CreateAssistantRequestPatterns on CreateAssistantRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateAssistantRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateAssistantRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateAssistantRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateAssistantRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateAssistantRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateAssistantRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @_AssistantModelConverter() AssistantModel model,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_CreateAssistantRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateAssistantRequestResponseFormat? responseFormat)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateAssistantRequest() when $default != null:
        return $default(
            _that.model,
            _that.name,
            _that.description,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @_AssistantModelConverter() AssistantModel model,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_CreateAssistantRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateAssistantRequestResponseFormat? responseFormat)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateAssistantRequest():
        return $default(
            _that.model,
            _that.name,
            _that.description,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @_AssistantModelConverter() AssistantModel model,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_CreateAssistantRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateAssistantRequestResponseFormat? responseFormat)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateAssistantRequest() when $default != null:
        return $default(
            _that.model,
            _that.name,
            _that.description,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateAssistantRequest extends CreateAssistantRequest {
  const _CreateAssistantRequest(
      {@_AssistantModelConverter() required this.model,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) this.instructions,
      final List<AssistantTools> tools = const [],
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @_CreateAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat})
      : _tools = tools,
        _metadata = metadata,
        super._();
  factory _CreateAssistantRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateAssistantRequestFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @override
  @_AssistantModelConverter()
  final AssistantModel model;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  @override
  @JsonKey()
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_CreateAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final CreateAssistantRequestResponseFormat? responseFormat;

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateAssistantRequestCopyWith<_CreateAssistantRequest> get copyWith =>
      __$CreateAssistantRequestCopyWithImpl<_CreateAssistantRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateAssistantRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateAssistantRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      responseFormat);

  @override
  String toString() {
    return 'CreateAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class _$CreateAssistantRequestCopyWith<$Res>
    implements $CreateAssistantRequestCopyWith<$Res> {
  factory _$CreateAssistantRequestCopyWith(_CreateAssistantRequest value,
          $Res Function(_CreateAssistantRequest) _then) =
      __$CreateAssistantRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@_AssistantModelConverter() AssistantModel model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_CreateAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateAssistantRequestResponseFormat? responseFormat});

  @override
  $AssistantModelCopyWith<$Res> get model;
  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $CreateAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$CreateAssistantRequestCopyWithImpl<$Res>
    implements _$CreateAssistantRequestCopyWith<$Res> {
  __$CreateAssistantRequestCopyWithImpl(this._self, this._then);

  final _CreateAssistantRequest _self;
  final $Res Function(_CreateAssistantRequest) _then;

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? model = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_CreateAssistantRequest(
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as AssistantModel,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateAssistantRequestResponseFormat?,
    ));
  }

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantModelCopyWith<$Res> get model {
    return $AssistantModelCopyWith<$Res>(_self.model, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of CreateAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $CreateAssistantRequestResponseFormatCopyWith<$Res>(
        _self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

AssistantModel _$AssistantModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return AssistantModelEnumeration.fromJson(json);
    case 'modelId':
      return AssistantModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'AssistantModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$AssistantModel {
  Object get value;

  /// Serializes this AssistantModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'AssistantModel(value: $value)';
  }
}

/// @nodoc
class $AssistantModelCopyWith<$Res> {
  $AssistantModelCopyWith(AssistantModel _, $Res Function(AssistantModel) __);
}

/// Adds pattern-matching-related methods to [AssistantModel].
extension AssistantModelPatterns on AssistantModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantModelEnumeration value)? model,
    TResult Function(AssistantModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AssistantModelEnumeration() when model != null:
        return model(_that);
      case AssistantModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantModelEnumeration value) model,
    required TResult Function(AssistantModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantModelEnumeration():
        return model(_that);
      case AssistantModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantModelEnumeration value)? model,
    TResult? Function(AssistantModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantModelEnumeration() when model != null:
        return model(_that);
      case AssistantModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AssistantModelEnumeration() when model != null:
        return model(_that.value);
      case AssistantModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantModelEnumeration():
        return model(_that.value);
      case AssistantModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantModelEnumeration() when model != null:
        return model(_that.value);
      case AssistantModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class AssistantModelEnumeration extends AssistantModel {
  const AssistantModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory AssistantModelEnumeration.fromJson(Map<String, dynamic> json) =>
      _$AssistantModelEnumerationFromJson(json);

  @override
  final AssistantModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of AssistantModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantModelEnumerationCopyWith<AssistantModelEnumeration> get copyWith =>
      _$AssistantModelEnumerationCopyWithImpl<AssistantModelEnumeration>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'AssistantModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $AssistantModelEnumerationCopyWith<$Res>
    implements $AssistantModelCopyWith<$Res> {
  factory $AssistantModelEnumerationCopyWith(AssistantModelEnumeration value,
          $Res Function(AssistantModelEnumeration) _then) =
      _$AssistantModelEnumerationCopyWithImpl;
  @useResult
  $Res call({AssistantModels value});
}

/// @nodoc
class _$AssistantModelEnumerationCopyWithImpl<$Res>
    implements $AssistantModelEnumerationCopyWith<$Res> {
  _$AssistantModelEnumerationCopyWithImpl(this._self, this._then);

  final AssistantModelEnumeration _self;
  final $Res Function(AssistantModelEnumeration) _then;

  /// Create a copy of AssistantModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(AssistantModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class AssistantModelString extends AssistantModel {
  const AssistantModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory AssistantModelString.fromJson(Map<String, dynamic> json) =>
      _$AssistantModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of AssistantModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantModelStringCopyWith<AssistantModelString> get copyWith =>
      _$AssistantModelStringCopyWithImpl<AssistantModelString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'AssistantModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $AssistantModelStringCopyWith<$Res>
    implements $AssistantModelCopyWith<$Res> {
  factory $AssistantModelStringCopyWith(AssistantModelString value,
          $Res Function(AssistantModelString) _then) =
      _$AssistantModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$AssistantModelStringCopyWithImpl<$Res>
    implements $AssistantModelStringCopyWith<$Res> {
  _$AssistantModelStringCopyWithImpl(this._self, this._then);

  final AssistantModelString _self;
  final $Res Function(AssistantModelString) _then;

  /// Create a copy of AssistantModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(AssistantModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

CreateAssistantRequestResponseFormat
    _$CreateAssistantRequestResponseFormatFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateAssistantRequestResponseFormatEnumeration.fromJson(json);
    case 'responseFormat':
      return CreateAssistantRequestResponseFormatResponseFormat.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateAssistantRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateAssistantRequestResponseFormat {
  Object get value;

  /// Serializes this CreateAssistantRequestResponseFormat to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateAssistantRequestResponseFormat &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateAssistantRequestResponseFormat(value: $value)';
  }
}

/// @nodoc
class $CreateAssistantRequestResponseFormatCopyWith<$Res> {
  $CreateAssistantRequestResponseFormatCopyWith(
      CreateAssistantRequestResponseFormat _,
      $Res Function(CreateAssistantRequestResponseFormat) __);
}

/// Adds pattern-matching-related methods to [CreateAssistantRequestResponseFormat].
extension CreateAssistantRequestResponseFormatPatterns
    on CreateAssistantRequestResponseFormat {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(CreateAssistantRequestResponseFormatResponseFormat value)?
        responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case CreateAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateAssistantRequestResponseFormatResponseFormat value)
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateAssistantRequestResponseFormatEnumeration():
        return mode(_that);
      case CreateAssistantRequestResponseFormatResponseFormat():
        return responseFormat(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(CreateAssistantRequestResponseFormatResponseFormat value)?
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case CreateAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateAssistantResponseFormatMode value)? mode,
    TResult Function(ResponseFormat value)? responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case CreateAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateAssistantResponseFormatMode value) mode,
    required TResult Function(ResponseFormat value) responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateAssistantRequestResponseFormatEnumeration():
        return mode(_that.value);
      case CreateAssistantRequestResponseFormatResponseFormat():
        return responseFormat(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantResponseFormatMode value)? mode,
    TResult? Function(ResponseFormat value)? responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case CreateAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateAssistantRequestResponseFormatEnumeration
    extends CreateAssistantRequestResponseFormat {
  const CreateAssistantRequestResponseFormatEnumeration(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory CreateAssistantRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$CreateAssistantRequestResponseFormatEnumerationFromJson(json);

  @override
  final CreateAssistantResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateAssistantRequestResponseFormatEnumerationCopyWith<
          CreateAssistantRequestResponseFormatEnumeration>
      get copyWith =>
          _$CreateAssistantRequestResponseFormatEnumerationCopyWithImpl<
                  CreateAssistantRequestResponseFormatEnumeration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateAssistantRequestResponseFormatEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateAssistantRequestResponseFormatEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateAssistantRequestResponseFormat.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateAssistantRequestResponseFormatEnumerationCopyWith<
    $Res> implements $CreateAssistantRequestResponseFormatCopyWith<$Res> {
  factory $CreateAssistantRequestResponseFormatEnumerationCopyWith(
          CreateAssistantRequestResponseFormatEnumeration value,
          $Res Function(CreateAssistantRequestResponseFormatEnumeration)
              _then) =
      _$CreateAssistantRequestResponseFormatEnumerationCopyWithImpl;
  @useResult
  $Res call({CreateAssistantResponseFormatMode value});
}

/// @nodoc
class _$CreateAssistantRequestResponseFormatEnumerationCopyWithImpl<$Res>
    implements $CreateAssistantRequestResponseFormatEnumerationCopyWith<$Res> {
  _$CreateAssistantRequestResponseFormatEnumerationCopyWithImpl(
      this._self, this._then);

  final CreateAssistantRequestResponseFormatEnumeration _self;
  final $Res Function(CreateAssistantRequestResponseFormatEnumeration) _then;

  /// Create a copy of CreateAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateAssistantRequestResponseFormatEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateAssistantResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateAssistantRequestResponseFormatResponseFormat
    extends CreateAssistantRequestResponseFormat {
  const CreateAssistantRequestResponseFormatResponseFormat(this.value,
      {final String? $type})
      : $type = $type ?? 'responseFormat',
        super._();
  factory CreateAssistantRequestResponseFormatResponseFormat.fromJson(
          Map<String, dynamic> json) =>
      _$CreateAssistantRequestResponseFormatResponseFormatFromJson(json);

  @override
  final ResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateAssistantRequestResponseFormatResponseFormatCopyWith<
          CreateAssistantRequestResponseFormatResponseFormat>
      get copyWith =>
          _$CreateAssistantRequestResponseFormatResponseFormatCopyWithImpl<
                  CreateAssistantRequestResponseFormatResponseFormat>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateAssistantRequestResponseFormatResponseFormatToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateAssistantRequestResponseFormatResponseFormat &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateAssistantRequestResponseFormat.responseFormat(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateAssistantRequestResponseFormatResponseFormatCopyWith<
    $Res> implements $CreateAssistantRequestResponseFormatCopyWith<$Res> {
  factory $CreateAssistantRequestResponseFormatResponseFormatCopyWith(
          CreateAssistantRequestResponseFormatResponseFormat value,
          $Res Function(CreateAssistantRequestResponseFormatResponseFormat)
              _then) =
      _$CreateAssistantRequestResponseFormatResponseFormatCopyWithImpl;
  @useResult
  $Res call({ResponseFormat value});

  $ResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class _$CreateAssistantRequestResponseFormatResponseFormatCopyWithImpl<$Res>
    implements
        $CreateAssistantRequestResponseFormatResponseFormatCopyWith<$Res> {
  _$CreateAssistantRequestResponseFormatResponseFormatCopyWithImpl(
      this._self, this._then);

  final CreateAssistantRequestResponseFormatResponseFormat _self;
  final $Res Function(CreateAssistantRequestResponseFormatResponseFormat) _then;

  /// Create a copy of CreateAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateAssistantRequestResponseFormatResponseFormat(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ResponseFormat,
    ));
  }

  /// Create a copy of CreateAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res> get value {
    return $ResponseFormatCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

/// @nodoc
mixin _$ModifyAssistantRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @JsonKey(includeIfNull: false)
  String? get model;

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_ModifyAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  ModifyAssistantRequestResponseFormat? get responseFormat;

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModifyAssistantRequestCopyWith<ModifyAssistantRequest> get copyWith =>
      _$ModifyAssistantRequestCopyWithImpl<ModifyAssistantRequest>(
          this as ModifyAssistantRequest, _$identity);

  /// Serializes this ModifyAssistantRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModifyAssistantRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other.tools, tools) &&
            const DeepCollectionEquality().equals(other.fileIds, fileIds) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(tools),
      const DeepCollectionEquality().hash(fileIds),
      toolResources,
      const DeepCollectionEquality().hash(metadata),
      temperature,
      topP,
      responseFormat);

  @override
  String toString() {
    return 'ModifyAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, fileIds: $fileIds, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class $ModifyAssistantRequestCopyWith<$Res> {
  factory $ModifyAssistantRequestCopyWith(ModifyAssistantRequest value,
          $Res Function(ModifyAssistantRequest) _then) =
      _$ModifyAssistantRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_ModifyAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      ModifyAssistantRequestResponseFormat? responseFormat});

  $ToolResourcesCopyWith<$Res>? get toolResources;
  $ModifyAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$ModifyAssistantRequestCopyWithImpl<$Res>
    implements $ModifyAssistantRequestCopyWith<$Res> {
  _$ModifyAssistantRequestCopyWithImpl(this._self, this._then);

  final ModifyAssistantRequest _self;
  final $Res Function(ModifyAssistantRequest) _then;

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_self.copyWith(
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _self.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ModifyAssistantRequestResponseFormat?,
    ));
  }

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModifyAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $ModifyAssistantRequestResponseFormatCopyWith<$Res>(
        _self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ModifyAssistantRequest].
extension ModifyAssistantRequestPatterns on ModifyAssistantRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModifyAssistantRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyAssistantRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModifyAssistantRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyAssistantRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModifyAssistantRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyAssistantRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? model,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'file_ids') List<String> fileIds,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_ModifyAssistantRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            ModifyAssistantRequestResponseFormat? responseFormat)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyAssistantRequest() when $default != null:
        return $default(
            _that.model,
            _that.name,
            _that.description,
            _that.instructions,
            _that.tools,
            _that.fileIds,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? model,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'file_ids') List<String> fileIds,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_ModifyAssistantRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            ModifyAssistantRequestResponseFormat? responseFormat)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyAssistantRequest():
        return $default(
            _that.model,
            _that.name,
            _that.description,
            _that.instructions,
            _that.tools,
            _that.fileIds,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? model,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? description,
            @JsonKey(includeIfNull: false) String? instructions,
            List<AssistantTools> tools,
            @JsonKey(name: 'file_ids') List<String> fileIds,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @_ModifyAssistantRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            ModifyAssistantRequestResponseFormat? responseFormat)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyAssistantRequest() when $default != null:
        return $default(
            _that.model,
            _that.name,
            _that.description,
            _that.instructions,
            _that.tools,
            _that.fileIds,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.responseFormat);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModifyAssistantRequest extends ModifyAssistantRequest {
  const _ModifyAssistantRequest(
      {@JsonKey(includeIfNull: false) this.model,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) this.instructions,
      final List<AssistantTools> tools = const [],
      @JsonKey(name: 'file_ids') final List<String> fileIds = const [],
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @_ModifyAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat})
      : _tools = tools,
        _fileIds = fileIds,
        _metadata = metadata,
        super._();
  factory _ModifyAssistantRequest.fromJson(Map<String, dynamic> json) =>
      _$ModifyAssistantRequestFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list)
  /// API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for
  /// descriptions of them.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of
  /// types `code_interpreter`, `file_search`, or `function`.
  @override
  @JsonKey()
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  final List<String> _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_ModifyAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final ModifyAssistantRequestResponseFormat? responseFormat;

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModifyAssistantRequestCopyWith<_ModifyAssistantRequest> get copyWith =>
      __$ModifyAssistantRequestCopyWithImpl<_ModifyAssistantRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModifyAssistantRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModifyAssistantRequest &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_fileIds),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      responseFormat);

  @override
  String toString() {
    return 'ModifyAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, fileIds: $fileIds, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class _$ModifyAssistantRequestCopyWith<$Res>
    implements $ModifyAssistantRequestCopyWith<$Res> {
  factory _$ModifyAssistantRequestCopyWith(_ModifyAssistantRequest value,
          $Res Function(_ModifyAssistantRequest) _then) =
      __$ModifyAssistantRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_ModifyAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      ModifyAssistantRequestResponseFormat? responseFormat});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $ModifyAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$ModifyAssistantRequestCopyWithImpl<$Res>
    implements _$ModifyAssistantRequestCopyWith<$Res> {
  __$ModifyAssistantRequestCopyWithImpl(this._self, this._then);

  final _ModifyAssistantRequest _self;
  final $Res Function(_ModifyAssistantRequest) _then;

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? model = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_ModifyAssistantRequest(
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _self.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _self._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ModifyAssistantRequestResponseFormat?,
    ));
  }

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of ModifyAssistantRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModifyAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $ModifyAssistantRequestResponseFormatCopyWith<$Res>(
        _self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

ModifyAssistantRequestResponseFormat
    _$ModifyAssistantRequestResponseFormatFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ModifyAssistantRequestResponseFormatEnumeration.fromJson(json);
    case 'responseFormat':
      return ModifyAssistantRequestResponseFormatResponseFormat.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ModifyAssistantRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModifyAssistantRequestResponseFormat {
  Object get value;

  /// Serializes this ModifyAssistantRequestResponseFormat to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModifyAssistantRequestResponseFormat &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ModifyAssistantRequestResponseFormat(value: $value)';
  }
}

/// @nodoc
class $ModifyAssistantRequestResponseFormatCopyWith<$Res> {
  $ModifyAssistantRequestResponseFormatCopyWith(
      ModifyAssistantRequestResponseFormat _,
      $Res Function(ModifyAssistantRequestResponseFormat) __);
}

/// Adds pattern-matching-related methods to [ModifyAssistantRequestResponseFormat].
extension ModifyAssistantRequestResponseFormatPatterns
    on ModifyAssistantRequestResponseFormat {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(ModifyAssistantRequestResponseFormatResponseFormat value)?
        responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModifyAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case ModifyAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ModifyAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            ModifyAssistantRequestResponseFormatResponseFormat value)
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case ModifyAssistantRequestResponseFormatEnumeration():
        return mode(_that);
      case ModifyAssistantRequestResponseFormatResponseFormat():
        return responseFormat(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(ModifyAssistantRequestResponseFormatResponseFormat value)?
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case ModifyAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case ModifyAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult Function(ResponseFormat value)? responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModifyAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case ModifyAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModifyAssistantResponseFormatMode value) mode,
    required TResult Function(ResponseFormat value) responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case ModifyAssistantRequestResponseFormatEnumeration():
        return mode(_that.value);
      case ModifyAssistantRequestResponseFormatResponseFormat():
        return responseFormat(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult? Function(ResponseFormat value)? responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case ModifyAssistantRequestResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case ModifyAssistantRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ModifyAssistantRequestResponseFormatEnumeration
    extends ModifyAssistantRequestResponseFormat {
  const ModifyAssistantRequestResponseFormatEnumeration(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory ModifyAssistantRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$ModifyAssistantRequestResponseFormatEnumerationFromJson(json);

  @override
  final ModifyAssistantResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ModifyAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModifyAssistantRequestResponseFormatEnumerationCopyWith<
          ModifyAssistantRequestResponseFormatEnumeration>
      get copyWith =>
          _$ModifyAssistantRequestResponseFormatEnumerationCopyWithImpl<
                  ModifyAssistantRequestResponseFormatEnumeration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModifyAssistantRequestResponseFormatEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModifyAssistantRequestResponseFormatEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ModifyAssistantRequestResponseFormat.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ModifyAssistantRequestResponseFormatEnumerationCopyWith<
    $Res> implements $ModifyAssistantRequestResponseFormatCopyWith<$Res> {
  factory $ModifyAssistantRequestResponseFormatEnumerationCopyWith(
          ModifyAssistantRequestResponseFormatEnumeration value,
          $Res Function(ModifyAssistantRequestResponseFormatEnumeration)
              _then) =
      _$ModifyAssistantRequestResponseFormatEnumerationCopyWithImpl;
  @useResult
  $Res call({ModifyAssistantResponseFormatMode value});
}

/// @nodoc
class _$ModifyAssistantRequestResponseFormatEnumerationCopyWithImpl<$Res>
    implements $ModifyAssistantRequestResponseFormatEnumerationCopyWith<$Res> {
  _$ModifyAssistantRequestResponseFormatEnumerationCopyWithImpl(
      this._self, this._then);

  final ModifyAssistantRequestResponseFormatEnumeration _self;
  final $Res Function(ModifyAssistantRequestResponseFormatEnumeration) _then;

  /// Create a copy of ModifyAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ModifyAssistantRequestResponseFormatEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ModifyAssistantResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ModifyAssistantRequestResponseFormatResponseFormat
    extends ModifyAssistantRequestResponseFormat {
  const ModifyAssistantRequestResponseFormatResponseFormat(this.value,
      {final String? $type})
      : $type = $type ?? 'responseFormat',
        super._();
  factory ModifyAssistantRequestResponseFormatResponseFormat.fromJson(
          Map<String, dynamic> json) =>
      _$ModifyAssistantRequestResponseFormatResponseFormatFromJson(json);

  @override
  final ResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ModifyAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModifyAssistantRequestResponseFormatResponseFormatCopyWith<
          ModifyAssistantRequestResponseFormatResponseFormat>
      get copyWith =>
          _$ModifyAssistantRequestResponseFormatResponseFormatCopyWithImpl<
                  ModifyAssistantRequestResponseFormatResponseFormat>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModifyAssistantRequestResponseFormatResponseFormatToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModifyAssistantRequestResponseFormatResponseFormat &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ModifyAssistantRequestResponseFormat.responseFormat(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ModifyAssistantRequestResponseFormatResponseFormatCopyWith<
    $Res> implements $ModifyAssistantRequestResponseFormatCopyWith<$Res> {
  factory $ModifyAssistantRequestResponseFormatResponseFormatCopyWith(
          ModifyAssistantRequestResponseFormatResponseFormat value,
          $Res Function(ModifyAssistantRequestResponseFormatResponseFormat)
              _then) =
      _$ModifyAssistantRequestResponseFormatResponseFormatCopyWithImpl;
  @useResult
  $Res call({ResponseFormat value});

  $ResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class _$ModifyAssistantRequestResponseFormatResponseFormatCopyWithImpl<$Res>
    implements
        $ModifyAssistantRequestResponseFormatResponseFormatCopyWith<$Res> {
  _$ModifyAssistantRequestResponseFormatResponseFormatCopyWithImpl(
      this._self, this._then);

  final ModifyAssistantRequestResponseFormatResponseFormat _self;
  final $Res Function(ModifyAssistantRequestResponseFormatResponseFormat) _then;

  /// Create a copy of ModifyAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ModifyAssistantRequestResponseFormatResponseFormat(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ResponseFormat,
    ));
  }

  /// Create a copy of ModifyAssistantRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res> get value {
    return $ResponseFormatCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

/// @nodoc
mixin _$DeleteAssistantResponse {
  /// The assistant identifier.
  String get id;

  /// Whether the assistant was deleted.
  bool get deleted;

  /// The object type, which is always `assistant.deleted`.
  DeleteAssistantResponseObject get object;

  /// Create a copy of DeleteAssistantResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DeleteAssistantResponseCopyWith<DeleteAssistantResponse> get copyWith =>
      _$DeleteAssistantResponseCopyWithImpl<DeleteAssistantResponse>(
          this as DeleteAssistantResponse, _$identity);

  /// Serializes this DeleteAssistantResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteAssistantResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteAssistantResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class $DeleteAssistantResponseCopyWith<$Res> {
  factory $DeleteAssistantResponseCopyWith(DeleteAssistantResponse value,
          $Res Function(DeleteAssistantResponse) _then) =
      _$DeleteAssistantResponseCopyWithImpl;
  @useResult
  $Res call({String id, bool deleted, DeleteAssistantResponseObject object});
}

/// @nodoc
class _$DeleteAssistantResponseCopyWithImpl<$Res>
    implements $DeleteAssistantResponseCopyWith<$Res> {
  _$DeleteAssistantResponseCopyWithImpl(this._self, this._then);

  final DeleteAssistantResponse _self;
  final $Res Function(DeleteAssistantResponse) _then;

  /// Create a copy of DeleteAssistantResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantResponseObject,
    ));
  }
}

/// Adds pattern-matching-related methods to [DeleteAssistantResponse].
extension DeleteAssistantResponsePatterns on DeleteAssistantResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DeleteAssistantResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteAssistantResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DeleteAssistantResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteAssistantResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DeleteAssistantResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteAssistantResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id, bool deleted, DeleteAssistantResponseObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteAssistantResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id, bool deleted, DeleteAssistantResponseObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteAssistantResponse():
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id, bool deleted, DeleteAssistantResponseObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteAssistantResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DeleteAssistantResponse extends DeleteAssistantResponse {
  const _DeleteAssistantResponse(
      {required this.id, required this.deleted, required this.object})
      : super._();
  factory _DeleteAssistantResponse.fromJson(Map<String, dynamic> json) =>
      _$DeleteAssistantResponseFromJson(json);

  /// The assistant identifier.
  @override
  final String id;

  /// Whether the assistant was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `assistant.deleted`.
  @override
  final DeleteAssistantResponseObject object;

  /// Create a copy of DeleteAssistantResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DeleteAssistantResponseCopyWith<_DeleteAssistantResponse> get copyWith =>
      __$DeleteAssistantResponseCopyWithImpl<_DeleteAssistantResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DeleteAssistantResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DeleteAssistantResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteAssistantResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$DeleteAssistantResponseCopyWith<$Res>
    implements $DeleteAssistantResponseCopyWith<$Res> {
  factory _$DeleteAssistantResponseCopyWith(_DeleteAssistantResponse value,
          $Res Function(_DeleteAssistantResponse) _then) =
      __$DeleteAssistantResponseCopyWithImpl;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteAssistantResponseObject object});
}

/// @nodoc
class __$DeleteAssistantResponseCopyWithImpl<$Res>
    implements _$DeleteAssistantResponseCopyWith<$Res> {
  __$DeleteAssistantResponseCopyWithImpl(this._self, this._then);

  final _DeleteAssistantResponse _self;
  final $Res Function(_DeleteAssistantResponse) _then;

  /// Create a copy of DeleteAssistantResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_DeleteAssistantResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantResponseObject,
    ));
  }
}

/// @nodoc
mixin _$ListAssistantsResponse {
  /// The object type, which is always `list`.
  String get object;

  /// The list of assistants.
  List<AssistantObject> get data;

  /// The ID of the first assistant in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last assistant in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more assistants to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListAssistantsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListAssistantsResponseCopyWith<ListAssistantsResponse> get copyWith =>
      _$ListAssistantsResponseCopyWithImpl<ListAssistantsResponse>(
          this as ListAssistantsResponse, _$identity);

  /// Serializes this ListAssistantsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListAssistantsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListAssistantsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListAssistantsResponseCopyWith<$Res> {
  factory $ListAssistantsResponseCopyWith(ListAssistantsResponse value,
          $Res Function(ListAssistantsResponse) _then) =
      _$ListAssistantsResponseCopyWithImpl;
  @useResult
  $Res call(
      {String object,
      List<AssistantObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListAssistantsResponseCopyWithImpl<$Res>
    implements $ListAssistantsResponseCopyWith<$Res> {
  _$ListAssistantsResponseCopyWithImpl(this._self, this._then);

  final ListAssistantsResponse _self;
  final $Res Function(ListAssistantsResponse) _then;

  /// Create a copy of ListAssistantsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListAssistantsResponse].
extension ListAssistantsResponsePatterns on ListAssistantsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListAssistantsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListAssistantsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListAssistantsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListAssistantsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListAssistantsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListAssistantsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String object,
            List<AssistantObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListAssistantsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String object,
            List<AssistantObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListAssistantsResponse():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String object,
            List<AssistantObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListAssistantsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListAssistantsResponse extends ListAssistantsResponse {
  const _ListAssistantsResponse(
      {required this.object,
      required final List<AssistantObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListAssistantsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListAssistantsResponseFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of assistants.
  final List<AssistantObject> _data;

  /// The list of assistants.
  @override
  List<AssistantObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first assistant in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last assistant in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more assistants to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListAssistantsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListAssistantsResponseCopyWith<_ListAssistantsResponse> get copyWith =>
      __$ListAssistantsResponseCopyWithImpl<_ListAssistantsResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListAssistantsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListAssistantsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListAssistantsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListAssistantsResponseCopyWith<$Res>
    implements $ListAssistantsResponseCopyWith<$Res> {
  factory _$ListAssistantsResponseCopyWith(_ListAssistantsResponse value,
          $Res Function(_ListAssistantsResponse) _then) =
      __$ListAssistantsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String object,
      List<AssistantObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListAssistantsResponseCopyWithImpl<$Res>
    implements _$ListAssistantsResponseCopyWith<$Res> {
  __$ListAssistantsResponseCopyWithImpl(this._self, this._then);

  final _ListAssistantsResponse _self;
  final $Res Function(_ListAssistantsResponse) _then;

  /// Create a copy of ListAssistantsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListAssistantsResponse(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$FileSearchRankingOptions {
  /// The ranker to use for the file search. If not specified will use the `auto` ranker.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  FileSearchRanker? get ranker;

  /// The score threshold for the file search. All values must be a floating point number between 0 and 1.
  @JsonKey(name: 'score_threshold')
  double get scoreThreshold;

  /// Create a copy of FileSearchRankingOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FileSearchRankingOptionsCopyWith<FileSearchRankingOptions> get copyWith =>
      _$FileSearchRankingOptionsCopyWithImpl<FileSearchRankingOptions>(
          this as FileSearchRankingOptions, _$identity);

  /// Serializes this FileSearchRankingOptions to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FileSearchRankingOptions &&
            (identical(other.ranker, ranker) || other.ranker == ranker) &&
            (identical(other.scoreThreshold, scoreThreshold) ||
                other.scoreThreshold == scoreThreshold));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ranker, scoreThreshold);

  @override
  String toString() {
    return 'FileSearchRankingOptions(ranker: $ranker, scoreThreshold: $scoreThreshold)';
  }
}

/// @nodoc
abstract mixin class $FileSearchRankingOptionsCopyWith<$Res> {
  factory $FileSearchRankingOptionsCopyWith(FileSearchRankingOptions value,
          $Res Function(FileSearchRankingOptions) _then) =
      _$FileSearchRankingOptionsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      FileSearchRanker? ranker,
      @JsonKey(name: 'score_threshold') double scoreThreshold});
}

/// @nodoc
class _$FileSearchRankingOptionsCopyWithImpl<$Res>
    implements $FileSearchRankingOptionsCopyWith<$Res> {
  _$FileSearchRankingOptionsCopyWithImpl(this._self, this._then);

  final FileSearchRankingOptions _self;
  final $Res Function(FileSearchRankingOptions) _then;

  /// Create a copy of FileSearchRankingOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ranker = freezed,
    Object? scoreThreshold = null,
  }) {
    return _then(_self.copyWith(
      ranker: freezed == ranker
          ? _self.ranker
          : ranker // ignore: cast_nullable_to_non_nullable
              as FileSearchRanker?,
      scoreThreshold: null == scoreThreshold
          ? _self.scoreThreshold
          : scoreThreshold // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// Adds pattern-matching-related methods to [FileSearchRankingOptions].
extension FileSearchRankingOptionsPatterns on FileSearchRankingOptions {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_FileSearchRankingOptions value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FileSearchRankingOptions() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_FileSearchRankingOptions value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FileSearchRankingOptions():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_FileSearchRankingOptions value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FileSearchRankingOptions() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            FileSearchRanker? ranker,
            @JsonKey(name: 'score_threshold') double scoreThreshold)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _FileSearchRankingOptions() when $default != null:
        return $default(_that.ranker, _that.scoreThreshold);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            FileSearchRanker? ranker,
            @JsonKey(name: 'score_threshold') double scoreThreshold)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FileSearchRankingOptions():
        return $default(_that.ranker, _that.scoreThreshold);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            FileSearchRanker? ranker,
            @JsonKey(name: 'score_threshold') double scoreThreshold)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _FileSearchRankingOptions() when $default != null:
        return $default(_that.ranker, _that.scoreThreshold);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _FileSearchRankingOptions extends FileSearchRankingOptions {
  const _FileSearchRankingOptions(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.ranker,
      @JsonKey(name: 'score_threshold') required this.scoreThreshold})
      : super._();
  factory _FileSearchRankingOptions.fromJson(Map<String, dynamic> json) =>
      _$FileSearchRankingOptionsFromJson(json);

  /// The ranker to use for the file search. If not specified will use the `auto` ranker.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final FileSearchRanker? ranker;

  /// The score threshold for the file search. All values must be a floating point number between 0 and 1.
  @override
  @JsonKey(name: 'score_threshold')
  final double scoreThreshold;

  /// Create a copy of FileSearchRankingOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FileSearchRankingOptionsCopyWith<_FileSearchRankingOptions> get copyWith =>
      __$FileSearchRankingOptionsCopyWithImpl<_FileSearchRankingOptions>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$FileSearchRankingOptionsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FileSearchRankingOptions &&
            (identical(other.ranker, ranker) || other.ranker == ranker) &&
            (identical(other.scoreThreshold, scoreThreshold) ||
                other.scoreThreshold == scoreThreshold));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ranker, scoreThreshold);

  @override
  String toString() {
    return 'FileSearchRankingOptions(ranker: $ranker, scoreThreshold: $scoreThreshold)';
  }
}

/// @nodoc
abstract mixin class _$FileSearchRankingOptionsCopyWith<$Res>
    implements $FileSearchRankingOptionsCopyWith<$Res> {
  factory _$FileSearchRankingOptionsCopyWith(_FileSearchRankingOptions value,
          $Res Function(_FileSearchRankingOptions) _then) =
      __$FileSearchRankingOptionsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      FileSearchRanker? ranker,
      @JsonKey(name: 'score_threshold') double scoreThreshold});
}

/// @nodoc
class __$FileSearchRankingOptionsCopyWithImpl<$Res>
    implements _$FileSearchRankingOptionsCopyWith<$Res> {
  __$FileSearchRankingOptionsCopyWithImpl(this._self, this._then);

  final _FileSearchRankingOptions _self;
  final $Res Function(_FileSearchRankingOptions) _then;

  /// Create a copy of FileSearchRankingOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? ranker = freezed,
    Object? scoreThreshold = null,
  }) {
    return _then(_FileSearchRankingOptions(
      ranker: freezed == ranker
          ? _self.ranker
          : ranker // ignore: cast_nullable_to_non_nullable
              as FileSearchRanker?,
      scoreThreshold: null == scoreThreshold
          ? _self.scoreThreshold
          : scoreThreshold // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
mixin _$AssistantsNamedToolChoice {
  /// The type of the tool. If type is `function`, the function name must be set
  AssistantsToolType get type;

  /// No Description
  @JsonKey(includeIfNull: false)
  AssistantsFunctionCallOption? get function;

  /// Create a copy of AssistantsNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantsNamedToolChoiceCopyWith<AssistantsNamedToolChoice> get copyWith =>
      _$AssistantsNamedToolChoiceCopyWithImpl<AssistantsNamedToolChoice>(
          this as AssistantsNamedToolChoice, _$identity);

  /// Serializes this AssistantsNamedToolChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantsNamedToolChoice &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @override
  String toString() {
    return 'AssistantsNamedToolChoice(type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $AssistantsNamedToolChoiceCopyWith<$Res> {
  factory $AssistantsNamedToolChoiceCopyWith(AssistantsNamedToolChoice value,
          $Res Function(AssistantsNamedToolChoice) _then) =
      _$AssistantsNamedToolChoiceCopyWithImpl;
  @useResult
  $Res call(
      {AssistantsToolType type,
      @JsonKey(includeIfNull: false) AssistantsFunctionCallOption? function});

  $AssistantsFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class _$AssistantsNamedToolChoiceCopyWithImpl<$Res>
    implements $AssistantsNamedToolChoiceCopyWith<$Res> {
  _$AssistantsNamedToolChoiceCopyWithImpl(this._self, this._then);

  final AssistantsNamedToolChoice _self;
  final $Res Function(AssistantsNamedToolChoice) _then;

  /// Create a copy of AssistantsNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = freezed,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as AssistantsToolType,
      function: freezed == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as AssistantsFunctionCallOption?,
    ));
  }

  /// Create a copy of AssistantsNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantsFunctionCallOptionCopyWith<$Res>? get function {
    if (_self.function == null) {
      return null;
    }

    return $AssistantsFunctionCallOptionCopyWith<$Res>(_self.function!,
        (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AssistantsNamedToolChoice].
extension AssistantsNamedToolChoicePatterns on AssistantsNamedToolChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AssistantsNamedToolChoice value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantsNamedToolChoice() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AssistantsNamedToolChoice value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsNamedToolChoice():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AssistantsNamedToolChoice value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsNamedToolChoice() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            AssistantsToolType type,
            @JsonKey(includeIfNull: false)
            AssistantsFunctionCallOption? function)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantsNamedToolChoice() when $default != null:
        return $default(_that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            AssistantsToolType type,
            @JsonKey(includeIfNull: false)
            AssistantsFunctionCallOption? function)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsNamedToolChoice():
        return $default(_that.type, _that.function);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            AssistantsToolType type,
            @JsonKey(includeIfNull: false)
            AssistantsFunctionCallOption? function)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsNamedToolChoice() when $default != null:
        return $default(_that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AssistantsNamedToolChoice extends AssistantsNamedToolChoice {
  const _AssistantsNamedToolChoice(
      {required this.type, @JsonKey(includeIfNull: false) this.function})
      : super._();
  factory _AssistantsNamedToolChoice.fromJson(Map<String, dynamic> json) =>
      _$AssistantsNamedToolChoiceFromJson(json);

  /// The type of the tool. If type is `function`, the function name must be set
  @override
  final AssistantsToolType type;

  /// No Description
  @override
  @JsonKey(includeIfNull: false)
  final AssistantsFunctionCallOption? function;

  /// Create a copy of AssistantsNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AssistantsNamedToolChoiceCopyWith<_AssistantsNamedToolChoice>
      get copyWith =>
          __$AssistantsNamedToolChoiceCopyWithImpl<_AssistantsNamedToolChoice>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantsNamedToolChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AssistantsNamedToolChoice &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @override
  String toString() {
    return 'AssistantsNamedToolChoice(type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class _$AssistantsNamedToolChoiceCopyWith<$Res>
    implements $AssistantsNamedToolChoiceCopyWith<$Res> {
  factory _$AssistantsNamedToolChoiceCopyWith(_AssistantsNamedToolChoice value,
          $Res Function(_AssistantsNamedToolChoice) _then) =
      __$AssistantsNamedToolChoiceCopyWithImpl;
  @override
  @useResult
  $Res call(
      {AssistantsToolType type,
      @JsonKey(includeIfNull: false) AssistantsFunctionCallOption? function});

  @override
  $AssistantsFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class __$AssistantsNamedToolChoiceCopyWithImpl<$Res>
    implements _$AssistantsNamedToolChoiceCopyWith<$Res> {
  __$AssistantsNamedToolChoiceCopyWithImpl(this._self, this._then);

  final _AssistantsNamedToolChoice _self;
  final $Res Function(_AssistantsNamedToolChoice) _then;

  /// Create a copy of AssistantsNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? function = freezed,
  }) {
    return _then(_AssistantsNamedToolChoice(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as AssistantsToolType,
      function: freezed == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as AssistantsFunctionCallOption?,
    ));
  }

  /// Create a copy of AssistantsNamedToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantsFunctionCallOptionCopyWith<$Res>? get function {
    if (_self.function == null) {
      return null;
    }

    return $AssistantsFunctionCallOptionCopyWith<$Res>(_self.function!,
        (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$AssistantsFunctionCallOption {
  /// The name of the function to call.
  String get name;

  /// Create a copy of AssistantsFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantsFunctionCallOptionCopyWith<AssistantsFunctionCallOption>
      get copyWith => _$AssistantsFunctionCallOptionCopyWithImpl<
              AssistantsFunctionCallOption>(
          this as AssistantsFunctionCallOption, _$identity);

  /// Serializes this AssistantsFunctionCallOption to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantsFunctionCallOption &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @override
  String toString() {
    return 'AssistantsFunctionCallOption(name: $name)';
  }
}

/// @nodoc
abstract mixin class $AssistantsFunctionCallOptionCopyWith<$Res> {
  factory $AssistantsFunctionCallOptionCopyWith(
          AssistantsFunctionCallOption value,
          $Res Function(AssistantsFunctionCallOption) _then) =
      _$AssistantsFunctionCallOptionCopyWithImpl;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$AssistantsFunctionCallOptionCopyWithImpl<$Res>
    implements $AssistantsFunctionCallOptionCopyWith<$Res> {
  _$AssistantsFunctionCallOptionCopyWithImpl(this._self, this._then);

  final AssistantsFunctionCallOption _self;
  final $Res Function(AssistantsFunctionCallOption) _then;

  /// Create a copy of AssistantsFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [AssistantsFunctionCallOption].
extension AssistantsFunctionCallOptionPatterns on AssistantsFunctionCallOption {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AssistantsFunctionCallOption value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantsFunctionCallOption() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AssistantsFunctionCallOption value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsFunctionCallOption():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AssistantsFunctionCallOption value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsFunctionCallOption() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String name)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantsFunctionCallOption() when $default != null:
        return $default(_that.name);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String name) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsFunctionCallOption():
        return $default(_that.name);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String name)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantsFunctionCallOption() when $default != null:
        return $default(_that.name);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AssistantsFunctionCallOption extends AssistantsFunctionCallOption {
  const _AssistantsFunctionCallOption({required this.name}) : super._();
  factory _AssistantsFunctionCallOption.fromJson(Map<String, dynamic> json) =>
      _$AssistantsFunctionCallOptionFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  /// Create a copy of AssistantsFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AssistantsFunctionCallOptionCopyWith<_AssistantsFunctionCallOption>
      get copyWith => __$AssistantsFunctionCallOptionCopyWithImpl<
          _AssistantsFunctionCallOption>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantsFunctionCallOptionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AssistantsFunctionCallOption &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @override
  String toString() {
    return 'AssistantsFunctionCallOption(name: $name)';
  }
}

/// @nodoc
abstract mixin class _$AssistantsFunctionCallOptionCopyWith<$Res>
    implements $AssistantsFunctionCallOptionCopyWith<$Res> {
  factory _$AssistantsFunctionCallOptionCopyWith(
          _AssistantsFunctionCallOption value,
          $Res Function(_AssistantsFunctionCallOption) _then) =
      __$AssistantsFunctionCallOptionCopyWithImpl;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$AssistantsFunctionCallOptionCopyWithImpl<$Res>
    implements _$AssistantsFunctionCallOptionCopyWith<$Res> {
  __$AssistantsFunctionCallOptionCopyWithImpl(this._self, this._then);

  final _AssistantsFunctionCallOption _self;
  final $Res Function(_AssistantsFunctionCallOption) _then;

  /// Create a copy of AssistantsFunctionCallOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
  }) {
    return _then(_AssistantsFunctionCallOption(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$TruncationObject {
  /// The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
  TruncationObjectType get type;

  /// The number of most recent messages from the thread when constructing the context for the run.
  @JsonKey(name: 'last_messages', includeIfNull: false)
  int? get lastMessages;

  /// Create a copy of TruncationObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<TruncationObject> get copyWith =>
      _$TruncationObjectCopyWithImpl<TruncationObject>(
          this as TruncationObject, _$identity);

  /// Serializes this TruncationObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TruncationObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.lastMessages, lastMessages) ||
                other.lastMessages == lastMessages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, lastMessages);

  @override
  String toString() {
    return 'TruncationObject(type: $type, lastMessages: $lastMessages)';
  }
}

/// @nodoc
abstract mixin class $TruncationObjectCopyWith<$Res> {
  factory $TruncationObjectCopyWith(
          TruncationObject value, $Res Function(TruncationObject) _then) =
      _$TruncationObjectCopyWithImpl;
  @useResult
  $Res call(
      {TruncationObjectType type,
      @JsonKey(name: 'last_messages', includeIfNull: false) int? lastMessages});
}

/// @nodoc
class _$TruncationObjectCopyWithImpl<$Res>
    implements $TruncationObjectCopyWith<$Res> {
  _$TruncationObjectCopyWithImpl(this._self, this._then);

  final TruncationObject _self;
  final $Res Function(TruncationObject) _then;

  /// Create a copy of TruncationObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? lastMessages = freezed,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as TruncationObjectType,
      lastMessages: freezed == lastMessages
          ? _self.lastMessages
          : lastMessages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [TruncationObject].
extension TruncationObjectPatterns on TruncationObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_TruncationObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TruncationObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_TruncationObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TruncationObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_TruncationObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TruncationObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            TruncationObjectType type,
            @JsonKey(name: 'last_messages', includeIfNull: false)
            int? lastMessages)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _TruncationObject() when $default != null:
        return $default(_that.type, _that.lastMessages);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            TruncationObjectType type,
            @JsonKey(name: 'last_messages', includeIfNull: false)
            int? lastMessages)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TruncationObject():
        return $default(_that.type, _that.lastMessages);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            TruncationObjectType type,
            @JsonKey(name: 'last_messages', includeIfNull: false)
            int? lastMessages)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _TruncationObject() when $default != null:
        return $default(_that.type, _that.lastMessages);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _TruncationObject extends TruncationObject {
  const _TruncationObject(
      {required this.type,
      @JsonKey(name: 'last_messages', includeIfNull: false) this.lastMessages})
      : super._();
  factory _TruncationObject.fromJson(Map<String, dynamic> json) =>
      _$TruncationObjectFromJson(json);

  /// The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
  @override
  final TruncationObjectType type;

  /// The number of most recent messages from the thread when constructing the context for the run.
  @override
  @JsonKey(name: 'last_messages', includeIfNull: false)
  final int? lastMessages;

  /// Create a copy of TruncationObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$TruncationObjectCopyWith<_TruncationObject> get copyWith =>
      __$TruncationObjectCopyWithImpl<_TruncationObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$TruncationObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TruncationObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.lastMessages, lastMessages) ||
                other.lastMessages == lastMessages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, lastMessages);

  @override
  String toString() {
    return 'TruncationObject(type: $type, lastMessages: $lastMessages)';
  }
}

/// @nodoc
abstract mixin class _$TruncationObjectCopyWith<$Res>
    implements $TruncationObjectCopyWith<$Res> {
  factory _$TruncationObjectCopyWith(
          _TruncationObject value, $Res Function(_TruncationObject) _then) =
      __$TruncationObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {TruncationObjectType type,
      @JsonKey(name: 'last_messages', includeIfNull: false) int? lastMessages});
}

/// @nodoc
class __$TruncationObjectCopyWithImpl<$Res>
    implements _$TruncationObjectCopyWith<$Res> {
  __$TruncationObjectCopyWithImpl(this._self, this._then);

  final _TruncationObject _self;
  final $Res Function(_TruncationObject) _then;

  /// Create a copy of TruncationObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? lastMessages = freezed,
  }) {
    return _then(_TruncationObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as TruncationObjectType,
      lastMessages: freezed == lastMessages
          ? _self.lastMessages
          : lastMessages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$RunObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `thread.run`.
  RunObjectObject get object;

  /// The Unix timestamp (in seconds) for when the run was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @JsonKey(name: 'thread_id')
  String get threadId;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
  RunStatus get status;

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @JsonKey(name: 'required_action')
  RunRequiredAction? get requiredAction;

  /// The last error associated with this run. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunLastError? get lastError;

  /// The Unix timestamp (in seconds) for when the run will expire.
  @JsonKey(name: 'expires_at')
  int? get expiresAt;

  /// The Unix timestamp (in seconds) for when the run was started.
  @JsonKey(name: 'started_at')
  int? get startedAt;

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt;

  /// The Unix timestamp (in seconds) for when the run failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt;

  /// The Unix timestamp (in seconds) for when the run was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;

  /// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
  @JsonKey(name: 'incomplete_details')
  RunObjectIncompleteDetails? get incompleteDetails;

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get model;

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get instructions;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  List<AssistantTools> get tools;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  Map<String, dynamic>? get metadata;

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  RunCompletionUsage? get usage;

  /// The sampling temperature used for this run. If not set, defaults to 1.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// The nucleus sampling value used for this run. If not set, defaults to 1.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// The maximum number of prompt tokens specified to have been used over the course of the run.
  @JsonKey(name: 'max_prompt_tokens')
  int? get maxPromptTokens;

  /// The maximum number of completion tokens specified to have been used over the course of the run.
  @JsonKey(name: 'max_completion_tokens')
  int? get maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run.
  @JsonKey(name: 'truncation_strategy')
  TruncationObject? get truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_RunObjectToolChoiceConverter()
  @JsonKey(name: 'tool_choice')
  RunObjectToolChoice? get toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls')
  bool? get parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_RunObjectResponseFormatConverter()
  @JsonKey(name: 'response_format')
  RunObjectResponseFormat get responseFormat;

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunObjectCopyWith<RunObject> get copyWith =>
      _$RunObjectCopyWithImpl<RunObject>(this as RunObject, _$identity);

  /// Serializes this RunObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.requiredAction, requiredAction) ||
                other.requiredAction == requiredAction) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.startedAt, startedAt) ||
                other.startedAt == startedAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.incompleteDetails, incompleteDetails) ||
                other.incompleteDetails == incompleteDetails) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other.tools, tools) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.usage, usage) || other.usage == usage) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        createdAt,
        threadId,
        assistantId,
        status,
        requiredAction,
        lastError,
        expiresAt,
        startedAt,
        cancelledAt,
        failedAt,
        completedAt,
        incompleteDetails,
        model,
        instructions,
        const DeepCollectionEquality().hash(tools),
        const DeepCollectionEquality().hash(metadata),
        usage,
        temperature,
        topP,
        maxPromptTokens,
        maxCompletionTokens,
        truncationStrategy,
        toolChoice,
        parallelToolCalls,
        responseFormat
      ]);

  @override
  String toString() {
    return 'RunObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, assistantId: $assistantId, status: $status, requiredAction: $requiredAction, lastError: $lastError, expiresAt: $expiresAt, startedAt: $startedAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, incompleteDetails: $incompleteDetails, model: $model, instructions: $instructions, tools: $tools, metadata: $metadata, usage: $usage, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class $RunObjectCopyWith<$Res> {
  factory $RunObjectCopyWith(RunObject value, $Res Function(RunObject) _then) =
      _$RunObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      RunObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'assistant_id') String assistantId,
      RunStatus status,
      @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') RunLastError? lastError,
      @JsonKey(name: 'expires_at') int? expiresAt,
      @JsonKey(name: 'started_at') int? startedAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_details')
      RunObjectIncompleteDetails? incompleteDetails,
      String model,
      String instructions,
      List<AssistantTools> tools,
      Map<String, dynamic>? metadata,
      RunCompletionUsage? usage,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens') int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens') int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy')
      TruncationObject? truncationStrategy,
      @_RunObjectToolChoiceConverter()
      @JsonKey(name: 'tool_choice')
      RunObjectToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls') bool? parallelToolCalls,
      @_RunObjectResponseFormatConverter()
      @JsonKey(name: 'response_format')
      RunObjectResponseFormat responseFormat});

  $RunRequiredActionCopyWith<$Res>? get requiredAction;
  $RunLastErrorCopyWith<$Res>? get lastError;
  $RunObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
  $RunCompletionUsageCopyWith<$Res>? get usage;
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  $RunObjectToolChoiceCopyWith<$Res>? get toolChoice;
  $RunObjectResponseFormatCopyWith<$Res> get responseFormat;
}

/// @nodoc
class _$RunObjectCopyWithImpl<$Res> implements $RunObjectCopyWith<$Res> {
  _$RunObjectCopyWithImpl(this._self, this._then);

  final RunObject _self;
  final $Res Function(RunObject) _then;

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? assistantId = null,
    Object? status = null,
    Object? requiredAction = freezed,
    Object? lastError = freezed,
    Object? expiresAt = freezed,
    Object? startedAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? incompleteDetails = freezed,
    Object? model = null,
    Object? instructions = null,
    Object? tools = null,
    Object? metadata = freezed,
    Object? usage = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStatus,
      requiredAction: freezed == requiredAction
          ? _self.requiredAction
          : requiredAction // ignore: cast_nullable_to_non_nullable
              as RunRequiredAction?,
      lastError: freezed == lastError
          ? _self.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunLastError?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      startedAt: freezed == startedAt
          ? _self.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _self.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _self.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteDetails: freezed == incompleteDetails
          ? _self.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetails?,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: null == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String,
      tools: null == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunCompletionUsage?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _self.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _self.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as RunObjectToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: null == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as RunObjectResponseFormat,
    ));
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunRequiredActionCopyWith<$Res>? get requiredAction {
    if (_self.requiredAction == null) {
      return null;
    }

    return $RunRequiredActionCopyWith<$Res>(_self.requiredAction!, (value) {
      return _then(_self.copyWith(requiredAction: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunLastErrorCopyWith<$Res>? get lastError {
    if (_self.lastError == null) {
      return null;
    }

    return $RunLastErrorCopyWith<$Res>(_self.lastError!, (value) {
      return _then(_self.copyWith(lastError: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails {
    if (_self.incompleteDetails == null) {
      return null;
    }

    return $RunObjectIncompleteDetailsCopyWith<$Res>(_self.incompleteDetails!,
        (value) {
      return _then(_self.copyWith(incompleteDetails: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunCompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $RunCompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_self.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_self.truncationStrategy!, (value) {
      return _then(_self.copyWith(truncationStrategy: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunObjectToolChoiceCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $RunObjectToolChoiceCopyWith<$Res>(_self.toolChoice!, (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunObjectResponseFormatCopyWith<$Res> get responseFormat {
    return $RunObjectResponseFormatCopyWith<$Res>(_self.responseFormat,
        (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

/// Adds pattern-matching-related methods to [RunObject].
extension RunObjectPatterns on RunObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            RunObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(name: 'assistant_id') String assistantId,
            RunStatus status,
            @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
            @JsonKey(name: 'last_error') RunLastError? lastError,
            @JsonKey(name: 'expires_at') int? expiresAt,
            @JsonKey(name: 'started_at') int? startedAt,
            @JsonKey(name: 'cancelled_at') int? cancelledAt,
            @JsonKey(name: 'failed_at') int? failedAt,
            @JsonKey(name: 'completed_at') int? completedAt,
            @JsonKey(name: 'incomplete_details')
            RunObjectIncompleteDetails? incompleteDetails,
            String model,
            String instructions,
            List<AssistantTools> tools,
            Map<String, dynamic>? metadata,
            RunCompletionUsage? usage,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens') int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens') int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy')
            TruncationObject? truncationStrategy,
            @_RunObjectToolChoiceConverter()
            @JsonKey(name: 'tool_choice')
            RunObjectToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls') bool? parallelToolCalls,
            @_RunObjectResponseFormatConverter()
            @JsonKey(name: 'response_format')
            RunObjectResponseFormat responseFormat)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.threadId,
            _that.assistantId,
            _that.status,
            _that.requiredAction,
            _that.lastError,
            _that.expiresAt,
            _that.startedAt,
            _that.cancelledAt,
            _that.failedAt,
            _that.completedAt,
            _that.incompleteDetails,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.metadata,
            _that.usage,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            RunObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(name: 'assistant_id') String assistantId,
            RunStatus status,
            @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
            @JsonKey(name: 'last_error') RunLastError? lastError,
            @JsonKey(name: 'expires_at') int? expiresAt,
            @JsonKey(name: 'started_at') int? startedAt,
            @JsonKey(name: 'cancelled_at') int? cancelledAt,
            @JsonKey(name: 'failed_at') int? failedAt,
            @JsonKey(name: 'completed_at') int? completedAt,
            @JsonKey(name: 'incomplete_details')
            RunObjectIncompleteDetails? incompleteDetails,
            String model,
            String instructions,
            List<AssistantTools> tools,
            Map<String, dynamic>? metadata,
            RunCompletionUsage? usage,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens') int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens') int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy')
            TruncationObject? truncationStrategy,
            @_RunObjectToolChoiceConverter()
            @JsonKey(name: 'tool_choice')
            RunObjectToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls') bool? parallelToolCalls,
            @_RunObjectResponseFormatConverter()
            @JsonKey(name: 'response_format')
            RunObjectResponseFormat responseFormat)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObject():
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.threadId,
            _that.assistantId,
            _that.status,
            _that.requiredAction,
            _that.lastError,
            _that.expiresAt,
            _that.startedAt,
            _that.cancelledAt,
            _that.failedAt,
            _that.completedAt,
            _that.incompleteDetails,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.metadata,
            _that.usage,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            RunObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(name: 'assistant_id') String assistantId,
            RunStatus status,
            @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
            @JsonKey(name: 'last_error') RunLastError? lastError,
            @JsonKey(name: 'expires_at') int? expiresAt,
            @JsonKey(name: 'started_at') int? startedAt,
            @JsonKey(name: 'cancelled_at') int? cancelledAt,
            @JsonKey(name: 'failed_at') int? failedAt,
            @JsonKey(name: 'completed_at') int? completedAt,
            @JsonKey(name: 'incomplete_details')
            RunObjectIncompleteDetails? incompleteDetails,
            String model,
            String instructions,
            List<AssistantTools> tools,
            Map<String, dynamic>? metadata,
            RunCompletionUsage? usage,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens') int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens') int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy')
            TruncationObject? truncationStrategy,
            @_RunObjectToolChoiceConverter()
            @JsonKey(name: 'tool_choice')
            RunObjectToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls') bool? parallelToolCalls,
            @_RunObjectResponseFormatConverter()
            @JsonKey(name: 'response_format')
            RunObjectResponseFormat responseFormat)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.threadId,
            _that.assistantId,
            _that.status,
            _that.requiredAction,
            _that.lastError,
            _that.expiresAt,
            _that.startedAt,
            _that.cancelledAt,
            _that.failedAt,
            _that.completedAt,
            _that.incompleteDetails,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.metadata,
            _that.usage,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunObject extends RunObject {
  const _RunObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      required this.status,
      @JsonKey(name: 'required_action') required this.requiredAction,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'expires_at') required this.expiresAt,
      @JsonKey(name: 'started_at') required this.startedAt,
      @JsonKey(name: 'cancelled_at') required this.cancelledAt,
      @JsonKey(name: 'failed_at') required this.failedAt,
      @JsonKey(name: 'completed_at') required this.completedAt,
      @JsonKey(name: 'incomplete_details') required this.incompleteDetails,
      required this.model,
      required this.instructions,
      required final List<AssistantTools> tools,
      required final Map<String, dynamic>? metadata,
      required this.usage,
      @JsonKey(includeIfNull: false) this.temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP,
      @JsonKey(name: 'max_prompt_tokens') required this.maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens') required this.maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy') required this.truncationStrategy,
      @_RunObjectToolChoiceConverter()
      @JsonKey(name: 'tool_choice')
      required this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls') required this.parallelToolCalls,
      @_RunObjectResponseFormatConverter()
      @JsonKey(name: 'response_format')
      required this.responseFormat})
      : _tools = tools,
        _metadata = metadata,
        super._();
  factory _RunObject.fromJson(Map<String, dynamic> json) =>
      _$RunObjectFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run`.
  @override
  final RunObjectObject object;

  /// The Unix timestamp (in seconds) for when the run was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
  @override
  final RunStatus status;

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @override
  @JsonKey(name: 'required_action')
  final RunRequiredAction? requiredAction;

  /// The last error associated with this run. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final RunLastError? lastError;

  /// The Unix timestamp (in seconds) for when the run will expire.
  @override
  @JsonKey(name: 'expires_at')
  final int? expiresAt;

  /// The Unix timestamp (in seconds) for when the run was started.
  @override
  @JsonKey(name: 'started_at')
  final int? startedAt;

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @override
  @JsonKey(name: 'cancelled_at')
  final int? cancelledAt;

  /// The Unix timestamp (in seconds) for when the run failed.
  @override
  @JsonKey(name: 'failed_at')
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the run was completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
  @override
  @JsonKey(name: 'incomplete_details')
  final RunObjectIncompleteDetails? incompleteDetails;

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  final String model;

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  final String instructions;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  final List<AssistantTools> _tools;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  @override
  final RunCompletionUsage? usage;

  /// The sampling temperature used for this run. If not set, defaults to 1.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// The nucleus sampling value used for this run. If not set, defaults to 1.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// The maximum number of prompt tokens specified to have been used over the course of the run.
  @override
  @JsonKey(name: 'max_prompt_tokens')
  final int? maxPromptTokens;

  /// The maximum number of completion tokens specified to have been used over the course of the run.
  @override
  @JsonKey(name: 'max_completion_tokens')
  final int? maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run.
  @override
  @JsonKey(name: 'truncation_strategy')
  final TruncationObject? truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @override
  @_RunObjectToolChoiceConverter()
  @JsonKey(name: 'tool_choice')
  final RunObjectToolChoice? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls')
  final bool? parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_RunObjectResponseFormatConverter()
  @JsonKey(name: 'response_format')
  final RunObjectResponseFormat responseFormat;

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunObjectCopyWith<_RunObject> get copyWith =>
      __$RunObjectCopyWithImpl<_RunObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.requiredAction, requiredAction) ||
                other.requiredAction == requiredAction) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.startedAt, startedAt) ||
                other.startedAt == startedAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.incompleteDetails, incompleteDetails) ||
                other.incompleteDetails == incompleteDetails) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.usage, usage) || other.usage == usage) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        createdAt,
        threadId,
        assistantId,
        status,
        requiredAction,
        lastError,
        expiresAt,
        startedAt,
        cancelledAt,
        failedAt,
        completedAt,
        incompleteDetails,
        model,
        instructions,
        const DeepCollectionEquality().hash(_tools),
        const DeepCollectionEquality().hash(_metadata),
        usage,
        temperature,
        topP,
        maxPromptTokens,
        maxCompletionTokens,
        truncationStrategy,
        toolChoice,
        parallelToolCalls,
        responseFormat
      ]);

  @override
  String toString() {
    return 'RunObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, assistantId: $assistantId, status: $status, requiredAction: $requiredAction, lastError: $lastError, expiresAt: $expiresAt, startedAt: $startedAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, incompleteDetails: $incompleteDetails, model: $model, instructions: $instructions, tools: $tools, metadata: $metadata, usage: $usage, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat)';
  }
}

/// @nodoc
abstract mixin class _$RunObjectCopyWith<$Res>
    implements $RunObjectCopyWith<$Res> {
  factory _$RunObjectCopyWith(
          _RunObject value, $Res Function(_RunObject) _then) =
      __$RunObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      RunObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'assistant_id') String assistantId,
      RunStatus status,
      @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') RunLastError? lastError,
      @JsonKey(name: 'expires_at') int? expiresAt,
      @JsonKey(name: 'started_at') int? startedAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_details')
      RunObjectIncompleteDetails? incompleteDetails,
      String model,
      String instructions,
      List<AssistantTools> tools,
      Map<String, dynamic>? metadata,
      RunCompletionUsage? usage,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens') int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens') int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy')
      TruncationObject? truncationStrategy,
      @_RunObjectToolChoiceConverter()
      @JsonKey(name: 'tool_choice')
      RunObjectToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls') bool? parallelToolCalls,
      @_RunObjectResponseFormatConverter()
      @JsonKey(name: 'response_format')
      RunObjectResponseFormat responseFormat});

  @override
  $RunRequiredActionCopyWith<$Res>? get requiredAction;
  @override
  $RunLastErrorCopyWith<$Res>? get lastError;
  @override
  $RunObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
  @override
  $RunCompletionUsageCopyWith<$Res>? get usage;
  @override
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  @override
  $RunObjectToolChoiceCopyWith<$Res>? get toolChoice;
  @override
  $RunObjectResponseFormatCopyWith<$Res> get responseFormat;
}

/// @nodoc
class __$RunObjectCopyWithImpl<$Res> implements _$RunObjectCopyWith<$Res> {
  __$RunObjectCopyWithImpl(this._self, this._then);

  final _RunObject _self;
  final $Res Function(_RunObject) _then;

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? assistantId = null,
    Object? status = null,
    Object? requiredAction = freezed,
    Object? lastError = freezed,
    Object? expiresAt = freezed,
    Object? startedAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? incompleteDetails = freezed,
    Object? model = null,
    Object? instructions = null,
    Object? tools = null,
    Object? metadata = freezed,
    Object? usage = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = null,
  }) {
    return _then(_RunObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStatus,
      requiredAction: freezed == requiredAction
          ? _self.requiredAction
          : requiredAction // ignore: cast_nullable_to_non_nullable
              as RunRequiredAction?,
      lastError: freezed == lastError
          ? _self.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunLastError?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      startedAt: freezed == startedAt
          ? _self.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _self.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _self.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteDetails: freezed == incompleteDetails
          ? _self.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetails?,
      model: null == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: null == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String,
      tools: null == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunCompletionUsage?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _self.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _self.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as RunObjectToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: null == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as RunObjectResponseFormat,
    ));
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunRequiredActionCopyWith<$Res>? get requiredAction {
    if (_self.requiredAction == null) {
      return null;
    }

    return $RunRequiredActionCopyWith<$Res>(_self.requiredAction!, (value) {
      return _then(_self.copyWith(requiredAction: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunLastErrorCopyWith<$Res>? get lastError {
    if (_self.lastError == null) {
      return null;
    }

    return $RunLastErrorCopyWith<$Res>(_self.lastError!, (value) {
      return _then(_self.copyWith(lastError: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails {
    if (_self.incompleteDetails == null) {
      return null;
    }

    return $RunObjectIncompleteDetailsCopyWith<$Res>(_self.incompleteDetails!,
        (value) {
      return _then(_self.copyWith(incompleteDetails: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunCompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $RunCompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_self.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_self.truncationStrategy!, (value) {
      return _then(_self.copyWith(truncationStrategy: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunObjectToolChoiceCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $RunObjectToolChoiceCopyWith<$Res>(_self.toolChoice!, (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of RunObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunObjectResponseFormatCopyWith<$Res> get responseFormat {
    return $RunObjectResponseFormatCopyWith<$Res>(_self.responseFormat,
        (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

/// @nodoc
mixin _$RunRequiredAction {
  /// For now, this is always `submit_tool_outputs`.
  RunRequiredActionType get type;

  /// Details on the tool outputs needed for this run to continue.
  @JsonKey(name: 'submit_tool_outputs')
  RunSubmitToolOutputs get submitToolOutputs;

  /// Create a copy of RunRequiredAction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunRequiredActionCopyWith<RunRequiredAction> get copyWith =>
      _$RunRequiredActionCopyWithImpl<RunRequiredAction>(
          this as RunRequiredAction, _$identity);

  /// Serializes this RunRequiredAction to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunRequiredAction &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.submitToolOutputs, submitToolOutputs) ||
                other.submitToolOutputs == submitToolOutputs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, submitToolOutputs);

  @override
  String toString() {
    return 'RunRequiredAction(type: $type, submitToolOutputs: $submitToolOutputs)';
  }
}

/// @nodoc
abstract mixin class $RunRequiredActionCopyWith<$Res> {
  factory $RunRequiredActionCopyWith(
          RunRequiredAction value, $Res Function(RunRequiredAction) _then) =
      _$RunRequiredActionCopyWithImpl;
  @useResult
  $Res call(
      {RunRequiredActionType type,
      @JsonKey(name: 'submit_tool_outputs')
      RunSubmitToolOutputs submitToolOutputs});

  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs;
}

/// @nodoc
class _$RunRequiredActionCopyWithImpl<$Res>
    implements $RunRequiredActionCopyWith<$Res> {
  _$RunRequiredActionCopyWithImpl(this._self, this._then);

  final RunRequiredAction _self;
  final $Res Function(RunRequiredAction) _then;

  /// Create a copy of RunRequiredAction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? submitToolOutputs = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunRequiredActionType,
      submitToolOutputs: null == submitToolOutputs
          ? _self.submitToolOutputs
          : submitToolOutputs // ignore: cast_nullable_to_non_nullable
              as RunSubmitToolOutputs,
    ));
  }

  /// Create a copy of RunRequiredAction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs {
    return $RunSubmitToolOutputsCopyWith<$Res>(_self.submitToolOutputs,
        (value) {
      return _then(_self.copyWith(submitToolOutputs: value));
    });
  }
}

/// Adds pattern-matching-related methods to [RunRequiredAction].
extension RunRequiredActionPatterns on RunRequiredAction {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunRequiredAction value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunRequiredAction() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunRequiredAction value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunRequiredAction():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunRequiredAction value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunRequiredAction() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            RunRequiredActionType type,
            @JsonKey(name: 'submit_tool_outputs')
            RunSubmitToolOutputs submitToolOutputs)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunRequiredAction() when $default != null:
        return $default(_that.type, _that.submitToolOutputs);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            RunRequiredActionType type,
            @JsonKey(name: 'submit_tool_outputs')
            RunSubmitToolOutputs submitToolOutputs)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunRequiredAction():
        return $default(_that.type, _that.submitToolOutputs);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            RunRequiredActionType type,
            @JsonKey(name: 'submit_tool_outputs')
            RunSubmitToolOutputs submitToolOutputs)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunRequiredAction() when $default != null:
        return $default(_that.type, _that.submitToolOutputs);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunRequiredAction extends RunRequiredAction {
  const _RunRequiredAction(
      {required this.type,
      @JsonKey(name: 'submit_tool_outputs') required this.submitToolOutputs})
      : super._();
  factory _RunRequiredAction.fromJson(Map<String, dynamic> json) =>
      _$RunRequiredActionFromJson(json);

  /// For now, this is always `submit_tool_outputs`.
  @override
  final RunRequiredActionType type;

  /// Details on the tool outputs needed for this run to continue.
  @override
  @JsonKey(name: 'submit_tool_outputs')
  final RunSubmitToolOutputs submitToolOutputs;

  /// Create a copy of RunRequiredAction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunRequiredActionCopyWith<_RunRequiredAction> get copyWith =>
      __$RunRequiredActionCopyWithImpl<_RunRequiredAction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunRequiredActionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunRequiredAction &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.submitToolOutputs, submitToolOutputs) ||
                other.submitToolOutputs == submitToolOutputs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, submitToolOutputs);

  @override
  String toString() {
    return 'RunRequiredAction(type: $type, submitToolOutputs: $submitToolOutputs)';
  }
}

/// @nodoc
abstract mixin class _$RunRequiredActionCopyWith<$Res>
    implements $RunRequiredActionCopyWith<$Res> {
  factory _$RunRequiredActionCopyWith(
          _RunRequiredAction value, $Res Function(_RunRequiredAction) _then) =
      __$RunRequiredActionCopyWithImpl;
  @override
  @useResult
  $Res call(
      {RunRequiredActionType type,
      @JsonKey(name: 'submit_tool_outputs')
      RunSubmitToolOutputs submitToolOutputs});

  @override
  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs;
}

/// @nodoc
class __$RunRequiredActionCopyWithImpl<$Res>
    implements _$RunRequiredActionCopyWith<$Res> {
  __$RunRequiredActionCopyWithImpl(this._self, this._then);

  final _RunRequiredAction _self;
  final $Res Function(_RunRequiredAction) _then;

  /// Create a copy of RunRequiredAction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? submitToolOutputs = null,
  }) {
    return _then(_RunRequiredAction(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunRequiredActionType,
      submitToolOutputs: null == submitToolOutputs
          ? _self.submitToolOutputs
          : submitToolOutputs // ignore: cast_nullable_to_non_nullable
              as RunSubmitToolOutputs,
    ));
  }

  /// Create a copy of RunRequiredAction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs {
    return $RunSubmitToolOutputsCopyWith<$Res>(_self.submitToolOutputs,
        (value) {
      return _then(_self.copyWith(submitToolOutputs: value));
    });
  }
}

/// @nodoc
mixin _$RunLastError {
  /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
  RunLastErrorCode get code;

  /// A human-readable description of the error.
  String get message;

  /// Create a copy of RunLastError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunLastErrorCopyWith<RunLastError> get copyWith =>
      _$RunLastErrorCopyWithImpl<RunLastError>(
          this as RunLastError, _$identity);

  /// Serializes this RunLastError to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunLastError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @override
  String toString() {
    return 'RunLastError(code: $code, message: $message)';
  }
}

/// @nodoc
abstract mixin class $RunLastErrorCopyWith<$Res> {
  factory $RunLastErrorCopyWith(
          RunLastError value, $Res Function(RunLastError) _then) =
      _$RunLastErrorCopyWithImpl;
  @useResult
  $Res call({RunLastErrorCode code, String message});
}

/// @nodoc
class _$RunLastErrorCopyWithImpl<$Res> implements $RunLastErrorCopyWith<$Res> {
  _$RunLastErrorCopyWithImpl(this._self, this._then);

  final RunLastError _self;
  final $Res Function(RunLastError) _then;

  /// Create a copy of RunLastError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_self.copyWith(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunLastErrorCode,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunLastError].
extension RunLastErrorPatterns on RunLastError {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunLastError value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunLastError() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunLastError value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunLastError():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunLastError value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunLastError() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(RunLastErrorCode code, String message)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunLastError() when $default != null:
        return $default(_that.code, _that.message);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(RunLastErrorCode code, String message) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunLastError():
        return $default(_that.code, _that.message);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(RunLastErrorCode code, String message)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunLastError() when $default != null:
        return $default(_that.code, _that.message);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunLastError extends RunLastError {
  const _RunLastError({required this.code, required this.message}) : super._();
  factory _RunLastError.fromJson(Map<String, dynamic> json) =>
      _$RunLastErrorFromJson(json);

  /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
  @override
  final RunLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  /// Create a copy of RunLastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunLastErrorCopyWith<_RunLastError> get copyWith =>
      __$RunLastErrorCopyWithImpl<_RunLastError>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunLastErrorToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunLastError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @override
  String toString() {
    return 'RunLastError(code: $code, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$RunLastErrorCopyWith<$Res>
    implements $RunLastErrorCopyWith<$Res> {
  factory _$RunLastErrorCopyWith(
          _RunLastError value, $Res Function(_RunLastError) _then) =
      __$RunLastErrorCopyWithImpl;
  @override
  @useResult
  $Res call({RunLastErrorCode code, String message});
}

/// @nodoc
class __$RunLastErrorCopyWithImpl<$Res>
    implements _$RunLastErrorCopyWith<$Res> {
  __$RunLastErrorCopyWithImpl(this._self, this._then);

  final _RunLastError _self;
  final $Res Function(_RunLastError) _then;

  /// Create a copy of RunLastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_RunLastError(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunLastErrorCode,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$RunObjectIncompleteDetails {
  /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  RunObjectIncompleteDetailsReason? get reason;

  /// Create a copy of RunObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunObjectIncompleteDetailsCopyWith<RunObjectIncompleteDetails>
      get copyWith =>
          _$RunObjectIncompleteDetailsCopyWithImpl<RunObjectIncompleteDetails>(
              this as RunObjectIncompleteDetails, _$identity);

  /// Serializes this RunObjectIncompleteDetails to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObjectIncompleteDetails &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @override
  String toString() {
    return 'RunObjectIncompleteDetails(reason: $reason)';
  }
}

/// @nodoc
abstract mixin class $RunObjectIncompleteDetailsCopyWith<$Res> {
  factory $RunObjectIncompleteDetailsCopyWith(RunObjectIncompleteDetails value,
          $Res Function(RunObjectIncompleteDetails) _then) =
      _$RunObjectIncompleteDetailsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      RunObjectIncompleteDetailsReason? reason});
}

/// @nodoc
class _$RunObjectIncompleteDetailsCopyWithImpl<$Res>
    implements $RunObjectIncompleteDetailsCopyWith<$Res> {
  _$RunObjectIncompleteDetailsCopyWithImpl(this._self, this._then);

  final RunObjectIncompleteDetails _self;
  final $Res Function(RunObjectIncompleteDetails) _then;

  /// Create a copy of RunObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = freezed,
  }) {
    return _then(_self.copyWith(
      reason: freezed == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetailsReason?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunObjectIncompleteDetails].
extension RunObjectIncompleteDetailsPatterns on RunObjectIncompleteDetails {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunObjectIncompleteDetails value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunObjectIncompleteDetails() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunObjectIncompleteDetails value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObjectIncompleteDetails():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunObjectIncompleteDetails value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObjectIncompleteDetails() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            RunObjectIncompleteDetailsReason? reason)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunObjectIncompleteDetails() when $default != null:
        return $default(_that.reason);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            RunObjectIncompleteDetailsReason? reason)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObjectIncompleteDetails():
        return $default(_that.reason);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            RunObjectIncompleteDetailsReason? reason)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunObjectIncompleteDetails() when $default != null:
        return $default(_that.reason);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunObjectIncompleteDetails extends RunObjectIncompleteDetails {
  const _RunObjectIncompleteDetails(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.reason})
      : super._();
  factory _RunObjectIncompleteDetails.fromJson(Map<String, dynamic> json) =>
      _$RunObjectIncompleteDetailsFromJson(json);

  /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final RunObjectIncompleteDetailsReason? reason;

  /// Create a copy of RunObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunObjectIncompleteDetailsCopyWith<_RunObjectIncompleteDetails>
      get copyWith => __$RunObjectIncompleteDetailsCopyWithImpl<
          _RunObjectIncompleteDetails>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunObjectIncompleteDetailsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunObjectIncompleteDetails &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @override
  String toString() {
    return 'RunObjectIncompleteDetails(reason: $reason)';
  }
}

/// @nodoc
abstract mixin class _$RunObjectIncompleteDetailsCopyWith<$Res>
    implements $RunObjectIncompleteDetailsCopyWith<$Res> {
  factory _$RunObjectIncompleteDetailsCopyWith(
          _RunObjectIncompleteDetails value,
          $Res Function(_RunObjectIncompleteDetails) _then) =
      __$RunObjectIncompleteDetailsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      RunObjectIncompleteDetailsReason? reason});
}

/// @nodoc
class __$RunObjectIncompleteDetailsCopyWithImpl<$Res>
    implements _$RunObjectIncompleteDetailsCopyWith<$Res> {
  __$RunObjectIncompleteDetailsCopyWithImpl(this._self, this._then);

  final _RunObjectIncompleteDetails _self;
  final $Res Function(_RunObjectIncompleteDetails) _then;

  /// Create a copy of RunObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? reason = freezed,
  }) {
    return _then(_RunObjectIncompleteDetails(
      reason: freezed == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetailsReason?,
    ));
  }
}

RunObjectToolChoice _$RunObjectToolChoiceFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return RunObjectToolChoiceEnumeration.fromJson(json);
    case 'tool':
      return RunObjectToolChoiceAssistantsNamedToolChoice.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'RunObjectToolChoice',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$RunObjectToolChoice {
  Object get value;

  /// Serializes this RunObjectToolChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObjectToolChoice &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'RunObjectToolChoice(value: $value)';
  }
}

/// @nodoc
class $RunObjectToolChoiceCopyWith<$Res> {
  $RunObjectToolChoiceCopyWith(
      RunObjectToolChoice _, $Res Function(RunObjectToolChoice) __);
}

/// Adds pattern-matching-related methods to [RunObjectToolChoice].
extension RunObjectToolChoicePatterns on RunObjectToolChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectToolChoiceEnumeration() when mode != null:
        return mode(_that);
      case RunObjectToolChoiceAssistantsNamedToolChoice() when tool != null:
        return tool(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceEnumeration value) mode,
    required TResult Function(
            RunObjectToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectToolChoiceEnumeration():
        return mode(_that);
      case RunObjectToolChoiceAssistantsNamedToolChoice():
        return tool(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult? Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectToolChoiceEnumeration() when mode != null:
        return mode(_that);
      case RunObjectToolChoiceAssistantsNamedToolChoice() when tool != null:
        return tool(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectToolChoiceEnumeration() when mode != null:
        return mode(_that.value);
      case RunObjectToolChoiceAssistantsNamedToolChoice() when tool != null:
        return tool(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectToolChoiceEnumeration():
        return mode(_that.value);
      case RunObjectToolChoiceAssistantsNamedToolChoice():
        return tool(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectToolChoiceEnumeration() when mode != null:
        return mode(_that.value);
      case RunObjectToolChoiceAssistantsNamedToolChoice() when tool != null:
        return tool(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunObjectToolChoiceEnumeration extends RunObjectToolChoice {
  const RunObjectToolChoiceEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory RunObjectToolChoiceEnumeration.fromJson(Map<String, dynamic> json) =>
      _$RunObjectToolChoiceEnumerationFromJson(json);

  @override
  final RunObjectToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of RunObjectToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunObjectToolChoiceEnumerationCopyWith<RunObjectToolChoiceEnumeration>
      get copyWith => _$RunObjectToolChoiceEnumerationCopyWithImpl<
          RunObjectToolChoiceEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunObjectToolChoiceEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObjectToolChoiceEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'RunObjectToolChoice.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $RunObjectToolChoiceEnumerationCopyWith<$Res>
    implements $RunObjectToolChoiceCopyWith<$Res> {
  factory $RunObjectToolChoiceEnumerationCopyWith(
          RunObjectToolChoiceEnumeration value,
          $Res Function(RunObjectToolChoiceEnumeration) _then) =
      _$RunObjectToolChoiceEnumerationCopyWithImpl;
  @useResult
  $Res call({RunObjectToolChoiceMode value});
}

/// @nodoc
class _$RunObjectToolChoiceEnumerationCopyWithImpl<$Res>
    implements $RunObjectToolChoiceEnumerationCopyWith<$Res> {
  _$RunObjectToolChoiceEnumerationCopyWithImpl(this._self, this._then);

  final RunObjectToolChoiceEnumeration _self;
  final $Res Function(RunObjectToolChoiceEnumeration) _then;

  /// Create a copy of RunObjectToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(RunObjectToolChoiceEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as RunObjectToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class RunObjectToolChoiceAssistantsNamedToolChoice extends RunObjectToolChoice {
  const RunObjectToolChoiceAssistantsNamedToolChoice(this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();
  factory RunObjectToolChoiceAssistantsNamedToolChoice.fromJson(
          Map<String, dynamic> json) =>
      _$RunObjectToolChoiceAssistantsNamedToolChoiceFromJson(json);

  @override
  final AssistantsNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of RunObjectToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunObjectToolChoiceAssistantsNamedToolChoiceCopyWith<
          RunObjectToolChoiceAssistantsNamedToolChoice>
      get copyWith =>
          _$RunObjectToolChoiceAssistantsNamedToolChoiceCopyWithImpl<
              RunObjectToolChoiceAssistantsNamedToolChoice>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunObjectToolChoiceAssistantsNamedToolChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObjectToolChoiceAssistantsNamedToolChoice &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'RunObjectToolChoice.tool(value: $value)';
  }
}

/// @nodoc
abstract mixin class $RunObjectToolChoiceAssistantsNamedToolChoiceCopyWith<$Res>
    implements $RunObjectToolChoiceCopyWith<$Res> {
  factory $RunObjectToolChoiceAssistantsNamedToolChoiceCopyWith(
          RunObjectToolChoiceAssistantsNamedToolChoice value,
          $Res Function(RunObjectToolChoiceAssistantsNamedToolChoice) _then) =
      _$RunObjectToolChoiceAssistantsNamedToolChoiceCopyWithImpl;
  @useResult
  $Res call({AssistantsNamedToolChoice value});

  $AssistantsNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class _$RunObjectToolChoiceAssistantsNamedToolChoiceCopyWithImpl<$Res>
    implements $RunObjectToolChoiceAssistantsNamedToolChoiceCopyWith<$Res> {
  _$RunObjectToolChoiceAssistantsNamedToolChoiceCopyWithImpl(
      this._self, this._then);

  final RunObjectToolChoiceAssistantsNamedToolChoice _self;
  final $Res Function(RunObjectToolChoiceAssistantsNamedToolChoice) _then;

  /// Create a copy of RunObjectToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(RunObjectToolChoiceAssistantsNamedToolChoice(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsNamedToolChoice,
    ));
  }

  /// Create a copy of RunObjectToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantsNamedToolChoiceCopyWith<$Res> get value {
    return $AssistantsNamedToolChoiceCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

RunObjectResponseFormat _$RunObjectResponseFormatFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return RunObjectResponseFormatEnumeration.fromJson(json);
    case 'responseFormat':
      return RunObjectResponseFormatResponseFormat.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'RunObjectResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$RunObjectResponseFormat {
  Object get value;

  /// Serializes this RunObjectResponseFormat to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObjectResponseFormat &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'RunObjectResponseFormat(value: $value)';
  }
}

/// @nodoc
class $RunObjectResponseFormatCopyWith<$Res> {
  $RunObjectResponseFormatCopyWith(
      RunObjectResponseFormat _, $Res Function(RunObjectResponseFormat) __);
}

/// Adds pattern-matching-related methods to [RunObjectResponseFormat].
extension RunObjectResponseFormatPatterns on RunObjectResponseFormat {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult Function(RunObjectResponseFormatResponseFormat value)?
        responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case RunObjectResponseFormatResponseFormat() when responseFormat != null:
        return responseFormat(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatEnumeration value) mode,
    required TResult Function(RunObjectResponseFormatResponseFormat value)
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectResponseFormatEnumeration():
        return mode(_that);
      case RunObjectResponseFormatResponseFormat():
        return responseFormat(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult? Function(RunObjectResponseFormatResponseFormat value)?
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case RunObjectResponseFormatResponseFormat() when responseFormat != null:
        return responseFormat(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatMode value)? mode,
    TResult Function(ResponseFormat value)? responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case RunObjectResponseFormatResponseFormat() when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatMode value) mode,
    required TResult Function(ResponseFormat value) responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectResponseFormatEnumeration():
        return mode(_that.value);
      case RunObjectResponseFormatResponseFormat():
        return responseFormat(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatMode value)? mode,
    TResult? Function(ResponseFormat value)? responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case RunObjectResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case RunObjectResponseFormatResponseFormat() when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunObjectResponseFormatEnumeration extends RunObjectResponseFormat {
  const RunObjectResponseFormatEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory RunObjectResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$RunObjectResponseFormatEnumerationFromJson(json);

  @override
  final RunObjectResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of RunObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunObjectResponseFormatEnumerationCopyWith<
          RunObjectResponseFormatEnumeration>
      get copyWith => _$RunObjectResponseFormatEnumerationCopyWithImpl<
          RunObjectResponseFormatEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunObjectResponseFormatEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObjectResponseFormatEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'RunObjectResponseFormat.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $RunObjectResponseFormatEnumerationCopyWith<$Res>
    implements $RunObjectResponseFormatCopyWith<$Res> {
  factory $RunObjectResponseFormatEnumerationCopyWith(
          RunObjectResponseFormatEnumeration value,
          $Res Function(RunObjectResponseFormatEnumeration) _then) =
      _$RunObjectResponseFormatEnumerationCopyWithImpl;
  @useResult
  $Res call({RunObjectResponseFormatMode value});
}

/// @nodoc
class _$RunObjectResponseFormatEnumerationCopyWithImpl<$Res>
    implements $RunObjectResponseFormatEnumerationCopyWith<$Res> {
  _$RunObjectResponseFormatEnumerationCopyWithImpl(this._self, this._then);

  final RunObjectResponseFormatEnumeration _self;
  final $Res Function(RunObjectResponseFormatEnumeration) _then;

  /// Create a copy of RunObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(RunObjectResponseFormatEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as RunObjectResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class RunObjectResponseFormatResponseFormat extends RunObjectResponseFormat {
  const RunObjectResponseFormatResponseFormat(this.value, {final String? $type})
      : $type = $type ?? 'responseFormat',
        super._();
  factory RunObjectResponseFormatResponseFormat.fromJson(
          Map<String, dynamic> json) =>
      _$RunObjectResponseFormatResponseFormatFromJson(json);

  @override
  final ResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of RunObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunObjectResponseFormatResponseFormatCopyWith<
          RunObjectResponseFormatResponseFormat>
      get copyWith => _$RunObjectResponseFormatResponseFormatCopyWithImpl<
          RunObjectResponseFormatResponseFormat>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunObjectResponseFormatResponseFormatToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunObjectResponseFormatResponseFormat &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'RunObjectResponseFormat.responseFormat(value: $value)';
  }
}

/// @nodoc
abstract mixin class $RunObjectResponseFormatResponseFormatCopyWith<$Res>
    implements $RunObjectResponseFormatCopyWith<$Res> {
  factory $RunObjectResponseFormatResponseFormatCopyWith(
          RunObjectResponseFormatResponseFormat value,
          $Res Function(RunObjectResponseFormatResponseFormat) _then) =
      _$RunObjectResponseFormatResponseFormatCopyWithImpl;
  @useResult
  $Res call({ResponseFormat value});

  $ResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class _$RunObjectResponseFormatResponseFormatCopyWithImpl<$Res>
    implements $RunObjectResponseFormatResponseFormatCopyWith<$Res> {
  _$RunObjectResponseFormatResponseFormatCopyWithImpl(this._self, this._then);

  final RunObjectResponseFormatResponseFormat _self;
  final $Res Function(RunObjectResponseFormatResponseFormat) _then;

  /// Create a copy of RunObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(RunObjectResponseFormatResponseFormat(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ResponseFormat,
    ));
  }

  /// Create a copy of RunObjectResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res> get value {
    return $ResponseFormatCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

/// @nodoc
mixin _$RunSubmitToolOutputs {
  /// A list of the relevant tool calls.
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls;

  /// Create a copy of RunSubmitToolOutputs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunSubmitToolOutputsCopyWith<RunSubmitToolOutputs> get copyWith =>
      _$RunSubmitToolOutputsCopyWithImpl<RunSubmitToolOutputs>(
          this as RunSubmitToolOutputs, _$identity);

  /// Serializes this RunSubmitToolOutputs to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunSubmitToolOutputs &&
            const DeepCollectionEquality().equals(other.toolCalls, toolCalls));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(toolCalls));

  @override
  String toString() {
    return 'RunSubmitToolOutputs(toolCalls: $toolCalls)';
  }
}

/// @nodoc
abstract mixin class $RunSubmitToolOutputsCopyWith<$Res> {
  factory $RunSubmitToolOutputsCopyWith(RunSubmitToolOutputs value,
          $Res Function(RunSubmitToolOutputs) _then) =
      _$RunSubmitToolOutputsCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls});
}

/// @nodoc
class _$RunSubmitToolOutputsCopyWithImpl<$Res>
    implements $RunSubmitToolOutputsCopyWith<$Res> {
  _$RunSubmitToolOutputsCopyWithImpl(this._self, this._then);

  final RunSubmitToolOutputs _self;
  final $Res Function(RunSubmitToolOutputs) _then;

  /// Create a copy of RunSubmitToolOutputs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCalls = null,
  }) {
    return _then(_self.copyWith(
      toolCalls: null == toolCalls
          ? _self.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunToolCallObject>,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunSubmitToolOutputs].
extension RunSubmitToolOutputsPatterns on RunSubmitToolOutputs {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunSubmitToolOutputs value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutputs() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunSubmitToolOutputs value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutputs():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunSubmitToolOutputs value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutputs() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutputs() when $default != null:
        return $default(_that.toolCalls);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutputs():
        return $default(_that.toolCalls);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutputs() when $default != null:
        return $default(_that.toolCalls);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunSubmitToolOutputs extends RunSubmitToolOutputs {
  const _RunSubmitToolOutputs(
      {@JsonKey(name: 'tool_calls')
      required final List<RunToolCallObject> toolCalls})
      : _toolCalls = toolCalls,
        super._();
  factory _RunSubmitToolOutputs.fromJson(Map<String, dynamic> json) =>
      _$RunSubmitToolOutputsFromJson(json);

  /// A list of the relevant tool calls.
  final List<RunToolCallObject> _toolCalls;

  /// A list of the relevant tool calls.
  @override
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls {
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolCalls);
  }

  /// Create a copy of RunSubmitToolOutputs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunSubmitToolOutputsCopyWith<_RunSubmitToolOutputs> get copyWith =>
      __$RunSubmitToolOutputsCopyWithImpl<_RunSubmitToolOutputs>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunSubmitToolOutputsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunSubmitToolOutputs &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_toolCalls));

  @override
  String toString() {
    return 'RunSubmitToolOutputs(toolCalls: $toolCalls)';
  }
}

/// @nodoc
abstract mixin class _$RunSubmitToolOutputsCopyWith<$Res>
    implements $RunSubmitToolOutputsCopyWith<$Res> {
  factory _$RunSubmitToolOutputsCopyWith(_RunSubmitToolOutputs value,
          $Res Function(_RunSubmitToolOutputs) _then) =
      __$RunSubmitToolOutputsCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls});
}

/// @nodoc
class __$RunSubmitToolOutputsCopyWithImpl<$Res>
    implements _$RunSubmitToolOutputsCopyWith<$Res> {
  __$RunSubmitToolOutputsCopyWithImpl(this._self, this._then);

  final _RunSubmitToolOutputs _self;
  final $Res Function(_RunSubmitToolOutputs) _then;

  /// Create a copy of RunSubmitToolOutputs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? toolCalls = null,
  }) {
    return _then(_RunSubmitToolOutputs(
      toolCalls: null == toolCalls
          ? _self._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunToolCallObject>,
    ));
  }
}

/// @nodoc
mixin _$RunCompletionUsage {
  /// Number of completion tokens used over the course of the run.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens;

  /// Number of prompt tokens used over the course of the run.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;

  /// Create a copy of RunCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunCompletionUsageCopyWith<RunCompletionUsage> get copyWith =>
      _$RunCompletionUsageCopyWithImpl<RunCompletionUsage>(
          this as RunCompletionUsage, _$identity);

  /// Serializes this RunCompletionUsage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunCompletionUsage &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @override
  String toString() {
    return 'RunCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }
}

/// @nodoc
abstract mixin class $RunCompletionUsageCopyWith<$Res> {
  factory $RunCompletionUsageCopyWith(
          RunCompletionUsage value, $Res Function(RunCompletionUsage) _then) =
      _$RunCompletionUsageCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$RunCompletionUsageCopyWithImpl<$Res>
    implements $RunCompletionUsageCopyWith<$Res> {
  _$RunCompletionUsageCopyWithImpl(this._self, this._then);

  final RunCompletionUsage _self;
  final $Res Function(RunCompletionUsage) _then;

  /// Create a copy of RunCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_self.copyWith(
      completionTokens: null == completionTokens
          ? _self.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunCompletionUsage].
extension RunCompletionUsagePatterns on RunCompletionUsage {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunCompletionUsage value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunCompletionUsage() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunCompletionUsage value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunCompletionUsage():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunCompletionUsage value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunCompletionUsage() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'completion_tokens') int completionTokens,
            @JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunCompletionUsage() when $default != null:
        return $default(
            _that.completionTokens, _that.promptTokens, _that.totalTokens);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'completion_tokens') int completionTokens,
            @JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunCompletionUsage():
        return $default(
            _that.completionTokens, _that.promptTokens, _that.totalTokens);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'completion_tokens') int completionTokens,
            @JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunCompletionUsage() when $default != null:
        return $default(
            _that.completionTokens, _that.promptTokens, _that.totalTokens);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunCompletionUsage extends RunCompletionUsage {
  const _RunCompletionUsage(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();
  factory _RunCompletionUsage.fromJson(Map<String, dynamic> json) =>
      _$RunCompletionUsageFromJson(json);

  /// Number of completion tokens used over the course of the run.
  @override
  @JsonKey(name: 'completion_tokens')
  final int completionTokens;

  /// Number of prompt tokens used over the course of the run.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  /// Create a copy of RunCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunCompletionUsageCopyWith<_RunCompletionUsage> get copyWith =>
      __$RunCompletionUsageCopyWithImpl<_RunCompletionUsage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunCompletionUsageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunCompletionUsage &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @override
  String toString() {
    return 'RunCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }
}

/// @nodoc
abstract mixin class _$RunCompletionUsageCopyWith<$Res>
    implements $RunCompletionUsageCopyWith<$Res> {
  factory _$RunCompletionUsageCopyWith(
          _RunCompletionUsage value, $Res Function(_RunCompletionUsage) _then) =
      __$RunCompletionUsageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$RunCompletionUsageCopyWithImpl<$Res>
    implements _$RunCompletionUsageCopyWith<$Res> {
  __$RunCompletionUsageCopyWithImpl(this._self, this._then);

  final _RunCompletionUsage _self;
  final $Res Function(_RunCompletionUsage) _then;

  /// Create a copy of RunCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_RunCompletionUsage(
      completionTokens: null == completionTokens
          ? _self.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$CreateRunRequest {
  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @_CreateRunRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateRunRequestModel? get model;

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions;

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  String? get additionalInstructions;

  /// Adds additional messages to the thread before creating the run.
  @JsonKey(name: 'additional_messages', includeIfNull: false)
  List<CreateMessageRequest>? get additionalMessages;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  int? get maxPromptTokens;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  int? get maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run.
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  TruncationObject? get truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_CreateRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  CreateRunRequestToolChoice? get toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateRunRequestResponseFormat? get responseFormat;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream;

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateRunRequestCopyWith<CreateRunRequest> get copyWith =>
      _$CreateRunRequestCopyWithImpl<CreateRunRequest>(
          this as CreateRunRequest, _$identity);

  /// Serializes this CreateRunRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequest &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            (identical(other.additionalInstructions, additionalInstructions) ||
                other.additionalInstructions == additionalInstructions) &&
            const DeepCollectionEquality()
                .equals(other.additionalMessages, additionalMessages) &&
            const DeepCollectionEquality().equals(other.tools, tools) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      model,
      instructions,
      additionalInstructions,
      const DeepCollectionEquality().hash(additionalMessages),
      const DeepCollectionEquality().hash(tools),
      const DeepCollectionEquality().hash(metadata),
      temperature,
      topP,
      maxPromptTokens,
      maxCompletionTokens,
      truncationStrategy,
      toolChoice,
      parallelToolCalls,
      responseFormat,
      stream);

  @override
  String toString() {
    return 'CreateRunRequest(assistantId: $assistantId, model: $model, instructions: $instructions, additionalInstructions: $additionalInstructions, additionalMessages: $additionalMessages, tools: $tools, metadata: $metadata, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat, stream: $stream)';
  }
}

/// @nodoc
abstract mixin class $CreateRunRequestCopyWith<$Res> {
  factory $CreateRunRequestCopyWith(
          CreateRunRequest value, $Res Function(CreateRunRequest) _then) =
      _$CreateRunRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @_CreateRunRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateRunRequestModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      String? additionalInstructions,
      @JsonKey(name: 'additional_messages', includeIfNull: false)
      List<CreateMessageRequest>? additionalMessages,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  $CreateRunRequestModelCopyWith<$Res>? get model;
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  $CreateRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  $CreateRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$CreateRunRequestCopyWithImpl<$Res>
    implements $CreateRunRequestCopyWith<$Res> {
  _$CreateRunRequestCopyWithImpl(this._self, this._then);

  final CreateRunRequest _self;
  final $Res Function(CreateRunRequest) _then;

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? additionalInstructions = freezed,
    Object? additionalMessages = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_self.copyWith(
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestModel?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInstructions: freezed == additionalInstructions
          ? _self.additionalInstructions
          : additionalInstructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalMessages: freezed == additionalMessages
          ? _self.additionalMessages
          : additionalMessages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      tools: freezed == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _self.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _self.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestResponseFormat?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $CreateRunRequestModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_self.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_self.truncationStrategy!, (value) {
      return _then(_self.copyWith(truncationStrategy: value));
    });
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestToolChoiceCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $CreateRunRequestToolChoiceCopyWith<$Res>(_self.toolChoice!,
        (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $CreateRunRequestResponseFormatCopyWith<$Res>(_self.responseFormat!,
        (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateRunRequest].
extension CreateRunRequestPatterns on CreateRunRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateRunRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateRunRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateRunRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateRunRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateRunRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateRunRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'assistant_id') String assistantId,
            @_CreateRunRequestModelConverter()
            @JsonKey(includeIfNull: false)
            CreateRunRequestModel? model,
            @JsonKey(includeIfNull: false) String? instructions,
            @JsonKey(name: 'additional_instructions', includeIfNull: false)
            String? additionalInstructions,
            @JsonKey(name: 'additional_messages', includeIfNull: false)
            List<CreateMessageRequest>? additionalMessages,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
            int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy', includeIfNull: false)
            TruncationObject? truncationStrategy,
            @_CreateRunRequestToolChoiceConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            CreateRunRequestToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @_CreateRunRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateRunRequestResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) bool? stream)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateRunRequest() when $default != null:
        return $default(
            _that.assistantId,
            _that.model,
            _that.instructions,
            _that.additionalInstructions,
            _that.additionalMessages,
            _that.tools,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat,
            _that.stream);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'assistant_id') String assistantId,
            @_CreateRunRequestModelConverter()
            @JsonKey(includeIfNull: false)
            CreateRunRequestModel? model,
            @JsonKey(includeIfNull: false) String? instructions,
            @JsonKey(name: 'additional_instructions', includeIfNull: false)
            String? additionalInstructions,
            @JsonKey(name: 'additional_messages', includeIfNull: false)
            List<CreateMessageRequest>? additionalMessages,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
            int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy', includeIfNull: false)
            TruncationObject? truncationStrategy,
            @_CreateRunRequestToolChoiceConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            CreateRunRequestToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @_CreateRunRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateRunRequestResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) bool? stream)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateRunRequest():
        return $default(
            _that.assistantId,
            _that.model,
            _that.instructions,
            _that.additionalInstructions,
            _that.additionalMessages,
            _that.tools,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat,
            _that.stream);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'assistant_id') String assistantId,
            @_CreateRunRequestModelConverter()
            @JsonKey(includeIfNull: false)
            CreateRunRequestModel? model,
            @JsonKey(includeIfNull: false) String? instructions,
            @JsonKey(name: 'additional_instructions', includeIfNull: false)
            String? additionalInstructions,
            @JsonKey(name: 'additional_messages', includeIfNull: false)
            List<CreateMessageRequest>? additionalMessages,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
            int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy', includeIfNull: false)
            TruncationObject? truncationStrategy,
            @_CreateRunRequestToolChoiceConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            CreateRunRequestToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @_CreateRunRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateRunRequestResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) bool? stream)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateRunRequest() when $default != null:
        return $default(
            _that.assistantId,
            _that.model,
            _that.instructions,
            _that.additionalInstructions,
            _that.additionalMessages,
            _that.tools,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat,
            _that.stream);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateRunRequest extends CreateRunRequest {
  const _CreateRunRequest(
      {@JsonKey(name: 'assistant_id') required this.assistantId,
      @_CreateRunRequestModelConverter()
      @JsonKey(includeIfNull: false)
      this.model,
      @JsonKey(includeIfNull: false) this.instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      this.additionalInstructions,
      @JsonKey(name: 'additional_messages', includeIfNull: false)
      final List<CreateMessageRequest>? additionalMessages,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      this.maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      this.maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      this.truncationStrategy,
      @_CreateRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      this.parallelToolCalls,
      @_CreateRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.stream})
      : _additionalMessages = additionalMessages,
        _tools = tools,
        _metadata = metadata,
        super._();
  factory _CreateRunRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateRunRequestFromJson(json);

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @override
  @_CreateRunRequestModelConverter()
  @JsonKey(includeIfNull: false)
  final CreateRunRequestModel? model;

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @override
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  final String? additionalInstructions;

  /// Adds additional messages to the thread before creating the run.
  final List<CreateMessageRequest>? _additionalMessages;

  /// Adds additional messages to the thread before creating the run.
  @override
  @JsonKey(name: 'additional_messages', includeIfNull: false)
  List<CreateMessageRequest>? get additionalMessages {
    final value = _additionalMessages;
    if (value == null) return null;
    if (_additionalMessages is EqualUnmodifiableListView)
      return _additionalMessages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  final List<AssistantTools>? _tools;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  final int? maxPromptTokens;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  final int? maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run.
  @override
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  final TruncationObject? truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @override
  @_CreateRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final CreateRunRequestToolChoice? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  final bool? parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_CreateRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final CreateRunRequestResponseFormat? responseFormat;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateRunRequestCopyWith<_CreateRunRequest> get copyWith =>
      __$CreateRunRequestCopyWithImpl<_CreateRunRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateRunRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateRunRequest &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            (identical(other.additionalInstructions, additionalInstructions) ||
                other.additionalInstructions == additionalInstructions) &&
            const DeepCollectionEquality()
                .equals(other._additionalMessages, _additionalMessages) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      model,
      instructions,
      additionalInstructions,
      const DeepCollectionEquality().hash(_additionalMessages),
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      maxPromptTokens,
      maxCompletionTokens,
      truncationStrategy,
      toolChoice,
      parallelToolCalls,
      responseFormat,
      stream);

  @override
  String toString() {
    return 'CreateRunRequest(assistantId: $assistantId, model: $model, instructions: $instructions, additionalInstructions: $additionalInstructions, additionalMessages: $additionalMessages, tools: $tools, metadata: $metadata, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat, stream: $stream)';
  }
}

/// @nodoc
abstract mixin class _$CreateRunRequestCopyWith<$Res>
    implements $CreateRunRequestCopyWith<$Res> {
  factory _$CreateRunRequestCopyWith(
          _CreateRunRequest value, $Res Function(_CreateRunRequest) _then) =
      __$CreateRunRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @_CreateRunRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateRunRequestModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      String? additionalInstructions,
      @JsonKey(name: 'additional_messages', includeIfNull: false)
      List<CreateMessageRequest>? additionalMessages,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  @override
  $CreateRunRequestModelCopyWith<$Res>? get model;
  @override
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  @override
  $CreateRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  @override
  $CreateRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$CreateRunRequestCopyWithImpl<$Res>
    implements _$CreateRunRequestCopyWith<$Res> {
  __$CreateRunRequestCopyWithImpl(this._self, this._then);

  final _CreateRunRequest _self;
  final $Res Function(_CreateRunRequest) _then;

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? assistantId = null,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? additionalInstructions = freezed,
    Object? additionalMessages = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_CreateRunRequest(
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestModel?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInstructions: freezed == additionalInstructions
          ? _self.additionalInstructions
          : additionalInstructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalMessages: freezed == additionalMessages
          ? _self._additionalMessages
          : additionalMessages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      tools: freezed == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _self.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _self.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestResponseFormat?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $CreateRunRequestModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_self.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_self.truncationStrategy!, (value) {
      return _then(_self.copyWith(truncationStrategy: value));
    });
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestToolChoiceCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $CreateRunRequestToolChoiceCopyWith<$Res>(_self.toolChoice!,
        (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of CreateRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $CreateRunRequestResponseFormatCopyWith<$Res>(_self.responseFormat!,
        (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

CreateRunRequestModel _$CreateRunRequestModelFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CreateRunRequestModelEnumeration.fromJson(json);
    case 'modelId':
      return CreateRunRequestModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateRunRequestModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateRunRequestModel {
  Object get value;

  /// Serializes this CreateRunRequestModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateRunRequestModel(value: $value)';
  }
}

/// @nodoc
class $CreateRunRequestModelCopyWith<$Res> {
  $CreateRunRequestModelCopyWith(
      CreateRunRequestModel _, $Res Function(CreateRunRequestModel) __);
}

/// Adds pattern-matching-related methods to [CreateRunRequestModel].
extension CreateRunRequestModelPatterns on CreateRunRequestModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestModelEnumeration value)? model,
    TResult Function(CreateRunRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestModelEnumeration() when model != null:
        return model(_that);
      case CreateRunRequestModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestModelEnumeration value) model,
    required TResult Function(CreateRunRequestModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestModelEnumeration():
        return model(_that);
      case CreateRunRequestModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestModelEnumeration value)? model,
    TResult? Function(CreateRunRequestModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestModelEnumeration() when model != null:
        return model(_that);
      case CreateRunRequestModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestModelEnumeration() when model != null:
        return model(_that.value);
      case CreateRunRequestModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestModelEnumeration():
        return model(_that.value);
      case CreateRunRequestModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestModelEnumeration() when model != null:
        return model(_that.value);
      case CreateRunRequestModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateRunRequestModelEnumeration extends CreateRunRequestModel {
  const CreateRunRequestModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory CreateRunRequestModelEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$CreateRunRequestModelEnumerationFromJson(json);

  @override
  final RunModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateRunRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateRunRequestModelEnumerationCopyWith<CreateRunRequestModelEnumeration>
      get copyWith => _$CreateRunRequestModelEnumerationCopyWithImpl<
          CreateRunRequestModelEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateRunRequestModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateRunRequestModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateRunRequestModelEnumerationCopyWith<$Res>
    implements $CreateRunRequestModelCopyWith<$Res> {
  factory $CreateRunRequestModelEnumerationCopyWith(
          CreateRunRequestModelEnumeration value,
          $Res Function(CreateRunRequestModelEnumeration) _then) =
      _$CreateRunRequestModelEnumerationCopyWithImpl;
  @useResult
  $Res call({RunModels value});
}

/// @nodoc
class _$CreateRunRequestModelEnumerationCopyWithImpl<$Res>
    implements $CreateRunRequestModelEnumerationCopyWith<$Res> {
  _$CreateRunRequestModelEnumerationCopyWithImpl(this._self, this._then);

  final CreateRunRequestModelEnumeration _self;
  final $Res Function(CreateRunRequestModelEnumeration) _then;

  /// Create a copy of CreateRunRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateRunRequestModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as RunModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateRunRequestModelString extends CreateRunRequestModel {
  const CreateRunRequestModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory CreateRunRequestModelString.fromJson(Map<String, dynamic> json) =>
      _$CreateRunRequestModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateRunRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateRunRequestModelStringCopyWith<CreateRunRequestModelString>
      get copyWith => _$CreateRunRequestModelStringCopyWithImpl<
          CreateRunRequestModelString>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateRunRequestModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateRunRequestModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateRunRequestModelStringCopyWith<$Res>
    implements $CreateRunRequestModelCopyWith<$Res> {
  factory $CreateRunRequestModelStringCopyWith(
          CreateRunRequestModelString value,
          $Res Function(CreateRunRequestModelString) _then) =
      _$CreateRunRequestModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$CreateRunRequestModelStringCopyWithImpl<$Res>
    implements $CreateRunRequestModelStringCopyWith<$Res> {
  _$CreateRunRequestModelStringCopyWithImpl(this._self, this._then);

  final CreateRunRequestModelString _self;
  final $Res Function(CreateRunRequestModelString) _then;

  /// Create a copy of CreateRunRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateRunRequestModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

CreateRunRequestToolChoice _$CreateRunRequestToolChoiceFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateRunRequestToolChoiceEnumeration.fromJson(json);
    case 'tool':
      return CreateRunRequestToolChoiceAssistantsNamedToolChoice.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateRunRequestToolChoice',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateRunRequestToolChoice {
  Object get value;

  /// Serializes this CreateRunRequestToolChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestToolChoice &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateRunRequestToolChoice(value: $value)';
  }
}

/// @nodoc
class $CreateRunRequestToolChoiceCopyWith<$Res> {
  $CreateRunRequestToolChoiceCopyWith(CreateRunRequestToolChoice _,
      $Res Function(CreateRunRequestToolChoice) __);
}

/// Adds pattern-matching-related methods to [CreateRunRequestToolChoice].
extension CreateRunRequestToolChoicePatterns on CreateRunRequestToolChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult Function(CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that);
      case CreateRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceEnumeration value) mode,
    required TResult Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestToolChoiceEnumeration():
        return mode(_that);
      case CreateRunRequestToolChoiceAssistantsNamedToolChoice():
        return tool(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult? Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that);
      case CreateRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that.value);
      case CreateRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestToolChoiceEnumeration():
        return mode(_that.value);
      case CreateRunRequestToolChoiceAssistantsNamedToolChoice():
        return tool(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that.value);
      case CreateRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateRunRequestToolChoiceEnumeration extends CreateRunRequestToolChoice {
  const CreateRunRequestToolChoiceEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory CreateRunRequestToolChoiceEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$CreateRunRequestToolChoiceEnumerationFromJson(json);

  @override
  final CreateRunRequestToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateRunRequestToolChoiceEnumerationCopyWith<
          CreateRunRequestToolChoiceEnumeration>
      get copyWith => _$CreateRunRequestToolChoiceEnumerationCopyWithImpl<
          CreateRunRequestToolChoiceEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateRunRequestToolChoiceEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestToolChoiceEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateRunRequestToolChoice.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateRunRequestToolChoiceEnumerationCopyWith<$Res>
    implements $CreateRunRequestToolChoiceCopyWith<$Res> {
  factory $CreateRunRequestToolChoiceEnumerationCopyWith(
          CreateRunRequestToolChoiceEnumeration value,
          $Res Function(CreateRunRequestToolChoiceEnumeration) _then) =
      _$CreateRunRequestToolChoiceEnumerationCopyWithImpl;
  @useResult
  $Res call({CreateRunRequestToolChoiceMode value});
}

/// @nodoc
class _$CreateRunRequestToolChoiceEnumerationCopyWithImpl<$Res>
    implements $CreateRunRequestToolChoiceEnumerationCopyWith<$Res> {
  _$CreateRunRequestToolChoiceEnumerationCopyWithImpl(this._self, this._then);

  final CreateRunRequestToolChoiceEnumeration _self;
  final $Res Function(CreateRunRequestToolChoiceEnumeration) _then;

  /// Create a copy of CreateRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateRunRequestToolChoiceEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateRunRequestToolChoiceAssistantsNamedToolChoice
    extends CreateRunRequestToolChoice {
  const CreateRunRequestToolChoiceAssistantsNamedToolChoice(this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();
  factory CreateRunRequestToolChoiceAssistantsNamedToolChoice.fromJson(
          Map<String, dynamic> json) =>
      _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceFromJson(json);

  @override
  final AssistantsNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith<
          CreateRunRequestToolChoiceAssistantsNamedToolChoice>
      get copyWith =>
          _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl<
                  CreateRunRequestToolChoiceAssistantsNamedToolChoice>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestToolChoiceAssistantsNamedToolChoice &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateRunRequestToolChoice.tool(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith<
    $Res> implements $CreateRunRequestToolChoiceCopyWith<$Res> {
  factory $CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith(
          CreateRunRequestToolChoiceAssistantsNamedToolChoice value,
          $Res Function(CreateRunRequestToolChoiceAssistantsNamedToolChoice)
              _then) =
      _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl;
  @useResult
  $Res call({AssistantsNamedToolChoice value});

  $AssistantsNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl<$Res>
    implements
        $CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith<$Res> {
  _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl(
      this._self, this._then);

  final CreateRunRequestToolChoiceAssistantsNamedToolChoice _self;
  final $Res Function(CreateRunRequestToolChoiceAssistantsNamedToolChoice)
      _then;

  /// Create a copy of CreateRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateRunRequestToolChoiceAssistantsNamedToolChoice(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsNamedToolChoice,
    ));
  }

  /// Create a copy of CreateRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantsNamedToolChoiceCopyWith<$Res> get value {
    return $AssistantsNamedToolChoiceCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

CreateRunRequestResponseFormat _$CreateRunRequestResponseFormatFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateRunRequestResponseFormatEnumeration.fromJson(json);
    case 'responseFormat':
      return CreateRunRequestResponseFormatResponseFormat.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateRunRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateRunRequestResponseFormat {
  Object get value;

  /// Serializes this CreateRunRequestResponseFormat to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestResponseFormat &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateRunRequestResponseFormat(value: $value)';
  }
}

/// @nodoc
class $CreateRunRequestResponseFormatCopyWith<$Res> {
  $CreateRunRequestResponseFormatCopyWith(CreateRunRequestResponseFormat _,
      $Res Function(CreateRunRequestResponseFormat) __);
}

/// Adds pattern-matching-related methods to [CreateRunRequestResponseFormat].
extension CreateRunRequestResponseFormatPatterns
    on CreateRunRequestResponseFormat {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult Function(CreateRunRequestResponseFormatResponseFormat value)?
        responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case CreateRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateRunRequestResponseFormatResponseFormat value)
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestResponseFormatEnumeration():
        return mode(_that);
      case CreateRunRequestResponseFormatResponseFormat():
        return responseFormat(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult? Function(CreateRunRequestResponseFormatResponseFormat value)?
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestResponseFormatEnumeration() when mode != null:
        return mode(_that);
      case CreateRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult Function(ResponseFormat value)? responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case CreateRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatMode value) mode,
    required TResult Function(ResponseFormat value) responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestResponseFormatEnumeration():
        return mode(_that.value);
      case CreateRunRequestResponseFormatResponseFormat():
        return responseFormat(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult? Function(ResponseFormat value)? responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateRunRequestResponseFormatEnumeration() when mode != null:
        return mode(_that.value);
      case CreateRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateRunRequestResponseFormatEnumeration
    extends CreateRunRequestResponseFormat {
  const CreateRunRequestResponseFormatEnumeration(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory CreateRunRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$CreateRunRequestResponseFormatEnumerationFromJson(json);

  @override
  final CreateRunRequestResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateRunRequestResponseFormatEnumerationCopyWith<
          CreateRunRequestResponseFormatEnumeration>
      get copyWith => _$CreateRunRequestResponseFormatEnumerationCopyWithImpl<
          CreateRunRequestResponseFormatEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateRunRequestResponseFormatEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestResponseFormatEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateRunRequestResponseFormat.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateRunRequestResponseFormatEnumerationCopyWith<$Res>
    implements $CreateRunRequestResponseFormatCopyWith<$Res> {
  factory $CreateRunRequestResponseFormatEnumerationCopyWith(
          CreateRunRequestResponseFormatEnumeration value,
          $Res Function(CreateRunRequestResponseFormatEnumeration) _then) =
      _$CreateRunRequestResponseFormatEnumerationCopyWithImpl;
  @useResult
  $Res call({CreateRunRequestResponseFormatMode value});
}

/// @nodoc
class _$CreateRunRequestResponseFormatEnumerationCopyWithImpl<$Res>
    implements $CreateRunRequestResponseFormatEnumerationCopyWith<$Res> {
  _$CreateRunRequestResponseFormatEnumerationCopyWithImpl(
      this._self, this._then);

  final CreateRunRequestResponseFormatEnumeration _self;
  final $Res Function(CreateRunRequestResponseFormatEnumeration) _then;

  /// Create a copy of CreateRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateRunRequestResponseFormatEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateRunRequestResponseFormatResponseFormat
    extends CreateRunRequestResponseFormat {
  const CreateRunRequestResponseFormatResponseFormat(this.value,
      {final String? $type})
      : $type = $type ?? 'responseFormat',
        super._();
  factory CreateRunRequestResponseFormatResponseFormat.fromJson(
          Map<String, dynamic> json) =>
      _$CreateRunRequestResponseFormatResponseFormatFromJson(json);

  @override
  final ResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateRunRequestResponseFormatResponseFormatCopyWith<
          CreateRunRequestResponseFormatResponseFormat>
      get copyWith =>
          _$CreateRunRequestResponseFormatResponseFormatCopyWithImpl<
              CreateRunRequestResponseFormatResponseFormat>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateRunRequestResponseFormatResponseFormatToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateRunRequestResponseFormatResponseFormat &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateRunRequestResponseFormat.responseFormat(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateRunRequestResponseFormatResponseFormatCopyWith<$Res>
    implements $CreateRunRequestResponseFormatCopyWith<$Res> {
  factory $CreateRunRequestResponseFormatResponseFormatCopyWith(
          CreateRunRequestResponseFormatResponseFormat value,
          $Res Function(CreateRunRequestResponseFormatResponseFormat) _then) =
      _$CreateRunRequestResponseFormatResponseFormatCopyWithImpl;
  @useResult
  $Res call({ResponseFormat value});

  $ResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class _$CreateRunRequestResponseFormatResponseFormatCopyWithImpl<$Res>
    implements $CreateRunRequestResponseFormatResponseFormatCopyWith<$Res> {
  _$CreateRunRequestResponseFormatResponseFormatCopyWithImpl(
      this._self, this._then);

  final CreateRunRequestResponseFormatResponseFormat _self;
  final $Res Function(CreateRunRequestResponseFormatResponseFormat) _then;

  /// Create a copy of CreateRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateRunRequestResponseFormatResponseFormat(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ResponseFormat,
    ));
  }

  /// Create a copy of CreateRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res> get value {
    return $ResponseFormatCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

/// @nodoc
mixin _$ListRunsResponse {
  /// The object type, which is always `list`.
  String get object;

  /// The list of runs.
  List<RunObject> get data;

  /// The ID of the first run in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last run in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more runs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListRunsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListRunsResponseCopyWith<ListRunsResponse> get copyWith =>
      _$ListRunsResponseCopyWithImpl<ListRunsResponse>(
          this as ListRunsResponse, _$identity);

  /// Serializes this ListRunsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListRunsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListRunsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListRunsResponseCopyWith<$Res> {
  factory $ListRunsResponseCopyWith(
          ListRunsResponse value, $Res Function(ListRunsResponse) _then) =
      _$ListRunsResponseCopyWithImpl;
  @useResult
  $Res call(
      {String object,
      List<RunObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListRunsResponseCopyWithImpl<$Res>
    implements $ListRunsResponseCopyWith<$Res> {
  _$ListRunsResponseCopyWithImpl(this._self, this._then);

  final ListRunsResponse _self;
  final $Res Function(ListRunsResponse) _then;

  /// Create a copy of ListRunsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListRunsResponse].
extension ListRunsResponsePatterns on ListRunsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListRunsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListRunsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListRunsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListRunsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String object,
            List<RunObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListRunsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String object,
            List<RunObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunsResponse():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String object,
            List<RunObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListRunsResponse extends ListRunsResponse {
  const _ListRunsResponse(
      {required this.object,
      required final List<RunObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListRunsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListRunsResponseFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of runs.
  final List<RunObject> _data;

  /// The list of runs.
  @override
  List<RunObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first run in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last run in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more runs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListRunsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListRunsResponseCopyWith<_ListRunsResponse> get copyWith =>
      __$ListRunsResponseCopyWithImpl<_ListRunsResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListRunsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListRunsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListRunsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListRunsResponseCopyWith<$Res>
    implements $ListRunsResponseCopyWith<$Res> {
  factory _$ListRunsResponseCopyWith(
          _ListRunsResponse value, $Res Function(_ListRunsResponse) _then) =
      __$ListRunsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String object,
      List<RunObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListRunsResponseCopyWithImpl<$Res>
    implements _$ListRunsResponseCopyWith<$Res> {
  __$ListRunsResponseCopyWithImpl(this._self, this._then);

  final _ListRunsResponse _self;
  final $Res Function(_ListRunsResponse) _then;

  /// Create a copy of ListRunsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListRunsResponse(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$ModifyRunRequest {
  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// Create a copy of ModifyRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModifyRunRequestCopyWith<ModifyRunRequest> get copyWith =>
      _$ModifyRunRequestCopyWithImpl<ModifyRunRequest>(
          this as ModifyRunRequest, _$identity);

  /// Serializes this ModifyRunRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModifyRunRequest &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'ModifyRunRequest(metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $ModifyRunRequestCopyWith<$Res> {
  factory $ModifyRunRequestCopyWith(
          ModifyRunRequest value, $Res Function(ModifyRunRequest) _then) =
      _$ModifyRunRequestCopyWithImpl;
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyRunRequestCopyWithImpl<$Res>
    implements $ModifyRunRequestCopyWith<$Res> {
  _$ModifyRunRequestCopyWithImpl(this._self, this._then);

  final ModifyRunRequest _self;
  final $Res Function(ModifyRunRequest) _then;

  /// Create a copy of ModifyRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ModifyRunRequest].
extension ModifyRunRequestPatterns on ModifyRunRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModifyRunRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyRunRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModifyRunRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyRunRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModifyRunRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyRunRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyRunRequest() when $default != null:
        return $default(_that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyRunRequest():
        return $default(_that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyRunRequest() when $default != null:
        return $default(_that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModifyRunRequest extends ModifyRunRequest {
  const _ModifyRunRequest(
      {@JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();
  factory _ModifyRunRequest.fromJson(Map<String, dynamic> json) =>
      _$ModifyRunRequestFromJson(json);

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ModifyRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModifyRunRequestCopyWith<_ModifyRunRequest> get copyWith =>
      __$ModifyRunRequestCopyWithImpl<_ModifyRunRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModifyRunRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModifyRunRequest &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'ModifyRunRequest(metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$ModifyRunRequestCopyWith<$Res>
    implements $ModifyRunRequestCopyWith<$Res> {
  factory _$ModifyRunRequestCopyWith(
          _ModifyRunRequest value, $Res Function(_ModifyRunRequest) _then) =
      __$ModifyRunRequestCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$ModifyRunRequestCopyWithImpl<$Res>
    implements _$ModifyRunRequestCopyWith<$Res> {
  __$ModifyRunRequestCopyWithImpl(this._self, this._then);

  final _ModifyRunRequest _self;
  final $Res Function(_ModifyRunRequest) _then;

  /// Create a copy of ModifyRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_ModifyRunRequest(
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
mixin _$SubmitToolOutputsRunRequest {
  /// A list of tools for which the outputs are being submitted.
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream;

  /// Create a copy of SubmitToolOutputsRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SubmitToolOutputsRunRequestCopyWith<SubmitToolOutputsRunRequest>
      get copyWith => _$SubmitToolOutputsRunRequestCopyWithImpl<
              SubmitToolOutputsRunRequest>(
          this as SubmitToolOutputsRunRequest, _$identity);

  /// Serializes this SubmitToolOutputsRunRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SubmitToolOutputsRunRequest &&
            const DeepCollectionEquality()
                .equals(other.toolOutputs, toolOutputs) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(toolOutputs), stream);

  @override
  String toString() {
    return 'SubmitToolOutputsRunRequest(toolOutputs: $toolOutputs, stream: $stream)';
  }
}

/// @nodoc
abstract mixin class $SubmitToolOutputsRunRequestCopyWith<$Res> {
  factory $SubmitToolOutputsRunRequestCopyWith(
          SubmitToolOutputsRunRequest value,
          $Res Function(SubmitToolOutputsRunRequest) _then) =
      _$SubmitToolOutputsRunRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_outputs') List<RunSubmitToolOutput> toolOutputs,
      @JsonKey(includeIfNull: false) bool? stream});
}

/// @nodoc
class _$SubmitToolOutputsRunRequestCopyWithImpl<$Res>
    implements $SubmitToolOutputsRunRequestCopyWith<$Res> {
  _$SubmitToolOutputsRunRequestCopyWithImpl(this._self, this._then);

  final SubmitToolOutputsRunRequest _self;
  final $Res Function(SubmitToolOutputsRunRequest) _then;

  /// Create a copy of SubmitToolOutputsRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolOutputs = null,
    Object? stream = freezed,
  }) {
    return _then(_self.copyWith(
      toolOutputs: null == toolOutputs
          ? _self.toolOutputs
          : toolOutputs // ignore: cast_nullable_to_non_nullable
              as List<RunSubmitToolOutput>,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// Adds pattern-matching-related methods to [SubmitToolOutputsRunRequest].
extension SubmitToolOutputsRunRequestPatterns on SubmitToolOutputsRunRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SubmitToolOutputsRunRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _SubmitToolOutputsRunRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SubmitToolOutputsRunRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubmitToolOutputsRunRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_SubmitToolOutputsRunRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubmitToolOutputsRunRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_outputs')
            List<RunSubmitToolOutput> toolOutputs,
            @JsonKey(includeIfNull: false) bool? stream)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _SubmitToolOutputsRunRequest() when $default != null:
        return $default(_that.toolOutputs, _that.stream);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_outputs')
            List<RunSubmitToolOutput> toolOutputs,
            @JsonKey(includeIfNull: false) bool? stream)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubmitToolOutputsRunRequest():
        return $default(_that.toolOutputs, _that.stream);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'tool_outputs')
            List<RunSubmitToolOutput> toolOutputs,
            @JsonKey(includeIfNull: false) bool? stream)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _SubmitToolOutputsRunRequest() when $default != null:
        return $default(_that.toolOutputs, _that.stream);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _SubmitToolOutputsRunRequest extends SubmitToolOutputsRunRequest {
  const _SubmitToolOutputsRunRequest(
      {@JsonKey(name: 'tool_outputs')
      required final List<RunSubmitToolOutput> toolOutputs,
      @JsonKey(includeIfNull: false) this.stream})
      : _toolOutputs = toolOutputs,
        super._();
  factory _SubmitToolOutputsRunRequest.fromJson(Map<String, dynamic> json) =>
      _$SubmitToolOutputsRunRequestFromJson(json);

  /// A list of tools for which the outputs are being submitted.
  final List<RunSubmitToolOutput> _toolOutputs;

  /// A list of tools for which the outputs are being submitted.
  @override
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs {
    if (_toolOutputs is EqualUnmodifiableListView) return _toolOutputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolOutputs);
  }

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// Create a copy of SubmitToolOutputsRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SubmitToolOutputsRunRequestCopyWith<_SubmitToolOutputsRunRequest>
      get copyWith => __$SubmitToolOutputsRunRequestCopyWithImpl<
          _SubmitToolOutputsRunRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$SubmitToolOutputsRunRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SubmitToolOutputsRunRequest &&
            const DeepCollectionEquality()
                .equals(other._toolOutputs, _toolOutputs) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_toolOutputs), stream);

  @override
  String toString() {
    return 'SubmitToolOutputsRunRequest(toolOutputs: $toolOutputs, stream: $stream)';
  }
}

/// @nodoc
abstract mixin class _$SubmitToolOutputsRunRequestCopyWith<$Res>
    implements $SubmitToolOutputsRunRequestCopyWith<$Res> {
  factory _$SubmitToolOutputsRunRequestCopyWith(
          _SubmitToolOutputsRunRequest value,
          $Res Function(_SubmitToolOutputsRunRequest) _then) =
      __$SubmitToolOutputsRunRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_outputs') List<RunSubmitToolOutput> toolOutputs,
      @JsonKey(includeIfNull: false) bool? stream});
}

/// @nodoc
class __$SubmitToolOutputsRunRequestCopyWithImpl<$Res>
    implements _$SubmitToolOutputsRunRequestCopyWith<$Res> {
  __$SubmitToolOutputsRunRequestCopyWithImpl(this._self, this._then);

  final _SubmitToolOutputsRunRequest _self;
  final $Res Function(_SubmitToolOutputsRunRequest) _then;

  /// Create a copy of SubmitToolOutputsRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? toolOutputs = null,
    Object? stream = freezed,
  }) {
    return _then(_SubmitToolOutputsRunRequest(
      toolOutputs: null == toolOutputs
          ? _self._toolOutputs
          : toolOutputs // ignore: cast_nullable_to_non_nullable
              as List<RunSubmitToolOutput>,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
mixin _$RunSubmitToolOutput {
  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  String? get toolCallId;

  /// The output of the tool call to be submitted to continue the run.
  @JsonKey(includeIfNull: false)
  String? get output;

  /// Create a copy of RunSubmitToolOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunSubmitToolOutputCopyWith<RunSubmitToolOutput> get copyWith =>
      _$RunSubmitToolOutputCopyWithImpl<RunSubmitToolOutput>(
          this as RunSubmitToolOutput, _$identity);

  /// Serializes this RunSubmitToolOutput to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunSubmitToolOutput &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, toolCallId, output);

  @override
  String toString() {
    return 'RunSubmitToolOutput(toolCallId: $toolCallId, output: $output)';
  }
}

/// @nodoc
abstract mixin class $RunSubmitToolOutputCopyWith<$Res> {
  factory $RunSubmitToolOutputCopyWith(
          RunSubmitToolOutput value, $Res Function(RunSubmitToolOutput) _then) =
      _$RunSubmitToolOutputCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class _$RunSubmitToolOutputCopyWithImpl<$Res>
    implements $RunSubmitToolOutputCopyWith<$Res> {
  _$RunSubmitToolOutputCopyWithImpl(this._self, this._then);

  final RunSubmitToolOutput _self;
  final $Res Function(RunSubmitToolOutput) _then;

  /// Create a copy of RunSubmitToolOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCallId = freezed,
    Object? output = freezed,
  }) {
    return _then(_self.copyWith(
      toolCallId: freezed == toolCallId
          ? _self.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _self.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunSubmitToolOutput].
extension RunSubmitToolOutputPatterns on RunSubmitToolOutput {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunSubmitToolOutput value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutput() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunSubmitToolOutput value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutput():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunSubmitToolOutput value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutput() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_call_id', includeIfNull: false)
            String? toolCallId,
            @JsonKey(includeIfNull: false) String? output)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutput() when $default != null:
        return $default(_that.toolCallId, _that.output);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_call_id', includeIfNull: false)
            String? toolCallId,
            @JsonKey(includeIfNull: false) String? output)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutput():
        return $default(_that.toolCallId, _that.output);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'tool_call_id', includeIfNull: false)
            String? toolCallId,
            @JsonKey(includeIfNull: false) String? output)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunSubmitToolOutput() when $default != null:
        return $default(_that.toolCallId, _that.output);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunSubmitToolOutput extends RunSubmitToolOutput {
  const _RunSubmitToolOutput(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) this.toolCallId,
      @JsonKey(includeIfNull: false) this.output})
      : super._();
  factory _RunSubmitToolOutput.fromJson(Map<String, dynamic> json) =>
      _$RunSubmitToolOutputFromJson(json);

  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @override
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  final String? toolCallId;

  /// The output of the tool call to be submitted to continue the run.
  @override
  @JsonKey(includeIfNull: false)
  final String? output;

  /// Create a copy of RunSubmitToolOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunSubmitToolOutputCopyWith<_RunSubmitToolOutput> get copyWith =>
      __$RunSubmitToolOutputCopyWithImpl<_RunSubmitToolOutput>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunSubmitToolOutputToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunSubmitToolOutput &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, toolCallId, output);

  @override
  String toString() {
    return 'RunSubmitToolOutput(toolCallId: $toolCallId, output: $output)';
  }
}

/// @nodoc
abstract mixin class _$RunSubmitToolOutputCopyWith<$Res>
    implements $RunSubmitToolOutputCopyWith<$Res> {
  factory _$RunSubmitToolOutputCopyWith(_RunSubmitToolOutput value,
          $Res Function(_RunSubmitToolOutput) _then) =
      __$RunSubmitToolOutputCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class __$RunSubmitToolOutputCopyWithImpl<$Res>
    implements _$RunSubmitToolOutputCopyWith<$Res> {
  __$RunSubmitToolOutputCopyWithImpl(this._self, this._then);

  final _RunSubmitToolOutput _self;
  final $Res Function(_RunSubmitToolOutput) _then;

  /// Create a copy of RunSubmitToolOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? toolCallId = freezed,
    Object? output = freezed,
  }) {
    return _then(_RunSubmitToolOutput(
      toolCallId: freezed == toolCallId
          ? _self.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _self.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$RunToolCallObject {
  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  String get id;

  /// The type of tool call the output is required for. For now, this is always `function`.
  RunToolCallObjectType get type;

  /// The function definition.
  RunToolCallFunction get function;

  /// Create a copy of RunToolCallObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunToolCallObjectCopyWith<RunToolCallObject> get copyWith =>
      _$RunToolCallObjectCopyWithImpl<RunToolCallObject>(
          this as RunToolCallObject, _$identity);

  /// Serializes this RunToolCallObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunToolCallObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @override
  String toString() {
    return 'RunToolCallObject(id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $RunToolCallObjectCopyWith<$Res> {
  factory $RunToolCallObjectCopyWith(
          RunToolCallObject value, $Res Function(RunToolCallObject) _then) =
      _$RunToolCallObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id, RunToolCallObjectType type, RunToolCallFunction function});

  $RunToolCallFunctionCopyWith<$Res> get function;
}

/// @nodoc
class _$RunToolCallObjectCopyWithImpl<$Res>
    implements $RunToolCallObjectCopyWith<$Res> {
  _$RunToolCallObjectCopyWithImpl(this._self, this._then);

  final RunToolCallObject _self;
  final $Res Function(RunToolCallObject) _then;

  /// Create a copy of RunToolCallObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunToolCallObjectType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunToolCallFunction,
    ));
  }

  /// Create a copy of RunToolCallObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunToolCallFunctionCopyWith<$Res> get function {
    return $RunToolCallFunctionCopyWith<$Res>(_self.function, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// Adds pattern-matching-related methods to [RunToolCallObject].
extension RunToolCallObjectPatterns on RunToolCallObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunToolCallObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunToolCallObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunToolCallObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunToolCallObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String id, RunToolCallObjectType type,
            RunToolCallFunction function)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunToolCallObject() when $default != null:
        return $default(_that.id, _that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id, RunToolCallObjectType type, RunToolCallFunction function)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallObject():
        return $default(_that.id, _that.type, _that.function);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String id, RunToolCallObjectType type,
            RunToolCallFunction function)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallObject() when $default != null:
        return $default(_that.id, _that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunToolCallObject extends RunToolCallObject {
  const _RunToolCallObject(
      {required this.id, required this.type, required this.function})
      : super._();
  factory _RunToolCallObject.fromJson(Map<String, dynamic> json) =>
      _$RunToolCallObjectFromJson(json);

  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  @override
  final String id;

  /// The type of tool call the output is required for. For now, this is always `function`.
  @override
  final RunToolCallObjectType type;

  /// The function definition.
  @override
  final RunToolCallFunction function;

  /// Create a copy of RunToolCallObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunToolCallObjectCopyWith<_RunToolCallObject> get copyWith =>
      __$RunToolCallObjectCopyWithImpl<_RunToolCallObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunToolCallObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunToolCallObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @override
  String toString() {
    return 'RunToolCallObject(id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class _$RunToolCallObjectCopyWith<$Res>
    implements $RunToolCallObjectCopyWith<$Res> {
  factory _$RunToolCallObjectCopyWith(
          _RunToolCallObject value, $Res Function(_RunToolCallObject) _then) =
      __$RunToolCallObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id, RunToolCallObjectType type, RunToolCallFunction function});

  @override
  $RunToolCallFunctionCopyWith<$Res> get function;
}

/// @nodoc
class __$RunToolCallObjectCopyWithImpl<$Res>
    implements _$RunToolCallObjectCopyWith<$Res> {
  __$RunToolCallObjectCopyWithImpl(this._self, this._then);

  final _RunToolCallObject _self;
  final $Res Function(_RunToolCallObject) _then;

  /// Create a copy of RunToolCallObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_RunToolCallObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunToolCallObjectType,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunToolCallFunction,
    ));
  }

  /// Create a copy of RunToolCallObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunToolCallFunctionCopyWith<$Res> get function {
    return $RunToolCallFunctionCopyWith<$Res>(_self.function, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$RunToolCallFunction {
  /// The name of the function.
  String get name;

  /// The arguments that the model expects you to pass to the function.
  String get arguments;

  /// Create a copy of RunToolCallFunction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunToolCallFunctionCopyWith<RunToolCallFunction> get copyWith =>
      _$RunToolCallFunctionCopyWithImpl<RunToolCallFunction>(
          this as RunToolCallFunction, _$identity);

  /// Serializes this RunToolCallFunction to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunToolCallFunction &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @override
  String toString() {
    return 'RunToolCallFunction(name: $name, arguments: $arguments)';
  }
}

/// @nodoc
abstract mixin class $RunToolCallFunctionCopyWith<$Res> {
  factory $RunToolCallFunctionCopyWith(
          RunToolCallFunction value, $Res Function(RunToolCallFunction) _then) =
      _$RunToolCallFunctionCopyWithImpl;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$RunToolCallFunctionCopyWithImpl<$Res>
    implements $RunToolCallFunctionCopyWith<$Res> {
  _$RunToolCallFunctionCopyWithImpl(this._self, this._then);

  final RunToolCallFunction _self;
  final $Res Function(RunToolCallFunction) _then;

  /// Create a copy of RunToolCallFunction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunToolCallFunction].
extension RunToolCallFunctionPatterns on RunToolCallFunction {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunToolCallFunction value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunToolCallFunction() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunToolCallFunction value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallFunction():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunToolCallFunction value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallFunction() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String name, String arguments)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunToolCallFunction() when $default != null:
        return $default(_that.name, _that.arguments);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String name, String arguments) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallFunction():
        return $default(_that.name, _that.arguments);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String name, String arguments)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunToolCallFunction() when $default != null:
        return $default(_that.name, _that.arguments);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunToolCallFunction extends RunToolCallFunction {
  const _RunToolCallFunction({required this.name, required this.arguments})
      : super._();
  factory _RunToolCallFunction.fromJson(Map<String, dynamic> json) =>
      _$RunToolCallFunctionFromJson(json);

  /// The name of the function.
  @override
  final String name;

  /// The arguments that the model expects you to pass to the function.
  @override
  final String arguments;

  /// Create a copy of RunToolCallFunction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunToolCallFunctionCopyWith<_RunToolCallFunction> get copyWith =>
      __$RunToolCallFunctionCopyWithImpl<_RunToolCallFunction>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunToolCallFunctionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunToolCallFunction &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @override
  String toString() {
    return 'RunToolCallFunction(name: $name, arguments: $arguments)';
  }
}

/// @nodoc
abstract mixin class _$RunToolCallFunctionCopyWith<$Res>
    implements $RunToolCallFunctionCopyWith<$Res> {
  factory _$RunToolCallFunctionCopyWith(_RunToolCallFunction value,
          $Res Function(_RunToolCallFunction) _then) =
      __$RunToolCallFunctionCopyWithImpl;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$RunToolCallFunctionCopyWithImpl<$Res>
    implements _$RunToolCallFunctionCopyWith<$Res> {
  __$RunToolCallFunctionCopyWithImpl(this._self, this._then);

  final _RunToolCallFunction _self;
  final $Res Function(_RunToolCallFunction) _then;

  /// Create a copy of RunToolCallFunction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_RunToolCallFunction(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$CreateThreadAndRunRequest {
  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this
  /// run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;

  /// If no thread is provided, an empty thread will be created.
  @JsonKey(includeIfNull: false)
  CreateThreadRequest? get thread;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run.
  /// If a value is provided here, it will override the model associated with the assistant. If not, the model
  /// associated with the assistant will be used.
  @_ThreadAndRunModelConverter()
  @JsonKey(includeIfNull: false)
  ThreadAndRunModel? get model;

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run
  /// basis.
  @JsonKey(includeIfNull: false)
  String? get instructions;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a
  /// per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best
  /// effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run
  /// exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See
  /// `incomplete_details` for more info.
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  int? get maxPromptTokens;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a
  /// best effort to use only the number of completion tokens specified, across multiple turns of the run. If the
  /// run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See
  /// `incomplete_details` for more info.
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  int? get maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run.
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  TruncationObject? get truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more
  ///  tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or
  /// `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_CreateThreadAndRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  CreateThreadAndRunRequestToolChoice? get toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateThreadAndRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateThreadAndRunRequestResponseFormat? get responseFormat;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when
  /// the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream;

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestCopyWith<CreateThreadAndRunRequest> get copyWith =>
      _$CreateThreadAndRunRequestCopyWithImpl<CreateThreadAndRunRequest>(
          this as CreateThreadAndRunRequest, _$identity);

  /// Serializes this CreateThreadAndRunRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateThreadAndRunRequest &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.thread, thread) || other.thread == thread) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other.tools, tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      thread,
      model,
      instructions,
      const DeepCollectionEquality().hash(tools),
      toolResources,
      const DeepCollectionEquality().hash(metadata),
      temperature,
      topP,
      maxPromptTokens,
      maxCompletionTokens,
      truncationStrategy,
      toolChoice,
      parallelToolCalls,
      responseFormat,
      stream);

  @override
  String toString() {
    return 'CreateThreadAndRunRequest(assistantId: $assistantId, thread: $thread, model: $model, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat, stream: $stream)';
  }
}

/// @nodoc
abstract mixin class $CreateThreadAndRunRequestCopyWith<$Res> {
  factory $CreateThreadAndRunRequestCopyWith(CreateThreadAndRunRequest value,
          $Res Function(CreateThreadAndRunRequest) _then) =
      _$CreateThreadAndRunRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
      @_ThreadAndRunModelConverter()
      @JsonKey(includeIfNull: false)
      ThreadAndRunModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateThreadAndRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateThreadAndRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateThreadAndRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateThreadAndRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  $CreateThreadRequestCopyWith<$Res>? get thread;
  $ThreadAndRunModelCopyWith<$Res>? get model;
  $ToolResourcesCopyWith<$Res>? get toolResources;
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$CreateThreadAndRunRequestCopyWithImpl<$Res>
    implements $CreateThreadAndRunRequestCopyWith<$Res> {
  _$CreateThreadAndRunRequestCopyWithImpl(this._self, this._then);

  final CreateThreadAndRunRequest _self;
  final $Res Function(CreateThreadAndRunRequest) _then;

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? thread = freezed,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? tools = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_self.copyWith(
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      thread: freezed == thread
          ? _self.thread
          : thread // ignore: cast_nullable_to_non_nullable
              as CreateThreadRequest?,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as ThreadAndRunModel?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _self.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _self.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestResponseFormat?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateThreadRequestCopyWith<$Res>? get thread {
    if (_self.thread == null) {
      return null;
    }

    return $CreateThreadRequestCopyWith<$Res>(_self.thread!, (value) {
      return _then(_self.copyWith(thread: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ThreadAndRunModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $ThreadAndRunModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_self.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_self.truncationStrategy!, (value) {
      return _then(_self.copyWith(truncationStrategy: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>(_self.toolChoice!,
        (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>(
        _self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateThreadAndRunRequest].
extension CreateThreadAndRunRequestPatterns on CreateThreadAndRunRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateThreadAndRunRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateThreadAndRunRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateThreadAndRunRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadAndRunRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateThreadAndRunRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadAndRunRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'assistant_id') String assistantId,
            @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
            @_ThreadAndRunModelConverter()
            @JsonKey(includeIfNull: false)
            ThreadAndRunModel? model,
            @JsonKey(includeIfNull: false) String? instructions,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
            int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy', includeIfNull: false)
            TruncationObject? truncationStrategy,
            @_CreateThreadAndRunRequestToolChoiceConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            CreateThreadAndRunRequestToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @_CreateThreadAndRunRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateThreadAndRunRequestResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) bool? stream)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateThreadAndRunRequest() when $default != null:
        return $default(
            _that.assistantId,
            _that.thread,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat,
            _that.stream);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'assistant_id') String assistantId,
            @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
            @_ThreadAndRunModelConverter()
            @JsonKey(includeIfNull: false)
            ThreadAndRunModel? model,
            @JsonKey(includeIfNull: false) String? instructions,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
            int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy', includeIfNull: false)
            TruncationObject? truncationStrategy,
            @_CreateThreadAndRunRequestToolChoiceConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            CreateThreadAndRunRequestToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @_CreateThreadAndRunRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateThreadAndRunRequestResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) bool? stream)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadAndRunRequest():
        return $default(
            _that.assistantId,
            _that.thread,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat,
            _that.stream);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'assistant_id') String assistantId,
            @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
            @_ThreadAndRunModelConverter()
            @JsonKey(includeIfNull: false)
            ThreadAndRunModel? model,
            @JsonKey(includeIfNull: false) String? instructions,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
            @JsonKey(includeIfNull: false) double? temperature,
            @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
            @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
            int? maxPromptTokens,
            @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
            int? maxCompletionTokens,
            @JsonKey(name: 'truncation_strategy', includeIfNull: false)
            TruncationObject? truncationStrategy,
            @_CreateThreadAndRunRequestToolChoiceConverter()
            @JsonKey(name: 'tool_choice', includeIfNull: false)
            CreateThreadAndRunRequestToolChoice? toolChoice,
            @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
            bool? parallelToolCalls,
            @_CreateThreadAndRunRequestResponseFormatConverter()
            @JsonKey(name: 'response_format', includeIfNull: false)
            CreateThreadAndRunRequestResponseFormat? responseFormat,
            @JsonKey(includeIfNull: false) bool? stream)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadAndRunRequest() when $default != null:
        return $default(
            _that.assistantId,
            _that.thread,
            _that.model,
            _that.instructions,
            _that.tools,
            _that.toolResources,
            _that.metadata,
            _that.temperature,
            _that.topP,
            _that.maxPromptTokens,
            _that.maxCompletionTokens,
            _that.truncationStrategy,
            _that.toolChoice,
            _that.parallelToolCalls,
            _that.responseFormat,
            _that.stream);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateThreadAndRunRequest extends CreateThreadAndRunRequest {
  const _CreateThreadAndRunRequest(
      {@JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(includeIfNull: false) this.thread,
      @_ThreadAndRunModelConverter() @JsonKey(includeIfNull: false) this.model,
      @JsonKey(includeIfNull: false) this.instructions,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      this.maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      this.maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      this.truncationStrategy,
      @_CreateThreadAndRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      this.parallelToolCalls,
      @_CreateThreadAndRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.stream})
      : _tools = tools,
        _metadata = metadata,
        super._();
  factory _CreateThreadAndRunRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateThreadAndRunRequestFromJson(json);

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this
  /// run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// If no thread is provided, an empty thread will be created.
  @override
  @JsonKey(includeIfNull: false)
  final CreateThreadRequest? thread;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run.
  /// If a value is provided here, it will override the model associated with the assistant. If not, the model
  /// associated with the assistant will be used.
  @override
  @_ThreadAndRunModelConverter()
  @JsonKey(includeIfNull: false)
  final ThreadAndRunModel? model;

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run
  /// basis.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a
  /// per-run basis.
  final List<AssistantTools>? _tools;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a
  /// per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random,
  /// while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results
  /// of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability
  /// mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best
  /// effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run
  /// exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See
  /// `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  final int? maxPromptTokens;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a
  /// best effort to use only the number of completion tokens specified, across multiple turns of the run. If the
  /// run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See
  /// `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  final int? maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run.
  @override
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  final TruncationObject? truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more
  ///  tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or
  /// `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @override
  @_CreateThreadAndRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final CreateThreadAndRunRequestToolChoice? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  final bool? parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with
  /// [GPT-4o](https://platform.openai.com/docs/models#gpt-4o),
  /// [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models
  /// since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures
  /// the model will match your supplied JSON schema. Learn more in the
  /// [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates
  /// is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a
  /// system or user message. Without this, the model may generate an unending stream of whitespace until the
  /// generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note
  /// that the message content may be partially cut off if `finish_reason="length"`, which indicates the
  /// generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_CreateThreadAndRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final CreateThreadAndRunRequestResponseFormat? responseFormat;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when
  /// the Run enters a terminal state with a `data: [DONE]` message.
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateThreadAndRunRequestCopyWith<_CreateThreadAndRunRequest>
      get copyWith =>
          __$CreateThreadAndRunRequestCopyWithImpl<_CreateThreadAndRunRequest>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateThreadAndRunRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateThreadAndRunRequest &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.thread, thread) || other.thread == thread) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      thread,
      model,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      maxPromptTokens,
      maxCompletionTokens,
      truncationStrategy,
      toolChoice,
      parallelToolCalls,
      responseFormat,
      stream);

  @override
  String toString() {
    return 'CreateThreadAndRunRequest(assistantId: $assistantId, thread: $thread, model: $model, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat, stream: $stream)';
  }
}

/// @nodoc
abstract mixin class _$CreateThreadAndRunRequestCopyWith<$Res>
    implements $CreateThreadAndRunRequestCopyWith<$Res> {
  factory _$CreateThreadAndRunRequestCopyWith(_CreateThreadAndRunRequest value,
          $Res Function(_CreateThreadAndRunRequest) _then) =
      __$CreateThreadAndRunRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
      @_ThreadAndRunModelConverter()
      @JsonKey(includeIfNull: false)
      ThreadAndRunModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateThreadAndRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateThreadAndRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateThreadAndRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateThreadAndRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  @override
  $CreateThreadRequestCopyWith<$Res>? get thread;
  @override
  $ThreadAndRunModelCopyWith<$Res>? get model;
  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  @override
  $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  @override
  $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$CreateThreadAndRunRequestCopyWithImpl<$Res>
    implements _$CreateThreadAndRunRequestCopyWith<$Res> {
  __$CreateThreadAndRunRequestCopyWithImpl(this._self, this._then);

  final _CreateThreadAndRunRequest _self;
  final $Res Function(_CreateThreadAndRunRequest) _then;

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? assistantId = null,
    Object? thread = freezed,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? tools = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_CreateThreadAndRunRequest(
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      thread: freezed == thread
          ? _self.thread
          : thread // ignore: cast_nullable_to_non_nullable
              as CreateThreadRequest?,
      model: freezed == model
          ? _self.model
          : model // ignore: cast_nullable_to_non_nullable
              as ThreadAndRunModel?,
      instructions: freezed == instructions
          ? _self.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _self.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _self.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _self.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _self.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _self.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _self.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _self.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _self.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestResponseFormat?,
      stream: freezed == stream
          ? _self.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateThreadRequestCopyWith<$Res>? get thread {
    if (_self.thread == null) {
      return null;
    }

    return $CreateThreadRequestCopyWith<$Res>(_self.thread!, (value) {
      return _then(_self.copyWith(thread: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ThreadAndRunModelCopyWith<$Res>? get model {
    if (_self.model == null) {
      return null;
    }

    return $ThreadAndRunModelCopyWith<$Res>(_self.model!, (value) {
      return _then(_self.copyWith(model: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_self.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_self.truncationStrategy!, (value) {
      return _then(_self.copyWith(truncationStrategy: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>? get toolChoice {
    if (_self.toolChoice == null) {
      return null;
    }

    return $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>(_self.toolChoice!,
        (value) {
      return _then(_self.copyWith(toolChoice: value));
    });
  }

  /// Create a copy of CreateThreadAndRunRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_self.responseFormat == null) {
      return null;
    }

    return $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>(
        _self.responseFormat!, (value) {
      return _then(_self.copyWith(responseFormat: value));
    });
  }
}

ThreadAndRunModel _$ThreadAndRunModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ThreadAndRunModelEnumeration.fromJson(json);
    case 'modelId':
      return ThreadAndRunModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ThreadAndRunModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ThreadAndRunModel {
  Object get value;

  /// Serializes this ThreadAndRunModel to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ThreadAndRunModel &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ThreadAndRunModel(value: $value)';
  }
}

/// @nodoc
class $ThreadAndRunModelCopyWith<$Res> {
  $ThreadAndRunModelCopyWith(
      ThreadAndRunModel _, $Res Function(ThreadAndRunModel) __);
}

/// Adds pattern-matching-related methods to [ThreadAndRunModel].
extension ThreadAndRunModelPatterns on ThreadAndRunModel {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadAndRunModelEnumeration value)? model,
    TResult Function(ThreadAndRunModelString value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ThreadAndRunModelEnumeration() when model != null:
        return model(_that);
      case ThreadAndRunModelString() when modelId != null:
        return modelId(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadAndRunModelEnumeration value) model,
    required TResult Function(ThreadAndRunModelString value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadAndRunModelEnumeration():
        return model(_that);
      case ThreadAndRunModelString():
        return modelId(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModelEnumeration value)? model,
    TResult? Function(ThreadAndRunModelString value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadAndRunModelEnumeration() when model != null:
        return model(_that);
      case ThreadAndRunModelString() when modelId != null:
        return modelId(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ThreadAndRunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ThreadAndRunModelEnumeration() when model != null:
        return model(_that.value);
      case ThreadAndRunModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ThreadAndRunModels value) model,
    required TResult Function(String value) modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadAndRunModelEnumeration():
        return model(_that.value);
      case ThreadAndRunModelString():
        return modelId(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadAndRunModelEnumeration() when model != null:
        return model(_that.value);
      case ThreadAndRunModelString() when modelId != null:
        return modelId(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ThreadAndRunModelEnumeration extends ThreadAndRunModel {
  const ThreadAndRunModelEnumeration(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();
  factory ThreadAndRunModelEnumeration.fromJson(Map<String, dynamic> json) =>
      _$ThreadAndRunModelEnumerationFromJson(json);

  @override
  final ThreadAndRunModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ThreadAndRunModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ThreadAndRunModelEnumerationCopyWith<ThreadAndRunModelEnumeration>
      get copyWith => _$ThreadAndRunModelEnumerationCopyWithImpl<
          ThreadAndRunModelEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ThreadAndRunModelEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ThreadAndRunModelEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ThreadAndRunModel.model(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ThreadAndRunModelEnumerationCopyWith<$Res>
    implements $ThreadAndRunModelCopyWith<$Res> {
  factory $ThreadAndRunModelEnumerationCopyWith(
          ThreadAndRunModelEnumeration value,
          $Res Function(ThreadAndRunModelEnumeration) _then) =
      _$ThreadAndRunModelEnumerationCopyWithImpl;
  @useResult
  $Res call({ThreadAndRunModels value});
}

/// @nodoc
class _$ThreadAndRunModelEnumerationCopyWithImpl<$Res>
    implements $ThreadAndRunModelEnumerationCopyWith<$Res> {
  _$ThreadAndRunModelEnumerationCopyWithImpl(this._self, this._then);

  final ThreadAndRunModelEnumeration _self;
  final $Res Function(ThreadAndRunModelEnumeration) _then;

  /// Create a copy of ThreadAndRunModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ThreadAndRunModelEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ThreadAndRunModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ThreadAndRunModelString extends ThreadAndRunModel {
  const ThreadAndRunModelString(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();
  factory ThreadAndRunModelString.fromJson(Map<String, dynamic> json) =>
      _$ThreadAndRunModelStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ThreadAndRunModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ThreadAndRunModelStringCopyWith<ThreadAndRunModelString> get copyWith =>
      _$ThreadAndRunModelStringCopyWithImpl<ThreadAndRunModelString>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ThreadAndRunModelStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ThreadAndRunModelString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ThreadAndRunModel.modelId(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ThreadAndRunModelStringCopyWith<$Res>
    implements $ThreadAndRunModelCopyWith<$Res> {
  factory $ThreadAndRunModelStringCopyWith(ThreadAndRunModelString value,
          $Res Function(ThreadAndRunModelString) _then) =
      _$ThreadAndRunModelStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$ThreadAndRunModelStringCopyWithImpl<$Res>
    implements $ThreadAndRunModelStringCopyWith<$Res> {
  _$ThreadAndRunModelStringCopyWithImpl(this._self, this._then);

  final ThreadAndRunModelString _self;
  final $Res Function(ThreadAndRunModelString) _then;

  /// Create a copy of ThreadAndRunModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ThreadAndRunModelString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

CreateThreadAndRunRequestToolChoice
    _$CreateThreadAndRunRequestToolChoiceFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateThreadAndRunRequestToolChoiceEnumeration.fromJson(json);
    case 'tool':
      return CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateThreadAndRunRequestToolChoice',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateThreadAndRunRequestToolChoice {
  Object get value;

  /// Serializes this CreateThreadAndRunRequestToolChoice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateThreadAndRunRequestToolChoice &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateThreadAndRunRequestToolChoice(value: $value)';
  }
}

/// @nodoc
class $CreateThreadAndRunRequestToolChoiceCopyWith<$Res> {
  $CreateThreadAndRunRequestToolChoiceCopyWith(
      CreateThreadAndRunRequestToolChoice _,
      $Res Function(CreateThreadAndRunRequestToolChoice) __);
}

/// Adds pattern-matching-related methods to [CreateThreadAndRunRequestToolChoice].
extension CreateThreadAndRunRequestToolChoicePatterns
    on CreateThreadAndRunRequestToolChoice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that);
      case CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestToolChoiceEnumeration():
        return mode(_that);
      case CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice():
        return tool(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that);
      case CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that.value);
      case CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestToolChoiceMode value)
        mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestToolChoiceEnumeration():
        return mode(_that.value);
      case CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice():
        return tool(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestToolChoiceEnumeration() when mode != null:
        return mode(_that.value);
      case CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice()
          when tool != null:
        return tool(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateThreadAndRunRequestToolChoiceEnumeration
    extends CreateThreadAndRunRequestToolChoice {
  const CreateThreadAndRunRequestToolChoiceEnumeration(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory CreateThreadAndRunRequestToolChoiceEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$CreateThreadAndRunRequestToolChoiceEnumerationFromJson(json);

  @override
  final CreateThreadAndRunRequestToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateThreadAndRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestToolChoiceEnumerationCopyWith<
          CreateThreadAndRunRequestToolChoiceEnumeration>
      get copyWith =>
          _$CreateThreadAndRunRequestToolChoiceEnumerationCopyWithImpl<
              CreateThreadAndRunRequestToolChoiceEnumeration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateThreadAndRunRequestToolChoiceEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateThreadAndRunRequestToolChoiceEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateThreadAndRunRequestToolChoice.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateThreadAndRunRequestToolChoiceEnumerationCopyWith<
    $Res> implements $CreateThreadAndRunRequestToolChoiceCopyWith<$Res> {
  factory $CreateThreadAndRunRequestToolChoiceEnumerationCopyWith(
          CreateThreadAndRunRequestToolChoiceEnumeration value,
          $Res Function(CreateThreadAndRunRequestToolChoiceEnumeration) _then) =
      _$CreateThreadAndRunRequestToolChoiceEnumerationCopyWithImpl;
  @useResult
  $Res call({CreateThreadAndRunRequestToolChoiceMode value});
}

/// @nodoc
class _$CreateThreadAndRunRequestToolChoiceEnumerationCopyWithImpl<$Res>
    implements $CreateThreadAndRunRequestToolChoiceEnumerationCopyWith<$Res> {
  _$CreateThreadAndRunRequestToolChoiceEnumerationCopyWithImpl(
      this._self, this._then);

  final CreateThreadAndRunRequestToolChoiceEnumeration _self;
  final $Res Function(CreateThreadAndRunRequestToolChoiceEnumeration) _then;

  /// Create a copy of CreateThreadAndRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateThreadAndRunRequestToolChoiceEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice
    extends CreateThreadAndRunRequestToolChoice {
  const CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice(this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();
  factory CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice.fromJson(
          Map<String, dynamic> json) =>
      _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceFromJson(
          json);

  @override
  final AssistantsNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateThreadAndRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith<
          CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice>
      get copyWith =>
          _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl<
                  CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateThreadAndRunRequestToolChoice.tool(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith<
    $Res> implements $CreateThreadAndRunRequestToolChoiceCopyWith<$Res> {
  factory $CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith(
          CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value,
          $Res Function(
                  CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice)
              _then) =
      _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl;
  @useResult
  $Res call({AssistantsNamedToolChoice value});

  $AssistantsNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl<
        $Res>
    implements
        $CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWith<
            $Res> {
  _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceCopyWithImpl(
      this._self, this._then);

  final CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice _self;
  final $Res Function(
      CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice) _then;

  /// Create a copy of CreateThreadAndRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsNamedToolChoice,
    ));
  }

  /// Create a copy of CreateThreadAndRunRequestToolChoice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantsNamedToolChoiceCopyWith<$Res> get value {
    return $AssistantsNamedToolChoiceCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

CreateThreadAndRunRequestResponseFormat
    _$CreateThreadAndRunRequestResponseFormatFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateThreadAndRunRequestResponseFormatEnumeration.fromJson(json);
    case 'responseFormat':
      return CreateThreadAndRunRequestResponseFormatResponseFormat.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateThreadAndRunRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateThreadAndRunRequestResponseFormat {
  Object get value;

  /// Serializes this CreateThreadAndRunRequestResponseFormat to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateThreadAndRunRequestResponseFormat &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateThreadAndRunRequestResponseFormat(value: $value)';
  }
}

/// @nodoc
class $CreateThreadAndRunRequestResponseFormatCopyWith<$Res> {
  $CreateThreadAndRunRequestResponseFormatCopyWith(
      CreateThreadAndRunRequestResponseFormat _,
      $Res Function(CreateThreadAndRunRequestResponseFormat) __);
}

/// Adds pattern-matching-related methods to [CreateThreadAndRunRequestResponseFormat].
extension CreateThreadAndRunRequestResponseFormatPatterns
    on CreateThreadAndRunRequestResponseFormat {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestResponseFormatResponseFormat value)?
        responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestResponseFormatEnumeration()
          when mode != null:
        return mode(_that);
      case CreateThreadAndRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatResponseFormat value)
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestResponseFormatEnumeration():
        return mode(_that);
      case CreateThreadAndRunRequestResponseFormatResponseFormat():
        return responseFormat(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestResponseFormatResponseFormat value)?
        responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestResponseFormatEnumeration()
          when mode != null:
        return mode(_that);
      case CreateThreadAndRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult Function(ResponseFormat value)? responseFormat,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestResponseFormatEnumeration()
          when mode != null:
        return mode(_that.value);
      case CreateThreadAndRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestResponseFormatMode value)
        mode,
    required TResult Function(ResponseFormat value) responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestResponseFormatEnumeration():
        return mode(_that.value);
      case CreateThreadAndRunRequestResponseFormatResponseFormat():
        return responseFormat(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult? Function(ResponseFormat value)? responseFormat,
  }) {
    final _that = this;
    switch (_that) {
      case CreateThreadAndRunRequestResponseFormatEnumeration()
          when mode != null:
        return mode(_that.value);
      case CreateThreadAndRunRequestResponseFormatResponseFormat()
          when responseFormat != null:
        return responseFormat(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateThreadAndRunRequestResponseFormatEnumeration
    extends CreateThreadAndRunRequestResponseFormat {
  const CreateThreadAndRunRequestResponseFormatEnumeration(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();
  factory CreateThreadAndRunRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =>
      _$CreateThreadAndRunRequestResponseFormatEnumerationFromJson(json);

  @override
  final CreateThreadAndRunRequestResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateThreadAndRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestResponseFormatEnumerationCopyWith<
          CreateThreadAndRunRequestResponseFormatEnumeration>
      get copyWith =>
          _$CreateThreadAndRunRequestResponseFormatEnumerationCopyWithImpl<
                  CreateThreadAndRunRequestResponseFormatEnumeration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateThreadAndRunRequestResponseFormatEnumerationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateThreadAndRunRequestResponseFormatEnumeration &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateThreadAndRunRequestResponseFormat.mode(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateThreadAndRunRequestResponseFormatEnumerationCopyWith<
    $Res> implements $CreateThreadAndRunRequestResponseFormatCopyWith<$Res> {
  factory $CreateThreadAndRunRequestResponseFormatEnumerationCopyWith(
          CreateThreadAndRunRequestResponseFormatEnumeration value,
          $Res Function(CreateThreadAndRunRequestResponseFormatEnumeration)
              _then) =
      _$CreateThreadAndRunRequestResponseFormatEnumerationCopyWithImpl;
  @useResult
  $Res call({CreateThreadAndRunRequestResponseFormatMode value});
}

/// @nodoc
class _$CreateThreadAndRunRequestResponseFormatEnumerationCopyWithImpl<$Res>
    implements
        $CreateThreadAndRunRequestResponseFormatEnumerationCopyWith<$Res> {
  _$CreateThreadAndRunRequestResponseFormatEnumerationCopyWithImpl(
      this._self, this._then);

  final CreateThreadAndRunRequestResponseFormatEnumeration _self;
  final $Res Function(CreateThreadAndRunRequestResponseFormatEnumeration) _then;

  /// Create a copy of CreateThreadAndRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateThreadAndRunRequestResponseFormatEnumeration(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateThreadAndRunRequestResponseFormatResponseFormat
    extends CreateThreadAndRunRequestResponseFormat {
  const CreateThreadAndRunRequestResponseFormatResponseFormat(this.value,
      {final String? $type})
      : $type = $type ?? 'responseFormat',
        super._();
  factory CreateThreadAndRunRequestResponseFormatResponseFormat.fromJson(
          Map<String, dynamic> json) =>
      _$CreateThreadAndRunRequestResponseFormatResponseFormatFromJson(json);

  @override
  final ResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateThreadAndRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestResponseFormatResponseFormatCopyWith<
          CreateThreadAndRunRequestResponseFormatResponseFormat>
      get copyWith =>
          _$CreateThreadAndRunRequestResponseFormatResponseFormatCopyWithImpl<
                  CreateThreadAndRunRequestResponseFormatResponseFormat>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateThreadAndRunRequestResponseFormatResponseFormatToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateThreadAndRunRequestResponseFormatResponseFormat &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateThreadAndRunRequestResponseFormat.responseFormat(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateThreadAndRunRequestResponseFormatResponseFormatCopyWith<
    $Res> implements $CreateThreadAndRunRequestResponseFormatCopyWith<$Res> {
  factory $CreateThreadAndRunRequestResponseFormatResponseFormatCopyWith(
          CreateThreadAndRunRequestResponseFormatResponseFormat value,
          $Res Function(CreateThreadAndRunRequestResponseFormatResponseFormat)
              _then) =
      _$CreateThreadAndRunRequestResponseFormatResponseFormatCopyWithImpl;
  @useResult
  $Res call({ResponseFormat value});

  $ResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class _$CreateThreadAndRunRequestResponseFormatResponseFormatCopyWithImpl<$Res>
    implements
        $CreateThreadAndRunRequestResponseFormatResponseFormatCopyWith<$Res> {
  _$CreateThreadAndRunRequestResponseFormatResponseFormatCopyWithImpl(
      this._self, this._then);

  final CreateThreadAndRunRequestResponseFormatResponseFormat _self;
  final $Res Function(CreateThreadAndRunRequestResponseFormatResponseFormat)
      _then;

  /// Create a copy of CreateThreadAndRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateThreadAndRunRequestResponseFormatResponseFormat(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as ResponseFormat,
    ));
  }

  /// Create a copy of CreateThreadAndRunRequestResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<$Res> get value {
    return $ResponseFormatCopyWith<$Res>(_self.value, (value) {
      return _then(_self.copyWith(value: value));
    });
  }
}

/// @nodoc
mixin _$ThreadObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `thread`.
  ThreadObjectObject get object;

  /// The Unix timestamp (in seconds) for when the thread was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources')
  ToolResources? get toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  Map<String, dynamic>? get metadata;

  /// Create a copy of ThreadObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ThreadObjectCopyWith<ThreadObject> get copyWith =>
      _$ThreadObjectCopyWithImpl<ThreadObject>(
          this as ThreadObject, _$identity);

  /// Serializes this ThreadObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ThreadObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, createdAt,
      toolResources, const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'ThreadObject(id: $id, object: $object, createdAt: $createdAt, toolResources: $toolResources, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $ThreadObjectCopyWith<$Res> {
  factory $ThreadObjectCopyWith(
          ThreadObject value, $Res Function(ThreadObject) _then) =
      _$ThreadObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      ThreadObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'tool_resources') ToolResources? toolResources,
      Map<String, dynamic>? metadata});

  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class _$ThreadObjectCopyWithImpl<$Res> implements $ThreadObjectCopyWith<$Res> {
  _$ThreadObjectCopyWithImpl(this._self, this._then);

  final ThreadObject _self;
  final $Res Function(ThreadObject) _then;

  /// Create a copy of ThreadObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ThreadObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of ThreadObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ThreadObject].
extension ThreadObjectPatterns on ThreadObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ThreadObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ThreadObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ThreadObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ThreadObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ThreadObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ThreadObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            ThreadObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'tool_resources') ToolResources? toolResources,
            Map<String, dynamic>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ThreadObject() when $default != null:
        return $default(_that.id, _that.object, _that.createdAt,
            _that.toolResources, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            ThreadObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'tool_resources') ToolResources? toolResources,
            Map<String, dynamic>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ThreadObject():
        return $default(_that.id, _that.object, _that.createdAt,
            _that.toolResources, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            ThreadObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'tool_resources') ToolResources? toolResources,
            Map<String, dynamic>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ThreadObject() when $default != null:
        return $default(_that.id, _that.object, _that.createdAt,
            _that.toolResources, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ThreadObject extends ThreadObject {
  const _ThreadObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'tool_resources') required this.toolResources,
      required final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();
  factory _ThreadObject.fromJson(Map<String, dynamic> json) =>
      _$ThreadObjectFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread`.
  @override
  final ThreadObjectObject object;

  /// The Unix timestamp (in seconds) for when the thread was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources')
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ThreadObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ThreadObjectCopyWith<_ThreadObject> get copyWith =>
      __$ThreadObjectCopyWithImpl<_ThreadObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ThreadObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ThreadObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, createdAt,
      toolResources, const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'ThreadObject(id: $id, object: $object, createdAt: $createdAt, toolResources: $toolResources, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$ThreadObjectCopyWith<$Res>
    implements $ThreadObjectCopyWith<$Res> {
  factory _$ThreadObjectCopyWith(
          _ThreadObject value, $Res Function(_ThreadObject) _then) =
      __$ThreadObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      ThreadObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'tool_resources') ToolResources? toolResources,
      Map<String, dynamic>? metadata});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class __$ThreadObjectCopyWithImpl<$Res>
    implements _$ThreadObjectCopyWith<$Res> {
  __$ThreadObjectCopyWithImpl(this._self, this._then);

  final _ThreadObject _self;
  final $Res Function(_ThreadObject) _then;

  /// Create a copy of ThreadObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_ThreadObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ThreadObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of ThreadObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }
}

/// @nodoc
mixin _$CreateThreadRequest {
  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// Create a copy of CreateThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateThreadRequestCopyWith<CreateThreadRequest> get copyWith =>
      _$CreateThreadRequestCopyWithImpl<CreateThreadRequest>(
          this as CreateThreadRequest, _$identity);

  /// Serializes this CreateThreadRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateThreadRequest &&
            const DeepCollectionEquality().equals(other.messages, messages) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(messages),
      toolResources,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'CreateThreadRequest(messages: $messages, toolResources: $toolResources, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $CreateThreadRequestCopyWith<$Res> {
  factory $CreateThreadRequestCopyWith(
          CreateThreadRequest value, $Res Function(CreateThreadRequest) _then) =
      _$CreateThreadRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class _$CreateThreadRequestCopyWithImpl<$Res>
    implements $CreateThreadRequestCopyWith<$Res> {
  _$CreateThreadRequestCopyWithImpl(this._self, this._then);

  final CreateThreadRequest _self;
  final $Res Function(CreateThreadRequest) _then;

  /// Create a copy of CreateThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messages = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      messages: freezed == messages
          ? _self.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of CreateThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateThreadRequest].
extension CreateThreadRequestPatterns on CreateThreadRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateThreadRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateThreadRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateThreadRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateThreadRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateThreadRequest() when $default != null:
        return $default(_that.messages, _that.toolResources, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadRequest():
        return $default(_that.messages, _that.toolResources, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateThreadRequest() when $default != null:
        return $default(_that.messages, _that.toolResources, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateThreadRequest extends CreateThreadRequest {
  const _CreateThreadRequest(
      {@JsonKey(includeIfNull: false)
      final List<CreateMessageRequest>? messages,
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _messages = messages,
        _metadata = metadata,
        super._();
  factory _CreateThreadRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateThreadRequestFromJson(json);

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  final List<CreateMessageRequest>? _messages;

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @override
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages {
    final value = _messages;
    if (value == null) return null;
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of CreateThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateThreadRequestCopyWith<_CreateThreadRequest> get copyWith =>
      __$CreateThreadRequestCopyWithImpl<_CreateThreadRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateThreadRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateThreadRequest &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_messages),
      toolResources,
      const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'CreateThreadRequest(messages: $messages, toolResources: $toolResources, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$CreateThreadRequestCopyWith<$Res>
    implements $CreateThreadRequestCopyWith<$Res> {
  factory _$CreateThreadRequestCopyWith(_CreateThreadRequest value,
          $Res Function(_CreateThreadRequest) _then) =
      __$CreateThreadRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class __$CreateThreadRequestCopyWithImpl<$Res>
    implements _$CreateThreadRequestCopyWith<$Res> {
  __$CreateThreadRequestCopyWithImpl(this._self, this._then);

  final _CreateThreadRequest _self;
  final $Res Function(_CreateThreadRequest) _then;

  /// Create a copy of CreateThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? messages = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_CreateThreadRequest(
      messages: freezed == messages
          ? _self._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of CreateThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }
}

/// @nodoc
mixin _$ModifyThreadRequest {
  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// Create a copy of ModifyThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModifyThreadRequestCopyWith<ModifyThreadRequest> get copyWith =>
      _$ModifyThreadRequestCopyWithImpl<ModifyThreadRequest>(
          this as ModifyThreadRequest, _$identity);

  /// Serializes this ModifyThreadRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModifyThreadRequest &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, toolResources,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'ModifyThreadRequest(toolResources: $toolResources, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $ModifyThreadRequestCopyWith<$Res> {
  factory $ModifyThreadRequestCopyWith(
          ModifyThreadRequest value, $Res Function(ModifyThreadRequest) _then) =
      _$ModifyThreadRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class _$ModifyThreadRequestCopyWithImpl<$Res>
    implements $ModifyThreadRequestCopyWith<$Res> {
  _$ModifyThreadRequestCopyWithImpl(this._self, this._then);

  final ModifyThreadRequest _self;
  final $Res Function(ModifyThreadRequest) _then;

  /// Create a copy of ModifyThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of ModifyThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ModifyThreadRequest].
extension ModifyThreadRequestPatterns on ModifyThreadRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModifyThreadRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyThreadRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModifyThreadRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyThreadRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModifyThreadRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyThreadRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyThreadRequest() when $default != null:
        return $default(_that.toolResources, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyThreadRequest():
        return $default(_that.toolResources, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'tool_resources', includeIfNull: false)
            ToolResources? toolResources,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyThreadRequest() when $default != null:
        return $default(_that.toolResources, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModifyThreadRequest extends ModifyThreadRequest {
  const _ModifyThreadRequest(
      {@JsonKey(name: 'tool_resources', includeIfNull: false)
      this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();
  factory _ModifyThreadRequest.fromJson(Map<String, dynamic> json) =>
      _$ModifyThreadRequestFromJson(json);

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific
  /// to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the
  /// `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ModifyThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModifyThreadRequestCopyWith<_ModifyThreadRequest> get copyWith =>
      __$ModifyThreadRequestCopyWithImpl<_ModifyThreadRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModifyThreadRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModifyThreadRequest &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, toolResources,
      const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'ModifyThreadRequest(toolResources: $toolResources, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$ModifyThreadRequestCopyWith<$Res>
    implements $ModifyThreadRequestCopyWith<$Res> {
  factory _$ModifyThreadRequestCopyWith(_ModifyThreadRequest value,
          $Res Function(_ModifyThreadRequest) _then) =
      __$ModifyThreadRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class __$ModifyThreadRequestCopyWithImpl<$Res>
    implements _$ModifyThreadRequestCopyWith<$Res> {
  __$ModifyThreadRequestCopyWithImpl(this._self, this._then);

  final _ModifyThreadRequest _self;
  final $Res Function(_ModifyThreadRequest) _then;

  /// Create a copy of ModifyThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_ModifyThreadRequest(
      toolResources: freezed == toolResources
          ? _self.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of ModifyThreadRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_self.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_self.toolResources!, (value) {
      return _then(_self.copyWith(toolResources: value));
    });
  }
}

/// @nodoc
mixin _$ToolResources {
  /// No Description
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  ToolResourcesCodeInterpreter? get codeInterpreter;

  /// No Description
  @JsonKey(name: 'file_search', includeIfNull: false)
  ToolResourcesFileSearch? get fileSearch;

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<ToolResources> get copyWith =>
      _$ToolResourcesCopyWithImpl<ToolResources>(
          this as ToolResources, _$identity);

  /// Serializes this ToolResources to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ToolResources &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter) &&
            (identical(other.fileSearch, fileSearch) ||
                other.fileSearch == fileSearch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, codeInterpreter, fileSearch);

  @override
  String toString() {
    return 'ToolResources(codeInterpreter: $codeInterpreter, fileSearch: $fileSearch)';
  }
}

/// @nodoc
abstract mixin class $ToolResourcesCopyWith<$Res> {
  factory $ToolResourcesCopyWith(
          ToolResources value, $Res Function(ToolResources) _then) =
      _$ToolResourcesCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'code_interpreter', includeIfNull: false)
      ToolResourcesCodeInterpreter? codeInterpreter,
      @JsonKey(name: 'file_search', includeIfNull: false)
      ToolResourcesFileSearch? fileSearch});

  $ToolResourcesCodeInterpreterCopyWith<$Res>? get codeInterpreter;
  $ToolResourcesFileSearchCopyWith<$Res>? get fileSearch;
}

/// @nodoc
class _$ToolResourcesCopyWithImpl<$Res>
    implements $ToolResourcesCopyWith<$Res> {
  _$ToolResourcesCopyWithImpl(this._self, this._then);

  final ToolResources _self;
  final $Res Function(ToolResources) _then;

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? codeInterpreter = freezed,
    Object? fileSearch = freezed,
  }) {
    return _then(_self.copyWith(
      codeInterpreter: freezed == codeInterpreter
          ? _self.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as ToolResourcesCodeInterpreter?,
      fileSearch: freezed == fileSearch
          ? _self.fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as ToolResourcesFileSearch?,
    ));
  }

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCodeInterpreterCopyWith<$Res>? get codeInterpreter {
    if (_self.codeInterpreter == null) {
      return null;
    }

    return $ToolResourcesCodeInterpreterCopyWith<$Res>(_self.codeInterpreter!,
        (value) {
      return _then(_self.copyWith(codeInterpreter: value));
    });
  }

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesFileSearchCopyWith<$Res>? get fileSearch {
    if (_self.fileSearch == null) {
      return null;
    }

    return $ToolResourcesFileSearchCopyWith<$Res>(_self.fileSearch!, (value) {
      return _then(_self.copyWith(fileSearch: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ToolResources].
extension ToolResourcesPatterns on ToolResources {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ToolResources value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResources() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ToolResources value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResources():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ToolResources value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResources() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            ToolResourcesCodeInterpreter? codeInterpreter,
            @JsonKey(name: 'file_search', includeIfNull: false)
            ToolResourcesFileSearch? fileSearch)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResources() when $default != null:
        return $default(_that.codeInterpreter, _that.fileSearch);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            ToolResourcesCodeInterpreter? codeInterpreter,
            @JsonKey(name: 'file_search', includeIfNull: false)
            ToolResourcesFileSearch? fileSearch)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResources():
        return $default(_that.codeInterpreter, _that.fileSearch);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            ToolResourcesCodeInterpreter? codeInterpreter,
            @JsonKey(name: 'file_search', includeIfNull: false)
            ToolResourcesFileSearch? fileSearch)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResources() when $default != null:
        return $default(_that.codeInterpreter, _that.fileSearch);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ToolResources extends ToolResources {
  const _ToolResources(
      {@JsonKey(name: 'code_interpreter', includeIfNull: false)
      this.codeInterpreter,
      @JsonKey(name: 'file_search', includeIfNull: false) this.fileSearch})
      : super._();
  factory _ToolResources.fromJson(Map<String, dynamic> json) =>
      _$ToolResourcesFromJson(json);

  /// No Description
  @override
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  final ToolResourcesCodeInterpreter? codeInterpreter;

  /// No Description
  @override
  @JsonKey(name: 'file_search', includeIfNull: false)
  final ToolResourcesFileSearch? fileSearch;

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ToolResourcesCopyWith<_ToolResources> get copyWith =>
      __$ToolResourcesCopyWithImpl<_ToolResources>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ToolResourcesToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ToolResources &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter) &&
            (identical(other.fileSearch, fileSearch) ||
                other.fileSearch == fileSearch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, codeInterpreter, fileSearch);

  @override
  String toString() {
    return 'ToolResources(codeInterpreter: $codeInterpreter, fileSearch: $fileSearch)';
  }
}

/// @nodoc
abstract mixin class _$ToolResourcesCopyWith<$Res>
    implements $ToolResourcesCopyWith<$Res> {
  factory _$ToolResourcesCopyWith(
          _ToolResources value, $Res Function(_ToolResources) _then) =
      __$ToolResourcesCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'code_interpreter', includeIfNull: false)
      ToolResourcesCodeInterpreter? codeInterpreter,
      @JsonKey(name: 'file_search', includeIfNull: false)
      ToolResourcesFileSearch? fileSearch});

  @override
  $ToolResourcesCodeInterpreterCopyWith<$Res>? get codeInterpreter;
  @override
  $ToolResourcesFileSearchCopyWith<$Res>? get fileSearch;
}

/// @nodoc
class __$ToolResourcesCopyWithImpl<$Res>
    implements _$ToolResourcesCopyWith<$Res> {
  __$ToolResourcesCopyWithImpl(this._self, this._then);

  final _ToolResources _self;
  final $Res Function(_ToolResources) _then;

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? codeInterpreter = freezed,
    Object? fileSearch = freezed,
  }) {
    return _then(_ToolResources(
      codeInterpreter: freezed == codeInterpreter
          ? _self.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as ToolResourcesCodeInterpreter?,
      fileSearch: freezed == fileSearch
          ? _self.fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as ToolResourcesFileSearch?,
    ));
  }

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCodeInterpreterCopyWith<$Res>? get codeInterpreter {
    if (_self.codeInterpreter == null) {
      return null;
    }

    return $ToolResourcesCodeInterpreterCopyWith<$Res>(_self.codeInterpreter!,
        (value) {
      return _then(_self.copyWith(codeInterpreter: value));
    });
  }

  /// Create a copy of ToolResources
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesFileSearchCopyWith<$Res>? get fileSearch {
    if (_self.fileSearch == null) {
      return null;
    }

    return $ToolResourcesFileSearchCopyWith<$Res>(_self.fileSearch!, (value) {
      return _then(_self.copyWith(fileSearch: value));
    });
  }
}

/// @nodoc
mixin _$ToolResourcesCodeInterpreter {
  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the
  /// `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;

  /// Create a copy of ToolResourcesCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ToolResourcesCodeInterpreterCopyWith<ToolResourcesCodeInterpreter>
      get copyWith => _$ToolResourcesCodeInterpreterCopyWithImpl<
              ToolResourcesCodeInterpreter>(
          this as ToolResourcesCodeInterpreter, _$identity);

  /// Serializes this ToolResourcesCodeInterpreter to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ToolResourcesCodeInterpreter &&
            const DeepCollectionEquality().equals(other.fileIds, fileIds));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(fileIds));

  @override
  String toString() {
    return 'ToolResourcesCodeInterpreter(fileIds: $fileIds)';
  }
}

/// @nodoc
abstract mixin class $ToolResourcesCodeInterpreterCopyWith<$Res> {
  factory $ToolResourcesCodeInterpreterCopyWith(
          ToolResourcesCodeInterpreter value,
          $Res Function(ToolResourcesCodeInterpreter) _then) =
      _$ToolResourcesCodeInterpreterCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'file_ids') List<String> fileIds});
}

/// @nodoc
class _$ToolResourcesCodeInterpreterCopyWithImpl<$Res>
    implements $ToolResourcesCodeInterpreterCopyWith<$Res> {
  _$ToolResourcesCodeInterpreterCopyWithImpl(this._self, this._then);

  final ToolResourcesCodeInterpreter _self;
  final $Res Function(ToolResourcesCodeInterpreter) _then;

  /// Create a copy of ToolResourcesCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = null,
  }) {
    return _then(_self.copyWith(
      fileIds: null == fileIds
          ? _self.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// Adds pattern-matching-related methods to [ToolResourcesCodeInterpreter].
extension ToolResourcesCodeInterpreterPatterns on ToolResourcesCodeInterpreter {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ToolResourcesCodeInterpreter value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesCodeInterpreter() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ToolResourcesCodeInterpreter value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesCodeInterpreter():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ToolResourcesCodeInterpreter value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesCodeInterpreter() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_ids') List<String> fileIds)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesCodeInterpreter() when $default != null:
        return $default(_that.fileIds);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_ids') List<String> fileIds) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesCodeInterpreter():
        return $default(_that.fileIds);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'file_ids') List<String> fileIds)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesCodeInterpreter() when $default != null:
        return $default(_that.fileIds);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ToolResourcesCodeInterpreter extends ToolResourcesCodeInterpreter {
  const _ToolResourcesCodeInterpreter(
      {@JsonKey(name: 'file_ids') final List<String> fileIds = const []})
      : _fileIds = fileIds,
        super._();
  factory _ToolResourcesCodeInterpreter.fromJson(Map<String, dynamic> json) =>
      _$ToolResourcesCodeInterpreterFromJson(json);

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the
  /// `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
  final List<String> _fileIds;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the
  /// `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// Create a copy of ToolResourcesCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ToolResourcesCodeInterpreterCopyWith<_ToolResourcesCodeInterpreter>
      get copyWith => __$ToolResourcesCodeInterpreterCopyWithImpl<
          _ToolResourcesCodeInterpreter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ToolResourcesCodeInterpreterToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ToolResourcesCodeInterpreter &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_fileIds));

  @override
  String toString() {
    return 'ToolResourcesCodeInterpreter(fileIds: $fileIds)';
  }
}

/// @nodoc
abstract mixin class _$ToolResourcesCodeInterpreterCopyWith<$Res>
    implements $ToolResourcesCodeInterpreterCopyWith<$Res> {
  factory _$ToolResourcesCodeInterpreterCopyWith(
          _ToolResourcesCodeInterpreter value,
          $Res Function(_ToolResourcesCodeInterpreter) _then) =
      __$ToolResourcesCodeInterpreterCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_ids') List<String> fileIds});
}

/// @nodoc
class __$ToolResourcesCodeInterpreterCopyWithImpl<$Res>
    implements _$ToolResourcesCodeInterpreterCopyWith<$Res> {
  __$ToolResourcesCodeInterpreterCopyWithImpl(this._self, this._then);

  final _ToolResourcesCodeInterpreter _self;
  final $Res Function(_ToolResourcesCodeInterpreter) _then;

  /// Create a copy of ToolResourcesCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileIds = null,
  }) {
    return _then(_ToolResourcesCodeInterpreter(
      fileIds: null == fileIds
          ? _self._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
mixin _$ToolResourcesFileSearch {
  /// The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to
  /// this thread. There can be a maximum of 1 vector store attached to the thread.
  @JsonKey(name: 'vector_store_ids', includeIfNull: false)
  List<String>? get vectorStoreIds;

  /// A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)
  /// with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the
  /// thread.
  @JsonKey(name: 'vector_stores', includeIfNull: false)
  List<ToolResourcesFileSearchVectorStore>? get vectorStores;

  /// Create a copy of ToolResourcesFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ToolResourcesFileSearchCopyWith<ToolResourcesFileSearch> get copyWith =>
      _$ToolResourcesFileSearchCopyWithImpl<ToolResourcesFileSearch>(
          this as ToolResourcesFileSearch, _$identity);

  /// Serializes this ToolResourcesFileSearch to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ToolResourcesFileSearch &&
            const DeepCollectionEquality()
                .equals(other.vectorStoreIds, vectorStoreIds) &&
            const DeepCollectionEquality()
                .equals(other.vectorStores, vectorStores));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(vectorStoreIds),
      const DeepCollectionEquality().hash(vectorStores));

  @override
  String toString() {
    return 'ToolResourcesFileSearch(vectorStoreIds: $vectorStoreIds, vectorStores: $vectorStores)';
  }
}

/// @nodoc
abstract mixin class $ToolResourcesFileSearchCopyWith<$Res> {
  factory $ToolResourcesFileSearchCopyWith(ToolResourcesFileSearch value,
          $Res Function(ToolResourcesFileSearch) _then) =
      _$ToolResourcesFileSearchCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'vector_store_ids', includeIfNull: false)
      List<String>? vectorStoreIds,
      @JsonKey(name: 'vector_stores', includeIfNull: false)
      List<ToolResourcesFileSearchVectorStore>? vectorStores});
}

/// @nodoc
class _$ToolResourcesFileSearchCopyWithImpl<$Res>
    implements $ToolResourcesFileSearchCopyWith<$Res> {
  _$ToolResourcesFileSearchCopyWithImpl(this._self, this._then);

  final ToolResourcesFileSearch _self;
  final $Res Function(ToolResourcesFileSearch) _then;

  /// Create a copy of ToolResourcesFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vectorStoreIds = freezed,
    Object? vectorStores = freezed,
  }) {
    return _then(_self.copyWith(
      vectorStoreIds: freezed == vectorStoreIds
          ? _self.vectorStoreIds
          : vectorStoreIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      vectorStores: freezed == vectorStores
          ? _self.vectorStores
          : vectorStores // ignore: cast_nullable_to_non_nullable
              as List<ToolResourcesFileSearchVectorStore>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ToolResourcesFileSearch].
extension ToolResourcesFileSearchPatterns on ToolResourcesFileSearch {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ToolResourcesFileSearch value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearch() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ToolResourcesFileSearch value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearch():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ToolResourcesFileSearch value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearch() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'vector_store_ids', includeIfNull: false)
            List<String>? vectorStoreIds,
            @JsonKey(name: 'vector_stores', includeIfNull: false)
            List<ToolResourcesFileSearchVectorStore>? vectorStores)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearch() when $default != null:
        return $default(_that.vectorStoreIds, _that.vectorStores);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'vector_store_ids', includeIfNull: false)
            List<String>? vectorStoreIds,
            @JsonKey(name: 'vector_stores', includeIfNull: false)
            List<ToolResourcesFileSearchVectorStore>? vectorStores)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearch():
        return $default(_that.vectorStoreIds, _that.vectorStores);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'vector_store_ids', includeIfNull: false)
            List<String>? vectorStoreIds,
            @JsonKey(name: 'vector_stores', includeIfNull: false)
            List<ToolResourcesFileSearchVectorStore>? vectorStores)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearch() when $default != null:
        return $default(_that.vectorStoreIds, _that.vectorStores);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ToolResourcesFileSearch extends ToolResourcesFileSearch {
  const _ToolResourcesFileSearch(
      {@JsonKey(name: 'vector_store_ids', includeIfNull: false)
      final List<String>? vectorStoreIds,
      @JsonKey(name: 'vector_stores', includeIfNull: false)
      final List<ToolResourcesFileSearchVectorStore>? vectorStores})
      : _vectorStoreIds = vectorStoreIds,
        _vectorStores = vectorStores,
        super._();
  factory _ToolResourcesFileSearch.fromJson(Map<String, dynamic> json) =>
      _$ToolResourcesFileSearchFromJson(json);

  /// The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to
  /// this thread. There can be a maximum of 1 vector store attached to the thread.
  final List<String>? _vectorStoreIds;

  /// The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to
  /// this thread. There can be a maximum of 1 vector store attached to the thread.
  @override
  @JsonKey(name: 'vector_store_ids', includeIfNull: false)
  List<String>? get vectorStoreIds {
    final value = _vectorStoreIds;
    if (value == null) return null;
    if (_vectorStoreIds is EqualUnmodifiableListView) return _vectorStoreIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)
  /// with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the
  /// thread.
  final List<ToolResourcesFileSearchVectorStore>? _vectorStores;

  /// A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)
  /// with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the
  /// thread.
  @override
  @JsonKey(name: 'vector_stores', includeIfNull: false)
  List<ToolResourcesFileSearchVectorStore>? get vectorStores {
    final value = _vectorStores;
    if (value == null) return null;
    if (_vectorStores is EqualUnmodifiableListView) return _vectorStores;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of ToolResourcesFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ToolResourcesFileSearchCopyWith<_ToolResourcesFileSearch> get copyWith =>
      __$ToolResourcesFileSearchCopyWithImpl<_ToolResourcesFileSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ToolResourcesFileSearchToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ToolResourcesFileSearch &&
            const DeepCollectionEquality()
                .equals(other._vectorStoreIds, _vectorStoreIds) &&
            const DeepCollectionEquality()
                .equals(other._vectorStores, _vectorStores));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_vectorStoreIds),
      const DeepCollectionEquality().hash(_vectorStores));

  @override
  String toString() {
    return 'ToolResourcesFileSearch(vectorStoreIds: $vectorStoreIds, vectorStores: $vectorStores)';
  }
}

/// @nodoc
abstract mixin class _$ToolResourcesFileSearchCopyWith<$Res>
    implements $ToolResourcesFileSearchCopyWith<$Res> {
  factory _$ToolResourcesFileSearchCopyWith(_ToolResourcesFileSearch value,
          $Res Function(_ToolResourcesFileSearch) _then) =
      __$ToolResourcesFileSearchCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'vector_store_ids', includeIfNull: false)
      List<String>? vectorStoreIds,
      @JsonKey(name: 'vector_stores', includeIfNull: false)
      List<ToolResourcesFileSearchVectorStore>? vectorStores});
}

/// @nodoc
class __$ToolResourcesFileSearchCopyWithImpl<$Res>
    implements _$ToolResourcesFileSearchCopyWith<$Res> {
  __$ToolResourcesFileSearchCopyWithImpl(this._self, this._then);

  final _ToolResourcesFileSearch _self;
  final $Res Function(_ToolResourcesFileSearch) _then;

  /// Create a copy of ToolResourcesFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? vectorStoreIds = freezed,
    Object? vectorStores = freezed,
  }) {
    return _then(_ToolResourcesFileSearch(
      vectorStoreIds: freezed == vectorStoreIds
          ? _self._vectorStoreIds
          : vectorStoreIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      vectorStores: freezed == vectorStores
          ? _self._vectorStores
          : vectorStores // ignore: cast_nullable_to_non_nullable
              as List<ToolResourcesFileSearchVectorStore>?,
    ));
  }
}

/// @nodoc
mixin _$ToolResourcesFileSearchVectorStore {
  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store.
  /// There can be a maximum of 10000 files in a vector store.
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;

  /// Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional
  /// information about the vector store in a structured format. Keys can be a maximum of 64 characters long and
  /// values can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;

  /// Create a copy of ToolResourcesFileSearchVectorStore
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ToolResourcesFileSearchVectorStoreCopyWith<
          ToolResourcesFileSearchVectorStore>
      get copyWith => _$ToolResourcesFileSearchVectorStoreCopyWithImpl<
              ToolResourcesFileSearchVectorStore>(
          this as ToolResourcesFileSearchVectorStore, _$identity);

  /// Serializes this ToolResourcesFileSearchVectorStore to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ToolResourcesFileSearchVectorStore &&
            const DeepCollectionEquality().equals(other.fileIds, fileIds) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(fileIds),
      chunkingStrategy,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'ToolResourcesFileSearchVectorStore(fileIds: $fileIds, chunkingStrategy: $chunkingStrategy, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $ToolResourcesFileSearchVectorStoreCopyWith<$Res> {
  factory $ToolResourcesFileSearchVectorStoreCopyWith(
          ToolResourcesFileSearchVectorStore value,
          $Res Function(ToolResourcesFileSearchVectorStore) _then) =
      _$ToolResourcesFileSearchVectorStoreCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$ToolResourcesFileSearchVectorStoreCopyWithImpl<$Res>
    implements $ToolResourcesFileSearchVectorStoreCopyWith<$Res> {
  _$ToolResourcesFileSearchVectorStoreCopyWithImpl(this._self, this._then);

  final ToolResourcesFileSearchVectorStore _self;
  final $Res Function(ToolResourcesFileSearchVectorStore) _then;

  /// Create a copy of ToolResourcesFileSearchVectorStore
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      fileIds: freezed == fileIds
          ? _self.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of ToolResourcesFileSearchVectorStore
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// Adds pattern-matching-related methods to [ToolResourcesFileSearchVectorStore].
extension ToolResourcesFileSearchVectorStorePatterns
    on ToolResourcesFileSearchVectorStore {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ToolResourcesFileSearchVectorStore value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearchVectorStore() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ToolResourcesFileSearchVectorStore value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearchVectorStore():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ToolResourcesFileSearchVectorStore value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearchVectorStore() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_ids', includeIfNull: false)
            List<String>? fileIds,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearchVectorStore() when $default != null:
        return $default(_that.fileIds, _that.chunkingStrategy, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_ids', includeIfNull: false)
            List<String>? fileIds,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy,
            @JsonKey(includeIfNull: false) dynamic metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearchVectorStore():
        return $default(_that.fileIds, _that.chunkingStrategy, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_ids', includeIfNull: false)
            List<String>? fileIds,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ToolResourcesFileSearchVectorStore() when $default != null:
        return $default(_that.fileIds, _that.chunkingStrategy, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ToolResourcesFileSearchVectorStore
    extends ToolResourcesFileSearchVectorStore {
  const _ToolResourcesFileSearchVectorStore(
      {@JsonKey(name: 'file_ids', includeIfNull: false)
      final List<String>? fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy,
      @JsonKey(includeIfNull: false) this.metadata})
      : _fileIds = fileIds,
        super._();
  factory _ToolResourcesFileSearchVectorStore.fromJson(
          Map<String, dynamic> json) =>
      _$ToolResourcesFileSearchVectorStoreFromJson(json);

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store.
  /// There can be a maximum of 10000 files in a vector store.
  final List<String>? _fileIds;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store.
  /// There can be a maximum of 10000 files in a vector store.
  @override
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds {
    final value = _fileIds;
    if (value == null) return null;
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  /// Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional
  /// information about the vector store in a structured format. Keys can be a maximum of 64 characters long and
  /// values can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  /// Create a copy of ToolResourcesFileSearchVectorStore
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ToolResourcesFileSearchVectorStoreCopyWith<
          _ToolResourcesFileSearchVectorStore>
      get copyWith => __$ToolResourcesFileSearchVectorStoreCopyWithImpl<
          _ToolResourcesFileSearchVectorStore>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ToolResourcesFileSearchVectorStoreToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ToolResourcesFileSearchVectorStore &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_fileIds),
      chunkingStrategy,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'ToolResourcesFileSearchVectorStore(fileIds: $fileIds, chunkingStrategy: $chunkingStrategy, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$ToolResourcesFileSearchVectorStoreCopyWith<$Res>
    implements $ToolResourcesFileSearchVectorStoreCopyWith<$Res> {
  factory _$ToolResourcesFileSearchVectorStoreCopyWith(
          _ToolResourcesFileSearchVectorStore value,
          $Res Function(_ToolResourcesFileSearchVectorStore) _then) =
      __$ToolResourcesFileSearchVectorStoreCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$ToolResourcesFileSearchVectorStoreCopyWithImpl<$Res>
    implements _$ToolResourcesFileSearchVectorStoreCopyWith<$Res> {
  __$ToolResourcesFileSearchVectorStoreCopyWithImpl(this._self, this._then);

  final _ToolResourcesFileSearchVectorStore _self;
  final $Res Function(_ToolResourcesFileSearchVectorStore) _then;

  /// Create a copy of ToolResourcesFileSearchVectorStore
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileIds = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_ToolResourcesFileSearchVectorStore(
      fileIds: freezed == fileIds
          ? _self._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of ToolResourcesFileSearchVectorStore
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// @nodoc
mixin _$DeleteThreadResponse {
  /// The thread identifier.
  String get id;

  /// Whether the thread was deleted.
  bool get deleted;

  /// The object type, which is always `thread.deleted`.
  DeleteThreadResponseObject get object;

  /// Create a copy of DeleteThreadResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DeleteThreadResponseCopyWith<DeleteThreadResponse> get copyWith =>
      _$DeleteThreadResponseCopyWithImpl<DeleteThreadResponse>(
          this as DeleteThreadResponse, _$identity);

  /// Serializes this DeleteThreadResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteThreadResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteThreadResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class $DeleteThreadResponseCopyWith<$Res> {
  factory $DeleteThreadResponseCopyWith(DeleteThreadResponse value,
          $Res Function(DeleteThreadResponse) _then) =
      _$DeleteThreadResponseCopyWithImpl;
  @useResult
  $Res call({String id, bool deleted, DeleteThreadResponseObject object});
}

/// @nodoc
class _$DeleteThreadResponseCopyWithImpl<$Res>
    implements $DeleteThreadResponseCopyWith<$Res> {
  _$DeleteThreadResponseCopyWithImpl(this._self, this._then);

  final DeleteThreadResponse _self;
  final $Res Function(DeleteThreadResponse) _then;

  /// Create a copy of DeleteThreadResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteThreadResponseObject,
    ));
  }
}

/// Adds pattern-matching-related methods to [DeleteThreadResponse].
extension DeleteThreadResponsePatterns on DeleteThreadResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DeleteThreadResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteThreadResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DeleteThreadResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteThreadResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DeleteThreadResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteThreadResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id, bool deleted, DeleteThreadResponseObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteThreadResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String id, bool deleted, DeleteThreadResponseObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteThreadResponse():
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id, bool deleted, DeleteThreadResponseObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteThreadResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DeleteThreadResponse extends DeleteThreadResponse {
  const _DeleteThreadResponse(
      {required this.id, required this.deleted, required this.object})
      : super._();
  factory _DeleteThreadResponse.fromJson(Map<String, dynamic> json) =>
      _$DeleteThreadResponseFromJson(json);

  /// The thread identifier.
  @override
  final String id;

  /// Whether the thread was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `thread.deleted`.
  @override
  final DeleteThreadResponseObject object;

  /// Create a copy of DeleteThreadResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DeleteThreadResponseCopyWith<_DeleteThreadResponse> get copyWith =>
      __$DeleteThreadResponseCopyWithImpl<_DeleteThreadResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DeleteThreadResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DeleteThreadResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteThreadResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$DeleteThreadResponseCopyWith<$Res>
    implements $DeleteThreadResponseCopyWith<$Res> {
  factory _$DeleteThreadResponseCopyWith(_DeleteThreadResponse value,
          $Res Function(_DeleteThreadResponse) _then) =
      __$DeleteThreadResponseCopyWithImpl;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteThreadResponseObject object});
}

/// @nodoc
class __$DeleteThreadResponseCopyWithImpl<$Res>
    implements _$DeleteThreadResponseCopyWith<$Res> {
  __$DeleteThreadResponseCopyWithImpl(this._self, this._then);

  final _DeleteThreadResponse _self;
  final $Res Function(_DeleteThreadResponse) _then;

  /// Create a copy of DeleteThreadResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_DeleteThreadResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteThreadResponseObject,
    ));
  }
}

/// @nodoc
mixin _$ListThreadsResponse {
  /// The object type, which is always `list`.
  String get object;

  /// The list of threads.
  List<ThreadObject> get data;

  /// The ID of the first thread in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last thread in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more threads to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListThreadsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListThreadsResponseCopyWith<ListThreadsResponse> get copyWith =>
      _$ListThreadsResponseCopyWithImpl<ListThreadsResponse>(
          this as ListThreadsResponse, _$identity);

  /// Serializes this ListThreadsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListThreadsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListThreadsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListThreadsResponseCopyWith<$Res> {
  factory $ListThreadsResponseCopyWith(
          ListThreadsResponse value, $Res Function(ListThreadsResponse) _then) =
      _$ListThreadsResponseCopyWithImpl;
  @useResult
  $Res call(
      {String object,
      List<ThreadObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListThreadsResponseCopyWithImpl<$Res>
    implements $ListThreadsResponseCopyWith<$Res> {
  _$ListThreadsResponseCopyWithImpl(this._self, this._then);

  final ListThreadsResponse _self;
  final $Res Function(ListThreadsResponse) _then;

  /// Create a copy of ListThreadsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ThreadObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListThreadsResponse].
extension ListThreadsResponsePatterns on ListThreadsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListThreadsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListThreadsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListThreadsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListThreadsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListThreadsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListThreadsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String object,
            List<ThreadObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListThreadsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String object,
            List<ThreadObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListThreadsResponse():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String object,
            List<ThreadObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListThreadsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListThreadsResponse extends ListThreadsResponse {
  const _ListThreadsResponse(
      {required this.object,
      required final List<ThreadObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListThreadsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListThreadsResponseFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of threads.
  final List<ThreadObject> _data;

  /// The list of threads.
  @override
  List<ThreadObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first thread in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last thread in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more threads to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListThreadsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListThreadsResponseCopyWith<_ListThreadsResponse> get copyWith =>
      __$ListThreadsResponseCopyWithImpl<_ListThreadsResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListThreadsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListThreadsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListThreadsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListThreadsResponseCopyWith<$Res>
    implements $ListThreadsResponseCopyWith<$Res> {
  factory _$ListThreadsResponseCopyWith(_ListThreadsResponse value,
          $Res Function(_ListThreadsResponse) _then) =
      __$ListThreadsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String object,
      List<ThreadObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListThreadsResponseCopyWithImpl<$Res>
    implements _$ListThreadsResponseCopyWith<$Res> {
  __$ListThreadsResponseCopyWithImpl(this._self, this._then);

  final _ListThreadsResponse _self;
  final $Res Function(_ListThreadsResponse) _then;

  /// Create a copy of ListThreadsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListThreadsResponse(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ThreadObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$MessageObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `thread.message`.
  MessageObjectObject get object;

  /// The Unix timestamp (in seconds) for when the message was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @JsonKey(name: 'thread_id')
  String get threadId;

  /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
  @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  MessageObjectStatus? get status;

  /// On an incomplete message, details about why the message is incomplete.
  @JsonKey(name: 'incomplete_details')
  MessageObjectIncompleteDetails? get incompleteDetails;

  /// The Unix timestamp (in seconds) for when the message was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;

  /// The Unix timestamp (in seconds) for when the message was marked as incomplete.
  @JsonKey(name: 'incomplete_at')
  int? get incompleteAt;

  /// The entity that produced the message. One of `user` or `assistant`.
  MessageRole get role;

  /// The content of the message in array of text and/or images.
  List<MessageContent> get content;

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @JsonKey(name: 'assistant_id')
  String? get assistantId;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
  @JsonKey(name: 'run_id')
  String? get runId;

  /// A list of files attached to the message, and the tools they were added to.
  List<MessageAttachment>? get attachments;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  Map<String, dynamic>? get metadata;

  /// Create a copy of MessageObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageObjectCopyWith<MessageObject> get copyWith =>
      _$MessageObjectCopyWithImpl<MessageObject>(
          this as MessageObject, _$identity);

  /// Serializes this MessageObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.incompleteDetails, incompleteDetails) ||
                other.incompleteDetails == incompleteDetails) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.incompleteAt, incompleteAt) ||
                other.incompleteAt == incompleteAt) &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other.content, content) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            const DeepCollectionEquality()
                .equals(other.attachments, attachments) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      threadId,
      status,
      incompleteDetails,
      completedAt,
      incompleteAt,
      role,
      const DeepCollectionEquality().hash(content),
      assistantId,
      runId,
      const DeepCollectionEquality().hash(attachments),
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'MessageObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, status: $status, incompleteDetails: $incompleteDetails, completedAt: $completedAt, incompleteAt: $incompleteAt, role: $role, content: $content, assistantId: $assistantId, runId: $runId, attachments: $attachments, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $MessageObjectCopyWith<$Res> {
  factory $MessageObjectCopyWith(
          MessageObject value, $Res Function(MessageObject) _then) =
      _$MessageObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      MessageObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageObjectStatus? status,
      @JsonKey(name: 'incomplete_details')
      MessageObjectIncompleteDetails? incompleteDetails,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_at') int? incompleteAt,
      MessageRole role,
      List<MessageContent> content,
      @JsonKey(name: 'assistant_id') String? assistantId,
      @JsonKey(name: 'run_id') String? runId,
      List<MessageAttachment>? attachments,
      Map<String, dynamic>? metadata});

  $MessageObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
}

/// @nodoc
class _$MessageObjectCopyWithImpl<$Res>
    implements $MessageObjectCopyWith<$Res> {
  _$MessageObjectCopyWithImpl(this._self, this._then);

  final MessageObject _self;
  final $Res Function(MessageObject) _then;

  /// Create a copy of MessageObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? status = freezed,
    Object? incompleteDetails = freezed,
    Object? completedAt = freezed,
    Object? incompleteAt = freezed,
    Object? role = null,
    Object? content = null,
    Object? assistantId = freezed,
    Object? runId = freezed,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MessageObjectStatus?,
      incompleteDetails: freezed == incompleteDetails
          ? _self.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetails?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteAt: freezed == incompleteAt
          ? _self.incompleteAt
          : incompleteAt // ignore: cast_nullable_to_non_nullable
              as int?,
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
      assistantId: freezed == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String?,
      runId: freezed == runId
          ? _self.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String?,
      attachments: freezed == attachments
          ? _self.attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of MessageObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails {
    if (_self.incompleteDetails == null) {
      return null;
    }

    return $MessageObjectIncompleteDetailsCopyWith<$Res>(
        _self.incompleteDetails!, (value) {
      return _then(_self.copyWith(incompleteDetails: value));
    });
  }
}

/// Adds pattern-matching-related methods to [MessageObject].
extension MessageObjectPatterns on MessageObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            MessageObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            MessageObjectStatus? status,
            @JsonKey(name: 'incomplete_details')
            MessageObjectIncompleteDetails? incompleteDetails,
            @JsonKey(name: 'completed_at') int? completedAt,
            @JsonKey(name: 'incomplete_at') int? incompleteAt,
            MessageRole role,
            List<MessageContent> content,
            @JsonKey(name: 'assistant_id') String? assistantId,
            @JsonKey(name: 'run_id') String? runId,
            List<MessageAttachment>? attachments,
            Map<String, dynamic>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.threadId,
            _that.status,
            _that.incompleteDetails,
            _that.completedAt,
            _that.incompleteAt,
            _that.role,
            _that.content,
            _that.assistantId,
            _that.runId,
            _that.attachments,
            _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            MessageObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            MessageObjectStatus? status,
            @JsonKey(name: 'incomplete_details')
            MessageObjectIncompleteDetails? incompleteDetails,
            @JsonKey(name: 'completed_at') int? completedAt,
            @JsonKey(name: 'incomplete_at') int? incompleteAt,
            MessageRole role,
            List<MessageContent> content,
            @JsonKey(name: 'assistant_id') String? assistantId,
            @JsonKey(name: 'run_id') String? runId,
            List<MessageAttachment>? attachments,
            Map<String, dynamic>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObject():
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.threadId,
            _that.status,
            _that.incompleteDetails,
            _that.completedAt,
            _that.incompleteAt,
            _that.role,
            _that.content,
            _that.assistantId,
            _that.runId,
            _that.attachments,
            _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            MessageObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            MessageObjectStatus? status,
            @JsonKey(name: 'incomplete_details')
            MessageObjectIncompleteDetails? incompleteDetails,
            @JsonKey(name: 'completed_at') int? completedAt,
            @JsonKey(name: 'incomplete_at') int? incompleteAt,
            MessageRole role,
            List<MessageContent> content,
            @JsonKey(name: 'assistant_id') String? assistantId,
            @JsonKey(name: 'run_id') String? runId,
            List<MessageAttachment>? attachments,
            Map<String, dynamic>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.threadId,
            _that.status,
            _that.incompleteDetails,
            _that.completedAt,
            _that.incompleteAt,
            _that.role,
            _that.content,
            _that.assistantId,
            _that.runId,
            _that.attachments,
            _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageObject extends MessageObject {
  const _MessageObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.status,
      @JsonKey(name: 'incomplete_details') required this.incompleteDetails,
      @JsonKey(name: 'completed_at') required this.completedAt,
      @JsonKey(name: 'incomplete_at') required this.incompleteAt,
      required this.role,
      required final List<MessageContent> content,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(name: 'run_id') required this.runId,
      required final List<MessageAttachment>? attachments,
      required final Map<String, dynamic>? metadata})
      : _content = content,
        _attachments = attachments,
        _metadata = metadata,
        super._();
  factory _MessageObject.fromJson(Map<String, dynamic> json) =>
      _$MessageObjectFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.message`.
  @override
  final MessageObjectObject object;

  /// The Unix timestamp (in seconds) for when the message was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
  @override
  @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final MessageObjectStatus? status;

  /// On an incomplete message, details about why the message is incomplete.
  @override
  @JsonKey(name: 'incomplete_details')
  final MessageObjectIncompleteDetails? incompleteDetails;

  /// The Unix timestamp (in seconds) for when the message was completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// The Unix timestamp (in seconds) for when the message was marked as incomplete.
  @override
  @JsonKey(name: 'incomplete_at')
  final int? incompleteAt;

  /// The entity that produced the message. One of `user` or `assistant`.
  @override
  final MessageRole role;

  /// The content of the message in array of text and/or images.
  final List<MessageContent> _content;

  /// The content of the message in array of text and/or images.
  @override
  List<MessageContent> get content {
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_content);
  }

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @override
  @JsonKey(name: 'assistant_id')
  final String? assistantId;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
  @override
  @JsonKey(name: 'run_id')
  final String? runId;

  /// A list of files attached to the message, and the tools they were added to.
  final List<MessageAttachment>? _attachments;

  /// A list of files attached to the message, and the tools they were added to.
  @override
  List<MessageAttachment>? get attachments {
    final value = _attachments;
    if (value == null) return null;
    if (_attachments is EqualUnmodifiableListView) return _attachments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of MessageObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageObjectCopyWith<_MessageObject> get copyWith =>
      __$MessageObjectCopyWithImpl<_MessageObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.incompleteDetails, incompleteDetails) ||
                other.incompleteDetails == incompleteDetails) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.incompleteAt, incompleteAt) ||
                other.incompleteAt == incompleteAt) &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            const DeepCollectionEquality()
                .equals(other._attachments, _attachments) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      threadId,
      status,
      incompleteDetails,
      completedAt,
      incompleteAt,
      role,
      const DeepCollectionEquality().hash(_content),
      assistantId,
      runId,
      const DeepCollectionEquality().hash(_attachments),
      const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'MessageObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, status: $status, incompleteDetails: $incompleteDetails, completedAt: $completedAt, incompleteAt: $incompleteAt, role: $role, content: $content, assistantId: $assistantId, runId: $runId, attachments: $attachments, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$MessageObjectCopyWith<$Res>
    implements $MessageObjectCopyWith<$Res> {
  factory _$MessageObjectCopyWith(
          _MessageObject value, $Res Function(_MessageObject) _then) =
      __$MessageObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      MessageObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageObjectStatus? status,
      @JsonKey(name: 'incomplete_details')
      MessageObjectIncompleteDetails? incompleteDetails,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_at') int? incompleteAt,
      MessageRole role,
      List<MessageContent> content,
      @JsonKey(name: 'assistant_id') String? assistantId,
      @JsonKey(name: 'run_id') String? runId,
      List<MessageAttachment>? attachments,
      Map<String, dynamic>? metadata});

  @override
  $MessageObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
}

/// @nodoc
class __$MessageObjectCopyWithImpl<$Res>
    implements _$MessageObjectCopyWith<$Res> {
  __$MessageObjectCopyWithImpl(this._self, this._then);

  final _MessageObject _self;
  final $Res Function(_MessageObject) _then;

  /// Create a copy of MessageObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? status = freezed,
    Object? incompleteDetails = freezed,
    Object? completedAt = freezed,
    Object? incompleteAt = freezed,
    Object? role = null,
    Object? content = null,
    Object? assistantId = freezed,
    Object? runId = freezed,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_MessageObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      status: freezed == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as MessageObjectStatus?,
      incompleteDetails: freezed == incompleteDetails
          ? _self.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetails?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteAt: freezed == incompleteAt
          ? _self.incompleteAt
          : incompleteAt // ignore: cast_nullable_to_non_nullable
              as int?,
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _self._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
      assistantId: freezed == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String?,
      runId: freezed == runId
          ? _self.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String?,
      attachments: freezed == attachments
          ? _self._attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of MessageObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails {
    if (_self.incompleteDetails == null) {
      return null;
    }

    return $MessageObjectIncompleteDetailsCopyWith<$Res>(
        _self.incompleteDetails!, (value) {
      return _then(_self.copyWith(incompleteDetails: value));
    });
  }
}

/// @nodoc
mixin _$MessageObjectIncompleteDetails {
  /// The reason the message is incomplete.
  MessageObjectIncompleteDetailsReason get reason;

  /// Create a copy of MessageObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageObjectIncompleteDetailsCopyWith<MessageObjectIncompleteDetails>
      get copyWith => _$MessageObjectIncompleteDetailsCopyWithImpl<
              MessageObjectIncompleteDetails>(
          this as MessageObjectIncompleteDetails, _$identity);

  /// Serializes this MessageObjectIncompleteDetails to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageObjectIncompleteDetails &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @override
  String toString() {
    return 'MessageObjectIncompleteDetails(reason: $reason)';
  }
}

/// @nodoc
abstract mixin class $MessageObjectIncompleteDetailsCopyWith<$Res> {
  factory $MessageObjectIncompleteDetailsCopyWith(
          MessageObjectIncompleteDetails value,
          $Res Function(MessageObjectIncompleteDetails) _then) =
      _$MessageObjectIncompleteDetailsCopyWithImpl;
  @useResult
  $Res call({MessageObjectIncompleteDetailsReason reason});
}

/// @nodoc
class _$MessageObjectIncompleteDetailsCopyWithImpl<$Res>
    implements $MessageObjectIncompleteDetailsCopyWith<$Res> {
  _$MessageObjectIncompleteDetailsCopyWithImpl(this._self, this._then);

  final MessageObjectIncompleteDetails _self;
  final $Res Function(MessageObjectIncompleteDetails) _then;

  /// Create a copy of MessageObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = null,
  }) {
    return _then(_self.copyWith(
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetailsReason,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageObjectIncompleteDetails].
extension MessageObjectIncompleteDetailsPatterns
    on MessageObjectIncompleteDetails {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageObjectIncompleteDetails value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageObjectIncompleteDetails() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageObjectIncompleteDetails value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObjectIncompleteDetails():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageObjectIncompleteDetails value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObjectIncompleteDetails() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(MessageObjectIncompleteDetailsReason reason)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageObjectIncompleteDetails() when $default != null:
        return $default(_that.reason);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(MessageObjectIncompleteDetailsReason reason) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObjectIncompleteDetails():
        return $default(_that.reason);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(MessageObjectIncompleteDetailsReason reason)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageObjectIncompleteDetails() when $default != null:
        return $default(_that.reason);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageObjectIncompleteDetails extends MessageObjectIncompleteDetails {
  const _MessageObjectIncompleteDetails({required this.reason}) : super._();
  factory _MessageObjectIncompleteDetails.fromJson(Map<String, dynamic> json) =>
      _$MessageObjectIncompleteDetailsFromJson(json);

  /// The reason the message is incomplete.
  @override
  final MessageObjectIncompleteDetailsReason reason;

  /// Create a copy of MessageObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageObjectIncompleteDetailsCopyWith<_MessageObjectIncompleteDetails>
      get copyWith => __$MessageObjectIncompleteDetailsCopyWithImpl<
          _MessageObjectIncompleteDetails>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageObjectIncompleteDetailsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageObjectIncompleteDetails &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @override
  String toString() {
    return 'MessageObjectIncompleteDetails(reason: $reason)';
  }
}

/// @nodoc
abstract mixin class _$MessageObjectIncompleteDetailsCopyWith<$Res>
    implements $MessageObjectIncompleteDetailsCopyWith<$Res> {
  factory _$MessageObjectIncompleteDetailsCopyWith(
          _MessageObjectIncompleteDetails value,
          $Res Function(_MessageObjectIncompleteDetails) _then) =
      __$MessageObjectIncompleteDetailsCopyWithImpl;
  @override
  @useResult
  $Res call({MessageObjectIncompleteDetailsReason reason});
}

/// @nodoc
class __$MessageObjectIncompleteDetailsCopyWithImpl<$Res>
    implements _$MessageObjectIncompleteDetailsCopyWith<$Res> {
  __$MessageObjectIncompleteDetailsCopyWithImpl(this._self, this._then);

  final _MessageObjectIncompleteDetails _self;
  final $Res Function(_MessageObjectIncompleteDetails) _then;

  /// Create a copy of MessageObjectIncompleteDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? reason = null,
  }) {
    return _then(_MessageObjectIncompleteDetails(
      reason: null == reason
          ? _self.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetailsReason,
    ));
  }
}

/// @nodoc
mixin _$MessageAttachment {
  /// The ID of the file to attach to the message.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;

  /// The tools to add this file to.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;

  /// Create a copy of MessageAttachment
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageAttachmentCopyWith<MessageAttachment> get copyWith =>
      _$MessageAttachmentCopyWithImpl<MessageAttachment>(
          this as MessageAttachment, _$identity);

  /// Serializes this MessageAttachment to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageAttachment &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            const DeepCollectionEquality().equals(other.tools, tools));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileId, const DeepCollectionEquality().hash(tools));

  @override
  String toString() {
    return 'MessageAttachment(fileId: $fileId, tools: $tools)';
  }
}

/// @nodoc
abstract mixin class $MessageAttachmentCopyWith<$Res> {
  factory $MessageAttachmentCopyWith(
          MessageAttachment value, $Res Function(MessageAttachment) _then) =
      _$MessageAttachmentCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools});
}

/// @nodoc
class _$MessageAttachmentCopyWithImpl<$Res>
    implements $MessageAttachmentCopyWith<$Res> {
  _$MessageAttachmentCopyWithImpl(this._self, this._then);

  final MessageAttachment _self;
  final $Res Function(MessageAttachment) _then;

  /// Create a copy of MessageAttachment
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
    Object? tools = freezed,
  }) {
    return _then(_self.copyWith(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _self.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageAttachment].
extension MessageAttachmentPatterns on MessageAttachment {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageAttachment value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageAttachment() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageAttachment value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageAttachment():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageAttachment value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageAttachment() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageAttachment() when $default != null:
        return $default(_that.fileId, _that.tools);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageAttachment():
        return $default(_that.fileId, _that.tools);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
            @JsonKey(includeIfNull: false) List<AssistantTools>? tools)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageAttachment() when $default != null:
        return $default(_that.fileId, _that.tools);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageAttachment extends MessageAttachment {
  const _MessageAttachment(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools})
      : _tools = tools,
        super._();
  factory _MessageAttachment.fromJson(Map<String, dynamic> json) =>
      _$MessageAttachmentFromJson(json);

  /// The ID of the file to attach to the message.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  /// The tools to add this file to.
  final List<AssistantTools>? _tools;

  /// The tools to add this file to.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of MessageAttachment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageAttachmentCopyWith<_MessageAttachment> get copyWith =>
      __$MessageAttachmentCopyWithImpl<_MessageAttachment>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageAttachmentToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageAttachment &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            const DeepCollectionEquality().equals(other._tools, _tools));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileId, const DeepCollectionEquality().hash(_tools));

  @override
  String toString() {
    return 'MessageAttachment(fileId: $fileId, tools: $tools)';
  }
}

/// @nodoc
abstract mixin class _$MessageAttachmentCopyWith<$Res>
    implements $MessageAttachmentCopyWith<$Res> {
  factory _$MessageAttachmentCopyWith(
          _MessageAttachment value, $Res Function(_MessageAttachment) _then) =
      __$MessageAttachmentCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools});
}

/// @nodoc
class __$MessageAttachmentCopyWithImpl<$Res>
    implements _$MessageAttachmentCopyWith<$Res> {
  __$MessageAttachmentCopyWithImpl(this._self, this._then);

  final _MessageAttachment _self;
  final $Res Function(_MessageAttachment) _then;

  /// Create a copy of MessageAttachment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = freezed,
    Object? tools = freezed,
  }) {
    return _then(_MessageAttachment(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _self._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
    ));
  }
}

/// @nodoc
mixin _$MessageDeltaObject {
  /// The identifier of the message, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `thread.message.delta`.
  MessageDeltaObjectObject get object;

  /// The delta containing the fields that have changed on the Message.
  MessageDelta get delta;

  /// Create a copy of MessageDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaObjectCopyWith<MessageDeltaObject> get copyWith =>
      _$MessageDeltaObjectCopyWithImpl<MessageDeltaObject>(
          this as MessageDeltaObject, _$identity);

  /// Serializes this MessageDeltaObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, delta);

  @override
  String toString() {
    return 'MessageDeltaObject(id: $id, object: $object, delta: $delta)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaObjectCopyWith<$Res> {
  factory $MessageDeltaObjectCopyWith(
          MessageDeltaObject value, $Res Function(MessageDeltaObject) _then) =
      _$MessageDeltaObjectCopyWithImpl;
  @useResult
  $Res call({String id, MessageDeltaObjectObject object, MessageDelta delta});

  $MessageDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class _$MessageDeltaObjectCopyWithImpl<$Res>
    implements $MessageDeltaObjectCopyWith<$Res> {
  _$MessageDeltaObjectCopyWithImpl(this._self, this._then);

  final MessageDeltaObject _self;
  final $Res Function(MessageDeltaObject) _then;

  /// Create a copy of MessageDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageDeltaObjectObject,
      delta: null == delta
          ? _self.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as MessageDelta,
    ));
  }

  /// Create a copy of MessageDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaCopyWith<$Res> get delta {
    return $MessageDeltaCopyWith<$Res>(_self.delta, (value) {
      return _then(_self.copyWith(delta: value));
    });
  }
}

/// Adds pattern-matching-related methods to [MessageDeltaObject].
extension MessageDeltaObjectPatterns on MessageDeltaObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageDeltaObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageDeltaObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageDeltaObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id, MessageDeltaObjectObject object, MessageDelta delta)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaObject() when $default != null:
        return $default(_that.id, _that.object, _that.delta);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id, MessageDeltaObjectObject object, MessageDelta delta)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaObject():
        return $default(_that.id, _that.object, _that.delta);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id, MessageDeltaObjectObject object, MessageDelta delta)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaObject() when $default != null:
        return $default(_that.id, _that.object, _that.delta);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageDeltaObject extends MessageDeltaObject {
  const _MessageDeltaObject(
      {required this.id, required this.object, required this.delta})
      : super._();
  factory _MessageDeltaObject.fromJson(Map<String, dynamic> json) =>
      _$MessageDeltaObjectFromJson(json);

  /// The identifier of the message, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.message.delta`.
  @override
  final MessageDeltaObjectObject object;

  /// The delta containing the fields that have changed on the Message.
  @override
  final MessageDelta delta;

  /// Create a copy of MessageDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageDeltaObjectCopyWith<_MessageDeltaObject> get copyWith =>
      __$MessageDeltaObjectCopyWithImpl<_MessageDeltaObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageDeltaObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, delta);

  @override
  String toString() {
    return 'MessageDeltaObject(id: $id, object: $object, delta: $delta)';
  }
}

/// @nodoc
abstract mixin class _$MessageDeltaObjectCopyWith<$Res>
    implements $MessageDeltaObjectCopyWith<$Res> {
  factory _$MessageDeltaObjectCopyWith(
          _MessageDeltaObject value, $Res Function(_MessageDeltaObject) _then) =
      __$MessageDeltaObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String id, MessageDeltaObjectObject object, MessageDelta delta});

  @override
  $MessageDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class __$MessageDeltaObjectCopyWithImpl<$Res>
    implements _$MessageDeltaObjectCopyWith<$Res> {
  __$MessageDeltaObjectCopyWithImpl(this._self, this._then);

  final _MessageDeltaObject _self;
  final $Res Function(_MessageDeltaObject) _then;

  /// Create a copy of MessageDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_MessageDeltaObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageDeltaObjectObject,
      delta: null == delta
          ? _self.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as MessageDelta,
    ));
  }

  /// Create a copy of MessageDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaCopyWith<$Res> get delta {
    return $MessageDeltaCopyWith<$Res>(_self.delta, (value) {
      return _then(_self.copyWith(delta: value));
    });
  }
}

/// @nodoc
mixin _$MessageDelta {
  /// The entity that produced the message. One of `user` or `assistant`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  MessageRole? get role;

  /// The content of the message in array of text and/or images.
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContent>? get content;

  /// Create a copy of MessageDelta
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaCopyWith<MessageDelta> get copyWith =>
      _$MessageDeltaCopyWithImpl<MessageDelta>(
          this as MessageDelta, _$identity);

  /// Serializes this MessageDelta to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDelta &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other.content, content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, role, const DeepCollectionEquality().hash(content));

  @override
  String toString() {
    return 'MessageDelta(role: $role, content: $content)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaCopyWith<$Res> {
  factory $MessageDeltaCopyWith(
          MessageDelta value, $Res Function(MessageDelta) _then) =
      _$MessageDeltaCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageRole? role,
      @JsonKey(includeIfNull: false) List<MessageDeltaContent>? content});
}

/// @nodoc
class _$MessageDeltaCopyWithImpl<$Res> implements $MessageDeltaCopyWith<$Res> {
  _$MessageDeltaCopyWithImpl(this._self, this._then);

  final MessageDelta _self;
  final $Res Function(MessageDelta) _then;

  /// Create a copy of MessageDelta
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = freezed,
    Object? content = freezed,
  }) {
    return _then(_self.copyWith(
      role: freezed == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole?,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContent>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageDelta].
extension MessageDeltaPatterns on MessageDelta {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageDelta value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDelta() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageDelta value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDelta():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageDelta value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDelta() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            MessageRole? role,
            @JsonKey(includeIfNull: false) List<MessageDeltaContent>? content)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDelta() when $default != null:
        return $default(_that.role, _that.content);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            MessageRole? role,
            @JsonKey(includeIfNull: false) List<MessageDeltaContent>? content)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDelta():
        return $default(_that.role, _that.content);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(
                includeIfNull: false,
                unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
            MessageRole? role,
            @JsonKey(includeIfNull: false) List<MessageDeltaContent>? content)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDelta() when $default != null:
        return $default(_that.role, _that.content);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageDelta extends MessageDelta {
  const _MessageDelta(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.role,
      @JsonKey(includeIfNull: false) final List<MessageDeltaContent>? content})
      : _content = content,
        super._();
  factory _MessageDelta.fromJson(Map<String, dynamic> json) =>
      _$MessageDeltaFromJson(json);

  /// The entity that produced the message. One of `user` or `assistant`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final MessageRole? role;

  /// The content of the message in array of text and/or images.
  final List<MessageDeltaContent>? _content;

  /// The content of the message in array of text and/or images.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContent>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of MessageDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageDeltaCopyWith<_MessageDelta> get copyWith =>
      __$MessageDeltaCopyWithImpl<_MessageDelta>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageDelta &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other._content, _content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, role, const DeepCollectionEquality().hash(_content));

  @override
  String toString() {
    return 'MessageDelta(role: $role, content: $content)';
  }
}

/// @nodoc
abstract mixin class _$MessageDeltaCopyWith<$Res>
    implements $MessageDeltaCopyWith<$Res> {
  factory _$MessageDeltaCopyWith(
          _MessageDelta value, $Res Function(_MessageDelta) _then) =
      __$MessageDeltaCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageRole? role,
      @JsonKey(includeIfNull: false) List<MessageDeltaContent>? content});
}

/// @nodoc
class __$MessageDeltaCopyWithImpl<$Res>
    implements _$MessageDeltaCopyWith<$Res> {
  __$MessageDeltaCopyWithImpl(this._self, this._then);

  final _MessageDelta _self;
  final $Res Function(_MessageDelta) _then;

  /// Create a copy of MessageDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = freezed,
    Object? content = freezed,
  }) {
    return _then(_MessageDelta(
      role: freezed == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole?,
      content: freezed == content
          ? _self._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContent>?,
    ));
  }
}

/// @nodoc
mixin _$CreateMessageRequest {
  /// The entity that produced the message. One of `user` or `assistant`.
  MessageRole get role;

  /// The content of the message.
  @_CreateMessageRequestContentConverter()
  CreateMessageRequestContent get content;

  /// A list of files attached to the message, and the tools they were added to.
  @JsonKey(includeIfNull: false)
  List<MessageAttachment>? get attachments;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// Create a copy of CreateMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateMessageRequestCopyWith<CreateMessageRequest> get copyWith =>
      _$CreateMessageRequestCopyWithImpl<CreateMessageRequest>(
          this as CreateMessageRequest, _$identity);

  /// Serializes this CreateMessageRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateMessageRequest &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            const DeepCollectionEquality()
                .equals(other.attachments, attachments) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      role,
      content,
      const DeepCollectionEquality().hash(attachments),
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'CreateMessageRequest(role: $role, content: $content, attachments: $attachments, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $CreateMessageRequestCopyWith<$Res> {
  factory $CreateMessageRequestCopyWith(CreateMessageRequest value,
          $Res Function(CreateMessageRequest) _then) =
      _$CreateMessageRequestCopyWithImpl;
  @useResult
  $Res call(
      {MessageRole role,
      @_CreateMessageRequestContentConverter()
      CreateMessageRequestContent content,
      @JsonKey(includeIfNull: false) List<MessageAttachment>? attachments,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $CreateMessageRequestContentCopyWith<$Res> get content;
}

/// @nodoc
class _$CreateMessageRequestCopyWithImpl<$Res>
    implements $CreateMessageRequestCopyWith<$Res> {
  _$CreateMessageRequestCopyWithImpl(this._self, this._then);

  final CreateMessageRequest _self;
  final $Res Function(CreateMessageRequest) _then;

  /// Create a copy of CreateMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as CreateMessageRequestContent,
      attachments: freezed == attachments
          ? _self.attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of CreateMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateMessageRequestContentCopyWith<$Res> get content {
    return $CreateMessageRequestContentCopyWith<$Res>(_self.content, (value) {
      return _then(_self.copyWith(content: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateMessageRequest].
extension CreateMessageRequestPatterns on CreateMessageRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateMessageRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateMessageRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateMessageRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateMessageRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateMessageRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateMessageRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            MessageRole role,
            @_CreateMessageRequestContentConverter()
            CreateMessageRequestContent content,
            @JsonKey(includeIfNull: false) List<MessageAttachment>? attachments,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateMessageRequest() when $default != null:
        return $default(
            _that.role, _that.content, _that.attachments, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            MessageRole role,
            @_CreateMessageRequestContentConverter()
            CreateMessageRequestContent content,
            @JsonKey(includeIfNull: false) List<MessageAttachment>? attachments,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateMessageRequest():
        return $default(
            _that.role, _that.content, _that.attachments, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            MessageRole role,
            @_CreateMessageRequestContentConverter()
            CreateMessageRequestContent content,
            @JsonKey(includeIfNull: false) List<MessageAttachment>? attachments,
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateMessageRequest() when $default != null:
        return $default(
            _that.role, _that.content, _that.attachments, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateMessageRequest extends CreateMessageRequest {
  const _CreateMessageRequest(
      {required this.role,
      @_CreateMessageRequestContentConverter() required this.content,
      @JsonKey(includeIfNull: false) final List<MessageAttachment>? attachments,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _attachments = attachments,
        _metadata = metadata,
        super._();
  factory _CreateMessageRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateMessageRequestFromJson(json);

  /// The entity that produced the message. One of `user` or `assistant`.
  @override
  final MessageRole role;

  /// The content of the message.
  @override
  @_CreateMessageRequestContentConverter()
  final CreateMessageRequestContent content;

  /// A list of files attached to the message, and the tools they were added to.
  final List<MessageAttachment>? _attachments;

  /// A list of files attached to the message, and the tools they were added to.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageAttachment>? get attachments {
    final value = _attachments;
    if (value == null) return null;
    if (_attachments is EqualUnmodifiableListView) return _attachments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of CreateMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateMessageRequestCopyWith<_CreateMessageRequest> get copyWith =>
      __$CreateMessageRequestCopyWithImpl<_CreateMessageRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateMessageRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateMessageRequest &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            const DeepCollectionEquality()
                .equals(other._attachments, _attachments) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      role,
      content,
      const DeepCollectionEquality().hash(_attachments),
      const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'CreateMessageRequest(role: $role, content: $content, attachments: $attachments, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$CreateMessageRequestCopyWith<$Res>
    implements $CreateMessageRequestCopyWith<$Res> {
  factory _$CreateMessageRequestCopyWith(_CreateMessageRequest value,
          $Res Function(_CreateMessageRequest) _then) =
      __$CreateMessageRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {MessageRole role,
      @_CreateMessageRequestContentConverter()
      CreateMessageRequestContent content,
      @JsonKey(includeIfNull: false) List<MessageAttachment>? attachments,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $CreateMessageRequestContentCopyWith<$Res> get content;
}

/// @nodoc
class __$CreateMessageRequestCopyWithImpl<$Res>
    implements _$CreateMessageRequestCopyWith<$Res> {
  __$CreateMessageRequestCopyWithImpl(this._self, this._then);

  final _CreateMessageRequest _self;
  final $Res Function(_CreateMessageRequest) _then;

  /// Create a copy of CreateMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_CreateMessageRequest(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as CreateMessageRequestContent,
      attachments: freezed == attachments
          ? _self._attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  /// Create a copy of CreateMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreateMessageRequestContentCopyWith<$Res> get content {
    return $CreateMessageRequestContentCopyWith<$Res>(_self.content, (value) {
      return _then(_self.copyWith(content: value));
    });
  }
}

CreateMessageRequestContent _$CreateMessageRequestContentFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'parts':
      return CreateMessageRequestContentListMessageContent.fromJson(json);
    case 'text':
      return CreateMessageRequestContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateMessageRequestContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateMessageRequestContent {
  Object get value;

  /// Serializes this CreateMessageRequestContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateMessageRequestContent &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'CreateMessageRequestContent(value: $value)';
  }
}

/// @nodoc
class $CreateMessageRequestContentCopyWith<$Res> {
  $CreateMessageRequestContentCopyWith(CreateMessageRequestContent _,
      $Res Function(CreateMessageRequestContent) __);
}

/// Adds pattern-matching-related methods to [CreateMessageRequestContent].
extension CreateMessageRequestContentPatterns on CreateMessageRequestContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult Function(CreateMessageRequestContentString value)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateMessageRequestContentListMessageContent() when parts != null:
        return parts(_that);
      case CreateMessageRequestContentString() when text != null:
        return text(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateMessageRequestContentListMessageContent value)
        parts,
    required TResult Function(CreateMessageRequestContentString value) text,
  }) {
    final _that = this;
    switch (_that) {
      case CreateMessageRequestContentListMessageContent():
        return parts(_that);
      case CreateMessageRequestContentString():
        return text(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult? Function(CreateMessageRequestContentString value)? text,
  }) {
    final _that = this;
    switch (_that) {
      case CreateMessageRequestContentListMessageContent() when parts != null:
        return parts(_that);
      case CreateMessageRequestContentString() when text != null:
        return text(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<MessageContent> value)? parts,
    TResult Function(String value)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case CreateMessageRequestContentListMessageContent() when parts != null:
        return parts(_that.value);
      case CreateMessageRequestContentString() when text != null:
        return text(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<MessageContent> value) parts,
    required TResult Function(String value) text,
  }) {
    final _that = this;
    switch (_that) {
      case CreateMessageRequestContentListMessageContent():
        return parts(_that.value);
      case CreateMessageRequestContentString():
        return text(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<MessageContent> value)? parts,
    TResult? Function(String value)? text,
  }) {
    final _that = this;
    switch (_that) {
      case CreateMessageRequestContentListMessageContent() when parts != null:
        return parts(_that.value);
      case CreateMessageRequestContentString() when text != null:
        return text(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class CreateMessageRequestContentListMessageContent
    extends CreateMessageRequestContent {
  const CreateMessageRequestContentListMessageContent(
      final List<MessageContent> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'parts',
        super._();
  factory CreateMessageRequestContentListMessageContent.fromJson(
          Map<String, dynamic> json) =>
      _$CreateMessageRequestContentListMessageContentFromJson(json);

  final List<MessageContent> _value;
  @override
  List<MessageContent> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateMessageRequestContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateMessageRequestContentListMessageContentCopyWith<
          CreateMessageRequestContentListMessageContent>
      get copyWith =>
          _$CreateMessageRequestContentListMessageContentCopyWithImpl<
              CreateMessageRequestContentListMessageContent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateMessageRequestContentListMessageContentToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateMessageRequestContentListMessageContent &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'CreateMessageRequestContent.parts(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateMessageRequestContentListMessageContentCopyWith<
    $Res> implements $CreateMessageRequestContentCopyWith<$Res> {
  factory $CreateMessageRequestContentListMessageContentCopyWith(
          CreateMessageRequestContentListMessageContent value,
          $Res Function(CreateMessageRequestContentListMessageContent) _then) =
      _$CreateMessageRequestContentListMessageContentCopyWithImpl;
  @useResult
  $Res call({List<MessageContent> value});
}

/// @nodoc
class _$CreateMessageRequestContentListMessageContentCopyWithImpl<$Res>
    implements $CreateMessageRequestContentListMessageContentCopyWith<$Res> {
  _$CreateMessageRequestContentListMessageContentCopyWithImpl(
      this._self, this._then);

  final CreateMessageRequestContentListMessageContent _self;
  final $Res Function(CreateMessageRequestContentListMessageContent) _then;

  /// Create a copy of CreateMessageRequestContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateMessageRequestContentListMessageContent(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class CreateMessageRequestContentString extends CreateMessageRequestContent {
  const CreateMessageRequestContentString(this.value, {final String? $type})
      : $type = $type ?? 'text',
        super._();
  factory CreateMessageRequestContentString.fromJson(
          Map<String, dynamic> json) =>
      _$CreateMessageRequestContentStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of CreateMessageRequestContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateMessageRequestContentStringCopyWith<CreateMessageRequestContentString>
      get copyWith => _$CreateMessageRequestContentStringCopyWithImpl<
          CreateMessageRequestContentString>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateMessageRequestContentStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateMessageRequestContentString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'CreateMessageRequestContent.text(value: $value)';
  }
}

/// @nodoc
abstract mixin class $CreateMessageRequestContentStringCopyWith<$Res>
    implements $CreateMessageRequestContentCopyWith<$Res> {
  factory $CreateMessageRequestContentStringCopyWith(
          CreateMessageRequestContentString value,
          $Res Function(CreateMessageRequestContentString) _then) =
      _$CreateMessageRequestContentStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$CreateMessageRequestContentStringCopyWithImpl<$Res>
    implements $CreateMessageRequestContentStringCopyWith<$Res> {
  _$CreateMessageRequestContentStringCopyWithImpl(this._self, this._then);

  final CreateMessageRequestContentString _self;
  final $Res Function(CreateMessageRequestContentString) _then;

  /// Create a copy of CreateMessageRequestContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(CreateMessageRequestContentString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ModifyMessageRequest {
  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;

  /// Create a copy of ModifyMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModifyMessageRequestCopyWith<ModifyMessageRequest> get copyWith =>
      _$ModifyMessageRequestCopyWithImpl<ModifyMessageRequest>(
          this as ModifyMessageRequest, _$identity);

  /// Serializes this ModifyMessageRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModifyMessageRequest &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'ModifyMessageRequest(metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $ModifyMessageRequestCopyWith<$Res> {
  factory $ModifyMessageRequestCopyWith(ModifyMessageRequest value,
          $Res Function(ModifyMessageRequest) _then) =
      _$ModifyMessageRequestCopyWithImpl;
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyMessageRequestCopyWithImpl<$Res>
    implements $ModifyMessageRequestCopyWith<$Res> {
  _$ModifyMessageRequestCopyWithImpl(this._self, this._then);

  final ModifyMessageRequest _self;
  final $Res Function(ModifyMessageRequest) _then;

  /// Create a copy of ModifyMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [ModifyMessageRequest].
extension ModifyMessageRequestPatterns on ModifyMessageRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModifyMessageRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyMessageRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModifyMessageRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyMessageRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModifyMessageRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyMessageRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModifyMessageRequest() when $default != null:
        return $default(_that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyMessageRequest():
        return $default(_that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModifyMessageRequest() when $default != null:
        return $default(_that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModifyMessageRequest extends ModifyMessageRequest {
  const _ModifyMessageRequest(
      {@JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();
  factory _ModifyMessageRequest.fromJson(Map<String, dynamic> json) =>
      _$ModifyMessageRequestFromJson(json);

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of ModifyMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModifyMessageRequestCopyWith<_ModifyMessageRequest> get copyWith =>
      __$ModifyMessageRequestCopyWithImpl<_ModifyMessageRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModifyMessageRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModifyMessageRequest &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'ModifyMessageRequest(metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$ModifyMessageRequestCopyWith<$Res>
    implements $ModifyMessageRequestCopyWith<$Res> {
  factory _$ModifyMessageRequestCopyWith(_ModifyMessageRequest value,
          $Res Function(_ModifyMessageRequest) _then) =
      __$ModifyMessageRequestCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$ModifyMessageRequestCopyWithImpl<$Res>
    implements _$ModifyMessageRequestCopyWith<$Res> {
  __$ModifyMessageRequestCopyWithImpl(this._self, this._then);

  final _ModifyMessageRequest _self;
  final $Res Function(_ModifyMessageRequest) _then;

  /// Create a copy of ModifyMessageRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_ModifyMessageRequest(
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
mixin _$DeleteMessageResponse {
  /// The message identifier.
  String get id;

  /// Whether the message was deleted.
  bool get deleted;

  /// The object type, which is always `thread.message.deleted`.
  DeleteMessageResponseObject get object;

  /// Create a copy of DeleteMessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DeleteMessageResponseCopyWith<DeleteMessageResponse> get copyWith =>
      _$DeleteMessageResponseCopyWithImpl<DeleteMessageResponse>(
          this as DeleteMessageResponse, _$identity);

  /// Serializes this DeleteMessageResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteMessageResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteMessageResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class $DeleteMessageResponseCopyWith<$Res> {
  factory $DeleteMessageResponseCopyWith(DeleteMessageResponse value,
          $Res Function(DeleteMessageResponse) _then) =
      _$DeleteMessageResponseCopyWithImpl;
  @useResult
  $Res call({String id, bool deleted, DeleteMessageResponseObject object});
}

/// @nodoc
class _$DeleteMessageResponseCopyWithImpl<$Res>
    implements $DeleteMessageResponseCopyWith<$Res> {
  _$DeleteMessageResponseCopyWithImpl(this._self, this._then);

  final DeleteMessageResponse _self;
  final $Res Function(DeleteMessageResponse) _then;

  /// Create a copy of DeleteMessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteMessageResponseObject,
    ));
  }
}

/// Adds pattern-matching-related methods to [DeleteMessageResponse].
extension DeleteMessageResponsePatterns on DeleteMessageResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DeleteMessageResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteMessageResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DeleteMessageResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteMessageResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DeleteMessageResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteMessageResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id, bool deleted, DeleteMessageResponseObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteMessageResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id, bool deleted, DeleteMessageResponseObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteMessageResponse():
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id, bool deleted, DeleteMessageResponseObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteMessageResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DeleteMessageResponse extends DeleteMessageResponse {
  const _DeleteMessageResponse(
      {required this.id, required this.deleted, required this.object})
      : super._();
  factory _DeleteMessageResponse.fromJson(Map<String, dynamic> json) =>
      _$DeleteMessageResponseFromJson(json);

  /// The message identifier.
  @override
  final String id;

  /// Whether the message was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `thread.message.deleted`.
  @override
  final DeleteMessageResponseObject object;

  /// Create a copy of DeleteMessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DeleteMessageResponseCopyWith<_DeleteMessageResponse> get copyWith =>
      __$DeleteMessageResponseCopyWithImpl<_DeleteMessageResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DeleteMessageResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DeleteMessageResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteMessageResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$DeleteMessageResponseCopyWith<$Res>
    implements $DeleteMessageResponseCopyWith<$Res> {
  factory _$DeleteMessageResponseCopyWith(_DeleteMessageResponse value,
          $Res Function(_DeleteMessageResponse) _then) =
      __$DeleteMessageResponseCopyWithImpl;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteMessageResponseObject object});
}

/// @nodoc
class __$DeleteMessageResponseCopyWithImpl<$Res>
    implements _$DeleteMessageResponseCopyWith<$Res> {
  __$DeleteMessageResponseCopyWithImpl(this._self, this._then);

  final _DeleteMessageResponse _self;
  final $Res Function(_DeleteMessageResponse) _then;

  /// Create a copy of DeleteMessageResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_DeleteMessageResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteMessageResponseObject,
    ));
  }
}

/// @nodoc
mixin _$ListMessagesResponse {
  /// The object type, which is always `list`.
  String get object;

  /// The list of messages.
  List<MessageObject> get data;

  /// The ID of the first message in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last message in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more messages to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListMessagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListMessagesResponseCopyWith<ListMessagesResponse> get copyWith =>
      _$ListMessagesResponseCopyWithImpl<ListMessagesResponse>(
          this as ListMessagesResponse, _$identity);

  /// Serializes this ListMessagesResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListMessagesResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListMessagesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListMessagesResponseCopyWith<$Res> {
  factory $ListMessagesResponseCopyWith(ListMessagesResponse value,
          $Res Function(ListMessagesResponse) _then) =
      _$ListMessagesResponseCopyWithImpl;
  @useResult
  $Res call(
      {String object,
      List<MessageObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListMessagesResponseCopyWithImpl<$Res>
    implements $ListMessagesResponseCopyWith<$Res> {
  _$ListMessagesResponseCopyWithImpl(this._self, this._then);

  final ListMessagesResponse _self;
  final $Res Function(ListMessagesResponse) _then;

  /// Create a copy of ListMessagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListMessagesResponse].
extension ListMessagesResponsePatterns on ListMessagesResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListMessagesResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListMessagesResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListMessagesResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListMessagesResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListMessagesResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListMessagesResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String object,
            List<MessageObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListMessagesResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String object,
            List<MessageObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListMessagesResponse():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String object,
            List<MessageObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListMessagesResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListMessagesResponse extends ListMessagesResponse {
  const _ListMessagesResponse(
      {required this.object,
      required final List<MessageObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListMessagesResponse.fromJson(Map<String, dynamic> json) =>
      _$ListMessagesResponseFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of messages.
  final List<MessageObject> _data;

  /// The list of messages.
  @override
  List<MessageObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first message in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last message in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more messages to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListMessagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListMessagesResponseCopyWith<_ListMessagesResponse> get copyWith =>
      __$ListMessagesResponseCopyWithImpl<_ListMessagesResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListMessagesResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListMessagesResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListMessagesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListMessagesResponseCopyWith<$Res>
    implements $ListMessagesResponseCopyWith<$Res> {
  factory _$ListMessagesResponseCopyWith(_ListMessagesResponse value,
          $Res Function(_ListMessagesResponse) _then) =
      __$ListMessagesResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String object,
      List<MessageObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListMessagesResponseCopyWithImpl<$Res>
    implements _$ListMessagesResponseCopyWith<$Res> {
  __$ListMessagesResponseCopyWithImpl(this._self, this._then);

  final _ListMessagesResponse _self;
  final $Res Function(_ListMessagesResponse) _then;

  /// Create a copy of ListMessagesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListMessagesResponse(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$MessageContentImageFile {
  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose="vision"` when uploading the File if you need to later display the file content.
  @JsonKey(name: 'file_id')
  String get fileId;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  MessageContentImageDetail get detail;

  /// Create a copy of MessageContentImageFile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentImageFileCopyWith<MessageContentImageFile> get copyWith =>
      _$MessageContentImageFileCopyWithImpl<MessageContentImageFile>(
          this as MessageContentImageFile, _$identity);

  /// Serializes this MessageContentImageFile to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentImageFile &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, detail);

  @override
  String toString() {
    return 'MessageContentImageFile(fileId: $fileId, detail: $detail)';
  }
}

/// @nodoc
abstract mixin class $MessageContentImageFileCopyWith<$Res> {
  factory $MessageContentImageFileCopyWith(MessageContentImageFile value,
          $Res Function(MessageContentImageFile) _then) =
      _$MessageContentImageFileCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      MessageContentImageDetail detail});
}

/// @nodoc
class _$MessageContentImageFileCopyWithImpl<$Res>
    implements $MessageContentImageFileCopyWith<$Res> {
  _$MessageContentImageFileCopyWithImpl(this._self, this._then);

  final MessageContentImageFile _self;
  final $Res Function(MessageContentImageFile) _then;

  /// Create a copy of MessageContentImageFile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? detail = null,
  }) {
    return _then(_self.copyWith(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _self.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageContentImageFile].
extension MessageContentImageFilePatterns on MessageContentImageFile {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageContentImageFile value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageFile() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageContentImageFile value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageFile():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageContentImageFile value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageFile() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId,
            MessageContentImageDetail detail)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageFile() when $default != null:
        return $default(_that.fileId, _that.detail);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId,
            MessageContentImageDetail detail)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageFile():
        return $default(_that.fileId, _that.detail);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'file_id') String fileId,
            MessageContentImageDetail detail)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageFile() when $default != null:
        return $default(_that.fileId, _that.detail);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageContentImageFile extends MessageContentImageFile {
  const _MessageContentImageFile(
      {@JsonKey(name: 'file_id') required this.fileId,
      this.detail = MessageContentImageDetail.auto})
      : super._();
  factory _MessageContentImageFile.fromJson(Map<String, dynamic> json) =>
      _$MessageContentImageFileFromJson(json);

  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose="vision"` when uploading the File if you need to later display the file content.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  @override
  @JsonKey()
  final MessageContentImageDetail detail;

  /// Create a copy of MessageContentImageFile
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageContentImageFileCopyWith<_MessageContentImageFile> get copyWith =>
      __$MessageContentImageFileCopyWithImpl<_MessageContentImageFile>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentImageFileToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageContentImageFile &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, detail);

  @override
  String toString() {
    return 'MessageContentImageFile(fileId: $fileId, detail: $detail)';
  }
}

/// @nodoc
abstract mixin class _$MessageContentImageFileCopyWith<$Res>
    implements $MessageContentImageFileCopyWith<$Res> {
  factory _$MessageContentImageFileCopyWith(_MessageContentImageFile value,
          $Res Function(_MessageContentImageFile) _then) =
      __$MessageContentImageFileCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      MessageContentImageDetail detail});
}

/// @nodoc
class __$MessageContentImageFileCopyWithImpl<$Res>
    implements _$MessageContentImageFileCopyWith<$Res> {
  __$MessageContentImageFileCopyWithImpl(this._self, this._then);

  final _MessageContentImageFile _self;
  final $Res Function(_MessageContentImageFile) _then;

  /// Create a copy of MessageContentImageFile
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = null,
    Object? detail = null,
  }) {
    return _then(_MessageContentImageFile(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _self.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ));
  }
}

/// @nodoc
mixin _$MessageContentImageUrl {
  /// The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
  String get url;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  MessageContentImageDetail get detail;

  /// Create a copy of MessageContentImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentImageUrlCopyWith<MessageContentImageUrl> get copyWith =>
      _$MessageContentImageUrlCopyWithImpl<MessageContentImageUrl>(
          this as MessageContentImageUrl, _$identity);

  /// Serializes this MessageContentImageUrl to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentImageUrl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @override
  String toString() {
    return 'MessageContentImageUrl(url: $url, detail: $detail)';
  }
}

/// @nodoc
abstract mixin class $MessageContentImageUrlCopyWith<$Res> {
  factory $MessageContentImageUrlCopyWith(MessageContentImageUrl value,
          $Res Function(MessageContentImageUrl) _then) =
      _$MessageContentImageUrlCopyWithImpl;
  @useResult
  $Res call({String url, MessageContentImageDetail detail});
}

/// @nodoc
class _$MessageContentImageUrlCopyWithImpl<$Res>
    implements $MessageContentImageUrlCopyWith<$Res> {
  _$MessageContentImageUrlCopyWithImpl(this._self, this._then);

  final MessageContentImageUrl _self;
  final $Res Function(MessageContentImageUrl) _then;

  /// Create a copy of MessageContentImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_self.copyWith(
      url: null == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _self.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageContentImageUrl].
extension MessageContentImageUrlPatterns on MessageContentImageUrl {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageContentImageUrl value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageUrl() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageContentImageUrl value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageUrl():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageContentImageUrl value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageUrl() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String url, MessageContentImageDetail detail)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageUrl() when $default != null:
        return $default(_that.url, _that.detail);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String url, MessageContentImageDetail detail) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageUrl():
        return $default(_that.url, _that.detail);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String url, MessageContentImageDetail detail)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentImageUrl() when $default != null:
        return $default(_that.url, _that.detail);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageContentImageUrl extends MessageContentImageUrl {
  const _MessageContentImageUrl(
      {required this.url, this.detail = MessageContentImageDetail.auto})
      : super._();
  factory _MessageContentImageUrl.fromJson(Map<String, dynamic> json) =>
      _$MessageContentImageUrlFromJson(json);

  /// The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
  @override
  final String url;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  @override
  @JsonKey()
  final MessageContentImageDetail detail;

  /// Create a copy of MessageContentImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageContentImageUrlCopyWith<_MessageContentImageUrl> get copyWith =>
      __$MessageContentImageUrlCopyWithImpl<_MessageContentImageUrl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentImageUrlToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageContentImageUrl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @override
  String toString() {
    return 'MessageContentImageUrl(url: $url, detail: $detail)';
  }
}

/// @nodoc
abstract mixin class _$MessageContentImageUrlCopyWith<$Res>
    implements $MessageContentImageUrlCopyWith<$Res> {
  factory _$MessageContentImageUrlCopyWith(_MessageContentImageUrl value,
          $Res Function(_MessageContentImageUrl) _then) =
      __$MessageContentImageUrlCopyWithImpl;
  @override
  @useResult
  $Res call({String url, MessageContentImageDetail detail});
}

/// @nodoc
class __$MessageContentImageUrlCopyWithImpl<$Res>
    implements _$MessageContentImageUrlCopyWith<$Res> {
  __$MessageContentImageUrlCopyWithImpl(this._self, this._then);

  final _MessageContentImageUrl _self;
  final $Res Function(_MessageContentImageUrl) _then;

  /// Create a copy of MessageContentImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_MessageContentImageUrl(
      url: null == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _self.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ));
  }
}

/// @nodoc
mixin _$MessageRequestContentTextObject {
  /// Always `text`.
  String get type;

  /// Text content to be sent to the model
  String get text;

  /// Create a copy of MessageRequestContentTextObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageRequestContentTextObjectCopyWith<MessageRequestContentTextObject>
      get copyWith => _$MessageRequestContentTextObjectCopyWithImpl<
              MessageRequestContentTextObject>(
          this as MessageRequestContentTextObject, _$identity);

  /// Serializes this MessageRequestContentTextObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageRequestContentTextObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @override
  String toString() {
    return 'MessageRequestContentTextObject(type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class $MessageRequestContentTextObjectCopyWith<$Res> {
  factory $MessageRequestContentTextObjectCopyWith(
          MessageRequestContentTextObject value,
          $Res Function(MessageRequestContentTextObject) _then) =
      _$MessageRequestContentTextObjectCopyWithImpl;
  @useResult
  $Res call({String type, String text});
}

/// @nodoc
class _$MessageRequestContentTextObjectCopyWithImpl<$Res>
    implements $MessageRequestContentTextObjectCopyWith<$Res> {
  _$MessageRequestContentTextObjectCopyWithImpl(this._self, this._then);

  final MessageRequestContentTextObject _self;
  final $Res Function(MessageRequestContentTextObject) _then;

  /// Create a copy of MessageRequestContentTextObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageRequestContentTextObject].
extension MessageRequestContentTextObjectPatterns
    on MessageRequestContentTextObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageRequestContentTextObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageRequestContentTextObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageRequestContentTextObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageRequestContentTextObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageRequestContentTextObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageRequestContentTextObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String type, String text)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageRequestContentTextObject() when $default != null:
        return $default(_that.type, _that.text);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String type, String text) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageRequestContentTextObject():
        return $default(_that.type, _that.text);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String type, String text)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageRequestContentTextObject() when $default != null:
        return $default(_that.type, _that.text);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageRequestContentTextObject extends MessageRequestContentTextObject {
  const _MessageRequestContentTextObject(
      {required this.type, required this.text})
      : super._();
  factory _MessageRequestContentTextObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageRequestContentTextObjectFromJson(json);

  /// Always `text`.
  @override
  final String type;

  /// Text content to be sent to the model
  @override
  final String text;

  /// Create a copy of MessageRequestContentTextObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageRequestContentTextObjectCopyWith<_MessageRequestContentTextObject>
      get copyWith => __$MessageRequestContentTextObjectCopyWithImpl<
          _MessageRequestContentTextObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageRequestContentTextObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageRequestContentTextObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @override
  String toString() {
    return 'MessageRequestContentTextObject(type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class _$MessageRequestContentTextObjectCopyWith<$Res>
    implements $MessageRequestContentTextObjectCopyWith<$Res> {
  factory _$MessageRequestContentTextObjectCopyWith(
          _MessageRequestContentTextObject value,
          $Res Function(_MessageRequestContentTextObject) _then) =
      __$MessageRequestContentTextObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String type, String text});
}

/// @nodoc
class __$MessageRequestContentTextObjectCopyWithImpl<$Res>
    implements _$MessageRequestContentTextObjectCopyWith<$Res> {
  __$MessageRequestContentTextObjectCopyWithImpl(this._self, this._then);

  final _MessageRequestContentTextObject _self;
  final $Res Function(_MessageRequestContentTextObject) _then;

  /// Create a copy of MessageRequestContentTextObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_MessageRequestContentTextObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$MessageContentText {
  /// The data that makes up the text.
  String get value;

  /// A list of annotations that point to specific quotes from specific files.
  @JsonKey(includeIfNull: false)
  List<MessageContentTextAnnotations>? get annotations;

  /// Create a copy of MessageContentText
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentTextCopyWith<MessageContentText> get copyWith =>
      _$MessageContentTextCopyWithImpl<MessageContentText>(
          this as MessageContentText, _$identity);

  /// Serializes this MessageContentText to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentText &&
            (identical(other.value, value) || other.value == value) &&
            const DeepCollectionEquality()
                .equals(other.annotations, annotations));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, value, const DeepCollectionEquality().hash(annotations));

  @override
  String toString() {
    return 'MessageContentText(value: $value, annotations: $annotations)';
  }
}

/// @nodoc
abstract mixin class $MessageContentTextCopyWith<$Res> {
  factory $MessageContentTextCopyWith(
          MessageContentText value, $Res Function(MessageContentText) _then) =
      _$MessageContentTextCopyWithImpl;
  @useResult
  $Res call(
      {String value,
      @JsonKey(includeIfNull: false)
      List<MessageContentTextAnnotations>? annotations});
}

/// @nodoc
class _$MessageContentTextCopyWithImpl<$Res>
    implements $MessageContentTextCopyWith<$Res> {
  _$MessageContentTextCopyWithImpl(this._self, this._then);

  final MessageContentText _self;
  final $Res Function(MessageContentText) _then;

  /// Create a copy of MessageContentText
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? annotations = freezed,
  }) {
    return _then(_self.copyWith(
      value: null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      annotations: freezed == annotations
          ? _self.annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageContentTextAnnotations>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageContentText].
extension MessageContentTextPatterns on MessageContentText {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageContentText value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentText() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageContentText value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentText():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageContentText value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentText() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String value,
            @JsonKey(includeIfNull: false)
            List<MessageContentTextAnnotations>? annotations)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentText() when $default != null:
        return $default(_that.value, _that.annotations);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String value,
            @JsonKey(includeIfNull: false)
            List<MessageContentTextAnnotations>? annotations)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentText():
        return $default(_that.value, _that.annotations);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String value,
            @JsonKey(includeIfNull: false)
            List<MessageContentTextAnnotations>? annotations)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentText() when $default != null:
        return $default(_that.value, _that.annotations);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageContentText extends MessageContentText {
  const _MessageContentText(
      {required this.value,
      @JsonKey(includeIfNull: false)
      final List<MessageContentTextAnnotations>? annotations})
      : _annotations = annotations,
        super._();
  factory _MessageContentText.fromJson(Map<String, dynamic> json) =>
      _$MessageContentTextFromJson(json);

  /// The data that makes up the text.
  @override
  final String value;

  /// A list of annotations that point to specific quotes from specific files.
  final List<MessageContentTextAnnotations>? _annotations;

  /// A list of annotations that point to specific quotes from specific files.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageContentTextAnnotations>? get annotations {
    final value = _annotations;
    if (value == null) return null;
    if (_annotations is EqualUnmodifiableListView) return _annotations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of MessageContentText
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageContentTextCopyWith<_MessageContentText> get copyWith =>
      __$MessageContentTextCopyWithImpl<_MessageContentText>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentTextToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageContentText &&
            (identical(other.value, value) || other.value == value) &&
            const DeepCollectionEquality()
                .equals(other._annotations, _annotations));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, value, const DeepCollectionEquality().hash(_annotations));

  @override
  String toString() {
    return 'MessageContentText(value: $value, annotations: $annotations)';
  }
}

/// @nodoc
abstract mixin class _$MessageContentTextCopyWith<$Res>
    implements $MessageContentTextCopyWith<$Res> {
  factory _$MessageContentTextCopyWith(
          _MessageContentText value, $Res Function(_MessageContentText) _then) =
      __$MessageContentTextCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String value,
      @JsonKey(includeIfNull: false)
      List<MessageContentTextAnnotations>? annotations});
}

/// @nodoc
class __$MessageContentTextCopyWithImpl<$Res>
    implements _$MessageContentTextCopyWith<$Res> {
  __$MessageContentTextCopyWithImpl(this._self, this._then);

  final _MessageContentText _self;
  final $Res Function(_MessageContentText) _then;

  /// Create a copy of MessageContentText
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
    Object? annotations = freezed,
  }) {
    return _then(_MessageContentText(
      value: null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      annotations: freezed == annotations
          ? _self._annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageContentTextAnnotations>?,
    ));
  }
}

/// @nodoc
mixin _$MessageContentTextAnnotationsFileCitation {
  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id')
  String get fileId;

  /// Create a copy of MessageContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFileCitationCopyWith<
          MessageContentTextAnnotationsFileCitation>
      get copyWith => _$MessageContentTextAnnotationsFileCitationCopyWithImpl<
              MessageContentTextAnnotationsFileCitation>(
          this as MessageContentTextAnnotationsFileCitation, _$identity);

  /// Serializes this MessageContentTextAnnotationsFileCitation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentTextAnnotationsFileCitation &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFileCitation(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFileCitationCopyWith(
          MessageContentTextAnnotationsFileCitation value,
          $Res Function(MessageContentTextAnnotationsFileCitation) _then) =
      _$MessageContentTextAnnotationsFileCitationCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res>
    implements $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  _$MessageContentTextAnnotationsFileCitationCopyWithImpl(
      this._self, this._then);

  final MessageContentTextAnnotationsFileCitation _self;
  final $Res Function(MessageContentTextAnnotationsFileCitation) _then;

  /// Create a copy of MessageContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_self.copyWith(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageContentTextAnnotationsFileCitation].
extension MessageContentTextAnnotationsFileCitationPatterns
    on MessageContentTextAnnotationsFileCitation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageContentTextAnnotationsFileCitation value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFileCitation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageContentTextAnnotationsFileCitation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFileCitation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageContentTextAnnotationsFileCitation value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFileCitation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFileCitation() when $default != null:
        return $default(_that.fileId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFileCitation():
        return $default(_that.fileId);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'file_id') String fileId)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFileCitation() when $default != null:
        return $default(_that.fileId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageContentTextAnnotationsFileCitation
    extends MessageContentTextAnnotationsFileCitation {
  const _MessageContentTextAnnotationsFileCitation(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();
  factory _MessageContentTextAnnotationsFileCitation.fromJson(
          Map<String, dynamic> json) =>
      _$MessageContentTextAnnotationsFileCitationFromJson(json);

  /// The ID of the specific File the citation is from.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// Create a copy of MessageContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageContentTextAnnotationsFileCitationCopyWith<
          _MessageContentTextAnnotationsFileCitation>
      get copyWith => __$MessageContentTextAnnotationsFileCitationCopyWithImpl<
          _MessageContentTextAnnotationsFileCitation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentTextAnnotationsFileCitationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageContentTextAnnotationsFileCitation &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFileCitation(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class _$MessageContentTextAnnotationsFileCitationCopyWith<$Res>
    implements $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory _$MessageContentTextAnnotationsFileCitationCopyWith(
          _MessageContentTextAnnotationsFileCitation value,
          $Res Function(_MessageContentTextAnnotationsFileCitation) _then) =
      __$MessageContentTextAnnotationsFileCitationCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res>
    implements _$MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  __$MessageContentTextAnnotationsFileCitationCopyWithImpl(
      this._self, this._then);

  final _MessageContentTextAnnotationsFileCitation _self;
  final $Res Function(_MessageContentTextAnnotationsFileCitation) _then;

  /// Create a copy of MessageContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_MessageContentTextAnnotationsFileCitation(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$MessageDeltaContentText {
  /// The data that makes up the text.
  @JsonKey(includeIfNull: false)
  String? get value;

  /// A list of annotations that point to specific quotes from specific files.
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContentTextAnnotations>? get annotations;

  /// Create a copy of MessageDeltaContentText
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextCopyWith<MessageDeltaContentText> get copyWith =>
      _$MessageDeltaContentTextCopyWithImpl<MessageDeltaContentText>(
          this as MessageDeltaContentText, _$identity);

  /// Serializes this MessageDeltaContentText to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentText &&
            (identical(other.value, value) || other.value == value) &&
            const DeepCollectionEquality()
                .equals(other.annotations, annotations));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, value, const DeepCollectionEquality().hash(annotations));

  @override
  String toString() {
    return 'MessageDeltaContentText(value: $value, annotations: $annotations)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentTextCopyWith<$Res> {
  factory $MessageDeltaContentTextCopyWith(MessageDeltaContentText value,
          $Res Function(MessageDeltaContentText) _then) =
      _$MessageDeltaContentTextCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? value,
      @JsonKey(includeIfNull: false)
      List<MessageDeltaContentTextAnnotations>? annotations});
}

/// @nodoc
class _$MessageDeltaContentTextCopyWithImpl<$Res>
    implements $MessageDeltaContentTextCopyWith<$Res> {
  _$MessageDeltaContentTextCopyWithImpl(this._self, this._then);

  final MessageDeltaContentText _self;
  final $Res Function(MessageDeltaContentText) _then;

  /// Create a copy of MessageDeltaContentText
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? annotations = freezed,
  }) {
    return _then(_self.copyWith(
      value: freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      annotations: freezed == annotations
          ? _self.annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContentTextAnnotations>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageDeltaContentText].
extension MessageDeltaContentTextPatterns on MessageDeltaContentText {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageDeltaContentText value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentText() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageDeltaContentText value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentText():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageDeltaContentText value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentText() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? value,
            @JsonKey(includeIfNull: false)
            List<MessageDeltaContentTextAnnotations>? annotations)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentText() when $default != null:
        return $default(_that.value, _that.annotations);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? value,
            @JsonKey(includeIfNull: false)
            List<MessageDeltaContentTextAnnotations>? annotations)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentText():
        return $default(_that.value, _that.annotations);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? value,
            @JsonKey(includeIfNull: false)
            List<MessageDeltaContentTextAnnotations>? annotations)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentText() when $default != null:
        return $default(_that.value, _that.annotations);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageDeltaContentText extends MessageDeltaContentText {
  const _MessageDeltaContentText(
      {@JsonKey(includeIfNull: false) this.value,
      @JsonKey(includeIfNull: false)
      final List<MessageDeltaContentTextAnnotations>? annotations})
      : _annotations = annotations,
        super._();
  factory _MessageDeltaContentText.fromJson(Map<String, dynamic> json) =>
      _$MessageDeltaContentTextFromJson(json);

  /// The data that makes up the text.
  @override
  @JsonKey(includeIfNull: false)
  final String? value;

  /// A list of annotations that point to specific quotes from specific files.
  final List<MessageDeltaContentTextAnnotations>? _annotations;

  /// A list of annotations that point to specific quotes from specific files.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContentTextAnnotations>? get annotations {
    final value = _annotations;
    if (value == null) return null;
    if (_annotations is EqualUnmodifiableListView) return _annotations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of MessageDeltaContentText
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageDeltaContentTextCopyWith<_MessageDeltaContentText> get copyWith =>
      __$MessageDeltaContentTextCopyWithImpl<_MessageDeltaContentText>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentTextToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageDeltaContentText &&
            (identical(other.value, value) || other.value == value) &&
            const DeepCollectionEquality()
                .equals(other._annotations, _annotations));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, value, const DeepCollectionEquality().hash(_annotations));

  @override
  String toString() {
    return 'MessageDeltaContentText(value: $value, annotations: $annotations)';
  }
}

/// @nodoc
abstract mixin class _$MessageDeltaContentTextCopyWith<$Res>
    implements $MessageDeltaContentTextCopyWith<$Res> {
  factory _$MessageDeltaContentTextCopyWith(_MessageDeltaContentText value,
          $Res Function(_MessageDeltaContentText) _then) =
      __$MessageDeltaContentTextCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? value,
      @JsonKey(includeIfNull: false)
      List<MessageDeltaContentTextAnnotations>? annotations});
}

/// @nodoc
class __$MessageDeltaContentTextCopyWithImpl<$Res>
    implements _$MessageDeltaContentTextCopyWith<$Res> {
  __$MessageDeltaContentTextCopyWithImpl(this._self, this._then);

  final _MessageDeltaContentText _self;
  final $Res Function(_MessageDeltaContentText) _then;

  /// Create a copy of MessageDeltaContentText
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = freezed,
    Object? annotations = freezed,
  }) {
    return _then(_MessageDeltaContentText(
      value: freezed == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      annotations: freezed == annotations
          ? _self._annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContentTextAnnotations>?,
    ));
  }
}

/// @nodoc
mixin _$MessageDeltaContentTextAnnotationsFileCitation {
  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;

  /// The specific quote in the file.
  @JsonKey(includeIfNull: false)
  String? get quote;

  /// Create a copy of MessageDeltaContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFileCitationCopyWith<
          MessageDeltaContentTextAnnotationsFileCitation>
      get copyWith =>
          _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl<
                  MessageDeltaContentTextAnnotationsFileCitation>(
              this as MessageDeltaContentTextAnnotationsFileCitation,
              _$identity);

  /// Serializes this MessageDeltaContentTextAnnotationsFileCitation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentTextAnnotationsFileCitation &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.quote, quote) || other.quote == quote));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, quote);

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotationsFileCitation(fileId: $fileId, quote: $quote)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentTextAnnotationsFileCitationCopyWith<
    $Res> {
  factory $MessageDeltaContentTextAnnotationsFileCitationCopyWith(
          MessageDeltaContentTextAnnotationsFileCitation value,
          $Res Function(MessageDeltaContentTextAnnotationsFileCitation) _then) =
      _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) String? quote});
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl<$Res>
    implements $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res> {
  _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl(
      this._self, this._then);

  final MessageDeltaContentTextAnnotationsFileCitation _self;
  final $Res Function(MessageDeltaContentTextAnnotationsFileCitation) _then;

  /// Create a copy of MessageDeltaContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
    Object? quote = freezed,
  }) {
    return _then(_self.copyWith(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      quote: freezed == quote
          ? _self.quote
          : quote // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageDeltaContentTextAnnotationsFileCitation].
extension MessageDeltaContentTextAnnotationsFileCitationPatterns
    on MessageDeltaContentTextAnnotationsFileCitation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageDeltaContentTextAnnotationsFileCitation value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFileCitation()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageDeltaContentTextAnnotationsFileCitation value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFileCitation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageDeltaContentTextAnnotationsFileCitation value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFileCitation()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
            @JsonKey(includeIfNull: false) String? quote)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFileCitation()
          when $default != null:
        return $default(_that.fileId, _that.quote);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
            @JsonKey(includeIfNull: false) String? quote)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFileCitation():
        return $default(_that.fileId, _that.quote);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
            @JsonKey(includeIfNull: false) String? quote)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFileCitation()
          when $default != null:
        return $default(_that.fileId, _that.quote);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageDeltaContentTextAnnotationsFileCitation
    extends MessageDeltaContentTextAnnotationsFileCitation {
  const _MessageDeltaContentTextAnnotationsFileCitation(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId,
      @JsonKey(includeIfNull: false) this.quote})
      : super._();
  factory _MessageDeltaContentTextAnnotationsFileCitation.fromJson(
          Map<String, dynamic> json) =>
      _$MessageDeltaContentTextAnnotationsFileCitationFromJson(json);

  /// The ID of the specific File the citation is from.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  /// The specific quote in the file.
  @override
  @JsonKey(includeIfNull: false)
  final String? quote;

  /// Create a copy of MessageDeltaContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageDeltaContentTextAnnotationsFileCitationCopyWith<
          _MessageDeltaContentTextAnnotationsFileCitation>
      get copyWith =>
          __$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl<
                  _MessageDeltaContentTextAnnotationsFileCitation>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentTextAnnotationsFileCitationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageDeltaContentTextAnnotationsFileCitation &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.quote, quote) || other.quote == quote));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, quote);

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotationsFileCitation(fileId: $fileId, quote: $quote)';
  }
}

/// @nodoc
abstract mixin class _$MessageDeltaContentTextAnnotationsFileCitationCopyWith<
        $Res>
    implements $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory _$MessageDeltaContentTextAnnotationsFileCitationCopyWith(
          _MessageDeltaContentTextAnnotationsFileCitation value,
          $Res Function(_MessageDeltaContentTextAnnotationsFileCitation)
              _then) =
      __$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) String? quote});
}

/// @nodoc
class __$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl<$Res>
    implements _$MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res> {
  __$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl(
      this._self, this._then);

  final _MessageDeltaContentTextAnnotationsFileCitation _self;
  final $Res Function(_MessageDeltaContentTextAnnotationsFileCitation) _then;

  /// Create a copy of MessageDeltaContentTextAnnotationsFileCitation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = freezed,
    Object? quote = freezed,
  }) {
    return _then(_MessageDeltaContentTextAnnotationsFileCitation(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      quote: freezed == quote
          ? _self.quote
          : quote // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$RunStepObject {
  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `thread.run.step`.
  RunStepObjectObject get object;

  /// The Unix timestamp (in seconds) for when the run step was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @JsonKey(name: 'assistant_id')
  String get assistantId;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @JsonKey(name: 'thread_id')
  String get threadId;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @JsonKey(name: 'run_id')
  String get runId;

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  RunStepType get type;

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  RunStepStatus get status;

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details')
  RunStepDetails get stepDetails;

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunStepLastError? get lastError;

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @JsonKey(name: 'expired_at')
  int? get expiredAt;

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt;

  /// The Unix timestamp (in seconds) for when the run step failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt;

  /// The Unix timestamp (in seconds) for when the run step completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  Map<String, dynamic>? get metadata;

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  RunStepCompletionUsage? get usage;

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepObjectCopyWith<RunStepObject> get copyWith =>
      _$RunStepObjectCopyWithImpl<RunStepObject>(
          this as RunStepObject, _$identity);

  /// Serializes this RunStepObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.stepDetails, stepDetails) ||
                other.stepDetails == stepDetails) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiredAt, expiredAt) ||
                other.expiredAt == expiredAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            const DeepCollectionEquality().equals(other.metadata, metadata) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      assistantId,
      threadId,
      runId,
      type,
      status,
      stepDetails,
      lastError,
      expiredAt,
      cancelledAt,
      failedAt,
      completedAt,
      const DeepCollectionEquality().hash(metadata),
      usage);

  @override
  String toString() {
    return 'RunStepObject(id: $id, object: $object, createdAt: $createdAt, assistantId: $assistantId, threadId: $threadId, runId: $runId, type: $type, status: $status, stepDetails: $stepDetails, lastError: $lastError, expiredAt: $expiredAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, metadata: $metadata, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class $RunStepObjectCopyWith<$Res> {
  factory $RunStepObjectCopyWith(
          RunStepObject value, $Res Function(RunStepObject) _then) =
      _$RunStepObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      RunStepObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'run_id') String runId,
      RunStepType type,
      RunStepStatus status,
      @JsonKey(name: 'step_details') RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') int? expiredAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      Map<String, dynamic>? metadata,
      RunStepCompletionUsage? usage});

  $RunStepDetailsCopyWith<$Res> get stepDetails;
  $RunStepLastErrorCopyWith<$Res>? get lastError;
  $RunStepCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$RunStepObjectCopyWithImpl<$Res>
    implements $RunStepObjectCopyWith<$Res> {
  _$RunStepObjectCopyWithImpl(this._self, this._then);

  final RunStepObject _self;
  final $Res Function(RunStepObject) _then;

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
    Object? threadId = null,
    Object? runId = null,
    Object? type = null,
    Object? status = null,
    Object? stepDetails = null,
    Object? lastError = freezed,
    Object? expiredAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: null == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      runId: null == runId
          ? _self.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepType,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStepStatus,
      stepDetails: null == stepDetails
          ? _self.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDetails,
      lastError: freezed == lastError
          ? _self.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunStepLastError?,
      expiredAt: freezed == expiredAt
          ? _self.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _self.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _self.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunStepCompletionUsage?,
    ));
  }

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsCopyWith<$Res> get stepDetails {
    return $RunStepDetailsCopyWith<$Res>(_self.stepDetails, (value) {
      return _then(_self.copyWith(stepDetails: value));
    });
  }

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepLastErrorCopyWith<$Res>? get lastError {
    if (_self.lastError == null) {
      return null;
    }

    return $RunStepLastErrorCopyWith<$Res>(_self.lastError!, (value) {
      return _then(_self.copyWith(lastError: value));
    });
  }

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepCompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $RunStepCompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// Adds pattern-matching-related methods to [RunStepObject].
extension RunStepObjectPatterns on RunStepObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            RunStepObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'assistant_id') String assistantId,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(name: 'run_id') String runId,
            RunStepType type,
            RunStepStatus status,
            @JsonKey(name: 'step_details') RunStepDetails stepDetails,
            @JsonKey(name: 'last_error') RunStepLastError? lastError,
            @JsonKey(name: 'expired_at') int? expiredAt,
            @JsonKey(name: 'cancelled_at') int? cancelledAt,
            @JsonKey(name: 'failed_at') int? failedAt,
            @JsonKey(name: 'completed_at') int? completedAt,
            Map<String, dynamic>? metadata,
            RunStepCompletionUsage? usage)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.assistantId,
            _that.threadId,
            _that.runId,
            _that.type,
            _that.status,
            _that.stepDetails,
            _that.lastError,
            _that.expiredAt,
            _that.cancelledAt,
            _that.failedAt,
            _that.completedAt,
            _that.metadata,
            _that.usage);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            RunStepObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'assistant_id') String assistantId,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(name: 'run_id') String runId,
            RunStepType type,
            RunStepStatus status,
            @JsonKey(name: 'step_details') RunStepDetails stepDetails,
            @JsonKey(name: 'last_error') RunStepLastError? lastError,
            @JsonKey(name: 'expired_at') int? expiredAt,
            @JsonKey(name: 'cancelled_at') int? cancelledAt,
            @JsonKey(name: 'failed_at') int? failedAt,
            @JsonKey(name: 'completed_at') int? completedAt,
            Map<String, dynamic>? metadata,
            RunStepCompletionUsage? usage)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepObject():
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.assistantId,
            _that.threadId,
            _that.runId,
            _that.type,
            _that.status,
            _that.stepDetails,
            _that.lastError,
            _that.expiredAt,
            _that.cancelledAt,
            _that.failedAt,
            _that.completedAt,
            _that.metadata,
            _that.usage);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            RunStepObjectObject object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'assistant_id') String assistantId,
            @JsonKey(name: 'thread_id') String threadId,
            @JsonKey(name: 'run_id') String runId,
            RunStepType type,
            RunStepStatus status,
            @JsonKey(name: 'step_details') RunStepDetails stepDetails,
            @JsonKey(name: 'last_error') RunStepLastError? lastError,
            @JsonKey(name: 'expired_at') int? expiredAt,
            @JsonKey(name: 'cancelled_at') int? cancelledAt,
            @JsonKey(name: 'failed_at') int? failedAt,
            @JsonKey(name: 'completed_at') int? completedAt,
            Map<String, dynamic>? metadata,
            RunStepCompletionUsage? usage)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.assistantId,
            _that.threadId,
            _that.runId,
            _that.type,
            _that.status,
            _that.stepDetails,
            _that.lastError,
            _that.expiredAt,
            _that.cancelledAt,
            _that.failedAt,
            _that.completedAt,
            _that.metadata,
            _that.usage);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepObject extends RunStepObject {
  const _RunStepObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(name: 'run_id') required this.runId,
      required this.type,
      required this.status,
      @JsonKey(name: 'step_details') required this.stepDetails,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'expired_at') required this.expiredAt,
      @JsonKey(name: 'cancelled_at') required this.cancelledAt,
      @JsonKey(name: 'failed_at') required this.failedAt,
      @JsonKey(name: 'completed_at') required this.completedAt,
      required final Map<String, dynamic>? metadata,
      required this.usage})
      : _metadata = metadata,
        super._();
  factory _RunStepObject.fromJson(Map<String, dynamic> json) =>
      _$RunStepObjectFromJson(json);

  /// The identifier of the run step, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run.step`.
  @override
  final RunStepObjectObject object;

  /// The Unix timestamp (in seconds) for when the run step was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @override
  @JsonKey(name: 'run_id')
  final String runId;

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  @override
  final RunStepType type;

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  @override
  final RunStepStatus status;

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @override
  @JsonKey(name: 'step_details')
  final RunStepDetails stepDetails;

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final RunStepLastError? lastError;

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @override
  @JsonKey(name: 'expired_at')
  final int? expiredAt;

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @override
  @JsonKey(name: 'cancelled_at')
  final int? cancelledAt;

  /// The Unix timestamp (in seconds) for when the run step failed.
  @override
  @JsonKey(name: 'failed_at')
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the run step completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  @override
  final RunStepCompletionUsage? usage;

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepObjectCopyWith<_RunStepObject> get copyWith =>
      __$RunStepObjectCopyWithImpl<_RunStepObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.stepDetails, stepDetails) ||
                other.stepDetails == stepDetails) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiredAt, expiredAt) ||
                other.expiredAt == expiredAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      assistantId,
      threadId,
      runId,
      type,
      status,
      stepDetails,
      lastError,
      expiredAt,
      cancelledAt,
      failedAt,
      completedAt,
      const DeepCollectionEquality().hash(_metadata),
      usage);

  @override
  String toString() {
    return 'RunStepObject(id: $id, object: $object, createdAt: $createdAt, assistantId: $assistantId, threadId: $threadId, runId: $runId, type: $type, status: $status, stepDetails: $stepDetails, lastError: $lastError, expiredAt: $expiredAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, metadata: $metadata, usage: $usage)';
  }
}

/// @nodoc
abstract mixin class _$RunStepObjectCopyWith<$Res>
    implements $RunStepObjectCopyWith<$Res> {
  factory _$RunStepObjectCopyWith(
          _RunStepObject value, $Res Function(_RunStepObject) _then) =
      __$RunStepObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      RunStepObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'run_id') String runId,
      RunStepType type,
      RunStepStatus status,
      @JsonKey(name: 'step_details') RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') int? expiredAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      Map<String, dynamic>? metadata,
      RunStepCompletionUsage? usage});

  @override
  $RunStepDetailsCopyWith<$Res> get stepDetails;
  @override
  $RunStepLastErrorCopyWith<$Res>? get lastError;
  @override
  $RunStepCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$RunStepObjectCopyWithImpl<$Res>
    implements _$RunStepObjectCopyWith<$Res> {
  __$RunStepObjectCopyWithImpl(this._self, this._then);

  final _RunStepObject _self;
  final $Res Function(_RunStepObject) _then;

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
    Object? threadId = null,
    Object? runId = null,
    Object? type = null,
    Object? status = null,
    Object? stepDetails = null,
    Object? lastError = freezed,
    Object? expiredAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_RunStepObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepObjectObject,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _self.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: null == threadId
          ? _self.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      runId: null == runId
          ? _self.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepType,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStepStatus,
      stepDetails: null == stepDetails
          ? _self.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDetails,
      lastError: freezed == lastError
          ? _self.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunStepLastError?,
      expiredAt: freezed == expiredAt
          ? _self.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _self.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _self.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _self.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunStepCompletionUsage?,
    ));
  }

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsCopyWith<$Res> get stepDetails {
    return $RunStepDetailsCopyWith<$Res>(_self.stepDetails, (value) {
      return _then(_self.copyWith(stepDetails: value));
    });
  }

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepLastErrorCopyWith<$Res>? get lastError {
    if (_self.lastError == null) {
      return null;
    }

    return $RunStepLastErrorCopyWith<$Res>(_self.lastError!, (value) {
      return _then(_self.copyWith(lastError: value));
    });
  }

  /// Create a copy of RunStepObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepCompletionUsageCopyWith<$Res>? get usage {
    if (_self.usage == null) {
      return null;
    }

    return $RunStepCompletionUsageCopyWith<$Res>(_self.usage!, (value) {
      return _then(_self.copyWith(usage: value));
    });
  }
}

/// @nodoc
mixin _$RunStepLastError {
  /// One of `server_error` or `rate_limit_exceeded`.
  RunStepLastErrorCode get code;

  /// A human-readable description of the error.
  String get message;

  /// Create a copy of RunStepLastError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepLastErrorCopyWith<RunStepLastError> get copyWith =>
      _$RunStepLastErrorCopyWithImpl<RunStepLastError>(
          this as RunStepLastError, _$identity);

  /// Serializes this RunStepLastError to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepLastError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @override
  String toString() {
    return 'RunStepLastError(code: $code, message: $message)';
  }
}

/// @nodoc
abstract mixin class $RunStepLastErrorCopyWith<$Res> {
  factory $RunStepLastErrorCopyWith(
          RunStepLastError value, $Res Function(RunStepLastError) _then) =
      _$RunStepLastErrorCopyWithImpl;
  @useResult
  $Res call({RunStepLastErrorCode code, String message});
}

/// @nodoc
class _$RunStepLastErrorCopyWithImpl<$Res>
    implements $RunStepLastErrorCopyWith<$Res> {
  _$RunStepLastErrorCopyWithImpl(this._self, this._then);

  final RunStepLastError _self;
  final $Res Function(RunStepLastError) _then;

  /// Create a copy of RunStepLastError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_self.copyWith(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunStepLastErrorCode,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepLastError].
extension RunStepLastErrorPatterns on RunStepLastError {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepLastError value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepLastError() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepLastError value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepLastError():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepLastError value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepLastError() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(RunStepLastErrorCode code, String message)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepLastError() when $default != null:
        return $default(_that.code, _that.message);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(RunStepLastErrorCode code, String message) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepLastError():
        return $default(_that.code, _that.message);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(RunStepLastErrorCode code, String message)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepLastError() when $default != null:
        return $default(_that.code, _that.message);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepLastError extends RunStepLastError {
  const _RunStepLastError({required this.code, required this.message})
      : super._();
  factory _RunStepLastError.fromJson(Map<String, dynamic> json) =>
      _$RunStepLastErrorFromJson(json);

  /// One of `server_error` or `rate_limit_exceeded`.
  @override
  final RunStepLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  /// Create a copy of RunStepLastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepLastErrorCopyWith<_RunStepLastError> get copyWith =>
      __$RunStepLastErrorCopyWithImpl<_RunStepLastError>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepLastErrorToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepLastError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @override
  String toString() {
    return 'RunStepLastError(code: $code, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$RunStepLastErrorCopyWith<$Res>
    implements $RunStepLastErrorCopyWith<$Res> {
  factory _$RunStepLastErrorCopyWith(
          _RunStepLastError value, $Res Function(_RunStepLastError) _then) =
      __$RunStepLastErrorCopyWithImpl;
  @override
  @useResult
  $Res call({RunStepLastErrorCode code, String message});
}

/// @nodoc
class __$RunStepLastErrorCopyWithImpl<$Res>
    implements _$RunStepLastErrorCopyWith<$Res> {
  __$RunStepLastErrorCopyWithImpl(this._self, this._then);

  final _RunStepLastError _self;
  final $Res Function(_RunStepLastError) _then;

  /// Create a copy of RunStepLastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_RunStepLastError(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunStepLastErrorCode,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$RunStepDeltaObject {
  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `thread.run.step.delta`.
  RunStepDeltaObjectObject get object;

  /// The delta containing the fields that have changed on the run step.
  RunStepDelta get delta;

  /// Create a copy of RunStepDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaObjectCopyWith<RunStepDeltaObject> get copyWith =>
      _$RunStepDeltaObjectCopyWithImpl<RunStepDeltaObject>(
          this as RunStepDeltaObject, _$identity);

  /// Serializes this RunStepDeltaObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, delta);

  @override
  String toString() {
    return 'RunStepDeltaObject(id: $id, object: $object, delta: $delta)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaObjectCopyWith<$Res> {
  factory $RunStepDeltaObjectCopyWith(
          RunStepDeltaObject value, $Res Function(RunStepDeltaObject) _then) =
      _$RunStepDeltaObjectCopyWithImpl;
  @useResult
  $Res call({String id, RunStepDeltaObjectObject object, RunStepDelta delta});

  $RunStepDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class _$RunStepDeltaObjectCopyWithImpl<$Res>
    implements $RunStepDeltaObjectCopyWith<$Res> {
  _$RunStepDeltaObjectCopyWithImpl(this._self, this._then);

  final RunStepDeltaObject _self;
  final $Res Function(RunStepDeltaObject) _then;

  /// Create a copy of RunStepDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaObjectObject,
      delta: null == delta
          ? _self.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as RunStepDelta,
    ));
  }

  /// Create a copy of RunStepDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaCopyWith<$Res> get delta {
    return $RunStepDeltaCopyWith<$Res>(_self.delta, (value) {
      return _then(_self.copyWith(delta: value));
    });
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaObject].
extension RunStepDeltaObjectPatterns on RunStepDeltaObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDeltaObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDeltaObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDeltaObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id, RunStepDeltaObjectObject object, RunStepDelta delta)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaObject() when $default != null:
        return $default(_that.id, _that.object, _that.delta);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id, RunStepDeltaObjectObject object, RunStepDelta delta)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaObject():
        return $default(_that.id, _that.object, _that.delta);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id, RunStepDeltaObjectObject object, RunStepDelta delta)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaObject() when $default != null:
        return $default(_that.id, _that.object, _that.delta);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDeltaObject extends RunStepDeltaObject {
  const _RunStepDeltaObject(
      {required this.id, required this.object, required this.delta})
      : super._();
  factory _RunStepDeltaObject.fromJson(Map<String, dynamic> json) =>
      _$RunStepDeltaObjectFromJson(json);

  /// The identifier of the run step, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run.step.delta`.
  @override
  final RunStepDeltaObjectObject object;

  /// The delta containing the fields that have changed on the run step.
  @override
  final RunStepDelta delta;

  /// Create a copy of RunStepDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDeltaObjectCopyWith<_RunStepDeltaObject> get copyWith =>
      __$RunStepDeltaObjectCopyWithImpl<_RunStepDeltaObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDeltaObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, delta);

  @override
  String toString() {
    return 'RunStepDeltaObject(id: $id, object: $object, delta: $delta)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDeltaObjectCopyWith<$Res>
    implements $RunStepDeltaObjectCopyWith<$Res> {
  factory _$RunStepDeltaObjectCopyWith(
          _RunStepDeltaObject value, $Res Function(_RunStepDeltaObject) _then) =
      __$RunStepDeltaObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String id, RunStepDeltaObjectObject object, RunStepDelta delta});

  @override
  $RunStepDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class __$RunStepDeltaObjectCopyWithImpl<$Res>
    implements _$RunStepDeltaObjectCopyWith<$Res> {
  __$RunStepDeltaObjectCopyWithImpl(this._self, this._then);

  final _RunStepDeltaObject _self;
  final $Res Function(_RunStepDeltaObject) _then;

  /// Create a copy of RunStepDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_RunStepDeltaObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaObjectObject,
      delta: null == delta
          ? _self.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as RunStepDelta,
    ));
  }

  /// Create a copy of RunStepDeltaObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaCopyWith<$Res> get delta {
    return $RunStepDeltaCopyWith<$Res>(_self.delta, (value) {
      return _then(_self.copyWith(delta: value));
    });
  }
}

/// @nodoc
mixin _$RunStepDelta {
  /// The details of the run step
  /// Any of: [RunStepDeltaStepDetailsMessageCreationObject], [RunStepDeltaStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details', includeIfNull: false)
  RunStepDeltaDetails? get stepDetails;

  /// Create a copy of RunStepDelta
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaCopyWith<RunStepDelta> get copyWith =>
      _$RunStepDeltaCopyWithImpl<RunStepDelta>(
          this as RunStepDelta, _$identity);

  /// Serializes this RunStepDelta to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDelta &&
            (identical(other.stepDetails, stepDetails) ||
                other.stepDetails == stepDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, stepDetails);

  @override
  String toString() {
    return 'RunStepDelta(stepDetails: $stepDetails)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaCopyWith<$Res> {
  factory $RunStepDeltaCopyWith(
          RunStepDelta value, $Res Function(RunStepDelta) _then) =
      _$RunStepDeltaCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'step_details', includeIfNull: false)
      RunStepDeltaDetails? stepDetails});

  $RunStepDeltaDetailsCopyWith<$Res>? get stepDetails;
}

/// @nodoc
class _$RunStepDeltaCopyWithImpl<$Res> implements $RunStepDeltaCopyWith<$Res> {
  _$RunStepDeltaCopyWithImpl(this._self, this._then);

  final RunStepDelta _self;
  final $Res Function(RunStepDelta) _then;

  /// Create a copy of RunStepDelta
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stepDetails = freezed,
  }) {
    return _then(_self.copyWith(
      stepDetails: freezed == stepDetails
          ? _self.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaDetails?,
    ));
  }

  /// Create a copy of RunStepDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaDetailsCopyWith<$Res>? get stepDetails {
    if (_self.stepDetails == null) {
      return null;
    }

    return $RunStepDeltaDetailsCopyWith<$Res>(_self.stepDetails!, (value) {
      return _then(_self.copyWith(stepDetails: value));
    });
  }
}

/// Adds pattern-matching-related methods to [RunStepDelta].
extension RunStepDeltaPatterns on RunStepDelta {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDelta value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDelta() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDelta value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDelta():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDelta value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDelta() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'step_details', includeIfNull: false)
            RunStepDeltaDetails? stepDetails)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDelta() when $default != null:
        return $default(_that.stepDetails);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'step_details', includeIfNull: false)
            RunStepDeltaDetails? stepDetails)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDelta():
        return $default(_that.stepDetails);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'step_details', includeIfNull: false)
            RunStepDeltaDetails? stepDetails)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDelta() when $default != null:
        return $default(_that.stepDetails);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDelta extends RunStepDelta {
  const _RunStepDelta(
      {@JsonKey(name: 'step_details', includeIfNull: false) this.stepDetails})
      : super._();
  factory _RunStepDelta.fromJson(Map<String, dynamic> json) =>
      _$RunStepDeltaFromJson(json);

  /// The details of the run step
  /// Any of: [RunStepDeltaStepDetailsMessageCreationObject], [RunStepDeltaStepDetailsToolCallsObject]
  @override
  @JsonKey(name: 'step_details', includeIfNull: false)
  final RunStepDeltaDetails? stepDetails;

  /// Create a copy of RunStepDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDeltaCopyWith<_RunStepDelta> get copyWith =>
      __$RunStepDeltaCopyWithImpl<_RunStepDelta>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDelta &&
            (identical(other.stepDetails, stepDetails) ||
                other.stepDetails == stepDetails));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, stepDetails);

  @override
  String toString() {
    return 'RunStepDelta(stepDetails: $stepDetails)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDeltaCopyWith<$Res>
    implements $RunStepDeltaCopyWith<$Res> {
  factory _$RunStepDeltaCopyWith(
          _RunStepDelta value, $Res Function(_RunStepDelta) _then) =
      __$RunStepDeltaCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'step_details', includeIfNull: false)
      RunStepDeltaDetails? stepDetails});

  @override
  $RunStepDeltaDetailsCopyWith<$Res>? get stepDetails;
}

/// @nodoc
class __$RunStepDeltaCopyWithImpl<$Res>
    implements _$RunStepDeltaCopyWith<$Res> {
  __$RunStepDeltaCopyWithImpl(this._self, this._then);

  final _RunStepDelta _self;
  final $Res Function(_RunStepDelta) _then;

  /// Create a copy of RunStepDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? stepDetails = freezed,
  }) {
    return _then(_RunStepDelta(
      stepDetails: freezed == stepDetails
          ? _self.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaDetails?,
    ));
  }

  /// Create a copy of RunStepDelta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaDetailsCopyWith<$Res>? get stepDetails {
    if (_self.stepDetails == null) {
      return null;
    }

    return $RunStepDeltaDetailsCopyWith<$Res>(_self.stepDetails!, (value) {
      return _then(_self.copyWith(stepDetails: value));
    });
  }
}

/// @nodoc
mixin _$ListRunStepsResponse {
  /// The object type, which is always `list`.
  String get object;

  /// The list of run steps.
  List<RunStepObject> get data;

  /// The ID of the first run step in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last run step in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more run steps to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListRunStepsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListRunStepsResponseCopyWith<ListRunStepsResponse> get copyWith =>
      _$ListRunStepsResponseCopyWithImpl<ListRunStepsResponse>(
          this as ListRunStepsResponse, _$identity);

  /// Serializes this ListRunStepsResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListRunStepsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListRunStepsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListRunStepsResponseCopyWith<$Res> {
  factory $ListRunStepsResponseCopyWith(ListRunStepsResponse value,
          $Res Function(ListRunStepsResponse) _then) =
      _$ListRunStepsResponseCopyWithImpl;
  @useResult
  $Res call(
      {String object,
      List<RunStepObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListRunStepsResponseCopyWithImpl<$Res>
    implements $ListRunStepsResponseCopyWith<$Res> {
  _$ListRunStepsResponseCopyWithImpl(this._self, this._then);

  final ListRunStepsResponse _self;
  final $Res Function(ListRunStepsResponse) _then;

  /// Create a copy of ListRunStepsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunStepObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListRunStepsResponse].
extension ListRunStepsResponsePatterns on ListRunStepsResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListRunStepsResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListRunStepsResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListRunStepsResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunStepsResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListRunStepsResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunStepsResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String object,
            List<RunStepObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListRunStepsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String object,
            List<RunStepObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunStepsResponse():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String object,
            List<RunStepObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListRunStepsResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListRunStepsResponse extends ListRunStepsResponse {
  const _ListRunStepsResponse(
      {required this.object,
      required final List<RunStepObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListRunStepsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListRunStepsResponseFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of run steps.
  final List<RunStepObject> _data;

  /// The list of run steps.
  @override
  List<RunStepObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first run step in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last run step in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more run steps to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListRunStepsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListRunStepsResponseCopyWith<_ListRunStepsResponse> get copyWith =>
      __$ListRunStepsResponseCopyWithImpl<_ListRunStepsResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListRunStepsResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListRunStepsResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListRunStepsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListRunStepsResponseCopyWith<$Res>
    implements $ListRunStepsResponseCopyWith<$Res> {
  factory _$ListRunStepsResponseCopyWith(_ListRunStepsResponse value,
          $Res Function(_ListRunStepsResponse) _then) =
      __$ListRunStepsResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String object,
      List<RunStepObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListRunStepsResponseCopyWithImpl<$Res>
    implements _$ListRunStepsResponseCopyWith<$Res> {
  __$ListRunStepsResponseCopyWithImpl(this._self, this._then);

  final _ListRunStepsResponse _self;
  final $Res Function(_ListRunStepsResponse) _then;

  /// Create a copy of ListRunStepsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListRunStepsResponse(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunStepObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$RunStepDetailsMessageCreation {
  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id')
  String get messageId;

  /// Create a copy of RunStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsMessageCreationCopyWith<RunStepDetailsMessageCreation>
      get copyWith => _$RunStepDetailsMessageCreationCopyWithImpl<
              RunStepDetailsMessageCreation>(
          this as RunStepDetailsMessageCreation, _$identity);

  /// Serializes this RunStepDetailsMessageCreation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsMessageCreation &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, messageId);

  @override
  String toString() {
    return 'RunStepDetailsMessageCreation(messageId: $messageId)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsMessageCreationCopyWith<$Res> {
  factory $RunStepDetailsMessageCreationCopyWith(
          RunStepDetailsMessageCreation value,
          $Res Function(RunStepDetailsMessageCreation) _then) =
      _$RunStepDetailsMessageCreationCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class _$RunStepDetailsMessageCreationCopyWithImpl<$Res>
    implements $RunStepDetailsMessageCreationCopyWith<$Res> {
  _$RunStepDetailsMessageCreationCopyWithImpl(this._self, this._then);

  final RunStepDetailsMessageCreation _self;
  final $Res Function(RunStepDetailsMessageCreation) _then;

  /// Create a copy of RunStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = null,
  }) {
    return _then(_self.copyWith(
      messageId: null == messageId
          ? _self.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsMessageCreation].
extension RunStepDetailsMessageCreationPatterns
    on RunStepDetailsMessageCreation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDetailsMessageCreation value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsMessageCreation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDetailsMessageCreation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsMessageCreation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDetailsMessageCreation value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsMessageCreation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'message_id') String messageId)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsMessageCreation() when $default != null:
        return $default(_that.messageId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'message_id') String messageId) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsMessageCreation():
        return $default(_that.messageId);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'message_id') String messageId)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsMessageCreation() when $default != null:
        return $default(_that.messageId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsMessageCreation extends RunStepDetailsMessageCreation {
  const _RunStepDetailsMessageCreation(
      {@JsonKey(name: 'message_id') required this.messageId})
      : super._();
  factory _RunStepDetailsMessageCreation.fromJson(Map<String, dynamic> json) =>
      _$RunStepDetailsMessageCreationFromJson(json);

  /// The ID of the message that was created by this run step.
  @override
  @JsonKey(name: 'message_id')
  final String messageId;

  /// Create a copy of RunStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsMessageCreationCopyWith<_RunStepDetailsMessageCreation>
      get copyWith => __$RunStepDetailsMessageCreationCopyWithImpl<
          _RunStepDetailsMessageCreation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsMessageCreationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsMessageCreation &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, messageId);

  @override
  String toString() {
    return 'RunStepDetailsMessageCreation(messageId: $messageId)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsMessageCreationCopyWith<$Res>
    implements $RunStepDetailsMessageCreationCopyWith<$Res> {
  factory _$RunStepDetailsMessageCreationCopyWith(
          _RunStepDetailsMessageCreation value,
          $Res Function(_RunStepDetailsMessageCreation) _then) =
      __$RunStepDetailsMessageCreationCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class __$RunStepDetailsMessageCreationCopyWithImpl<$Res>
    implements _$RunStepDetailsMessageCreationCopyWith<$Res> {
  __$RunStepDetailsMessageCreationCopyWithImpl(this._self, this._then);

  final _RunStepDetailsMessageCreation _self;
  final $Res Function(_RunStepDetailsMessageCreation) _then;

  /// Create a copy of RunStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? messageId = null,
  }) {
    return _then(_RunStepDetailsMessageCreation(
      messageId: null == messageId
          ? _self.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsMessageCreation {
  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id', includeIfNull: false)
  String? get messageId;

  /// Create a copy of RunStepDeltaStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsMessageCreationCopyWith<
          RunStepDeltaStepDetailsMessageCreation>
      get copyWith => _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl<
              RunStepDeltaStepDetailsMessageCreation>(
          this as RunStepDeltaStepDetailsMessageCreation, _$identity);

  /// Serializes this RunStepDeltaStepDetailsMessageCreation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsMessageCreation &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, messageId);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsMessageCreation(messageId: $messageId)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsMessageCreationCopyWith(
          RunStepDeltaStepDetailsMessageCreation value,
          $Res Function(RunStepDeltaStepDetailsMessageCreation) _then) =
      _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'message_id', includeIfNull: false) String? messageId});
}

/// @nodoc
class _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res> {
  _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl(this._self, this._then);

  final RunStepDeltaStepDetailsMessageCreation _self;
  final $Res Function(RunStepDeltaStepDetailsMessageCreation) _then;

  /// Create a copy of RunStepDeltaStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = freezed,
  }) {
    return _then(_self.copyWith(
      messageId: freezed == messageId
          ? _self.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaStepDetailsMessageCreation].
extension RunStepDeltaStepDetailsMessageCreationPatterns
    on RunStepDeltaStepDetailsMessageCreation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDeltaStepDetailsMessageCreation value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsMessageCreation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDeltaStepDetailsMessageCreation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsMessageCreation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDeltaStepDetailsMessageCreation value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsMessageCreation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'message_id', includeIfNull: false)
            String? messageId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsMessageCreation() when $default != null:
        return $default(_that.messageId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'message_id', includeIfNull: false)
            String? messageId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsMessageCreation():
        return $default(_that.messageId);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'message_id', includeIfNull: false)
            String? messageId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsMessageCreation() when $default != null:
        return $default(_that.messageId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDeltaStepDetailsMessageCreation
    extends RunStepDeltaStepDetailsMessageCreation {
  const _RunStepDeltaStepDetailsMessageCreation(
      {@JsonKey(name: 'message_id', includeIfNull: false) this.messageId})
      : super._();
  factory _RunStepDeltaStepDetailsMessageCreation.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsMessageCreationFromJson(json);

  /// The ID of the message that was created by this run step.
  @override
  @JsonKey(name: 'message_id', includeIfNull: false)
  final String? messageId;

  /// Create a copy of RunStepDeltaStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDeltaStepDetailsMessageCreationCopyWith<
          _RunStepDeltaStepDetailsMessageCreation>
      get copyWith => __$RunStepDeltaStepDetailsMessageCreationCopyWithImpl<
          _RunStepDeltaStepDetailsMessageCreation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsMessageCreationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDeltaStepDetailsMessageCreation &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, messageId);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsMessageCreation(messageId: $messageId)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDeltaStepDetailsMessageCreationCopyWith<$Res>
    implements $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res> {
  factory _$RunStepDeltaStepDetailsMessageCreationCopyWith(
          _RunStepDeltaStepDetailsMessageCreation value,
          $Res Function(_RunStepDeltaStepDetailsMessageCreation) _then) =
      __$RunStepDeltaStepDetailsMessageCreationCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'message_id', includeIfNull: false) String? messageId});
}

/// @nodoc
class __$RunStepDeltaStepDetailsMessageCreationCopyWithImpl<$Res>
    implements _$RunStepDeltaStepDetailsMessageCreationCopyWith<$Res> {
  __$RunStepDeltaStepDetailsMessageCreationCopyWithImpl(this._self, this._then);

  final _RunStepDeltaStepDetailsMessageCreation _self;
  final $Res Function(_RunStepDeltaStepDetailsMessageCreation) _then;

  /// Create a copy of RunStepDeltaStepDetailsMessageCreation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? messageId = freezed,
  }) {
    return _then(_RunStepDeltaStepDetailsMessageCreation(
      messageId: freezed == messageId
          ? _self.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  /// The input to the Code Interpreter tool call.
  String get input;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  List<RunStepDetailsToolCallsCodeOutput> get outputs;

  /// Create a copy of RunStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
          RunStepDetailsToolCallsCodeObjectCodeInterpreter>
      get copyWith =>
          _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
                  RunStepDetailsToolCallsCodeObjectCodeInterpreter>(
              this as RunStepDetailsToolCallsCodeObjectCodeInterpreter,
              _$identity);

  /// Serializes this RunStepDetailsToolCallsCodeObjectCodeInterpreter to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsCodeObjectCodeInterpreter &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other.outputs, outputs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(outputs));

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeObjectCodeInterpreter(input: $input, outputs: $outputs)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
    $Res> {
  factory $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith(
          RunStepDetailsToolCallsCodeObjectCodeInterpreter value,
          $Res Function(RunStepDetailsToolCallsCodeObjectCodeInterpreter)
              _then) =
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl;
  @useResult
  $Res call({String input, List<RunStepDetailsToolCallsCodeOutput> outputs});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl(
      this._self, this._then);

  final RunStepDetailsToolCallsCodeObjectCodeInterpreter _self;
  final $Res Function(RunStepDetailsToolCallsCodeObjectCodeInterpreter) _then;

  /// Create a copy of RunStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? outputs = null,
  }) {
    return _then(_self.copyWith(
      input: null == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
      outputs: null == outputs
          ? _self.outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsCodeOutput>,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsCodeObjectCodeInterpreter].
extension RunStepDetailsToolCallsCodeObjectCodeInterpreterPatterns
    on RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsCodeObjectCodeInterpreter value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsCodeObjectCodeInterpreter value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeObjectCodeInterpreter():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDetailsToolCallsCodeObjectCodeInterpreter value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String input, List<RunStepDetailsToolCallsCodeOutput> outputs)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that.input, _that.outputs);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String input, List<RunStepDetailsToolCallsCodeOutput> outputs)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeObjectCodeInterpreter():
        return $default(_that.input, _that.outputs);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String input, List<RunStepDetailsToolCallsCodeOutput> outputs)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that.input, _that.outputs);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsToolCallsCodeObjectCodeInterpreter
    extends RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  const _RunStepDetailsToolCallsCodeObjectCodeInterpreter(
      {required this.input,
      required final List<RunStepDetailsToolCallsCodeOutput> outputs})
      : _outputs = outputs,
        super._();
  factory _RunStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterFromJson(json);

  /// The input to the Code Interpreter tool call.
  @override
  final String input;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  final List<RunStepDetailsToolCallsCodeOutput> _outputs;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @override
  List<RunStepDetailsToolCallsCodeOutput> get outputs {
    if (_outputs is EqualUnmodifiableListView) return _outputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_outputs);
  }

  /// Create a copy of RunStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
          _RunStepDetailsToolCallsCodeObjectCodeInterpreter>
      get copyWith =>
          __$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
                  _RunStepDetailsToolCallsCodeObjectCodeInterpreter>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsCodeObjectCodeInterpreterToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsToolCallsCodeObjectCodeInterpreter &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other._outputs, _outputs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(_outputs));

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeObjectCodeInterpreter(input: $input, outputs: $outputs)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
        $Res>
    implements $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  factory _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith(
          _RunStepDetailsToolCallsCodeObjectCodeInterpreter value,
          $Res Function(_RunStepDetailsToolCallsCodeObjectCodeInterpreter)
              _then) =
      __$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl;
  @override
  @useResult
  $Res call({String input, List<RunStepDetailsToolCallsCodeOutput> outputs});
}

/// @nodoc
class __$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res>
    implements
        _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  __$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl(
      this._self, this._then);

  final _RunStepDetailsToolCallsCodeObjectCodeInterpreter _self;
  final $Res Function(_RunStepDetailsToolCallsCodeObjectCodeInterpreter) _then;

  /// Create a copy of RunStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? input = null,
    Object? outputs = null,
  }) {
    return _then(_RunStepDetailsToolCallsCodeObjectCodeInterpreter(
      input: null == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
      outputs: null == outputs
          ? _self._outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsCodeOutput>,
    ));
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
  /// The input to the Code Interpreter tool call.
  @JsonKey(includeIfNull: false)
  String? get input;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @JsonKey(includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCallsCodeOutput>? get outputs;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>
      get copyWith =>
          _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
                  RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>(
              this as RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter,
              _$identity);

  /// Serializes this RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other.outputs, outputs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(outputs));

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter(input: $input, outputs: $outputs)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
    $Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value,
          $Res Function(
                  RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter)
              _then) =
      _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? input,
      @JsonKey(includeIfNull: false)
      List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
        $Res>
    implements
        $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
            $Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter)
      _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = freezed,
    Object? outputs = freezed,
  }) {
    return _then(_self.copyWith(
      input: freezed == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as String?,
      outputs: freezed == outputs
          ? _self.outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDeltaStepDetailsToolCallsCodeOutput>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter].
extension RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterPatterns
    on RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(
            _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(
            _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(
            _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? input,
            @JsonKey(includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that.input, _that.outputs);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? input,
            @JsonKey(includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter():
        return $default(_that.input, _that.outputs);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? input,
            @JsonKey(includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter()
          when $default != null:
        return $default(_that.input, _that.outputs);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
    extends RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
  const _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter(
      {@JsonKey(includeIfNull: false) this.input,
      @JsonKey(includeIfNull: false)
      final List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs})
      : _outputs = outputs,
        super._();
  factory _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterFromJson(json);

  /// The input to the Code Interpreter tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? input;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  final List<RunStepDeltaStepDetailsToolCallsCodeOutput>? _outputs;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @override
  @JsonKey(includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCallsCodeOutput>? get outputs {
    final value = _outputs;
    if (value == null) return null;
    if (_outputs is EqualUnmodifiableListView) return _outputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
          _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>
      get copyWith =>
          __$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
                  _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other._outputs, _outputs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(_outputs));

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter(input: $input, outputs: $outputs)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
        $Res>
    implements
        $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
            $Res> {
  factory _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith(
          _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value,
          $Res Function(
                  _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter)
              _then) =
      __$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? input,
      @JsonKey(includeIfNull: false)
      List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs});
}

/// @nodoc
class __$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
        $Res>
    implements
        _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
            $Res> {
  __$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl(
      this._self, this._then);

  final _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter _self;
  final $Res Function(
      _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? input = freezed,
    Object? outputs = freezed,
  }) {
    return _then(_RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter(
      input: freezed == input
          ? _self.input
          : input // ignore: cast_nullable_to_non_nullable
              as String?,
      outputs: freezed == outputs
          ? _self._outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDeltaStepDetailsToolCallsCodeOutput>?,
    ));
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeOutputImage {
  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id')
  String get fileId;

  /// Create a copy of RunStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeOutputImageCopyWith<
          RunStepDetailsToolCallsCodeOutputImage>
      get copyWith => _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<
              RunStepDetailsToolCallsCodeOutputImage>(
          this as RunStepDetailsToolCallsCodeOutputImage, _$identity);

  /// Serializes this RunStepDetailsToolCallsCodeOutputImage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsCodeOutputImage &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutputImage(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputImageCopyWith(
          RunStepDetailsToolCallsCodeOutputImage value,
          $Res Function(RunStepDetailsToolCallsCodeOutputImage) _then) =
      _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsCodeOutputImage _self;
  final $Res Function(RunStepDetailsToolCallsCodeOutputImage) _then;

  /// Create a copy of RunStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_self.copyWith(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsCodeOutputImage].
extension RunStepDetailsToolCallsCodeOutputImagePatterns
    on RunStepDetailsToolCallsCodeOutputImage {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsCodeOutputImage value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeOutputImage() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsCodeOutputImage value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeOutputImage():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDetailsToolCallsCodeOutputImage value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeOutputImage() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeOutputImage() when $default != null:
        return $default(_that.fileId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeOutputImage():
        return $default(_that.fileId);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'file_id') String fileId)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsCodeOutputImage() when $default != null:
        return $default(_that.fileId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsToolCallsCodeOutputImage
    extends RunStepDetailsToolCallsCodeOutputImage {
  const _RunStepDetailsToolCallsCodeOutputImage(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();
  factory _RunStepDetailsToolCallsCodeOutputImage.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsCodeOutputImageFromJson(json);

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// Create a copy of RunStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsToolCallsCodeOutputImageCopyWith<
          _RunStepDetailsToolCallsCodeOutputImage>
      get copyWith => __$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<
          _RunStepDetailsToolCallsCodeOutputImage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsCodeOutputImageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsToolCallsCodeOutputImage &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutputImage(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res>
    implements $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory _$RunStepDetailsToolCallsCodeOutputImageCopyWith(
          _RunStepDetailsToolCallsCodeOutputImage value,
          $Res Function(_RunStepDetailsToolCallsCodeOutputImage) _then) =
      __$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res>
    implements _$RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  __$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl(this._self, this._then);

  final _RunStepDetailsToolCallsCodeOutputImage _self;
  final $Res Function(_RunStepDetailsToolCallsCodeOutputImage) _then;

  /// Create a copy of RunStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_RunStepDetailsToolCallsCodeOutputImage(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsCodeOutputImage {
  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeOutputImage>
      get copyWith => _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl<
              RunStepDeltaStepDetailsToolCallsCodeOutputImage>(
          this as RunStepDeltaStepDetailsToolCallsCodeOutputImage, _$identity);

  /// Serializes this RunStepDeltaStepDetailsToolCallsCodeOutputImage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsCodeOutputImage &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutputImage(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<
    $Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeOutputImage value,
          $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutputImage)
              _then) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsCodeOutputImage _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutputImage) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_self.copyWith(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaStepDetailsToolCallsCodeOutputImage].
extension RunStepDeltaStepDetailsToolCallsCodeOutputImagePatterns
    on RunStepDeltaStepDetailsToolCallsCodeOutputImage {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDeltaStepDetailsToolCallsCodeOutputImage value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeOutputImage()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDeltaStepDetailsToolCallsCodeOutputImage value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeOutputImage():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDeltaStepDetailsToolCallsCodeOutputImage value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeOutputImage()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeOutputImage()
          when $default != null:
        return $default(_that.fileId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeOutputImage():
        return $default(_that.fileId);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsCodeOutputImage()
          when $default != null:
        return $default(_that.fileId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDeltaStepDetailsToolCallsCodeOutputImage
    extends RunStepDeltaStepDetailsToolCallsCodeOutputImage {
  const _RunStepDeltaStepDetailsToolCallsCodeOutputImage(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId})
      : super._();
  factory _RunStepDeltaStepDetailsToolCallsCodeOutputImage.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageFromJson(json);

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<
          _RunStepDeltaStepDetailsToolCallsCodeOutputImage>
      get copyWith =>
          __$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl<
                  _RunStepDeltaStepDetailsToolCallsCodeOutputImage>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsCodeOutputImageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDeltaStepDetailsToolCallsCodeOutputImage &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutputImage(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<
        $Res>
    implements $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith(
          _RunStepDeltaStepDetailsToolCallsCodeOutputImage value,
          $Res Function(_RunStepDeltaStepDetailsToolCallsCodeOutputImage)
              _then) =
      __$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class __$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res>
    implements _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  __$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl(
      this._self, this._then);

  final _RunStepDeltaStepDetailsToolCallsCodeOutputImage _self;
  final $Res Function(_RunStepDeltaStepDetailsToolCallsCodeOutputImage) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutputImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_RunStepDeltaStepDetailsToolCallsCodeOutputImage(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsFileSearch {
  /// The ranking options for the file search.
  @JsonKey(name: 'ranking_options', includeIfNull: false)
  RunStepDetailsToolCallsFileSearchRankingOptionsObject? get rankingOptions;

  /// The results of the file search.
  @JsonKey(includeIfNull: false)
  List<RunStepDetailsToolCallsFileSearchResultObject>? get results;

  /// Create a copy of RunStepDetailsToolCallsFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchCopyWith<RunStepDetailsToolCallsFileSearch>
      get copyWith => _$RunStepDetailsToolCallsFileSearchCopyWithImpl<
              RunStepDetailsToolCallsFileSearch>(
          this as RunStepDetailsToolCallsFileSearch, _$identity);

  /// Serializes this RunStepDetailsToolCallsFileSearch to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsFileSearch &&
            (identical(other.rankingOptions, rankingOptions) ||
                other.rankingOptions == rankingOptions) &&
            const DeepCollectionEquality().equals(other.results, results));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, rankingOptions,
      const DeepCollectionEquality().hash(results));

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearch(rankingOptions: $rankingOptions, results: $results)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsFileSearchCopyWith<$Res> {
  factory $RunStepDetailsToolCallsFileSearchCopyWith(
          RunStepDetailsToolCallsFileSearch value,
          $Res Function(RunStepDetailsToolCallsFileSearch) _then) =
      _$RunStepDetailsToolCallsFileSearchCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'ranking_options', includeIfNull: false)
      RunStepDetailsToolCallsFileSearchRankingOptionsObject? rankingOptions,
      @JsonKey(includeIfNull: false)
      List<RunStepDetailsToolCallsFileSearchResultObject>? results});

  $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res>?
      get rankingOptions;
}

/// @nodoc
class _$RunStepDetailsToolCallsFileSearchCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsFileSearchCopyWith<$Res> {
  _$RunStepDetailsToolCallsFileSearchCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsFileSearch _self;
  final $Res Function(RunStepDetailsToolCallsFileSearch) _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rankingOptions = freezed,
    Object? results = freezed,
  }) {
    return _then(_self.copyWith(
      rankingOptions: freezed == rankingOptions
          ? _self.rankingOptions
          : rankingOptions // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsFileSearchRankingOptionsObject?,
      results: freezed == results
          ? _self.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsFileSearchResultObject>?,
    ));
  }

  /// Create a copy of RunStepDetailsToolCallsFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res>?
      get rankingOptions {
    if (_self.rankingOptions == null) {
      return null;
    }

    return $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res>(
        _self.rankingOptions!, (value) {
      return _then(_self.copyWith(rankingOptions: value));
    });
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsFileSearch].
extension RunStepDetailsToolCallsFileSearchPatterns
    on RunStepDetailsToolCallsFileSearch {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFileSearch value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearch() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFileSearch value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearch():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDetailsToolCallsFileSearch value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearch() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'ranking_options', includeIfNull: false)
            RunStepDetailsToolCallsFileSearchRankingOptionsObject?
                rankingOptions,
            @JsonKey(includeIfNull: false)
            List<RunStepDetailsToolCallsFileSearchResultObject>? results)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearch() when $default != null:
        return $default(_that.rankingOptions, _that.results);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'ranking_options', includeIfNull: false)
            RunStepDetailsToolCallsFileSearchRankingOptionsObject?
                rankingOptions,
            @JsonKey(includeIfNull: false)
            List<RunStepDetailsToolCallsFileSearchResultObject>? results)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearch():
        return $default(_that.rankingOptions, _that.results);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'ranking_options', includeIfNull: false)
            RunStepDetailsToolCallsFileSearchRankingOptionsObject?
                rankingOptions,
            @JsonKey(includeIfNull: false)
            List<RunStepDetailsToolCallsFileSearchResultObject>? results)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearch() when $default != null:
        return $default(_that.rankingOptions, _that.results);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsToolCallsFileSearch
    extends RunStepDetailsToolCallsFileSearch {
  const _RunStepDetailsToolCallsFileSearch(
      {@JsonKey(name: 'ranking_options', includeIfNull: false)
      this.rankingOptions,
      @JsonKey(includeIfNull: false)
      final List<RunStepDetailsToolCallsFileSearchResultObject>? results})
      : _results = results,
        super._();
  factory _RunStepDetailsToolCallsFileSearch.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsFileSearchFromJson(json);

  /// The ranking options for the file search.
  @override
  @JsonKey(name: 'ranking_options', includeIfNull: false)
  final RunStepDetailsToolCallsFileSearchRankingOptionsObject? rankingOptions;

  /// The results of the file search.
  final List<RunStepDetailsToolCallsFileSearchResultObject>? _results;

  /// The results of the file search.
  @override
  @JsonKey(includeIfNull: false)
  List<RunStepDetailsToolCallsFileSearchResultObject>? get results {
    final value = _results;
    if (value == null) return null;
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of RunStepDetailsToolCallsFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsToolCallsFileSearchCopyWith<
          _RunStepDetailsToolCallsFileSearch>
      get copyWith => __$RunStepDetailsToolCallsFileSearchCopyWithImpl<
          _RunStepDetailsToolCallsFileSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsFileSearchToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsToolCallsFileSearch &&
            (identical(other.rankingOptions, rankingOptions) ||
                other.rankingOptions == rankingOptions) &&
            const DeepCollectionEquality().equals(other._results, _results));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, rankingOptions,
      const DeepCollectionEquality().hash(_results));

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearch(rankingOptions: $rankingOptions, results: $results)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsToolCallsFileSearchCopyWith<$Res>
    implements $RunStepDetailsToolCallsFileSearchCopyWith<$Res> {
  factory _$RunStepDetailsToolCallsFileSearchCopyWith(
          _RunStepDetailsToolCallsFileSearch value,
          $Res Function(_RunStepDetailsToolCallsFileSearch) _then) =
      __$RunStepDetailsToolCallsFileSearchCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'ranking_options', includeIfNull: false)
      RunStepDetailsToolCallsFileSearchRankingOptionsObject? rankingOptions,
      @JsonKey(includeIfNull: false)
      List<RunStepDetailsToolCallsFileSearchResultObject>? results});

  @override
  $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res>?
      get rankingOptions;
}

/// @nodoc
class __$RunStepDetailsToolCallsFileSearchCopyWithImpl<$Res>
    implements _$RunStepDetailsToolCallsFileSearchCopyWith<$Res> {
  __$RunStepDetailsToolCallsFileSearchCopyWithImpl(this._self, this._then);

  final _RunStepDetailsToolCallsFileSearch _self;
  final $Res Function(_RunStepDetailsToolCallsFileSearch) _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? rankingOptions = freezed,
    Object? results = freezed,
  }) {
    return _then(_RunStepDetailsToolCallsFileSearch(
      rankingOptions: freezed == rankingOptions
          ? _self.rankingOptions
          : rankingOptions // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsFileSearchRankingOptionsObject?,
      results: freezed == results
          ? _self._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsFileSearchResultObject>?,
    ));
  }

  /// Create a copy of RunStepDetailsToolCallsFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res>?
      get rankingOptions {
    if (_self.rankingOptions == null) {
      return null;
    }

    return $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res>(
        _self.rankingOptions!, (value) {
      return _then(_self.copyWith(rankingOptions: value));
    });
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsFileSearchRankingOptionsObject {
  /// The ranker to use for the file search. If not specified will use the `auto` ranker.
  FileSearchRanker get ranker;

  /// The score threshold for the file search. All values must be a floating point number between 0 and 1.
  @JsonKey(name: 'score_threshold')
  double get scoreThreshold;

  /// Create a copy of RunStepDetailsToolCallsFileSearchRankingOptionsObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<
          RunStepDetailsToolCallsFileSearchRankingOptionsObject>
      get copyWith =>
          _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl<
                  RunStepDetailsToolCallsFileSearchRankingOptionsObject>(
              this as RunStepDetailsToolCallsFileSearchRankingOptionsObject,
              _$identity);

  /// Serializes this RunStepDetailsToolCallsFileSearchRankingOptionsObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsFileSearchRankingOptionsObject &&
            (identical(other.ranker, ranker) || other.ranker == ranker) &&
            (identical(other.scoreThreshold, scoreThreshold) ||
                other.scoreThreshold == scoreThreshold));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ranker, scoreThreshold);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearchRankingOptionsObject(ranker: $ranker, scoreThreshold: $scoreThreshold)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<
    $Res> {
  factory $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith(
          RunStepDetailsToolCallsFileSearchRankingOptionsObject value,
          $Res Function(RunStepDetailsToolCallsFileSearchRankingOptionsObject)
              _then) =
      _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl;
  @useResult
  $Res call(
      {FileSearchRanker ranker,
      @JsonKey(name: 'score_threshold') double scoreThreshold});
}

/// @nodoc
class _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl<$Res>
    implements
        $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDetailsToolCallsFileSearchRankingOptionsObject _self;
  final $Res Function(RunStepDetailsToolCallsFileSearchRankingOptionsObject)
      _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearchRankingOptionsObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ranker = null,
    Object? scoreThreshold = null,
  }) {
    return _then(_self.copyWith(
      ranker: null == ranker
          ? _self.ranker
          : ranker // ignore: cast_nullable_to_non_nullable
              as FileSearchRanker,
      scoreThreshold: null == scoreThreshold
          ? _self.scoreThreshold
          : scoreThreshold // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsFileSearchRankingOptionsObject].
extension RunStepDetailsToolCallsFileSearchRankingOptionsObjectPatterns
    on RunStepDetailsToolCallsFileSearchRankingOptionsObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(
            _RunStepDetailsToolCallsFileSearchRankingOptionsObject value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchRankingOptionsObject()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(
            _RunStepDetailsToolCallsFileSearchRankingOptionsObject value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchRankingOptionsObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(
            _RunStepDetailsToolCallsFileSearchRankingOptionsObject value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchRankingOptionsObject()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(FileSearchRanker ranker,
            @JsonKey(name: 'score_threshold') double scoreThreshold)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchRankingOptionsObject()
          when $default != null:
        return $default(_that.ranker, _that.scoreThreshold);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(FileSearchRanker ranker,
            @JsonKey(name: 'score_threshold') double scoreThreshold)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchRankingOptionsObject():
        return $default(_that.ranker, _that.scoreThreshold);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(FileSearchRanker ranker,
            @JsonKey(name: 'score_threshold') double scoreThreshold)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchRankingOptionsObject()
          when $default != null:
        return $default(_that.ranker, _that.scoreThreshold);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsToolCallsFileSearchRankingOptionsObject
    extends RunStepDetailsToolCallsFileSearchRankingOptionsObject {
  const _RunStepDetailsToolCallsFileSearchRankingOptionsObject(
      {required this.ranker,
      @JsonKey(name: 'score_threshold') required this.scoreThreshold})
      : super._();
  factory _RunStepDetailsToolCallsFileSearchRankingOptionsObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectFromJson(json);

  /// The ranker to use for the file search. If not specified will use the `auto` ranker.
  @override
  final FileSearchRanker ranker;

  /// The score threshold for the file search. All values must be a floating point number between 0 and 1.
  @override
  @JsonKey(name: 'score_threshold')
  final double scoreThreshold;

  /// Create a copy of RunStepDetailsToolCallsFileSearchRankingOptionsObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<
          _RunStepDetailsToolCallsFileSearchRankingOptionsObject>
      get copyWith =>
          __$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl<
                  _RunStepDetailsToolCallsFileSearchRankingOptionsObject>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsToolCallsFileSearchRankingOptionsObject &&
            (identical(other.ranker, ranker) || other.ranker == ranker) &&
            (identical(other.scoreThreshold, scoreThreshold) ||
                other.scoreThreshold == scoreThreshold));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, ranker, scoreThreshold);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearchRankingOptionsObject(ranker: $ranker, scoreThreshold: $scoreThreshold)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<
        $Res>
    implements
        $RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res> {
  factory _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith(
          _RunStepDetailsToolCallsFileSearchRankingOptionsObject value,
          $Res Function(_RunStepDetailsToolCallsFileSearchRankingOptionsObject)
              _then) =
      __$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {FileSearchRanker ranker,
      @JsonKey(name: 'score_threshold') double scoreThreshold});
}

/// @nodoc
class __$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl<$Res>
    implements
        _$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWith<$Res> {
  __$RunStepDetailsToolCallsFileSearchRankingOptionsObjectCopyWithImpl(
      this._self, this._then);

  final _RunStepDetailsToolCallsFileSearchRankingOptionsObject _self;
  final $Res Function(_RunStepDetailsToolCallsFileSearchRankingOptionsObject)
      _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearchRankingOptionsObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? ranker = null,
    Object? scoreThreshold = null,
  }) {
    return _then(_RunStepDetailsToolCallsFileSearchRankingOptionsObject(
      ranker: null == ranker
          ? _self.ranker
          : ranker // ignore: cast_nullable_to_non_nullable
              as FileSearchRanker,
      scoreThreshold: null == scoreThreshold
          ? _self.scoreThreshold
          : scoreThreshold // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsFileSearchResultObject {
  /// The ID of the file that result was found in.
  @JsonKey(name: 'file_id')
  String get fileId;

  /// The name of the file that result was found in.
  @JsonKey(name: 'file_name')
  String get fileName;

  /// The score of the result. All values must be a floating point number between 0 and 1.
  double get score;

  /// The content of the result that was found. The content is only included if requested via the include
  /// query parameter.
  @JsonKey(includeIfNull: false)
  List<RunStepDetailsToolCallsFileSearchResultContent>? get content;

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchResultObjectCopyWith<
          RunStepDetailsToolCallsFileSearchResultObject>
      get copyWith =>
          _$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl<
                  RunStepDetailsToolCallsFileSearchResultObject>(
              this as RunStepDetailsToolCallsFileSearchResultObject,
              _$identity);

  /// Serializes this RunStepDetailsToolCallsFileSearchResultObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsFileSearchResultObject &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.score, score) || other.score == score) &&
            const DeepCollectionEquality().equals(other.content, content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, fileName, score,
      const DeepCollectionEquality().hash(content));

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearchResultObject(fileId: $fileId, fileName: $fileName, score: $score, content: $content)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsFileSearchResultObjectCopyWith<
    $Res> {
  factory $RunStepDetailsToolCallsFileSearchResultObjectCopyWith(
          RunStepDetailsToolCallsFileSearchResultObject value,
          $Res Function(RunStepDetailsToolCallsFileSearchResultObject) _then) =
      _$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      @JsonKey(name: 'file_name') String fileName,
      double score,
      @JsonKey(includeIfNull: false)
      List<RunStepDetailsToolCallsFileSearchResultContent>? content});
}

/// @nodoc
class _$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsFileSearchResultObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDetailsToolCallsFileSearchResultObject _self;
  final $Res Function(RunStepDetailsToolCallsFileSearchResultObject) _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? fileName = null,
    Object? score = null,
    Object? content = freezed,
  }) {
    return _then(_self.copyWith(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: null == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      score: null == score
          ? _self.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsFileSearchResultContent>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsFileSearchResultObject].
extension RunStepDetailsToolCallsFileSearchResultObjectPatterns
    on RunStepDetailsToolCallsFileSearchResultObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFileSearchResultObject value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultObject()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFileSearchResultObject value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDetailsToolCallsFileSearchResultObject value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultObject()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id') String fileId,
            @JsonKey(name: 'file_name') String fileName,
            double score,
            @JsonKey(includeIfNull: false)
            List<RunStepDetailsToolCallsFileSearchResultContent>? content)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultObject()
          when $default != null:
        return $default(
            _that.fileId, _that.fileName, _that.score, _that.content);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id') String fileId,
            @JsonKey(name: 'file_name') String fileName,
            double score,
            @JsonKey(includeIfNull: false)
            List<RunStepDetailsToolCallsFileSearchResultContent>? content)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultObject():
        return $default(
            _that.fileId, _that.fileName, _that.score, _that.content);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_id') String fileId,
            @JsonKey(name: 'file_name') String fileName,
            double score,
            @JsonKey(includeIfNull: false)
            List<RunStepDetailsToolCallsFileSearchResultContent>? content)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultObject()
          when $default != null:
        return $default(
            _that.fileId, _that.fileName, _that.score, _that.content);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsToolCallsFileSearchResultObject
    extends RunStepDetailsToolCallsFileSearchResultObject {
  const _RunStepDetailsToolCallsFileSearchResultObject(
      {@JsonKey(name: 'file_id') required this.fileId,
      @JsonKey(name: 'file_name') required this.fileName,
      required this.score,
      @JsonKey(includeIfNull: false)
      final List<RunStepDetailsToolCallsFileSearchResultContent>? content})
      : _content = content,
        super._();
  factory _RunStepDetailsToolCallsFileSearchResultObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsFileSearchResultObjectFromJson(json);

  /// The ID of the file that result was found in.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// The name of the file that result was found in.
  @override
  @JsonKey(name: 'file_name')
  final String fileName;

  /// The score of the result. All values must be a floating point number between 0 and 1.
  @override
  final double score;

  /// The content of the result that was found. The content is only included if requested via the include
  /// query parameter.
  final List<RunStepDetailsToolCallsFileSearchResultContent>? _content;

  /// The content of the result that was found. The content is only included if requested via the include
  /// query parameter.
  @override
  @JsonKey(includeIfNull: false)
  List<RunStepDetailsToolCallsFileSearchResultContent>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsToolCallsFileSearchResultObjectCopyWith<
          _RunStepDetailsToolCallsFileSearchResultObject>
      get copyWith =>
          __$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl<
              _RunStepDetailsToolCallsFileSearchResultObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsFileSearchResultObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsToolCallsFileSearchResultObject &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.score, score) || other.score == score) &&
            const DeepCollectionEquality().equals(other._content, _content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, fileName, score,
      const DeepCollectionEquality().hash(_content));

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearchResultObject(fileId: $fileId, fileName: $fileName, score: $score, content: $content)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsToolCallsFileSearchResultObjectCopyWith<
        $Res>
    implements $RunStepDetailsToolCallsFileSearchResultObjectCopyWith<$Res> {
  factory _$RunStepDetailsToolCallsFileSearchResultObjectCopyWith(
          _RunStepDetailsToolCallsFileSearchResultObject value,
          $Res Function(_RunStepDetailsToolCallsFileSearchResultObject) _then) =
      __$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      @JsonKey(name: 'file_name') String fileName,
      double score,
      @JsonKey(includeIfNull: false)
      List<RunStepDetailsToolCallsFileSearchResultContent>? content});
}

/// @nodoc
class __$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl<$Res>
    implements _$RunStepDetailsToolCallsFileSearchResultObjectCopyWith<$Res> {
  __$RunStepDetailsToolCallsFileSearchResultObjectCopyWithImpl(
      this._self, this._then);

  final _RunStepDetailsToolCallsFileSearchResultObject _self;
  final $Res Function(_RunStepDetailsToolCallsFileSearchResultObject) _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = null,
    Object? fileName = null,
    Object? score = null,
    Object? content = freezed,
  }) {
    return _then(_RunStepDetailsToolCallsFileSearchResultObject(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: null == fileName
          ? _self.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      score: null == score
          ? _self.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      content: freezed == content
          ? _self._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsFileSearchResultContent>?,
    ));
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsFileSearchResultContent {
  /// The type of the content.
  String get type;

  /// The text content of the file.
  @JsonKey(includeIfNull: false)
  String? get text;

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchResultContentCopyWith<
          RunStepDetailsToolCallsFileSearchResultContent>
      get copyWith =>
          _$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl<
                  RunStepDetailsToolCallsFileSearchResultContent>(
              this as RunStepDetailsToolCallsFileSearchResultContent,
              _$identity);

  /// Serializes this RunStepDetailsToolCallsFileSearchResultContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsFileSearchResultContent &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearchResultContent(type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsFileSearchResultContentCopyWith<
    $Res> {
  factory $RunStepDetailsToolCallsFileSearchResultContentCopyWith(
          RunStepDetailsToolCallsFileSearchResultContent value,
          $Res Function(RunStepDetailsToolCallsFileSearchResultContent) _then) =
      _$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl;
  @useResult
  $Res call({String type, @JsonKey(includeIfNull: false) String? text});
}

/// @nodoc
class _$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsFileSearchResultContentCopyWith<$Res> {
  _$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl(
      this._self, this._then);

  final RunStepDetailsToolCallsFileSearchResultContent _self;
  final $Res Function(RunStepDetailsToolCallsFileSearchResultContent) _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = freezed,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsFileSearchResultContent].
extension RunStepDetailsToolCallsFileSearchResultContentPatterns
    on RunStepDetailsToolCallsFileSearchResultContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFileSearchResultContent value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultContent()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFileSearchResultContent value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultContent():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDetailsToolCallsFileSearchResultContent value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultContent()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String type, @JsonKey(includeIfNull: false) String? text)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultContent()
          when $default != null:
        return $default(_that.type, _that.text);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String type, @JsonKey(includeIfNull: false) String? text)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultContent():
        return $default(_that.type, _that.text);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String type, @JsonKey(includeIfNull: false) String? text)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFileSearchResultContent()
          when $default != null:
        return $default(_that.type, _that.text);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsToolCallsFileSearchResultContent
    extends RunStepDetailsToolCallsFileSearchResultContent {
  const _RunStepDetailsToolCallsFileSearchResultContent(
      {this.type = 'text', @JsonKey(includeIfNull: false) this.text})
      : super._();
  factory _RunStepDetailsToolCallsFileSearchResultContent.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsFileSearchResultContentFromJson(json);

  /// The type of the content.
  @override
  @JsonKey()
  final String type;

  /// The text content of the file.
  @override
  @JsonKey(includeIfNull: false)
  final String? text;

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsToolCallsFileSearchResultContentCopyWith<
          _RunStepDetailsToolCallsFileSearchResultContent>
      get copyWith =>
          __$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl<
                  _RunStepDetailsToolCallsFileSearchResultContent>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsFileSearchResultContentToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsToolCallsFileSearchResultContent &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFileSearchResultContent(type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsToolCallsFileSearchResultContentCopyWith<
        $Res>
    implements $RunStepDetailsToolCallsFileSearchResultContentCopyWith<$Res> {
  factory _$RunStepDetailsToolCallsFileSearchResultContentCopyWith(
          _RunStepDetailsToolCallsFileSearchResultContent value,
          $Res Function(_RunStepDetailsToolCallsFileSearchResultContent)
              _then) =
      __$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl;
  @override
  @useResult
  $Res call({String type, @JsonKey(includeIfNull: false) String? text});
}

/// @nodoc
class __$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl<$Res>
    implements _$RunStepDetailsToolCallsFileSearchResultContentCopyWith<$Res> {
  __$RunStepDetailsToolCallsFileSearchResultContentCopyWithImpl(
      this._self, this._then);

  final _RunStepDetailsToolCallsFileSearchResultContent _self;
  final $Res Function(_RunStepDetailsToolCallsFileSearchResultContent) _then;

  /// Create a copy of RunStepDetailsToolCallsFileSearchResultContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = freezed,
  }) {
    return _then(_RunStepDetailsToolCallsFileSearchResultContent(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
mixin _$RunStepCompletionUsage {
  /// Number of completion tokens used over the course of the run step.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens;

  /// Number of prompt tokens used over the course of the run step.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;

  /// Create a copy of RunStepCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepCompletionUsageCopyWith<RunStepCompletionUsage> get copyWith =>
      _$RunStepCompletionUsageCopyWithImpl<RunStepCompletionUsage>(
          this as RunStepCompletionUsage, _$identity);

  /// Serializes this RunStepCompletionUsage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepCompletionUsage &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @override
  String toString() {
    return 'RunStepCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }
}

/// @nodoc
abstract mixin class $RunStepCompletionUsageCopyWith<$Res> {
  factory $RunStepCompletionUsageCopyWith(RunStepCompletionUsage value,
          $Res Function(RunStepCompletionUsage) _then) =
      _$RunStepCompletionUsageCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$RunStepCompletionUsageCopyWithImpl<$Res>
    implements $RunStepCompletionUsageCopyWith<$Res> {
  _$RunStepCompletionUsageCopyWithImpl(this._self, this._then);

  final RunStepCompletionUsage _self;
  final $Res Function(RunStepCompletionUsage) _then;

  /// Create a copy of RunStepCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_self.copyWith(
      completionTokens: null == completionTokens
          ? _self.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepCompletionUsage].
extension RunStepCompletionUsagePatterns on RunStepCompletionUsage {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepCompletionUsage value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepCompletionUsage() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepCompletionUsage value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepCompletionUsage():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepCompletionUsage value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepCompletionUsage() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'completion_tokens') int completionTokens,
            @JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepCompletionUsage() when $default != null:
        return $default(
            _that.completionTokens, _that.promptTokens, _that.totalTokens);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'completion_tokens') int completionTokens,
            @JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepCompletionUsage():
        return $default(
            _that.completionTokens, _that.promptTokens, _that.totalTokens);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'completion_tokens') int completionTokens,
            @JsonKey(name: 'prompt_tokens') int promptTokens,
            @JsonKey(name: 'total_tokens') int totalTokens)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepCompletionUsage() when $default != null:
        return $default(
            _that.completionTokens, _that.promptTokens, _that.totalTokens);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepCompletionUsage extends RunStepCompletionUsage {
  const _RunStepCompletionUsage(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();
  factory _RunStepCompletionUsage.fromJson(Map<String, dynamic> json) =>
      _$RunStepCompletionUsageFromJson(json);

  /// Number of completion tokens used over the course of the run step.
  @override
  @JsonKey(name: 'completion_tokens')
  final int completionTokens;

  /// Number of prompt tokens used over the course of the run step.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  /// Create a copy of RunStepCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepCompletionUsageCopyWith<_RunStepCompletionUsage> get copyWith =>
      __$RunStepCompletionUsageCopyWithImpl<_RunStepCompletionUsage>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepCompletionUsageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepCompletionUsage &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @override
  String toString() {
    return 'RunStepCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }
}

/// @nodoc
abstract mixin class _$RunStepCompletionUsageCopyWith<$Res>
    implements $RunStepCompletionUsageCopyWith<$Res> {
  factory _$RunStepCompletionUsageCopyWith(_RunStepCompletionUsage value,
          $Res Function(_RunStepCompletionUsage) _then) =
      __$RunStepCompletionUsageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$RunStepCompletionUsageCopyWithImpl<$Res>
    implements _$RunStepCompletionUsageCopyWith<$Res> {
  __$RunStepCompletionUsageCopyWithImpl(this._self, this._then);

  final _RunStepCompletionUsage _self;
  final $Res Function(_RunStepCompletionUsage) _then;

  /// Create a copy of RunStepCompletionUsage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_RunStepCompletionUsage(
      completionTokens: null == completionTokens
          ? _self.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _self.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _self.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$VectorStoreExpirationAfter {
  /// Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
  VectorStoreExpirationAfterAnchor get anchor;

  /// The number of days after the anchor time that the vector store will expire.
  int get days;

  /// Create a copy of VectorStoreExpirationAfter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<VectorStoreExpirationAfter>
      get copyWith =>
          _$VectorStoreExpirationAfterCopyWithImpl<VectorStoreExpirationAfter>(
              this as VectorStoreExpirationAfter, _$identity);

  /// Serializes this VectorStoreExpirationAfter to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VectorStoreExpirationAfter &&
            (identical(other.anchor, anchor) || other.anchor == anchor) &&
            (identical(other.days, days) || other.days == days));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, anchor, days);

  @override
  String toString() {
    return 'VectorStoreExpirationAfter(anchor: $anchor, days: $days)';
  }
}

/// @nodoc
abstract mixin class $VectorStoreExpirationAfterCopyWith<$Res> {
  factory $VectorStoreExpirationAfterCopyWith(VectorStoreExpirationAfter value,
          $Res Function(VectorStoreExpirationAfter) _then) =
      _$VectorStoreExpirationAfterCopyWithImpl;
  @useResult
  $Res call({VectorStoreExpirationAfterAnchor anchor, int days});
}

/// @nodoc
class _$VectorStoreExpirationAfterCopyWithImpl<$Res>
    implements $VectorStoreExpirationAfterCopyWith<$Res> {
  _$VectorStoreExpirationAfterCopyWithImpl(this._self, this._then);

  final VectorStoreExpirationAfter _self;
  final $Res Function(VectorStoreExpirationAfter) _then;

  /// Create a copy of VectorStoreExpirationAfter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? anchor = null,
    Object? days = null,
  }) {
    return _then(_self.copyWith(
      anchor: null == anchor
          ? _self.anchor
          : anchor // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfterAnchor,
      days: null == days
          ? _self.days
          : days // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [VectorStoreExpirationAfter].
extension VectorStoreExpirationAfterPatterns on VectorStoreExpirationAfter {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VectorStoreExpirationAfter value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreExpirationAfter() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VectorStoreExpirationAfter value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreExpirationAfter():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VectorStoreExpirationAfter value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreExpirationAfter() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(VectorStoreExpirationAfterAnchor anchor, int days)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreExpirationAfter() when $default != null:
        return $default(_that.anchor, _that.days);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(VectorStoreExpirationAfterAnchor anchor, int days)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreExpirationAfter():
        return $default(_that.anchor, _that.days);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(VectorStoreExpirationAfterAnchor anchor, int days)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreExpirationAfter() when $default != null:
        return $default(_that.anchor, _that.days);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VectorStoreExpirationAfter extends VectorStoreExpirationAfter {
  const _VectorStoreExpirationAfter({required this.anchor, required this.days})
      : super._();
  factory _VectorStoreExpirationAfter.fromJson(Map<String, dynamic> json) =>
      _$VectorStoreExpirationAfterFromJson(json);

  /// Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
  @override
  final VectorStoreExpirationAfterAnchor anchor;

  /// The number of days after the anchor time that the vector store will expire.
  @override
  final int days;

  /// Create a copy of VectorStoreExpirationAfter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VectorStoreExpirationAfterCopyWith<_VectorStoreExpirationAfter>
      get copyWith => __$VectorStoreExpirationAfterCopyWithImpl<
          _VectorStoreExpirationAfter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VectorStoreExpirationAfterToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VectorStoreExpirationAfter &&
            (identical(other.anchor, anchor) || other.anchor == anchor) &&
            (identical(other.days, days) || other.days == days));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, anchor, days);

  @override
  String toString() {
    return 'VectorStoreExpirationAfter(anchor: $anchor, days: $days)';
  }
}

/// @nodoc
abstract mixin class _$VectorStoreExpirationAfterCopyWith<$Res>
    implements $VectorStoreExpirationAfterCopyWith<$Res> {
  factory _$VectorStoreExpirationAfterCopyWith(
          _VectorStoreExpirationAfter value,
          $Res Function(_VectorStoreExpirationAfter) _then) =
      __$VectorStoreExpirationAfterCopyWithImpl;
  @override
  @useResult
  $Res call({VectorStoreExpirationAfterAnchor anchor, int days});
}

/// @nodoc
class __$VectorStoreExpirationAfterCopyWithImpl<$Res>
    implements _$VectorStoreExpirationAfterCopyWith<$Res> {
  __$VectorStoreExpirationAfterCopyWithImpl(this._self, this._then);

  final _VectorStoreExpirationAfter _self;
  final $Res Function(_VectorStoreExpirationAfter) _then;

  /// Create a copy of VectorStoreExpirationAfter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? anchor = null,
    Object? days = null,
  }) {
    return _then(_VectorStoreExpirationAfter(
      anchor: null == anchor
          ? _self.anchor
          : anchor // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfterAnchor,
      days: null == days
          ? _self.days
          : days // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$VectorStoreObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `vector_store`.
  String get object;

  /// The Unix timestamp (in seconds) for when the vector store was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The name of the vector store.
  String? get name;

  /// The total number of bytes used by the files in the vector store.
  @JsonKey(name: 'usage_bytes')
  int get usageBytes;

  /// The number of files in the vector store.
  @JsonKey(name: 'file_counts')
  VectorStoreObjectFileCounts get fileCounts;

  /// The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
  VectorStoreObjectStatus get status;

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter;

  /// The Unix timestamp (in seconds) for when the vector store will expire.
  @JsonKey(name: 'expires_at', includeIfNull: false)
  int? get expiresAt;

  /// The Unix timestamp (in seconds) for when the vector store was last active.
  @JsonKey(name: 'last_active_at')
  int? get lastActiveAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  dynamic get metadata;

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VectorStoreObjectCopyWith<VectorStoreObject> get copyWith =>
      _$VectorStoreObjectCopyWithImpl<VectorStoreObject>(
          this as VectorStoreObject, _$identity);

  /// Serializes this VectorStoreObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VectorStoreObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.usageBytes, usageBytes) ||
                other.usageBytes == usageBytes) &&
            (identical(other.fileCounts, fileCounts) ||
                other.fileCounts == fileCounts) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.lastActiveAt, lastActiveAt) ||
                other.lastActiveAt == lastActiveAt) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      name,
      usageBytes,
      fileCounts,
      status,
      expiresAfter,
      expiresAt,
      lastActiveAt,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'VectorStoreObject(id: $id, object: $object, createdAt: $createdAt, name: $name, usageBytes: $usageBytes, fileCounts: $fileCounts, status: $status, expiresAfter: $expiresAfter, expiresAt: $expiresAt, lastActiveAt: $lastActiveAt, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $VectorStoreObjectCopyWith<$Res> {
  factory $VectorStoreObjectCopyWith(
          VectorStoreObject value, $Res Function(VectorStoreObject) _then) =
      _$VectorStoreObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'file_counts') VectorStoreObjectFileCounts fileCounts,
      VectorStoreObjectStatus status,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'last_active_at') int? lastActiveAt,
      dynamic metadata});

  $VectorStoreObjectFileCountsCopyWith<$Res> get fileCounts;
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class _$VectorStoreObjectCopyWithImpl<$Res>
    implements $VectorStoreObjectCopyWith<$Res> {
  _$VectorStoreObjectCopyWithImpl(this._self, this._then);

  final VectorStoreObject _self;
  final $Res Function(VectorStoreObject) _then;

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? usageBytes = null,
    Object? fileCounts = null,
    Object? status = null,
    Object? expiresAfter = freezed,
    Object? expiresAt = freezed,
    Object? lastActiveAt = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      usageBytes: null == usageBytes
          ? _self.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      fileCounts: null == fileCounts
          ? _self.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectFileCounts,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectStatus,
      expiresAfter: freezed == expiresAfter
          ? _self.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      lastActiveAt: freezed == lastActiveAt
          ? _self.lastActiveAt
          : lastActiveAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreObjectFileCountsCopyWith<$Res> get fileCounts {
    return $VectorStoreObjectFileCountsCopyWith<$Res>(_self.fileCounts,
        (value) {
      return _then(_self.copyWith(fileCounts: value));
    });
  }

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_self.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_self.expiresAfter!,
        (value) {
      return _then(_self.copyWith(expiresAfter: value));
    });
  }
}

/// Adds pattern-matching-related methods to [VectorStoreObject].
extension VectorStoreObjectPatterns on VectorStoreObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VectorStoreObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VectorStoreObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VectorStoreObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            String object,
            @JsonKey(name: 'created_at') int createdAt,
            String? name,
            @JsonKey(name: 'usage_bytes') int usageBytes,
            @JsonKey(name: 'file_counts')
            VectorStoreObjectFileCounts fileCounts,
            VectorStoreObjectStatus status,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(name: 'last_active_at') int? lastActiveAt,
            dynamic metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.name,
            _that.usageBytes,
            _that.fileCounts,
            _that.status,
            _that.expiresAfter,
            _that.expiresAt,
            _that.lastActiveAt,
            _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            String object,
            @JsonKey(name: 'created_at') int createdAt,
            String? name,
            @JsonKey(name: 'usage_bytes') int usageBytes,
            @JsonKey(name: 'file_counts')
            VectorStoreObjectFileCounts fileCounts,
            VectorStoreObjectStatus status,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(name: 'last_active_at') int? lastActiveAt,
            dynamic metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObject():
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.name,
            _that.usageBytes,
            _that.fileCounts,
            _that.status,
            _that.expiresAfter,
            _that.expiresAt,
            _that.lastActiveAt,
            _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            String object,
            @JsonKey(name: 'created_at') int createdAt,
            String? name,
            @JsonKey(name: 'usage_bytes') int usageBytes,
            @JsonKey(name: 'file_counts')
            VectorStoreObjectFileCounts fileCounts,
            VectorStoreObjectStatus status,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(name: 'last_active_at') int? lastActiveAt,
            dynamic metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.createdAt,
            _that.name,
            _that.usageBytes,
            _that.fileCounts,
            _that.status,
            _that.expiresAfter,
            _that.expiresAt,
            _that.lastActiveAt,
            _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VectorStoreObject extends VectorStoreObject {
  const _VectorStoreObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.name,
      @JsonKey(name: 'usage_bytes') required this.usageBytes,
      @JsonKey(name: 'file_counts') required this.fileCounts,
      required this.status,
      @JsonKey(name: 'expires_after', includeIfNull: false) this.expiresAfter,
      @JsonKey(name: 'expires_at', includeIfNull: false) this.expiresAt,
      @JsonKey(name: 'last_active_at') required this.lastActiveAt,
      required this.metadata})
      : super._();
  factory _VectorStoreObject.fromJson(Map<String, dynamic> json) =>
      _$VectorStoreObjectFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `vector_store`.
  @override
  final String object;

  /// The Unix timestamp (in seconds) for when the vector store was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The name of the vector store.
  @override
  final String? name;

  /// The total number of bytes used by the files in the vector store.
  @override
  @JsonKey(name: 'usage_bytes')
  final int usageBytes;

  /// The number of files in the vector store.
  @override
  @JsonKey(name: 'file_counts')
  final VectorStoreObjectFileCounts fileCounts;

  /// The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
  @override
  final VectorStoreObjectStatus status;

  /// The expiration policy for a vector store.
  @override
  @JsonKey(name: 'expires_after', includeIfNull: false)
  final VectorStoreExpirationAfter? expiresAfter;

  /// The Unix timestamp (in seconds) for when the vector store will expire.
  @override
  @JsonKey(name: 'expires_at', includeIfNull: false)
  final int? expiresAt;

  /// The Unix timestamp (in seconds) for when the vector store was last active.
  @override
  @JsonKey(name: 'last_active_at')
  final int? lastActiveAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  final dynamic metadata;

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VectorStoreObjectCopyWith<_VectorStoreObject> get copyWith =>
      __$VectorStoreObjectCopyWithImpl<_VectorStoreObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VectorStoreObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VectorStoreObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.usageBytes, usageBytes) ||
                other.usageBytes == usageBytes) &&
            (identical(other.fileCounts, fileCounts) ||
                other.fileCounts == fileCounts) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.lastActiveAt, lastActiveAt) ||
                other.lastActiveAt == lastActiveAt) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      name,
      usageBytes,
      fileCounts,
      status,
      expiresAfter,
      expiresAt,
      lastActiveAt,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'VectorStoreObject(id: $id, object: $object, createdAt: $createdAt, name: $name, usageBytes: $usageBytes, fileCounts: $fileCounts, status: $status, expiresAfter: $expiresAfter, expiresAt: $expiresAt, lastActiveAt: $lastActiveAt, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$VectorStoreObjectCopyWith<$Res>
    implements $VectorStoreObjectCopyWith<$Res> {
  factory _$VectorStoreObjectCopyWith(
          _VectorStoreObject value, $Res Function(_VectorStoreObject) _then) =
      __$VectorStoreObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'file_counts') VectorStoreObjectFileCounts fileCounts,
      VectorStoreObjectStatus status,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'last_active_at') int? lastActiveAt,
      dynamic metadata});

  @override
  $VectorStoreObjectFileCountsCopyWith<$Res> get fileCounts;
  @override
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class __$VectorStoreObjectCopyWithImpl<$Res>
    implements _$VectorStoreObjectCopyWith<$Res> {
  __$VectorStoreObjectCopyWithImpl(this._self, this._then);

  final _VectorStoreObject _self;
  final $Res Function(_VectorStoreObject) _then;

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? usageBytes = null,
    Object? fileCounts = null,
    Object? status = null,
    Object? expiresAfter = freezed,
    Object? expiresAt = freezed,
    Object? lastActiveAt = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_VectorStoreObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      usageBytes: null == usageBytes
          ? _self.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      fileCounts: null == fileCounts
          ? _self.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectFileCounts,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectStatus,
      expiresAfter: freezed == expiresAfter
          ? _self.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      lastActiveAt: freezed == lastActiveAt
          ? _self.lastActiveAt
          : lastActiveAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreObjectFileCountsCopyWith<$Res> get fileCounts {
    return $VectorStoreObjectFileCountsCopyWith<$Res>(_self.fileCounts,
        (value) {
      return _then(_self.copyWith(fileCounts: value));
    });
  }

  /// Create a copy of VectorStoreObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_self.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_self.expiresAfter!,
        (value) {
      return _then(_self.copyWith(expiresAfter: value));
    });
  }
}

/// @nodoc
mixin _$VectorStoreObjectFileCounts {
  /// The number of files that are currently being processed.
  @JsonKey(name: 'in_progress')
  int get inProgress;

  /// The number of files that have been successfully processed.
  int get completed;

  /// The number of files that have failed to process.
  int get failed;

  /// The number of files that were cancelled.
  int get cancelled;

  /// The total number of files.
  int get total;

  /// Create a copy of VectorStoreObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VectorStoreObjectFileCountsCopyWith<VectorStoreObjectFileCounts>
      get copyWith => _$VectorStoreObjectFileCountsCopyWithImpl<
              VectorStoreObjectFileCounts>(
          this as VectorStoreObjectFileCounts, _$identity);

  /// Serializes this VectorStoreObjectFileCounts to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VectorStoreObjectFileCounts &&
            (identical(other.inProgress, inProgress) ||
                other.inProgress == inProgress) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed) &&
            (identical(other.cancelled, cancelled) ||
                other.cancelled == cancelled) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, inProgress, completed, failed, cancelled, total);

  @override
  String toString() {
    return 'VectorStoreObjectFileCounts(inProgress: $inProgress, completed: $completed, failed: $failed, cancelled: $cancelled, total: $total)';
  }
}

/// @nodoc
abstract mixin class $VectorStoreObjectFileCountsCopyWith<$Res> {
  factory $VectorStoreObjectFileCountsCopyWith(
          VectorStoreObjectFileCounts value,
          $Res Function(VectorStoreObjectFileCounts) _then) =
      _$VectorStoreObjectFileCountsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class _$VectorStoreObjectFileCountsCopyWithImpl<$Res>
    implements $VectorStoreObjectFileCountsCopyWith<$Res> {
  _$VectorStoreObjectFileCountsCopyWithImpl(this._self, this._then);

  final VectorStoreObjectFileCounts _self;
  final $Res Function(VectorStoreObjectFileCounts) _then;

  /// Create a copy of VectorStoreObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_self.copyWith(
      inProgress: null == inProgress
          ? _self.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _self.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _self.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _self.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [VectorStoreObjectFileCounts].
extension VectorStoreObjectFileCountsPatterns on VectorStoreObjectFileCounts {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VectorStoreObjectFileCounts value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObjectFileCounts() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VectorStoreObjectFileCounts value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObjectFileCounts():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VectorStoreObjectFileCounts value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObjectFileCounts() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'in_progress') int inProgress,
            int completed, int failed, int cancelled, int total)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObjectFileCounts() when $default != null:
        return $default(_that.inProgress, _that.completed, _that.failed,
            _that.cancelled, _that.total);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'in_progress') int inProgress,
            int completed, int failed, int cancelled, int total)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObjectFileCounts():
        return $default(_that.inProgress, _that.completed, _that.failed,
            _that.cancelled, _that.total);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'in_progress') int inProgress,
            int completed, int failed, int cancelled, int total)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreObjectFileCounts() when $default != null:
        return $default(_that.inProgress, _that.completed, _that.failed,
            _that.cancelled, _that.total);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VectorStoreObjectFileCounts extends VectorStoreObjectFileCounts {
  const _VectorStoreObjectFileCounts(
      {@JsonKey(name: 'in_progress') required this.inProgress,
      required this.completed,
      required this.failed,
      required this.cancelled,
      required this.total})
      : super._();
  factory _VectorStoreObjectFileCounts.fromJson(Map<String, dynamic> json) =>
      _$VectorStoreObjectFileCountsFromJson(json);

  /// The number of files that are currently being processed.
  @override
  @JsonKey(name: 'in_progress')
  final int inProgress;

  /// The number of files that have been successfully processed.
  @override
  final int completed;

  /// The number of files that have failed to process.
  @override
  final int failed;

  /// The number of files that were cancelled.
  @override
  final int cancelled;

  /// The total number of files.
  @override
  final int total;

  /// Create a copy of VectorStoreObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VectorStoreObjectFileCountsCopyWith<_VectorStoreObjectFileCounts>
      get copyWith => __$VectorStoreObjectFileCountsCopyWithImpl<
          _VectorStoreObjectFileCounts>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VectorStoreObjectFileCountsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VectorStoreObjectFileCounts &&
            (identical(other.inProgress, inProgress) ||
                other.inProgress == inProgress) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed) &&
            (identical(other.cancelled, cancelled) ||
                other.cancelled == cancelled) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, inProgress, completed, failed, cancelled, total);

  @override
  String toString() {
    return 'VectorStoreObjectFileCounts(inProgress: $inProgress, completed: $completed, failed: $failed, cancelled: $cancelled, total: $total)';
  }
}

/// @nodoc
abstract mixin class _$VectorStoreObjectFileCountsCopyWith<$Res>
    implements $VectorStoreObjectFileCountsCopyWith<$Res> {
  factory _$VectorStoreObjectFileCountsCopyWith(
          _VectorStoreObjectFileCounts value,
          $Res Function(_VectorStoreObjectFileCounts) _then) =
      __$VectorStoreObjectFileCountsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class __$VectorStoreObjectFileCountsCopyWithImpl<$Res>
    implements _$VectorStoreObjectFileCountsCopyWith<$Res> {
  __$VectorStoreObjectFileCountsCopyWithImpl(this._self, this._then);

  final _VectorStoreObjectFileCounts _self;
  final $Res Function(_VectorStoreObjectFileCounts) _then;

  /// Create a copy of VectorStoreObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_VectorStoreObjectFileCounts(
      inProgress: null == inProgress
          ? _self.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _self.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _self.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _self.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$CreateVectorStoreRequest {
  /// The name of the vector store.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds;

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateVectorStoreRequestCopyWith<CreateVectorStoreRequest> get copyWith =>
      _$CreateVectorStoreRequestCopyWithImpl<CreateVectorStoreRequest>(
          this as CreateVectorStoreRequest, _$identity);

  /// Serializes this CreateVectorStoreRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateVectorStoreRequest &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other.fileIds, fileIds) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      const DeepCollectionEquality().hash(fileIds),
      expiresAfter,
      chunkingStrategy,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'CreateVectorStoreRequest(name: $name, fileIds: $fileIds, expiresAfter: $expiresAfter, chunkingStrategy: $chunkingStrategy, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $CreateVectorStoreRequestCopyWith<$Res> {
  factory $CreateVectorStoreRequestCopyWith(CreateVectorStoreRequest value,
          $Res Function(CreateVectorStoreRequest) _then) =
      _$CreateVectorStoreRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$CreateVectorStoreRequestCopyWithImpl<$Res>
    implements $CreateVectorStoreRequestCopyWith<$Res> {
  _$CreateVectorStoreRequestCopyWithImpl(this._self, this._then);

  final CreateVectorStoreRequest _self;
  final $Res Function(CreateVectorStoreRequest) _then;

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? fileIds = freezed,
    Object? expiresAfter = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIds: freezed == fileIds
          ? _self.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      expiresAfter: freezed == expiresAfter
          ? _self.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_self.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_self.expiresAfter!,
        (value) {
      return _then(_self.copyWith(expiresAfter: value));
    });
  }

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateVectorStoreRequest].
extension CreateVectorStoreRequestPatterns on CreateVectorStoreRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateVectorStoreRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateVectorStoreRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateVectorStoreRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'file_ids', includeIfNull: false)
            List<String>? fileIds,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreRequest() when $default != null:
        return $default(_that.name, _that.fileIds, _that.expiresAfter,
            _that.chunkingStrategy, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'file_ids', includeIfNull: false)
            List<String>? fileIds,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy,
            @JsonKey(includeIfNull: false) dynamic metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreRequest():
        return $default(_that.name, _that.fileIds, _that.expiresAfter,
            _that.chunkingStrategy, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'file_ids', includeIfNull: false)
            List<String>? fileIds,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreRequest() when $default != null:
        return $default(_that.name, _that.fileIds, _that.expiresAfter,
            _that.chunkingStrategy, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateVectorStoreRequest extends CreateVectorStoreRequest {
  const _CreateVectorStoreRequest(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(name: 'file_ids', includeIfNull: false)
      final List<String>? fileIds,
      @JsonKey(name: 'expires_after', includeIfNull: false) this.expiresAfter,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy,
      @JsonKey(includeIfNull: false) this.metadata})
      : _fileIds = fileIds,
        super._();
  factory _CreateVectorStoreRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateVectorStoreRequestFromJson(json);

  /// The name of the vector store.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  final List<String>? _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @override
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds {
    final value = _fileIds;
    if (value == null) return null;
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The expiration policy for a vector store.
  @override
  @JsonKey(name: 'expires_after', includeIfNull: false)
  final VectorStoreExpirationAfter? expiresAfter;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateVectorStoreRequestCopyWith<_CreateVectorStoreRequest> get copyWith =>
      __$CreateVectorStoreRequestCopyWithImpl<_CreateVectorStoreRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateVectorStoreRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateVectorStoreRequest &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      const DeepCollectionEquality().hash(_fileIds),
      expiresAfter,
      chunkingStrategy,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'CreateVectorStoreRequest(name: $name, fileIds: $fileIds, expiresAfter: $expiresAfter, chunkingStrategy: $chunkingStrategy, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$CreateVectorStoreRequestCopyWith<$Res>
    implements $CreateVectorStoreRequestCopyWith<$Res> {
  factory _$CreateVectorStoreRequestCopyWith(_CreateVectorStoreRequest value,
          $Res Function(_CreateVectorStoreRequest) _then) =
      __$CreateVectorStoreRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$CreateVectorStoreRequestCopyWithImpl<$Res>
    implements _$CreateVectorStoreRequestCopyWith<$Res> {
  __$CreateVectorStoreRequestCopyWithImpl(this._self, this._then);

  final _CreateVectorStoreRequest _self;
  final $Res Function(_CreateVectorStoreRequest) _then;

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? fileIds = freezed,
    Object? expiresAfter = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_CreateVectorStoreRequest(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIds: freezed == fileIds
          ? _self._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      expiresAfter: freezed == expiresAfter
          ? _self.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_self.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_self.expiresAfter!,
        (value) {
      return _then(_self.copyWith(expiresAfter: value));
    });
  }

  /// Create a copy of CreateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// @nodoc
mixin _$UpdateVectorStoreRequest {
  /// The name of the vector store.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;

  /// Create a copy of UpdateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UpdateVectorStoreRequestCopyWith<UpdateVectorStoreRequest> get copyWith =>
      _$UpdateVectorStoreRequestCopyWithImpl<UpdateVectorStoreRequest>(
          this as UpdateVectorStoreRequest, _$identity);

  /// Serializes this UpdateVectorStoreRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UpdateVectorStoreRequest &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, expiresAfter,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'UpdateVectorStoreRequest(name: $name, expiresAfter: $expiresAfter, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $UpdateVectorStoreRequestCopyWith<$Res> {
  factory $UpdateVectorStoreRequestCopyWith(UpdateVectorStoreRequest value,
          $Res Function(UpdateVectorStoreRequest) _then) =
      _$UpdateVectorStoreRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class _$UpdateVectorStoreRequestCopyWithImpl<$Res>
    implements $UpdateVectorStoreRequestCopyWith<$Res> {
  _$UpdateVectorStoreRequestCopyWithImpl(this._self, this._then);

  final UpdateVectorStoreRequest _self;
  final $Res Function(UpdateVectorStoreRequest) _then;

  /// Create a copy of UpdateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? expiresAfter = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAfter: freezed == expiresAfter
          ? _self.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of UpdateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_self.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_self.expiresAfter!,
        (value) {
      return _then(_self.copyWith(expiresAfter: value));
    });
  }
}

/// Adds pattern-matching-related methods to [UpdateVectorStoreRequest].
extension UpdateVectorStoreRequestPatterns on UpdateVectorStoreRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UpdateVectorStoreRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UpdateVectorStoreRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UpdateVectorStoreRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateVectorStoreRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_UpdateVectorStoreRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateVectorStoreRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _UpdateVectorStoreRequest() when $default != null:
        return $default(_that.name, _that.expiresAfter, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(includeIfNull: false) dynamic metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateVectorStoreRequest():
        return $default(_that.name, _that.expiresAfter, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'expires_after', includeIfNull: false)
            VectorStoreExpirationAfter? expiresAfter,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _UpdateVectorStoreRequest() when $default != null:
        return $default(_that.name, _that.expiresAfter, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _UpdateVectorStoreRequest extends UpdateVectorStoreRequest {
  const _UpdateVectorStoreRequest(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(name: 'expires_after', includeIfNull: false) this.expiresAfter,
      @JsonKey(includeIfNull: false) this.metadata})
      : super._();
  factory _UpdateVectorStoreRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateVectorStoreRequestFromJson(json);

  /// The name of the vector store.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The expiration policy for a vector store.
  @override
  @JsonKey(name: 'expires_after', includeIfNull: false)
  final VectorStoreExpirationAfter? expiresAfter;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  /// Create a copy of UpdateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UpdateVectorStoreRequestCopyWith<_UpdateVectorStoreRequest> get copyWith =>
      __$UpdateVectorStoreRequestCopyWithImpl<_UpdateVectorStoreRequest>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$UpdateVectorStoreRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateVectorStoreRequest &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, expiresAfter,
      const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'UpdateVectorStoreRequest(name: $name, expiresAfter: $expiresAfter, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$UpdateVectorStoreRequestCopyWith<$Res>
    implements $UpdateVectorStoreRequestCopyWith<$Res> {
  factory _$UpdateVectorStoreRequestCopyWith(_UpdateVectorStoreRequest value,
          $Res Function(_UpdateVectorStoreRequest) _then) =
      __$UpdateVectorStoreRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class __$UpdateVectorStoreRequestCopyWithImpl<$Res>
    implements _$UpdateVectorStoreRequestCopyWith<$Res> {
  __$UpdateVectorStoreRequestCopyWithImpl(this._self, this._then);

  final _UpdateVectorStoreRequest _self;
  final $Res Function(_UpdateVectorStoreRequest) _then;

  /// Create a copy of UpdateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? expiresAfter = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_UpdateVectorStoreRequest(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAfter: freezed == expiresAfter
          ? _self.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of UpdateVectorStoreRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_self.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_self.expiresAfter!,
        (value) {
      return _then(_self.copyWith(expiresAfter: value));
    });
  }
}

/// @nodoc
mixin _$ListVectorStoresResponse {
  /// The object type, which is always `list`.
  String get object;

  /// A list of assistant files.
  List<VectorStoreObject> get data;

  /// The ID of the first assistant file in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last assistant file in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more assistant files available.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListVectorStoresResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListVectorStoresResponseCopyWith<ListVectorStoresResponse> get copyWith =>
      _$ListVectorStoresResponseCopyWithImpl<ListVectorStoresResponse>(
          this as ListVectorStoresResponse, _$identity);

  /// Serializes this ListVectorStoresResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListVectorStoresResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListVectorStoresResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListVectorStoresResponseCopyWith<$Res> {
  factory $ListVectorStoresResponseCopyWith(ListVectorStoresResponse value,
          $Res Function(ListVectorStoresResponse) _then) =
      _$ListVectorStoresResponseCopyWithImpl;
  @useResult
  $Res call(
      {String object,
      List<VectorStoreObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListVectorStoresResponseCopyWithImpl<$Res>
    implements $ListVectorStoresResponseCopyWith<$Res> {
  _$ListVectorStoresResponseCopyWithImpl(this._self, this._then);

  final ListVectorStoresResponse _self;
  final $Res Function(ListVectorStoresResponse) _then;

  /// Create a copy of ListVectorStoresResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListVectorStoresResponse].
extension ListVectorStoresResponsePatterns on ListVectorStoresResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListVectorStoresResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoresResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListVectorStoresResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoresResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListVectorStoresResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoresResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String object,
            List<VectorStoreObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoresResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String object,
            List<VectorStoreObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoresResponse():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String object,
            List<VectorStoreObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoresResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListVectorStoresResponse extends ListVectorStoresResponse {
  const _ListVectorStoresResponse(
      {required this.object,
      required final List<VectorStoreObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListVectorStoresResponse.fromJson(Map<String, dynamic> json) =>
      _$ListVectorStoresResponseFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// A list of assistant files.
  final List<VectorStoreObject> _data;

  /// A list of assistant files.
  @override
  List<VectorStoreObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first assistant file in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last assistant file in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more assistant files available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListVectorStoresResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListVectorStoresResponseCopyWith<_ListVectorStoresResponse> get copyWith =>
      __$ListVectorStoresResponseCopyWithImpl<_ListVectorStoresResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListVectorStoresResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListVectorStoresResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListVectorStoresResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListVectorStoresResponseCopyWith<$Res>
    implements $ListVectorStoresResponseCopyWith<$Res> {
  factory _$ListVectorStoresResponseCopyWith(_ListVectorStoresResponse value,
          $Res Function(_ListVectorStoresResponse) _then) =
      __$ListVectorStoresResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String object,
      List<VectorStoreObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListVectorStoresResponseCopyWithImpl<$Res>
    implements _$ListVectorStoresResponseCopyWith<$Res> {
  __$ListVectorStoresResponseCopyWithImpl(this._self, this._then);

  final _ListVectorStoresResponse _self;
  final $Res Function(_ListVectorStoresResponse) _then;

  /// Create a copy of ListVectorStoresResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListVectorStoresResponse(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$DeleteVectorStoreResponse {
  /// The ID of the deleted vector store.
  String get id;

  /// Whether the vector store was deleted.
  bool get deleted;

  /// The object type, which is always `vector_store.deleted`.
  String get object;

  /// Create a copy of DeleteVectorStoreResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DeleteVectorStoreResponseCopyWith<DeleteVectorStoreResponse> get copyWith =>
      _$DeleteVectorStoreResponseCopyWithImpl<DeleteVectorStoreResponse>(
          this as DeleteVectorStoreResponse, _$identity);

  /// Serializes this DeleteVectorStoreResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteVectorStoreResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteVectorStoreResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class $DeleteVectorStoreResponseCopyWith<$Res> {
  factory $DeleteVectorStoreResponseCopyWith(DeleteVectorStoreResponse value,
          $Res Function(DeleteVectorStoreResponse) _then) =
      _$DeleteVectorStoreResponseCopyWithImpl;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteVectorStoreResponseCopyWithImpl<$Res>
    implements $DeleteVectorStoreResponseCopyWith<$Res> {
  _$DeleteVectorStoreResponseCopyWithImpl(this._self, this._then);

  final DeleteVectorStoreResponse _self;
  final $Res Function(DeleteVectorStoreResponse) _then;

  /// Create a copy of DeleteVectorStoreResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [DeleteVectorStoreResponse].
extension DeleteVectorStoreResponsePatterns on DeleteVectorStoreResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DeleteVectorStoreResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DeleteVectorStoreResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DeleteVectorStoreResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String id, bool deleted, String object)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String id, bool deleted, String object) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreResponse():
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String id, bool deleted, String object)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DeleteVectorStoreResponse extends DeleteVectorStoreResponse {
  const _DeleteVectorStoreResponse(
      {required this.id, required this.deleted, required this.object})
      : super._();
  factory _DeleteVectorStoreResponse.fromJson(Map<String, dynamic> json) =>
      _$DeleteVectorStoreResponseFromJson(json);

  /// The ID of the deleted vector store.
  @override
  final String id;

  /// Whether the vector store was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `vector_store.deleted`.
  @override
  final String object;

  /// Create a copy of DeleteVectorStoreResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DeleteVectorStoreResponseCopyWith<_DeleteVectorStoreResponse>
      get copyWith =>
          __$DeleteVectorStoreResponseCopyWithImpl<_DeleteVectorStoreResponse>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DeleteVectorStoreResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DeleteVectorStoreResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteVectorStoreResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$DeleteVectorStoreResponseCopyWith<$Res>
    implements $DeleteVectorStoreResponseCopyWith<$Res> {
  factory _$DeleteVectorStoreResponseCopyWith(_DeleteVectorStoreResponse value,
          $Res Function(_DeleteVectorStoreResponse) _then) =
      __$DeleteVectorStoreResponseCopyWithImpl;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$DeleteVectorStoreResponseCopyWithImpl<$Res>
    implements _$DeleteVectorStoreResponseCopyWith<$Res> {
  __$DeleteVectorStoreResponseCopyWithImpl(this._self, this._then);

  final _DeleteVectorStoreResponse _self;
  final $Res Function(_DeleteVectorStoreResponse) _then;

  /// Create a copy of DeleteVectorStoreResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_DeleteVectorStoreResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$VectorStoreFileObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `vector_store.file`.
  String get object;

  /// The total vector store usage in bytes. Note that this may be different from the original file size.
  @JsonKey(name: 'usage_bytes')
  int get usageBytes;

  /// The Unix timestamp (in seconds) for when the vector store file was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'vector_store_id')
  String get vectorStoreId;

  /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
  VectorStoreFileStatus get status;

  /// The last error associated with this vector store file. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  VectorStoreFileObjectLastError? get lastError;

  /// The chunking strategy used to chunk the file(s).
  /// Any of: [StaticChunkingStrategyResponseParam], [OtherChunkingStrategyResponseParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyResponseParam? get chunkingStrategy;

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VectorStoreFileObjectCopyWith<VectorStoreFileObject> get copyWith =>
      _$VectorStoreFileObjectCopyWithImpl<VectorStoreFileObject>(
          this as VectorStoreFileObject, _$identity);

  /// Serializes this VectorStoreFileObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VectorStoreFileObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usageBytes, usageBytes) ||
                other.usageBytes == usageBytes) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.vectorStoreId, vectorStoreId) ||
                other.vectorStoreId == vectorStoreId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, usageBytes,
      createdAt, vectorStoreId, status, lastError, chunkingStrategy);

  @override
  String toString() {
    return 'VectorStoreFileObject(id: $id, object: $object, usageBytes: $usageBytes, createdAt: $createdAt, vectorStoreId: $vectorStoreId, status: $status, lastError: $lastError, chunkingStrategy: $chunkingStrategy)';
  }
}

/// @nodoc
abstract mixin class $VectorStoreFileObjectCopyWith<$Res> {
  factory $VectorStoreFileObjectCopyWith(VectorStoreFileObject value,
          $Res Function(VectorStoreFileObject) _then) =
      _$VectorStoreFileObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileStatus status,
      @JsonKey(name: 'last_error') VectorStoreFileObjectLastError? lastError,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyResponseParam? chunkingStrategy});

  $VectorStoreFileObjectLastErrorCopyWith<$Res>? get lastError;
  $ChunkingStrategyResponseParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$VectorStoreFileObjectCopyWithImpl<$Res>
    implements $VectorStoreFileObjectCopyWith<$Res> {
  _$VectorStoreFileObjectCopyWithImpl(this._self, this._then);

  final VectorStoreFileObject _self;
  final $Res Function(VectorStoreFileObject) _then;

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? usageBytes = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? lastError = freezed,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usageBytes: null == usageBytes
          ? _self.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _self.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileStatus,
      lastError: freezed == lastError
          ? _self.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastError?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyResponseParam?,
    ));
  }

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreFileObjectLastErrorCopyWith<$Res>? get lastError {
    if (_self.lastError == null) {
      return null;
    }

    return $VectorStoreFileObjectLastErrorCopyWith<$Res>(_self.lastError!,
        (value) {
      return _then(_self.copyWith(lastError: value));
    });
  }

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyResponseParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyResponseParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// Adds pattern-matching-related methods to [VectorStoreFileObject].
extension VectorStoreFileObjectPatterns on VectorStoreFileObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VectorStoreFileObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VectorStoreFileObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VectorStoreFileObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            String object,
            @JsonKey(name: 'usage_bytes') int usageBytes,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'vector_store_id') String vectorStoreId,
            VectorStoreFileStatus status,
            @JsonKey(name: 'last_error')
            VectorStoreFileObjectLastError? lastError,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyResponseParam? chunkingStrategy)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.usageBytes,
            _that.createdAt,
            _that.vectorStoreId,
            _that.status,
            _that.lastError,
            _that.chunkingStrategy);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            String object,
            @JsonKey(name: 'usage_bytes') int usageBytes,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'vector_store_id') String vectorStoreId,
            VectorStoreFileStatus status,
            @JsonKey(name: 'last_error')
            VectorStoreFileObjectLastError? lastError,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyResponseParam? chunkingStrategy)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObject():
        return $default(
            _that.id,
            _that.object,
            _that.usageBytes,
            _that.createdAt,
            _that.vectorStoreId,
            _that.status,
            _that.lastError,
            _that.chunkingStrategy);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            String object,
            @JsonKey(name: 'usage_bytes') int usageBytes,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'vector_store_id') String vectorStoreId,
            VectorStoreFileStatus status,
            @JsonKey(name: 'last_error')
            VectorStoreFileObjectLastError? lastError,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyResponseParam? chunkingStrategy)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObject() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.usageBytes,
            _that.createdAt,
            _that.vectorStoreId,
            _that.status,
            _that.lastError,
            _that.chunkingStrategy);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VectorStoreFileObject extends VectorStoreFileObject {
  const _VectorStoreFileObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'usage_bytes') required this.usageBytes,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'vector_store_id') required this.vectorStoreId,
      required this.status,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy})
      : super._();
  factory _VectorStoreFileObject.fromJson(Map<String, dynamic> json) =>
      _$VectorStoreFileObjectFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `vector_store.file`.
  @override
  final String object;

  /// The total vector store usage in bytes. Note that this may be different from the original file size.
  @override
  @JsonKey(name: 'usage_bytes')
  final int usageBytes;

  /// The Unix timestamp (in seconds) for when the vector store file was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @override
  @JsonKey(name: 'vector_store_id')
  final String vectorStoreId;

  /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
  @override
  final VectorStoreFileStatus status;

  /// The last error associated with this vector store file. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final VectorStoreFileObjectLastError? lastError;

  /// The chunking strategy used to chunk the file(s).
  /// Any of: [StaticChunkingStrategyResponseParam], [OtherChunkingStrategyResponseParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyResponseParam? chunkingStrategy;

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VectorStoreFileObjectCopyWith<_VectorStoreFileObject> get copyWith =>
      __$VectorStoreFileObjectCopyWithImpl<_VectorStoreFileObject>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VectorStoreFileObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VectorStoreFileObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usageBytes, usageBytes) ||
                other.usageBytes == usageBytes) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.vectorStoreId, vectorStoreId) ||
                other.vectorStoreId == vectorStoreId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, usageBytes,
      createdAt, vectorStoreId, status, lastError, chunkingStrategy);

  @override
  String toString() {
    return 'VectorStoreFileObject(id: $id, object: $object, usageBytes: $usageBytes, createdAt: $createdAt, vectorStoreId: $vectorStoreId, status: $status, lastError: $lastError, chunkingStrategy: $chunkingStrategy)';
  }
}

/// @nodoc
abstract mixin class _$VectorStoreFileObjectCopyWith<$Res>
    implements $VectorStoreFileObjectCopyWith<$Res> {
  factory _$VectorStoreFileObjectCopyWith(_VectorStoreFileObject value,
          $Res Function(_VectorStoreFileObject) _then) =
      __$VectorStoreFileObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileStatus status,
      @JsonKey(name: 'last_error') VectorStoreFileObjectLastError? lastError,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyResponseParam? chunkingStrategy});

  @override
  $VectorStoreFileObjectLastErrorCopyWith<$Res>? get lastError;
  @override
  $ChunkingStrategyResponseParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$VectorStoreFileObjectCopyWithImpl<$Res>
    implements _$VectorStoreFileObjectCopyWith<$Res> {
  __$VectorStoreFileObjectCopyWithImpl(this._self, this._then);

  final _VectorStoreFileObject _self;
  final $Res Function(_VectorStoreFileObject) _then;

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? usageBytes = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? lastError = freezed,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_VectorStoreFileObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usageBytes: null == usageBytes
          ? _self.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _self.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileStatus,
      lastError: freezed == lastError
          ? _self.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastError?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyResponseParam?,
    ));
  }

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreFileObjectLastErrorCopyWith<$Res>? get lastError {
    if (_self.lastError == null) {
      return null;
    }

    return $VectorStoreFileObjectLastErrorCopyWith<$Res>(_self.lastError!,
        (value) {
      return _then(_self.copyWith(lastError: value));
    });
  }

  /// Create a copy of VectorStoreFileObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyResponseParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyResponseParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// @nodoc
mixin _$VectorStoreFileObjectLastError {
  /// One of `server_error` or `rate_limit_exceeded`.
  VectorStoreFileObjectLastErrorCode get code;

  /// A human-readable description of the error.
  String get message;

  /// Create a copy of VectorStoreFileObjectLastError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VectorStoreFileObjectLastErrorCopyWith<VectorStoreFileObjectLastError>
      get copyWith => _$VectorStoreFileObjectLastErrorCopyWithImpl<
              VectorStoreFileObjectLastError>(
          this as VectorStoreFileObjectLastError, _$identity);

  /// Serializes this VectorStoreFileObjectLastError to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VectorStoreFileObjectLastError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @override
  String toString() {
    return 'VectorStoreFileObjectLastError(code: $code, message: $message)';
  }
}

/// @nodoc
abstract mixin class $VectorStoreFileObjectLastErrorCopyWith<$Res> {
  factory $VectorStoreFileObjectLastErrorCopyWith(
          VectorStoreFileObjectLastError value,
          $Res Function(VectorStoreFileObjectLastError) _then) =
      _$VectorStoreFileObjectLastErrorCopyWithImpl;
  @useResult
  $Res call({VectorStoreFileObjectLastErrorCode code, String message});
}

/// @nodoc
class _$VectorStoreFileObjectLastErrorCopyWithImpl<$Res>
    implements $VectorStoreFileObjectLastErrorCopyWith<$Res> {
  _$VectorStoreFileObjectLastErrorCopyWithImpl(this._self, this._then);

  final VectorStoreFileObjectLastError _self;
  final $Res Function(VectorStoreFileObjectLastError) _then;

  /// Create a copy of VectorStoreFileObjectLastError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_self.copyWith(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastErrorCode,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [VectorStoreFileObjectLastError].
extension VectorStoreFileObjectLastErrorPatterns
    on VectorStoreFileObjectLastError {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VectorStoreFileObjectLastError value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObjectLastError() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VectorStoreFileObjectLastError value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObjectLastError():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VectorStoreFileObjectLastError value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObjectLastError() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(VectorStoreFileObjectLastErrorCode code, String message)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObjectLastError() when $default != null:
        return $default(_that.code, _that.message);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(VectorStoreFileObjectLastErrorCode code, String message)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObjectLastError():
        return $default(_that.code, _that.message);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(VectorStoreFileObjectLastErrorCode code, String message)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileObjectLastError() when $default != null:
        return $default(_that.code, _that.message);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VectorStoreFileObjectLastError extends VectorStoreFileObjectLastError {
  const _VectorStoreFileObjectLastError(
      {required this.code, required this.message})
      : super._();
  factory _VectorStoreFileObjectLastError.fromJson(Map<String, dynamic> json) =>
      _$VectorStoreFileObjectLastErrorFromJson(json);

  /// One of `server_error` or `rate_limit_exceeded`.
  @override
  final VectorStoreFileObjectLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  /// Create a copy of VectorStoreFileObjectLastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VectorStoreFileObjectLastErrorCopyWith<_VectorStoreFileObjectLastError>
      get copyWith => __$VectorStoreFileObjectLastErrorCopyWithImpl<
          _VectorStoreFileObjectLastError>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VectorStoreFileObjectLastErrorToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VectorStoreFileObjectLastError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @override
  String toString() {
    return 'VectorStoreFileObjectLastError(code: $code, message: $message)';
  }
}

/// @nodoc
abstract mixin class _$VectorStoreFileObjectLastErrorCopyWith<$Res>
    implements $VectorStoreFileObjectLastErrorCopyWith<$Res> {
  factory _$VectorStoreFileObjectLastErrorCopyWith(
          _VectorStoreFileObjectLastError value,
          $Res Function(_VectorStoreFileObjectLastError) _then) =
      __$VectorStoreFileObjectLastErrorCopyWithImpl;
  @override
  @useResult
  $Res call({VectorStoreFileObjectLastErrorCode code, String message});
}

/// @nodoc
class __$VectorStoreFileObjectLastErrorCopyWithImpl<$Res>
    implements _$VectorStoreFileObjectLastErrorCopyWith<$Res> {
  __$VectorStoreFileObjectLastErrorCopyWithImpl(this._self, this._then);

  final _VectorStoreFileObjectLastError _self;
  final $Res Function(_VectorStoreFileObjectLastError) _then;

  /// Create a copy of VectorStoreFileObjectLastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_VectorStoreFileObjectLastError(
      code: null == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastErrorCode,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$StaticChunkingStrategy {
  /// The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the
  /// maximum value is `4096`.
  @JsonKey(name: 'max_chunk_size_tokens')
  int get maxChunkSizeTokens;

  /// The number of tokens that overlap between chunks. The default value is `400`.
  ///
  /// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
  @JsonKey(name: 'chunk_overlap_tokens')
  int get chunkOverlapTokens;

  /// Create a copy of StaticChunkingStrategy
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StaticChunkingStrategyCopyWith<StaticChunkingStrategy> get copyWith =>
      _$StaticChunkingStrategyCopyWithImpl<StaticChunkingStrategy>(
          this as StaticChunkingStrategy, _$identity);

  /// Serializes this StaticChunkingStrategy to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StaticChunkingStrategy &&
            (identical(other.maxChunkSizeTokens, maxChunkSizeTokens) ||
                other.maxChunkSizeTokens == maxChunkSizeTokens) &&
            (identical(other.chunkOverlapTokens, chunkOverlapTokens) ||
                other.chunkOverlapTokens == chunkOverlapTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, maxChunkSizeTokens, chunkOverlapTokens);

  @override
  String toString() {
    return 'StaticChunkingStrategy(maxChunkSizeTokens: $maxChunkSizeTokens, chunkOverlapTokens: $chunkOverlapTokens)';
  }
}

/// @nodoc
abstract mixin class $StaticChunkingStrategyCopyWith<$Res> {
  factory $StaticChunkingStrategyCopyWith(StaticChunkingStrategy value,
          $Res Function(StaticChunkingStrategy) _then) =
      _$StaticChunkingStrategyCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'max_chunk_size_tokens') int maxChunkSizeTokens,
      @JsonKey(name: 'chunk_overlap_tokens') int chunkOverlapTokens});
}

/// @nodoc
class _$StaticChunkingStrategyCopyWithImpl<$Res>
    implements $StaticChunkingStrategyCopyWith<$Res> {
  _$StaticChunkingStrategyCopyWithImpl(this._self, this._then);

  final StaticChunkingStrategy _self;
  final $Res Function(StaticChunkingStrategy) _then;

  /// Create a copy of StaticChunkingStrategy
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? maxChunkSizeTokens = null,
    Object? chunkOverlapTokens = null,
  }) {
    return _then(_self.copyWith(
      maxChunkSizeTokens: null == maxChunkSizeTokens
          ? _self.maxChunkSizeTokens
          : maxChunkSizeTokens // ignore: cast_nullable_to_non_nullable
              as int,
      chunkOverlapTokens: null == chunkOverlapTokens
          ? _self.chunkOverlapTokens
          : chunkOverlapTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [StaticChunkingStrategy].
extension StaticChunkingStrategyPatterns on StaticChunkingStrategy {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_StaticChunkingStrategy value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StaticChunkingStrategy() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_StaticChunkingStrategy value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StaticChunkingStrategy():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_StaticChunkingStrategy value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StaticChunkingStrategy() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'max_chunk_size_tokens') int maxChunkSizeTokens,
            @JsonKey(name: 'chunk_overlap_tokens') int chunkOverlapTokens)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _StaticChunkingStrategy() when $default != null:
        return $default(_that.maxChunkSizeTokens, _that.chunkOverlapTokens);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'max_chunk_size_tokens') int maxChunkSizeTokens,
            @JsonKey(name: 'chunk_overlap_tokens') int chunkOverlapTokens)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StaticChunkingStrategy():
        return $default(_that.maxChunkSizeTokens, _that.chunkOverlapTokens);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'max_chunk_size_tokens') int maxChunkSizeTokens,
            @JsonKey(name: 'chunk_overlap_tokens') int chunkOverlapTokens)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _StaticChunkingStrategy() when $default != null:
        return $default(_that.maxChunkSizeTokens, _that.chunkOverlapTokens);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _StaticChunkingStrategy extends StaticChunkingStrategy {
  const _StaticChunkingStrategy(
      {@JsonKey(name: 'max_chunk_size_tokens') required this.maxChunkSizeTokens,
      @JsonKey(name: 'chunk_overlap_tokens') required this.chunkOverlapTokens})
      : super._();
  factory _StaticChunkingStrategy.fromJson(Map<String, dynamic> json) =>
      _$StaticChunkingStrategyFromJson(json);

  /// The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the
  /// maximum value is `4096`.
  @override
  @JsonKey(name: 'max_chunk_size_tokens')
  final int maxChunkSizeTokens;

  /// The number of tokens that overlap between chunks. The default value is `400`.
  ///
  /// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
  @override
  @JsonKey(name: 'chunk_overlap_tokens')
  final int chunkOverlapTokens;

  /// Create a copy of StaticChunkingStrategy
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$StaticChunkingStrategyCopyWith<_StaticChunkingStrategy> get copyWith =>
      __$StaticChunkingStrategyCopyWithImpl<_StaticChunkingStrategy>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StaticChunkingStrategyToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StaticChunkingStrategy &&
            (identical(other.maxChunkSizeTokens, maxChunkSizeTokens) ||
                other.maxChunkSizeTokens == maxChunkSizeTokens) &&
            (identical(other.chunkOverlapTokens, chunkOverlapTokens) ||
                other.chunkOverlapTokens == chunkOverlapTokens));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, maxChunkSizeTokens, chunkOverlapTokens);

  @override
  String toString() {
    return 'StaticChunkingStrategy(maxChunkSizeTokens: $maxChunkSizeTokens, chunkOverlapTokens: $chunkOverlapTokens)';
  }
}

/// @nodoc
abstract mixin class _$StaticChunkingStrategyCopyWith<$Res>
    implements $StaticChunkingStrategyCopyWith<$Res> {
  factory _$StaticChunkingStrategyCopyWith(_StaticChunkingStrategy value,
          $Res Function(_StaticChunkingStrategy) _then) =
      __$StaticChunkingStrategyCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'max_chunk_size_tokens') int maxChunkSizeTokens,
      @JsonKey(name: 'chunk_overlap_tokens') int chunkOverlapTokens});
}

/// @nodoc
class __$StaticChunkingStrategyCopyWithImpl<$Res>
    implements _$StaticChunkingStrategyCopyWith<$Res> {
  __$StaticChunkingStrategyCopyWithImpl(this._self, this._then);

  final _StaticChunkingStrategy _self;
  final $Res Function(_StaticChunkingStrategy) _then;

  /// Create a copy of StaticChunkingStrategy
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? maxChunkSizeTokens = null,
    Object? chunkOverlapTokens = null,
  }) {
    return _then(_StaticChunkingStrategy(
      maxChunkSizeTokens: null == maxChunkSizeTokens
          ? _self.maxChunkSizeTokens
          : maxChunkSizeTokens // ignore: cast_nullable_to_non_nullable
              as int,
      chunkOverlapTokens: null == chunkOverlapTokens
          ? _self.chunkOverlapTokens
          : chunkOverlapTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$CreateVectorStoreFileRequest {
  /// A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_id')
  String get fileId;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;

  /// Create a copy of CreateVectorStoreFileRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateVectorStoreFileRequestCopyWith<CreateVectorStoreFileRequest>
      get copyWith => _$CreateVectorStoreFileRequestCopyWithImpl<
              CreateVectorStoreFileRequest>(
          this as CreateVectorStoreFileRequest, _$identity);

  /// Serializes this CreateVectorStoreFileRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateVectorStoreFileRequest &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, chunkingStrategy);

  @override
  String toString() {
    return 'CreateVectorStoreFileRequest(fileId: $fileId, chunkingStrategy: $chunkingStrategy)';
  }
}

/// @nodoc
abstract mixin class $CreateVectorStoreFileRequestCopyWith<$Res> {
  factory $CreateVectorStoreFileRequestCopyWith(
          CreateVectorStoreFileRequest value,
          $Res Function(CreateVectorStoreFileRequest) _then) =
      _$CreateVectorStoreFileRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$CreateVectorStoreFileRequestCopyWithImpl<$Res>
    implements $CreateVectorStoreFileRequestCopyWith<$Res> {
  _$CreateVectorStoreFileRequestCopyWithImpl(this._self, this._then);

  final CreateVectorStoreFileRequest _self;
  final $Res Function(CreateVectorStoreFileRequest) _then;

  /// Create a copy of CreateVectorStoreFileRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_self.copyWith(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ));
  }

  /// Create a copy of CreateVectorStoreFileRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateVectorStoreFileRequest].
extension CreateVectorStoreFileRequestPatterns on CreateVectorStoreFileRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateVectorStoreFileRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateVectorStoreFileRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateVectorStoreFileRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id') String fileId,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileRequest() when $default != null:
        return $default(_that.fileId, _that.chunkingStrategy);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id') String fileId,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileRequest():
        return $default(_that.fileId, _that.chunkingStrategy);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_id') String fileId,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileRequest() when $default != null:
        return $default(_that.fileId, _that.chunkingStrategy);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateVectorStoreFileRequest extends CreateVectorStoreFileRequest {
  const _CreateVectorStoreFileRequest(
      {@JsonKey(name: 'file_id') required this.fileId,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy})
      : super._();
  factory _CreateVectorStoreFileRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateVectorStoreFileRequestFromJson(json);

  /// A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  /// Create a copy of CreateVectorStoreFileRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateVectorStoreFileRequestCopyWith<_CreateVectorStoreFileRequest>
      get copyWith => __$CreateVectorStoreFileRequestCopyWithImpl<
          _CreateVectorStoreFileRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateVectorStoreFileRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateVectorStoreFileRequest &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, chunkingStrategy);

  @override
  String toString() {
    return 'CreateVectorStoreFileRequest(fileId: $fileId, chunkingStrategy: $chunkingStrategy)';
  }
}

/// @nodoc
abstract mixin class _$CreateVectorStoreFileRequestCopyWith<$Res>
    implements $CreateVectorStoreFileRequestCopyWith<$Res> {
  factory _$CreateVectorStoreFileRequestCopyWith(
          _CreateVectorStoreFileRequest value,
          $Res Function(_CreateVectorStoreFileRequest) _then) =
      __$CreateVectorStoreFileRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$CreateVectorStoreFileRequestCopyWithImpl<$Res>
    implements _$CreateVectorStoreFileRequestCopyWith<$Res> {
  __$CreateVectorStoreFileRequestCopyWithImpl(this._self, this._then);

  final _CreateVectorStoreFileRequest _self;
  final $Res Function(_CreateVectorStoreFileRequest) _then;

  /// Create a copy of CreateVectorStoreFileRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_CreateVectorStoreFileRequest(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ));
  }

  /// Create a copy of CreateVectorStoreFileRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// @nodoc
mixin _$ListVectorStoreFilesResponse {
  /// The object type, which is always `list`.
  String get object;

  /// A list of message files.
  List<VectorStoreFileObject> get data;

  /// The ID of the first message file in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last message file in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more message files available.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// Create a copy of ListVectorStoreFilesResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListVectorStoreFilesResponseCopyWith<ListVectorStoreFilesResponse>
      get copyWith => _$ListVectorStoreFilesResponseCopyWithImpl<
              ListVectorStoreFilesResponse>(
          this as ListVectorStoreFilesResponse, _$identity);

  /// Serializes this ListVectorStoreFilesResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListVectorStoreFilesResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListVectorStoreFilesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class $ListVectorStoreFilesResponseCopyWith<$Res> {
  factory $ListVectorStoreFilesResponseCopyWith(
          ListVectorStoreFilesResponse value,
          $Res Function(ListVectorStoreFilesResponse) _then) =
      _$ListVectorStoreFilesResponseCopyWithImpl;
  @useResult
  $Res call(
      {String object,
      List<VectorStoreFileObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListVectorStoreFilesResponseCopyWithImpl<$Res>
    implements $ListVectorStoreFilesResponseCopyWith<$Res> {
  _$ListVectorStoreFilesResponseCopyWithImpl(this._self, this._then);

  final ListVectorStoreFilesResponse _self;
  final $Res Function(ListVectorStoreFilesResponse) _then;

  /// Create a copy of ListVectorStoreFilesResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_self.copyWith(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreFileObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListVectorStoreFilesResponse].
extension ListVectorStoreFilesResponsePatterns on ListVectorStoreFilesResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListVectorStoreFilesResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoreFilesResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListVectorStoreFilesResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoreFilesResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListVectorStoreFilesResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoreFilesResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String object,
            List<VectorStoreFileObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoreFilesResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String object,
            List<VectorStoreFileObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoreFilesResponse():
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String object,
            List<VectorStoreFileObject> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListVectorStoreFilesResponse() when $default != null:
        return $default(_that.object, _that.data, _that.firstId, _that.lastId,
            _that.hasMore);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListVectorStoreFilesResponse extends ListVectorStoreFilesResponse {
  const _ListVectorStoreFilesResponse(
      {required this.object,
      required final List<VectorStoreFileObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();
  factory _ListVectorStoreFilesResponse.fromJson(Map<String, dynamic> json) =>
      _$ListVectorStoreFilesResponseFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// A list of message files.
  final List<VectorStoreFileObject> _data;

  /// A list of message files.
  @override
  List<VectorStoreFileObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first message file in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last message file in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more message files available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// Create a copy of ListVectorStoreFilesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListVectorStoreFilesResponseCopyWith<_ListVectorStoreFilesResponse>
      get copyWith => __$ListVectorStoreFilesResponseCopyWithImpl<
          _ListVectorStoreFilesResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListVectorStoreFilesResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListVectorStoreFilesResponse &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @override
  String toString() {
    return 'ListVectorStoreFilesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }
}

/// @nodoc
abstract mixin class _$ListVectorStoreFilesResponseCopyWith<$Res>
    implements $ListVectorStoreFilesResponseCopyWith<$Res> {
  factory _$ListVectorStoreFilesResponseCopyWith(
          _ListVectorStoreFilesResponse value,
          $Res Function(_ListVectorStoreFilesResponse) _then) =
      __$ListVectorStoreFilesResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String object,
      List<VectorStoreFileObject> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$ListVectorStoreFilesResponseCopyWithImpl<$Res>
    implements _$ListVectorStoreFilesResponseCopyWith<$Res> {
  __$ListVectorStoreFilesResponseCopyWithImpl(this._self, this._then);

  final _ListVectorStoreFilesResponse _self;
  final $Res Function(_ListVectorStoreFilesResponse) _then;

  /// Create a copy of ListVectorStoreFilesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_ListVectorStoreFilesResponse(
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreFileObject>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
mixin _$DeleteVectorStoreFileResponse {
  /// The ID of the deleted vector store file.
  String get id;

  /// Whether the vector store file was deleted.
  bool get deleted;

  /// The object type, which is always `vector_store.file.deleted`.
  String get object;

  /// Create a copy of DeleteVectorStoreFileResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DeleteVectorStoreFileResponseCopyWith<DeleteVectorStoreFileResponse>
      get copyWith => _$DeleteVectorStoreFileResponseCopyWithImpl<
              DeleteVectorStoreFileResponse>(
          this as DeleteVectorStoreFileResponse, _$identity);

  /// Serializes this DeleteVectorStoreFileResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteVectorStoreFileResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteVectorStoreFileResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class $DeleteVectorStoreFileResponseCopyWith<$Res> {
  factory $DeleteVectorStoreFileResponseCopyWith(
          DeleteVectorStoreFileResponse value,
          $Res Function(DeleteVectorStoreFileResponse) _then) =
      _$DeleteVectorStoreFileResponseCopyWithImpl;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteVectorStoreFileResponseCopyWithImpl<$Res>
    implements $DeleteVectorStoreFileResponseCopyWith<$Res> {
  _$DeleteVectorStoreFileResponseCopyWithImpl(this._self, this._then);

  final DeleteVectorStoreFileResponse _self;
  final $Res Function(DeleteVectorStoreFileResponse) _then;

  /// Create a copy of DeleteVectorStoreFileResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [DeleteVectorStoreFileResponse].
extension DeleteVectorStoreFileResponsePatterns
    on DeleteVectorStoreFileResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_DeleteVectorStoreFileResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreFileResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_DeleteVectorStoreFileResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreFileResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_DeleteVectorStoreFileResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreFileResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String id, bool deleted, String object)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreFileResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String id, bool deleted, String object) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreFileResponse():
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String id, bool deleted, String object)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _DeleteVectorStoreFileResponse() when $default != null:
        return $default(_that.id, _that.deleted, _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _DeleteVectorStoreFileResponse extends DeleteVectorStoreFileResponse {
  const _DeleteVectorStoreFileResponse(
      {required this.id, required this.deleted, required this.object})
      : super._();
  factory _DeleteVectorStoreFileResponse.fromJson(Map<String, dynamic> json) =>
      _$DeleteVectorStoreFileResponseFromJson(json);

  /// The ID of the deleted vector store file.
  @override
  final String id;

  /// Whether the vector store file was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `vector_store.file.deleted`.
  @override
  final String object;

  /// Create a copy of DeleteVectorStoreFileResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$DeleteVectorStoreFileResponseCopyWith<_DeleteVectorStoreFileResponse>
      get copyWith => __$DeleteVectorStoreFileResponseCopyWithImpl<
          _DeleteVectorStoreFileResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DeleteVectorStoreFileResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DeleteVectorStoreFileResponse &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @override
  String toString() {
    return 'DeleteVectorStoreFileResponse(id: $id, deleted: $deleted, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$DeleteVectorStoreFileResponseCopyWith<$Res>
    implements $DeleteVectorStoreFileResponseCopyWith<$Res> {
  factory _$DeleteVectorStoreFileResponseCopyWith(
          _DeleteVectorStoreFileResponse value,
          $Res Function(_DeleteVectorStoreFileResponse) _then) =
      __$DeleteVectorStoreFileResponseCopyWithImpl;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$DeleteVectorStoreFileResponseCopyWithImpl<$Res>
    implements _$DeleteVectorStoreFileResponseCopyWith<$Res> {
  __$DeleteVectorStoreFileResponseCopyWithImpl(this._self, this._then);

  final _DeleteVectorStoreFileResponse _self;
  final $Res Function(_DeleteVectorStoreFileResponse) _then;

  /// Create a copy of DeleteVectorStoreFileResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_DeleteVectorStoreFileResponse(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _self.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$VectorStoreFileBatchObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id;

  /// The object type, which is always `vector_store.files_batch`
  String get object;

  /// The Unix timestamp (in seconds) for when the vector store files batch was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'vector_store_id')
  String get vectorStoreId;

  /// The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
  VectorStoreFileBatchObjectStatus get status;

  /// The number of files per status.
  @JsonKey(name: 'file_counts')
  VectorStoreFileBatchObjectFileCounts get fileCounts;

  /// Create a copy of VectorStoreFileBatchObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VectorStoreFileBatchObjectCopyWith<VectorStoreFileBatchObject>
      get copyWith =>
          _$VectorStoreFileBatchObjectCopyWithImpl<VectorStoreFileBatchObject>(
              this as VectorStoreFileBatchObject, _$identity);

  /// Serializes this VectorStoreFileBatchObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VectorStoreFileBatchObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.vectorStoreId, vectorStoreId) ||
                other.vectorStoreId == vectorStoreId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.fileCounts, fileCounts) ||
                other.fileCounts == fileCounts));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, object, createdAt, vectorStoreId, status, fileCounts);

  @override
  String toString() {
    return 'VectorStoreFileBatchObject(id: $id, object: $object, createdAt: $createdAt, vectorStoreId: $vectorStoreId, status: $status, fileCounts: $fileCounts)';
  }
}

/// @nodoc
abstract mixin class $VectorStoreFileBatchObjectCopyWith<$Res> {
  factory $VectorStoreFileBatchObjectCopyWith(VectorStoreFileBatchObject value,
          $Res Function(VectorStoreFileBatchObject) _then) =
      _$VectorStoreFileBatchObjectCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileBatchObjectStatus status,
      @JsonKey(name: 'file_counts')
      VectorStoreFileBatchObjectFileCounts fileCounts});

  $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> get fileCounts;
}

/// @nodoc
class _$VectorStoreFileBatchObjectCopyWithImpl<$Res>
    implements $VectorStoreFileBatchObjectCopyWith<$Res> {
  _$VectorStoreFileBatchObjectCopyWithImpl(this._self, this._then);

  final VectorStoreFileBatchObject _self;
  final $Res Function(VectorStoreFileBatchObject) _then;

  /// Create a copy of VectorStoreFileBatchObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? fileCounts = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _self.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectStatus,
      fileCounts: null == fileCounts
          ? _self.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectFileCounts,
    ));
  }

  /// Create a copy of VectorStoreFileBatchObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> get fileCounts {
    return $VectorStoreFileBatchObjectFileCountsCopyWith<$Res>(_self.fileCounts,
        (value) {
      return _then(_self.copyWith(fileCounts: value));
    });
  }
}

/// Adds pattern-matching-related methods to [VectorStoreFileBatchObject].
extension VectorStoreFileBatchObjectPatterns on VectorStoreFileBatchObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VectorStoreFileBatchObject value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObject() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VectorStoreFileBatchObject value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObject():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VectorStoreFileBatchObject value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObject() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            String object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'vector_store_id') String vectorStoreId,
            VectorStoreFileBatchObjectStatus status,
            @JsonKey(name: 'file_counts')
            VectorStoreFileBatchObjectFileCounts fileCounts)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObject() when $default != null:
        return $default(_that.id, _that.object, _that.createdAt,
            _that.vectorStoreId, _that.status, _that.fileCounts);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            String object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'vector_store_id') String vectorStoreId,
            VectorStoreFileBatchObjectStatus status,
            @JsonKey(name: 'file_counts')
            VectorStoreFileBatchObjectFileCounts fileCounts)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObject():
        return $default(_that.id, _that.object, _that.createdAt,
            _that.vectorStoreId, _that.status, _that.fileCounts);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            String object,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'vector_store_id') String vectorStoreId,
            VectorStoreFileBatchObjectStatus status,
            @JsonKey(name: 'file_counts')
            VectorStoreFileBatchObjectFileCounts fileCounts)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObject() when $default != null:
        return $default(_that.id, _that.object, _that.createdAt,
            _that.vectorStoreId, _that.status, _that.fileCounts);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VectorStoreFileBatchObject extends VectorStoreFileBatchObject {
  const _VectorStoreFileBatchObject(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'vector_store_id') required this.vectorStoreId,
      required this.status,
      @JsonKey(name: 'file_counts') required this.fileCounts})
      : super._();
  factory _VectorStoreFileBatchObject.fromJson(Map<String, dynamic> json) =>
      _$VectorStoreFileBatchObjectFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `vector_store.files_batch`
  @override
  final String object;

  /// The Unix timestamp (in seconds) for when the vector store files batch was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @override
  @JsonKey(name: 'vector_store_id')
  final String vectorStoreId;

  /// The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
  @override
  final VectorStoreFileBatchObjectStatus status;

  /// The number of files per status.
  @override
  @JsonKey(name: 'file_counts')
  final VectorStoreFileBatchObjectFileCounts fileCounts;

  /// Create a copy of VectorStoreFileBatchObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VectorStoreFileBatchObjectCopyWith<_VectorStoreFileBatchObject>
      get copyWith => __$VectorStoreFileBatchObjectCopyWithImpl<
          _VectorStoreFileBatchObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VectorStoreFileBatchObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VectorStoreFileBatchObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.vectorStoreId, vectorStoreId) ||
                other.vectorStoreId == vectorStoreId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.fileCounts, fileCounts) ||
                other.fileCounts == fileCounts));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, object, createdAt, vectorStoreId, status, fileCounts);

  @override
  String toString() {
    return 'VectorStoreFileBatchObject(id: $id, object: $object, createdAt: $createdAt, vectorStoreId: $vectorStoreId, status: $status, fileCounts: $fileCounts)';
  }
}

/// @nodoc
abstract mixin class _$VectorStoreFileBatchObjectCopyWith<$Res>
    implements $VectorStoreFileBatchObjectCopyWith<$Res> {
  factory _$VectorStoreFileBatchObjectCopyWith(
          _VectorStoreFileBatchObject value,
          $Res Function(_VectorStoreFileBatchObject) _then) =
      __$VectorStoreFileBatchObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileBatchObjectStatus status,
      @JsonKey(name: 'file_counts')
      VectorStoreFileBatchObjectFileCounts fileCounts});

  @override
  $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> get fileCounts;
}

/// @nodoc
class __$VectorStoreFileBatchObjectCopyWithImpl<$Res>
    implements _$VectorStoreFileBatchObjectCopyWith<$Res> {
  __$VectorStoreFileBatchObjectCopyWithImpl(this._self, this._then);

  final _VectorStoreFileBatchObject _self;
  final $Res Function(_VectorStoreFileBatchObject) _then;

  /// Create a copy of VectorStoreFileBatchObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? fileCounts = null,
  }) {
    return _then(_VectorStoreFileBatchObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _self.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectStatus,
      fileCounts: null == fileCounts
          ? _self.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectFileCounts,
    ));
  }

  /// Create a copy of VectorStoreFileBatchObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> get fileCounts {
    return $VectorStoreFileBatchObjectFileCountsCopyWith<$Res>(_self.fileCounts,
        (value) {
      return _then(_self.copyWith(fileCounts: value));
    });
  }
}

/// @nodoc
mixin _$VectorStoreFileBatchObjectFileCounts {
  /// The number of files that are currently being processed.
  @JsonKey(name: 'in_progress')
  int get inProgress;

  /// The number of files that have been processed.
  int get completed;

  /// The number of files that have failed to process.
  int get failed;

  /// The number of files that where cancelled.
  int get cancelled;

  /// The total number of files.
  int get total;

  /// Create a copy of VectorStoreFileBatchObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $VectorStoreFileBatchObjectFileCountsCopyWith<
          VectorStoreFileBatchObjectFileCounts>
      get copyWith => _$VectorStoreFileBatchObjectFileCountsCopyWithImpl<
              VectorStoreFileBatchObjectFileCounts>(
          this as VectorStoreFileBatchObjectFileCounts, _$identity);

  /// Serializes this VectorStoreFileBatchObjectFileCounts to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is VectorStoreFileBatchObjectFileCounts &&
            (identical(other.inProgress, inProgress) ||
                other.inProgress == inProgress) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed) &&
            (identical(other.cancelled, cancelled) ||
                other.cancelled == cancelled) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, inProgress, completed, failed, cancelled, total);

  @override
  String toString() {
    return 'VectorStoreFileBatchObjectFileCounts(inProgress: $inProgress, completed: $completed, failed: $failed, cancelled: $cancelled, total: $total)';
  }
}

/// @nodoc
abstract mixin class $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> {
  factory $VectorStoreFileBatchObjectFileCountsCopyWith(
          VectorStoreFileBatchObjectFileCounts value,
          $Res Function(VectorStoreFileBatchObjectFileCounts) _then) =
      _$VectorStoreFileBatchObjectFileCountsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class _$VectorStoreFileBatchObjectFileCountsCopyWithImpl<$Res>
    implements $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> {
  _$VectorStoreFileBatchObjectFileCountsCopyWithImpl(this._self, this._then);

  final VectorStoreFileBatchObjectFileCounts _self;
  final $Res Function(VectorStoreFileBatchObjectFileCounts) _then;

  /// Create a copy of VectorStoreFileBatchObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_self.copyWith(
      inProgress: null == inProgress
          ? _self.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _self.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _self.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _self.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [VectorStoreFileBatchObjectFileCounts].
extension VectorStoreFileBatchObjectFileCountsPatterns
    on VectorStoreFileBatchObjectFileCounts {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_VectorStoreFileBatchObjectFileCounts value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObjectFileCounts() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_VectorStoreFileBatchObjectFileCounts value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObjectFileCounts():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_VectorStoreFileBatchObjectFileCounts value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObjectFileCounts() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'in_progress') int inProgress,
            int completed, int failed, int cancelled, int total)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObjectFileCounts() when $default != null:
        return $default(_that.inProgress, _that.completed, _that.failed,
            _that.cancelled, _that.total);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'in_progress') int inProgress,
            int completed, int failed, int cancelled, int total)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObjectFileCounts():
        return $default(_that.inProgress, _that.completed, _that.failed,
            _that.cancelled, _that.total);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'in_progress') int inProgress,
            int completed, int failed, int cancelled, int total)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _VectorStoreFileBatchObjectFileCounts() when $default != null:
        return $default(_that.inProgress, _that.completed, _that.failed,
            _that.cancelled, _that.total);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _VectorStoreFileBatchObjectFileCounts
    extends VectorStoreFileBatchObjectFileCounts {
  const _VectorStoreFileBatchObjectFileCounts(
      {@JsonKey(name: 'in_progress') required this.inProgress,
      required this.completed,
      required this.failed,
      required this.cancelled,
      required this.total})
      : super._();
  factory _VectorStoreFileBatchObjectFileCounts.fromJson(
          Map<String, dynamic> json) =>
      _$VectorStoreFileBatchObjectFileCountsFromJson(json);

  /// The number of files that are currently being processed.
  @override
  @JsonKey(name: 'in_progress')
  final int inProgress;

  /// The number of files that have been processed.
  @override
  final int completed;

  /// The number of files that have failed to process.
  @override
  final int failed;

  /// The number of files that where cancelled.
  @override
  final int cancelled;

  /// The total number of files.
  @override
  final int total;

  /// Create a copy of VectorStoreFileBatchObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$VectorStoreFileBatchObjectFileCountsCopyWith<
          _VectorStoreFileBatchObjectFileCounts>
      get copyWith => __$VectorStoreFileBatchObjectFileCountsCopyWithImpl<
          _VectorStoreFileBatchObjectFileCounts>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$VectorStoreFileBatchObjectFileCountsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _VectorStoreFileBatchObjectFileCounts &&
            (identical(other.inProgress, inProgress) ||
                other.inProgress == inProgress) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed) &&
            (identical(other.cancelled, cancelled) ||
                other.cancelled == cancelled) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, inProgress, completed, failed, cancelled, total);

  @override
  String toString() {
    return 'VectorStoreFileBatchObjectFileCounts(inProgress: $inProgress, completed: $completed, failed: $failed, cancelled: $cancelled, total: $total)';
  }
}

/// @nodoc
abstract mixin class _$VectorStoreFileBatchObjectFileCountsCopyWith<$Res>
    implements $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> {
  factory _$VectorStoreFileBatchObjectFileCountsCopyWith(
          _VectorStoreFileBatchObjectFileCounts value,
          $Res Function(_VectorStoreFileBatchObjectFileCounts) _then) =
      __$VectorStoreFileBatchObjectFileCountsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class __$VectorStoreFileBatchObjectFileCountsCopyWithImpl<$Res>
    implements _$VectorStoreFileBatchObjectFileCountsCopyWith<$Res> {
  __$VectorStoreFileBatchObjectFileCountsCopyWithImpl(this._self, this._then);

  final _VectorStoreFileBatchObjectFileCounts _self;
  final $Res Function(_VectorStoreFileBatchObjectFileCounts) _then;

  /// Create a copy of VectorStoreFileBatchObjectFileCounts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_VectorStoreFileBatchObjectFileCounts(
      inProgress: null == inProgress
          ? _self.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _self.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _self.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _self.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$CreateVectorStoreFileBatchRequest {
  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;

  /// Create a copy of CreateVectorStoreFileBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateVectorStoreFileBatchRequestCopyWith<CreateVectorStoreFileBatchRequest>
      get copyWith => _$CreateVectorStoreFileBatchRequestCopyWithImpl<
              CreateVectorStoreFileBatchRequest>(
          this as CreateVectorStoreFileBatchRequest, _$identity);

  /// Serializes this CreateVectorStoreFileBatchRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateVectorStoreFileBatchRequest &&
            const DeepCollectionEquality().equals(other.fileIds, fileIds) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(fileIds), chunkingStrategy);

  @override
  String toString() {
    return 'CreateVectorStoreFileBatchRequest(fileIds: $fileIds, chunkingStrategy: $chunkingStrategy)';
  }
}

/// @nodoc
abstract mixin class $CreateVectorStoreFileBatchRequestCopyWith<$Res> {
  factory $CreateVectorStoreFileBatchRequestCopyWith(
          CreateVectorStoreFileBatchRequest value,
          $Res Function(CreateVectorStoreFileBatchRequest) _then) =
      _$CreateVectorStoreFileBatchRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$CreateVectorStoreFileBatchRequestCopyWithImpl<$Res>
    implements $CreateVectorStoreFileBatchRequestCopyWith<$Res> {
  _$CreateVectorStoreFileBatchRequestCopyWithImpl(this._self, this._then);

  final CreateVectorStoreFileBatchRequest _self;
  final $Res Function(CreateVectorStoreFileBatchRequest) _then;

  /// Create a copy of CreateVectorStoreFileBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_self.copyWith(
      fileIds: null == fileIds
          ? _self.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ));
  }

  /// Create a copy of CreateVectorStoreFileBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// Adds pattern-matching-related methods to [CreateVectorStoreFileBatchRequest].
extension CreateVectorStoreFileBatchRequestPatterns
    on CreateVectorStoreFileBatchRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateVectorStoreFileBatchRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileBatchRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateVectorStoreFileBatchRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileBatchRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateVectorStoreFileBatchRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileBatchRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_ids') List<String> fileIds,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileBatchRequest() when $default != null:
        return $default(_that.fileIds, _that.chunkingStrategy);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_ids') List<String> fileIds,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileBatchRequest():
        return $default(_that.fileIds, _that.chunkingStrategy);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_ids') List<String> fileIds,
            @JsonKey(name: 'chunking_strategy', includeIfNull: false)
            ChunkingStrategyRequestParam? chunkingStrategy)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateVectorStoreFileBatchRequest() when $default != null:
        return $default(_that.fileIds, _that.chunkingStrategy);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateVectorStoreFileBatchRequest
    extends CreateVectorStoreFileBatchRequest {
  const _CreateVectorStoreFileBatchRequest(
      {@JsonKey(name: 'file_ids') required final List<String> fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy})
      : _fileIds = fileIds,
        super._();
  factory _CreateVectorStoreFileBatchRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreateVectorStoreFileBatchRequestFromJson(json);

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  final List<String> _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  /// Create a copy of CreateVectorStoreFileBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateVectorStoreFileBatchRequestCopyWith<
          _CreateVectorStoreFileBatchRequest>
      get copyWith => __$CreateVectorStoreFileBatchRequestCopyWithImpl<
          _CreateVectorStoreFileBatchRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateVectorStoreFileBatchRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateVectorStoreFileBatchRequest &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_fileIds), chunkingStrategy);

  @override
  String toString() {
    return 'CreateVectorStoreFileBatchRequest(fileIds: $fileIds, chunkingStrategy: $chunkingStrategy)';
  }
}

/// @nodoc
abstract mixin class _$CreateVectorStoreFileBatchRequestCopyWith<$Res>
    implements $CreateVectorStoreFileBatchRequestCopyWith<$Res> {
  factory _$CreateVectorStoreFileBatchRequestCopyWith(
          _CreateVectorStoreFileBatchRequest value,
          $Res Function(_CreateVectorStoreFileBatchRequest) _then) =
      __$CreateVectorStoreFileBatchRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$CreateVectorStoreFileBatchRequestCopyWithImpl<$Res>
    implements _$CreateVectorStoreFileBatchRequestCopyWith<$Res> {
  __$CreateVectorStoreFileBatchRequestCopyWithImpl(this._self, this._then);

  final _CreateVectorStoreFileBatchRequest _self;
  final $Res Function(_CreateVectorStoreFileBatchRequest) _then;

  /// Create a copy of CreateVectorStoreFileBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileIds = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_CreateVectorStoreFileBatchRequest(
      fileIds: null == fileIds
          ? _self._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      chunkingStrategy: freezed == chunkingStrategy
          ? _self.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ));
  }

  /// Create a copy of CreateVectorStoreFileBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_self.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_self.chunkingStrategy!,
        (value) {
      return _then(_self.copyWith(chunkingStrategy: value));
    });
  }
}

/// @nodoc
mixin _$Error {
  /// The error code.
  String? get code;

  /// A human-readable description of the error.
  String get message;

  /// The parameter in the request that caused the error.
  String? get param;

  /// The type of error.
  String get type;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErrorCopyWith<Error> get copyWith =>
      _$ErrorCopyWithImpl<Error>(this as Error, _$identity);

  /// Serializes this Error to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Error &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param, type);

  @override
  String toString() {
    return 'Error(code: $code, message: $message, param: $param, type: $type)';
  }
}

/// @nodoc
abstract mixin class $ErrorCopyWith<$Res> {
  factory $ErrorCopyWith(Error value, $Res Function(Error) _then) =
      _$ErrorCopyWithImpl;
  @useResult
  $Res call({String? code, String message, String? param, String type});
}

/// @nodoc
class _$ErrorCopyWithImpl<$Res> implements $ErrorCopyWith<$Res> {
  _$ErrorCopyWithImpl(this._self, this._then);

  final Error _self;
  final $Res Function(Error) _then;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = null,
    Object? param = freezed,
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _self.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [Error].
extension ErrorPatterns on Error {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Error value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Error() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Error value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Error():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Error value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Error() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String? code, String message, String? param, String type)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Error() when $default != null:
        return $default(_that.code, _that.message, _that.param, _that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String? code, String message, String? param, String type)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Error():
        return $default(_that.code, _that.message, _that.param, _that.type);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String? code, String message, String? param, String type)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Error() when $default != null:
        return $default(_that.code, _that.message, _that.param, _that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _Error extends Error {
  const _Error(
      {required this.code,
      required this.message,
      required this.param,
      required this.type})
      : super._();
  factory _Error.fromJson(Map<String, dynamic> json) => _$ErrorFromJson(json);

  /// The error code.
  @override
  final String? code;

  /// A human-readable description of the error.
  @override
  final String message;

  /// The parameter in the request that caused the error.
  @override
  final String? param;

  /// The type of error.
  @override
  final String type;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ErrorCopyWith<_Error> get copyWith =>
      __$ErrorCopyWithImpl<_Error>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ErrorToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Error &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param, type);

  @override
  String toString() {
    return 'Error(code: $code, message: $message, param: $param, type: $type)';
  }
}

/// @nodoc
abstract mixin class _$ErrorCopyWith<$Res> implements $ErrorCopyWith<$Res> {
  factory _$ErrorCopyWith(_Error value, $Res Function(_Error) _then) =
      __$ErrorCopyWithImpl;
  @override
  @useResult
  $Res call({String? code, String message, String? param, String type});
}

/// @nodoc
class __$ErrorCopyWithImpl<$Res> implements _$ErrorCopyWith<$Res> {
  __$ErrorCopyWithImpl(this._self, this._then);

  final _Error _self;
  final $Res Function(_Error) _then;

  /// Create a copy of Error
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = freezed,
    Object? message = null,
    Object? param = freezed,
    Object? type = null,
  }) {
    return _then(_Error(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: null == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _self.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$CreateBatchRequest {
  /// The ID of an uploaded file that contains requests for the new batch.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your input file must be formatted as a [JSONL file](https://platform.openai.com/docs/api-reference/batch/request-input),
  /// and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size.
  @JsonKey(name: 'input_file_id')
  String get inputFileId;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  BatchEndpoint get endpoint;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @JsonKey(name: 'completion_window')
  BatchCompletionWindow get completionWindow;

  /// Optional custom metadata for the batch.
  @JsonKey(includeIfNull: false)
  Map<String, String>? get metadata;

  /// Create a copy of CreateBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $CreateBatchRequestCopyWith<CreateBatchRequest> get copyWith =>
      _$CreateBatchRequestCopyWithImpl<CreateBatchRequest>(
          this as CreateBatchRequest, _$identity);

  /// Serializes this CreateBatchRequest to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateBatchRequest &&
            (identical(other.inputFileId, inputFileId) ||
                other.inputFileId == inputFileId) &&
            (identical(other.endpoint, endpoint) ||
                other.endpoint == endpoint) &&
            (identical(other.completionWindow, completionWindow) ||
                other.completionWindow == completionWindow) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, inputFileId, endpoint,
      completionWindow, const DeepCollectionEquality().hash(metadata));

  @override
  String toString() {
    return 'CreateBatchRequest(inputFileId: $inputFileId, endpoint: $endpoint, completionWindow: $completionWindow, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $CreateBatchRequestCopyWith<$Res> {
  factory $CreateBatchRequestCopyWith(
          CreateBatchRequest value, $Res Function(CreateBatchRequest) _then) =
      _$CreateBatchRequestCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'input_file_id') String inputFileId,
      BatchEndpoint endpoint,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      @JsonKey(includeIfNull: false) Map<String, String>? metadata});
}

/// @nodoc
class _$CreateBatchRequestCopyWithImpl<$Res>
    implements $CreateBatchRequestCopyWith<$Res> {
  _$CreateBatchRequestCopyWithImpl(this._self, this._then);

  final CreateBatchRequest _self;
  final $Res Function(CreateBatchRequest) _then;

  /// Create a copy of CreateBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inputFileId = null,
    Object? endpoint = null,
    Object? completionWindow = null,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      inputFileId: null == inputFileId
          ? _self.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      endpoint: null == endpoint
          ? _self.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      completionWindow: null == completionWindow
          ? _self.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [CreateBatchRequest].
extension CreateBatchRequestPatterns on CreateBatchRequest {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CreateBatchRequest value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateBatchRequest() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CreateBatchRequest value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateBatchRequest():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CreateBatchRequest value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateBatchRequest() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'input_file_id') String inputFileId,
            BatchEndpoint endpoint,
            @JsonKey(name: 'completion_window')
            BatchCompletionWindow completionWindow,
            @JsonKey(includeIfNull: false) Map<String, String>? metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _CreateBatchRequest() when $default != null:
        return $default(_that.inputFileId, _that.endpoint,
            _that.completionWindow, _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'input_file_id') String inputFileId,
            BatchEndpoint endpoint,
            @JsonKey(name: 'completion_window')
            BatchCompletionWindow completionWindow,
            @JsonKey(includeIfNull: false) Map<String, String>? metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateBatchRequest():
        return $default(_that.inputFileId, _that.endpoint,
            _that.completionWindow, _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'input_file_id') String inputFileId,
            BatchEndpoint endpoint,
            @JsonKey(name: 'completion_window')
            BatchCompletionWindow completionWindow,
            @JsonKey(includeIfNull: false) Map<String, String>? metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _CreateBatchRequest() when $default != null:
        return $default(_that.inputFileId, _that.endpoint,
            _that.completionWindow, _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _CreateBatchRequest extends CreateBatchRequest {
  const _CreateBatchRequest(
      {@JsonKey(name: 'input_file_id') required this.inputFileId,
      required this.endpoint,
      @JsonKey(name: 'completion_window') required this.completionWindow,
      @JsonKey(includeIfNull: false) final Map<String, String>? metadata})
      : _metadata = metadata,
        super._();
  factory _CreateBatchRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateBatchRequestFromJson(json);

  /// The ID of an uploaded file that contains requests for the new batch.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your input file must be formatted as a [JSONL file](https://platform.openai.com/docs/api-reference/batch/request-input),
  /// and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size.
  @override
  @JsonKey(name: 'input_file_id')
  final String inputFileId;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  @override
  final BatchEndpoint endpoint;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @override
  @JsonKey(name: 'completion_window')
  final BatchCompletionWindow completionWindow;

  /// Optional custom metadata for the batch.
  final Map<String, String>? _metadata;

  /// Optional custom metadata for the batch.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, String>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Create a copy of CreateBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$CreateBatchRequestCopyWith<_CreateBatchRequest> get copyWith =>
      __$CreateBatchRequestCopyWithImpl<_CreateBatchRequest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$CreateBatchRequestToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreateBatchRequest &&
            (identical(other.inputFileId, inputFileId) ||
                other.inputFileId == inputFileId) &&
            (identical(other.endpoint, endpoint) ||
                other.endpoint == endpoint) &&
            (identical(other.completionWindow, completionWindow) ||
                other.completionWindow == completionWindow) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, inputFileId, endpoint,
      completionWindow, const DeepCollectionEquality().hash(_metadata));

  @override
  String toString() {
    return 'CreateBatchRequest(inputFileId: $inputFileId, endpoint: $endpoint, completionWindow: $completionWindow, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$CreateBatchRequestCopyWith<$Res>
    implements $CreateBatchRequestCopyWith<$Res> {
  factory _$CreateBatchRequestCopyWith(
          _CreateBatchRequest value, $Res Function(_CreateBatchRequest) _then) =
      __$CreateBatchRequestCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'input_file_id') String inputFileId,
      BatchEndpoint endpoint,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      @JsonKey(includeIfNull: false) Map<String, String>? metadata});
}

/// @nodoc
class __$CreateBatchRequestCopyWithImpl<$Res>
    implements _$CreateBatchRequestCopyWith<$Res> {
  __$CreateBatchRequestCopyWithImpl(this._self, this._then);

  final _CreateBatchRequest _self;
  final $Res Function(_CreateBatchRequest) _then;

  /// Create a copy of CreateBatchRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? inputFileId = null,
    Object? endpoint = null,
    Object? completionWindow = null,
    Object? metadata = freezed,
  }) {
    return _then(_CreateBatchRequest(
      inputFileId: null == inputFileId
          ? _self.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      endpoint: null == endpoint
          ? _self.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      completionWindow: null == completionWindow
          ? _self.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      metadata: freezed == metadata
          ? _self._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
mixin _$Batch {
  /// No Description
  String get id;

  /// The object type, which is always `batch`.
  BatchObject get object;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  BatchEndpoint get endpoint;

  /// No Description
  @JsonKey(includeIfNull: false)
  BatchErrors? get errors;

  /// The ID of the input file for the batch.
  @JsonKey(name: 'input_file_id')
  String get inputFileId;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @JsonKey(name: 'completion_window')
  BatchCompletionWindow get completionWindow;

  /// The current status of the batch.
  BatchStatus get status;

  /// The ID of the file containing the outputs of successfully executed requests.
  @JsonKey(name: 'output_file_id', includeIfNull: false)
  String? get outputFileId;

  /// The ID of the file containing the outputs of requests with errors.
  @JsonKey(name: 'error_file_id', includeIfNull: false)
  String? get errorFileId;

  /// The Unix timestamp (in seconds) for when the batch was created.
  @JsonKey(name: 'created_at')
  int get createdAt;

  /// The Unix timestamp (in seconds) for when the batch started processing.
  @JsonKey(name: 'in_progress_at', includeIfNull: false)
  int? get inProgressAt;

  /// The Unix timestamp (in seconds) for when the batch will expire.
  @JsonKey(name: 'expires_at', includeIfNull: false)
  int? get expiresAt;

  /// The Unix timestamp (in seconds) for when the batch started finalizing.
  @JsonKey(name: 'finalizing_at', includeIfNull: false)
  int? get finalizingAt;

  /// The Unix timestamp (in seconds) for when the batch was completed.
  @JsonKey(name: 'completed_at', includeIfNull: false)
  int? get completedAt;

  /// The Unix timestamp (in seconds) for when the batch failed.
  @JsonKey(name: 'failed_at', includeIfNull: false)
  int? get failedAt;

  /// The Unix timestamp (in seconds) for when the batch expired.
  @JsonKey(name: 'expired_at', includeIfNull: false)
  int? get expiredAt;

  /// The Unix timestamp (in seconds) for when the batch started cancelling.
  @JsonKey(name: 'cancelling_at', includeIfNull: false)
  int? get cancellingAt;

  /// The Unix timestamp (in seconds) for when the batch was cancelled.
  @JsonKey(name: 'cancelled_at', includeIfNull: false)
  int? get cancelledAt;

  /// The request counts for different statuses within the batch.
  @JsonKey(name: 'request_counts', includeIfNull: false)
  BatchRequestCounts? get requestCounts;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BatchCopyWith<Batch> get copyWith =>
      _$BatchCopyWithImpl<Batch>(this as Batch, _$identity);

  /// Serializes this Batch to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Batch &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.endpoint, endpoint) ||
                other.endpoint == endpoint) &&
            (identical(other.errors, errors) || other.errors == errors) &&
            (identical(other.inputFileId, inputFileId) ||
                other.inputFileId == inputFileId) &&
            (identical(other.completionWindow, completionWindow) ||
                other.completionWindow == completionWindow) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.outputFileId, outputFileId) ||
                other.outputFileId == outputFileId) &&
            (identical(other.errorFileId, errorFileId) ||
                other.errorFileId == errorFileId) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.inProgressAt, inProgressAt) ||
                other.inProgressAt == inProgressAt) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.finalizingAt, finalizingAt) ||
                other.finalizingAt == finalizingAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.expiredAt, expiredAt) ||
                other.expiredAt == expiredAt) &&
            (identical(other.cancellingAt, cancellingAt) ||
                other.cancellingAt == cancellingAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.requestCounts, requestCounts) ||
                other.requestCounts == requestCounts) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        endpoint,
        errors,
        inputFileId,
        completionWindow,
        status,
        outputFileId,
        errorFileId,
        createdAt,
        inProgressAt,
        expiresAt,
        finalizingAt,
        completedAt,
        failedAt,
        expiredAt,
        cancellingAt,
        cancelledAt,
        requestCounts,
        const DeepCollectionEquality().hash(metadata)
      ]);

  @override
  String toString() {
    return 'Batch(id: $id, object: $object, endpoint: $endpoint, errors: $errors, inputFileId: $inputFileId, completionWindow: $completionWindow, status: $status, outputFileId: $outputFileId, errorFileId: $errorFileId, createdAt: $createdAt, inProgressAt: $inProgressAt, expiresAt: $expiresAt, finalizingAt: $finalizingAt, completedAt: $completedAt, failedAt: $failedAt, expiredAt: $expiredAt, cancellingAt: $cancellingAt, cancelledAt: $cancelledAt, requestCounts: $requestCounts, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class $BatchCopyWith<$Res> {
  factory $BatchCopyWith(Batch value, $Res Function(Batch) _then) =
      _$BatchCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      BatchObject object,
      BatchEndpoint endpoint,
      @JsonKey(includeIfNull: false) BatchErrors? errors,
      @JsonKey(name: 'input_file_id') String inputFileId,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      BatchStatus status,
      @JsonKey(name: 'output_file_id', includeIfNull: false)
      String? outputFileId,
      @JsonKey(name: 'error_file_id', includeIfNull: false) String? errorFileId,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'in_progress_at', includeIfNull: false) int? inProgressAt,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'finalizing_at', includeIfNull: false) int? finalizingAt,
      @JsonKey(name: 'completed_at', includeIfNull: false) int? completedAt,
      @JsonKey(name: 'failed_at', includeIfNull: false) int? failedAt,
      @JsonKey(name: 'expired_at', includeIfNull: false) int? expiredAt,
      @JsonKey(name: 'cancelling_at', includeIfNull: false) int? cancellingAt,
      @JsonKey(name: 'cancelled_at', includeIfNull: false) int? cancelledAt,
      @JsonKey(name: 'request_counts', includeIfNull: false)
      BatchRequestCounts? requestCounts,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $BatchErrorsCopyWith<$Res>? get errors;
  $BatchRequestCountsCopyWith<$Res>? get requestCounts;
}

/// @nodoc
class _$BatchCopyWithImpl<$Res> implements $BatchCopyWith<$Res> {
  _$BatchCopyWithImpl(this._self, this._then);

  final Batch _self;
  final $Res Function(Batch) _then;

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? endpoint = null,
    Object? errors = freezed,
    Object? inputFileId = null,
    Object? completionWindow = null,
    Object? status = null,
    Object? outputFileId = freezed,
    Object? errorFileId = freezed,
    Object? createdAt = null,
    Object? inProgressAt = freezed,
    Object? expiresAt = freezed,
    Object? finalizingAt = freezed,
    Object? completedAt = freezed,
    Object? failedAt = freezed,
    Object? expiredAt = freezed,
    Object? cancellingAt = freezed,
    Object? cancelledAt = freezed,
    Object? requestCounts = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as BatchObject,
      endpoint: null == endpoint
          ? _self.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      errors: freezed == errors
          ? _self.errors
          : errors // ignore: cast_nullable_to_non_nullable
              as BatchErrors?,
      inputFileId: null == inputFileId
          ? _self.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      completionWindow: null == completionWindow
          ? _self.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as BatchStatus,
      outputFileId: freezed == outputFileId
          ? _self.outputFileId
          : outputFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      errorFileId: freezed == errorFileId
          ? _self.errorFileId
          : errorFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      inProgressAt: freezed == inProgressAt
          ? _self.inProgressAt
          : inProgressAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      finalizingAt: freezed == finalizingAt
          ? _self.finalizingAt
          : finalizingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _self.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiredAt: freezed == expiredAt
          ? _self.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellingAt: freezed == cancellingAt
          ? _self.cancellingAt
          : cancellingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _self.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      requestCounts: freezed == requestCounts
          ? _self.requestCounts
          : requestCounts // ignore: cast_nullable_to_non_nullable
              as BatchRequestCounts?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BatchErrorsCopyWith<$Res>? get errors {
    if (_self.errors == null) {
      return null;
    }

    return $BatchErrorsCopyWith<$Res>(_self.errors!, (value) {
      return _then(_self.copyWith(errors: value));
    });
  }

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BatchRequestCountsCopyWith<$Res>? get requestCounts {
    if (_self.requestCounts == null) {
      return null;
    }

    return $BatchRequestCountsCopyWith<$Res>(_self.requestCounts!, (value) {
      return _then(_self.copyWith(requestCounts: value));
    });
  }
}

/// Adds pattern-matching-related methods to [Batch].
extension BatchPatterns on Batch {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Batch value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Batch() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Batch value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Batch():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Batch value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Batch() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String id,
            BatchObject object,
            BatchEndpoint endpoint,
            @JsonKey(includeIfNull: false) BatchErrors? errors,
            @JsonKey(name: 'input_file_id') String inputFileId,
            @JsonKey(name: 'completion_window')
            BatchCompletionWindow completionWindow,
            BatchStatus status,
            @JsonKey(name: 'output_file_id', includeIfNull: false)
            String? outputFileId,
            @JsonKey(name: 'error_file_id', includeIfNull: false)
            String? errorFileId,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'in_progress_at', includeIfNull: false)
            int? inProgressAt,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(name: 'finalizing_at', includeIfNull: false)
            int? finalizingAt,
            @JsonKey(name: 'completed_at', includeIfNull: false)
            int? completedAt,
            @JsonKey(name: 'failed_at', includeIfNull: false) int? failedAt,
            @JsonKey(name: 'expired_at', includeIfNull: false) int? expiredAt,
            @JsonKey(name: 'cancelling_at', includeIfNull: false)
            int? cancellingAt,
            @JsonKey(name: 'cancelled_at', includeIfNull: false)
            int? cancelledAt,
            @JsonKey(name: 'request_counts', includeIfNull: false)
            BatchRequestCounts? requestCounts,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _Batch() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.endpoint,
            _that.errors,
            _that.inputFileId,
            _that.completionWindow,
            _that.status,
            _that.outputFileId,
            _that.errorFileId,
            _that.createdAt,
            _that.inProgressAt,
            _that.expiresAt,
            _that.finalizingAt,
            _that.completedAt,
            _that.failedAt,
            _that.expiredAt,
            _that.cancellingAt,
            _that.cancelledAt,
            _that.requestCounts,
            _that.metadata);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String id,
            BatchObject object,
            BatchEndpoint endpoint,
            @JsonKey(includeIfNull: false) BatchErrors? errors,
            @JsonKey(name: 'input_file_id') String inputFileId,
            @JsonKey(name: 'completion_window')
            BatchCompletionWindow completionWindow,
            BatchStatus status,
            @JsonKey(name: 'output_file_id', includeIfNull: false)
            String? outputFileId,
            @JsonKey(name: 'error_file_id', includeIfNull: false)
            String? errorFileId,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'in_progress_at', includeIfNull: false)
            int? inProgressAt,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(name: 'finalizing_at', includeIfNull: false)
            int? finalizingAt,
            @JsonKey(name: 'completed_at', includeIfNull: false)
            int? completedAt,
            @JsonKey(name: 'failed_at', includeIfNull: false) int? failedAt,
            @JsonKey(name: 'expired_at', includeIfNull: false) int? expiredAt,
            @JsonKey(name: 'cancelling_at', includeIfNull: false)
            int? cancellingAt,
            @JsonKey(name: 'cancelled_at', includeIfNull: false)
            int? cancelledAt,
            @JsonKey(name: 'request_counts', includeIfNull: false)
            BatchRequestCounts? requestCounts,
            @JsonKey(includeIfNull: false) dynamic metadata)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Batch():
        return $default(
            _that.id,
            _that.object,
            _that.endpoint,
            _that.errors,
            _that.inputFileId,
            _that.completionWindow,
            _that.status,
            _that.outputFileId,
            _that.errorFileId,
            _that.createdAt,
            _that.inProgressAt,
            _that.expiresAt,
            _that.finalizingAt,
            _that.completedAt,
            _that.failedAt,
            _that.expiredAt,
            _that.cancellingAt,
            _that.cancelledAt,
            _that.requestCounts,
            _that.metadata);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String id,
            BatchObject object,
            BatchEndpoint endpoint,
            @JsonKey(includeIfNull: false) BatchErrors? errors,
            @JsonKey(name: 'input_file_id') String inputFileId,
            @JsonKey(name: 'completion_window')
            BatchCompletionWindow completionWindow,
            BatchStatus status,
            @JsonKey(name: 'output_file_id', includeIfNull: false)
            String? outputFileId,
            @JsonKey(name: 'error_file_id', includeIfNull: false)
            String? errorFileId,
            @JsonKey(name: 'created_at') int createdAt,
            @JsonKey(name: 'in_progress_at', includeIfNull: false)
            int? inProgressAt,
            @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
            @JsonKey(name: 'finalizing_at', includeIfNull: false)
            int? finalizingAt,
            @JsonKey(name: 'completed_at', includeIfNull: false)
            int? completedAt,
            @JsonKey(name: 'failed_at', includeIfNull: false) int? failedAt,
            @JsonKey(name: 'expired_at', includeIfNull: false) int? expiredAt,
            @JsonKey(name: 'cancelling_at', includeIfNull: false)
            int? cancellingAt,
            @JsonKey(name: 'cancelled_at', includeIfNull: false)
            int? cancelledAt,
            @JsonKey(name: 'request_counts', includeIfNull: false)
            BatchRequestCounts? requestCounts,
            @JsonKey(includeIfNull: false) dynamic metadata)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _Batch() when $default != null:
        return $default(
            _that.id,
            _that.object,
            _that.endpoint,
            _that.errors,
            _that.inputFileId,
            _that.completionWindow,
            _that.status,
            _that.outputFileId,
            _that.errorFileId,
            _that.createdAt,
            _that.inProgressAt,
            _that.expiresAt,
            _that.finalizingAt,
            _that.completedAt,
            _that.failedAt,
            _that.expiredAt,
            _that.cancellingAt,
            _that.cancelledAt,
            _that.requestCounts,
            _that.metadata);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _Batch extends Batch {
  const _Batch(
      {required this.id,
      required this.object,
      required this.endpoint,
      @JsonKey(includeIfNull: false) this.errors,
      @JsonKey(name: 'input_file_id') required this.inputFileId,
      @JsonKey(name: 'completion_window') required this.completionWindow,
      required this.status,
      @JsonKey(name: 'output_file_id', includeIfNull: false) this.outputFileId,
      @JsonKey(name: 'error_file_id', includeIfNull: false) this.errorFileId,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'in_progress_at', includeIfNull: false) this.inProgressAt,
      @JsonKey(name: 'expires_at', includeIfNull: false) this.expiresAt,
      @JsonKey(name: 'finalizing_at', includeIfNull: false) this.finalizingAt,
      @JsonKey(name: 'completed_at', includeIfNull: false) this.completedAt,
      @JsonKey(name: 'failed_at', includeIfNull: false) this.failedAt,
      @JsonKey(name: 'expired_at', includeIfNull: false) this.expiredAt,
      @JsonKey(name: 'cancelling_at', includeIfNull: false) this.cancellingAt,
      @JsonKey(name: 'cancelled_at', includeIfNull: false) this.cancelledAt,
      @JsonKey(name: 'request_counts', includeIfNull: false) this.requestCounts,
      @JsonKey(includeIfNull: false) this.metadata})
      : super._();
  factory _Batch.fromJson(Map<String, dynamic> json) => _$BatchFromJson(json);

  /// No Description
  @override
  final String id;

  /// The object type, which is always `batch`.
  @override
  final BatchObject object;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  @override
  final BatchEndpoint endpoint;

  /// No Description
  @override
  @JsonKey(includeIfNull: false)
  final BatchErrors? errors;

  /// The ID of the input file for the batch.
  @override
  @JsonKey(name: 'input_file_id')
  final String inputFileId;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @override
  @JsonKey(name: 'completion_window')
  final BatchCompletionWindow completionWindow;

  /// The current status of the batch.
  @override
  final BatchStatus status;

  /// The ID of the file containing the outputs of successfully executed requests.
  @override
  @JsonKey(name: 'output_file_id', includeIfNull: false)
  final String? outputFileId;

  /// The ID of the file containing the outputs of requests with errors.
  @override
  @JsonKey(name: 'error_file_id', includeIfNull: false)
  final String? errorFileId;

  /// The Unix timestamp (in seconds) for when the batch was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The Unix timestamp (in seconds) for when the batch started processing.
  @override
  @JsonKey(name: 'in_progress_at', includeIfNull: false)
  final int? inProgressAt;

  /// The Unix timestamp (in seconds) for when the batch will expire.
  @override
  @JsonKey(name: 'expires_at', includeIfNull: false)
  final int? expiresAt;

  /// The Unix timestamp (in seconds) for when the batch started finalizing.
  @override
  @JsonKey(name: 'finalizing_at', includeIfNull: false)
  final int? finalizingAt;

  /// The Unix timestamp (in seconds) for when the batch was completed.
  @override
  @JsonKey(name: 'completed_at', includeIfNull: false)
  final int? completedAt;

  /// The Unix timestamp (in seconds) for when the batch failed.
  @override
  @JsonKey(name: 'failed_at', includeIfNull: false)
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the batch expired.
  @override
  @JsonKey(name: 'expired_at', includeIfNull: false)
  final int? expiredAt;

  /// The Unix timestamp (in seconds) for when the batch started cancelling.
  @override
  @JsonKey(name: 'cancelling_at', includeIfNull: false)
  final int? cancellingAt;

  /// The Unix timestamp (in seconds) for when the batch was cancelled.
  @override
  @JsonKey(name: 'cancelled_at', includeIfNull: false)
  final int? cancelledAt;

  /// The request counts for different statuses within the batch.
  @override
  @JsonKey(name: 'request_counts', includeIfNull: false)
  final BatchRequestCounts? requestCounts;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
  /// information about the object in a structured format. Keys can be a maximum of 64 characters long and values
  /// can be a maximum of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BatchCopyWith<_Batch> get copyWith =>
      __$BatchCopyWithImpl<_Batch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BatchToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Batch &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.endpoint, endpoint) ||
                other.endpoint == endpoint) &&
            (identical(other.errors, errors) || other.errors == errors) &&
            (identical(other.inputFileId, inputFileId) ||
                other.inputFileId == inputFileId) &&
            (identical(other.completionWindow, completionWindow) ||
                other.completionWindow == completionWindow) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.outputFileId, outputFileId) ||
                other.outputFileId == outputFileId) &&
            (identical(other.errorFileId, errorFileId) ||
                other.errorFileId == errorFileId) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.inProgressAt, inProgressAt) ||
                other.inProgressAt == inProgressAt) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.finalizingAt, finalizingAt) ||
                other.finalizingAt == finalizingAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.expiredAt, expiredAt) ||
                other.expiredAt == expiredAt) &&
            (identical(other.cancellingAt, cancellingAt) ||
                other.cancellingAt == cancellingAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.requestCounts, requestCounts) ||
                other.requestCounts == requestCounts) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        endpoint,
        errors,
        inputFileId,
        completionWindow,
        status,
        outputFileId,
        errorFileId,
        createdAt,
        inProgressAt,
        expiresAt,
        finalizingAt,
        completedAt,
        failedAt,
        expiredAt,
        cancellingAt,
        cancelledAt,
        requestCounts,
        const DeepCollectionEquality().hash(metadata)
      ]);

  @override
  String toString() {
    return 'Batch(id: $id, object: $object, endpoint: $endpoint, errors: $errors, inputFileId: $inputFileId, completionWindow: $completionWindow, status: $status, outputFileId: $outputFileId, errorFileId: $errorFileId, createdAt: $createdAt, inProgressAt: $inProgressAt, expiresAt: $expiresAt, finalizingAt: $finalizingAt, completedAt: $completedAt, failedAt: $failedAt, expiredAt: $expiredAt, cancellingAt: $cancellingAt, cancelledAt: $cancelledAt, requestCounts: $requestCounts, metadata: $metadata)';
  }
}

/// @nodoc
abstract mixin class _$BatchCopyWith<$Res> implements $BatchCopyWith<$Res> {
  factory _$BatchCopyWith(_Batch value, $Res Function(_Batch) _then) =
      __$BatchCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      BatchObject object,
      BatchEndpoint endpoint,
      @JsonKey(includeIfNull: false) BatchErrors? errors,
      @JsonKey(name: 'input_file_id') String inputFileId,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      BatchStatus status,
      @JsonKey(name: 'output_file_id', includeIfNull: false)
      String? outputFileId,
      @JsonKey(name: 'error_file_id', includeIfNull: false) String? errorFileId,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'in_progress_at', includeIfNull: false) int? inProgressAt,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'finalizing_at', includeIfNull: false) int? finalizingAt,
      @JsonKey(name: 'completed_at', includeIfNull: false) int? completedAt,
      @JsonKey(name: 'failed_at', includeIfNull: false) int? failedAt,
      @JsonKey(name: 'expired_at', includeIfNull: false) int? expiredAt,
      @JsonKey(name: 'cancelling_at', includeIfNull: false) int? cancellingAt,
      @JsonKey(name: 'cancelled_at', includeIfNull: false) int? cancelledAt,
      @JsonKey(name: 'request_counts', includeIfNull: false)
      BatchRequestCounts? requestCounts,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $BatchErrorsCopyWith<$Res>? get errors;
  @override
  $BatchRequestCountsCopyWith<$Res>? get requestCounts;
}

/// @nodoc
class __$BatchCopyWithImpl<$Res> implements _$BatchCopyWith<$Res> {
  __$BatchCopyWithImpl(this._self, this._then);

  final _Batch _self;
  final $Res Function(_Batch) _then;

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? endpoint = null,
    Object? errors = freezed,
    Object? inputFileId = null,
    Object? completionWindow = null,
    Object? status = null,
    Object? outputFileId = freezed,
    Object? errorFileId = freezed,
    Object? createdAt = null,
    Object? inProgressAt = freezed,
    Object? expiresAt = freezed,
    Object? finalizingAt = freezed,
    Object? completedAt = freezed,
    Object? failedAt = freezed,
    Object? expiredAt = freezed,
    Object? cancellingAt = freezed,
    Object? cancelledAt = freezed,
    Object? requestCounts = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_Batch(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as BatchObject,
      endpoint: null == endpoint
          ? _self.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      errors: freezed == errors
          ? _self.errors
          : errors // ignore: cast_nullable_to_non_nullable
              as BatchErrors?,
      inputFileId: null == inputFileId
          ? _self.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      completionWindow: null == completionWindow
          ? _self.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      status: null == status
          ? _self.status
          : status // ignore: cast_nullable_to_non_nullable
              as BatchStatus,
      outputFileId: freezed == outputFileId
          ? _self.outputFileId
          : outputFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      errorFileId: freezed == errorFileId
          ? _self.errorFileId
          : errorFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      inProgressAt: freezed == inProgressAt
          ? _self.inProgressAt
          : inProgressAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiresAt: freezed == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      finalizingAt: freezed == finalizingAt
          ? _self.finalizingAt
          : finalizingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _self.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _self.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiredAt: freezed == expiredAt
          ? _self.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellingAt: freezed == cancellingAt
          ? _self.cancellingAt
          : cancellingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _self.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      requestCounts: freezed == requestCounts
          ? _self.requestCounts
          : requestCounts // ignore: cast_nullable_to_non_nullable
              as BatchRequestCounts?,
      metadata: freezed == metadata
          ? _self.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BatchErrorsCopyWith<$Res>? get errors {
    if (_self.errors == null) {
      return null;
    }

    return $BatchErrorsCopyWith<$Res>(_self.errors!, (value) {
      return _then(_self.copyWith(errors: value));
    });
  }

  /// Create a copy of Batch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BatchRequestCountsCopyWith<$Res>? get requestCounts {
    if (_self.requestCounts == null) {
      return null;
    }

    return $BatchRequestCountsCopyWith<$Res>(_self.requestCounts!, (value) {
      return _then(_self.copyWith(requestCounts: value));
    });
  }
}

/// @nodoc
mixin _$BatchErrors {
  /// The object type, which is always `list`.
  @JsonKey(includeIfNull: false)
  String? get object;

  /// No Description
  @JsonKey(includeIfNull: false)
  List<BatchErrorsDataInner>? get data;

  /// Create a copy of BatchErrors
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BatchErrorsCopyWith<BatchErrors> get copyWith =>
      _$BatchErrorsCopyWithImpl<BatchErrors>(this as BatchErrors, _$identity);

  /// Serializes this BatchErrors to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BatchErrors &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'BatchErrors(object: $object, data: $data)';
  }
}

/// @nodoc
abstract mixin class $BatchErrorsCopyWith<$Res> {
  factory $BatchErrorsCopyWith(
          BatchErrors value, $Res Function(BatchErrors) _then) =
      _$BatchErrorsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) List<BatchErrorsDataInner>? data});
}

/// @nodoc
class _$BatchErrorsCopyWithImpl<$Res> implements $BatchErrorsCopyWith<$Res> {
  _$BatchErrorsCopyWithImpl(this._self, this._then);

  final BatchErrors _self;
  final $Res Function(BatchErrors) _then;

  /// Create a copy of BatchErrors
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = freezed,
    Object? data = freezed,
  }) {
    return _then(_self.copyWith(
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<BatchErrorsDataInner>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [BatchErrors].
extension BatchErrorsPatterns on BatchErrors {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BatchErrors value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BatchErrors() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BatchErrors value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrors():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BatchErrors value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrors() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(includeIfNull: false) String? object,
            @JsonKey(includeIfNull: false) List<BatchErrorsDataInner>? data)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BatchErrors() when $default != null:
        return $default(_that.object, _that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(includeIfNull: false) String? object,
            @JsonKey(includeIfNull: false) List<BatchErrorsDataInner>? data)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrors():
        return $default(_that.object, _that.data);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(includeIfNull: false) String? object,
            @JsonKey(includeIfNull: false) List<BatchErrorsDataInner>? data)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrors() when $default != null:
        return $default(_that.object, _that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BatchErrors extends BatchErrors {
  const _BatchErrors(
      {@JsonKey(includeIfNull: false) this.object,
      @JsonKey(includeIfNull: false) final List<BatchErrorsDataInner>? data})
      : _data = data,
        super._();
  factory _BatchErrors.fromJson(Map<String, dynamic> json) =>
      _$BatchErrorsFromJson(json);

  /// The object type, which is always `list`.
  @override
  @JsonKey(includeIfNull: false)
  final String? object;

  /// No Description
  final List<BatchErrorsDataInner>? _data;

  /// No Description
  @override
  @JsonKey(includeIfNull: false)
  List<BatchErrorsDataInner>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of BatchErrors
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BatchErrorsCopyWith<_BatchErrors> get copyWith =>
      __$BatchErrorsCopyWithImpl<_BatchErrors>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BatchErrorsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BatchErrors &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'BatchErrors(object: $object, data: $data)';
  }
}

/// @nodoc
abstract mixin class _$BatchErrorsCopyWith<$Res>
    implements $BatchErrorsCopyWith<$Res> {
  factory _$BatchErrorsCopyWith(
          _BatchErrors value, $Res Function(_BatchErrors) _then) =
      __$BatchErrorsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) List<BatchErrorsDataInner>? data});
}

/// @nodoc
class __$BatchErrorsCopyWithImpl<$Res> implements _$BatchErrorsCopyWith<$Res> {
  __$BatchErrorsCopyWithImpl(this._self, this._then);

  final _BatchErrors _self;
  final $Res Function(_BatchErrors) _then;

  /// Create a copy of BatchErrors
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? object = freezed,
    Object? data = freezed,
  }) {
    return _then(_BatchErrors(
      object: freezed == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<BatchErrorsDataInner>?,
    ));
  }
}

/// @nodoc
mixin _$BatchRequestCounts {
  /// Total number of requests in the batch.
  int get total;

  /// Number of requests that have been completed successfully.
  int get completed;

  /// Number of requests that have failed.
  int get failed;

  /// Create a copy of BatchRequestCounts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BatchRequestCountsCopyWith<BatchRequestCounts> get copyWith =>
      _$BatchRequestCountsCopyWithImpl<BatchRequestCounts>(
          this as BatchRequestCounts, _$identity);

  /// Serializes this BatchRequestCounts to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BatchRequestCounts &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, total, completed, failed);

  @override
  String toString() {
    return 'BatchRequestCounts(total: $total, completed: $completed, failed: $failed)';
  }
}

/// @nodoc
abstract mixin class $BatchRequestCountsCopyWith<$Res> {
  factory $BatchRequestCountsCopyWith(
          BatchRequestCounts value, $Res Function(BatchRequestCounts) _then) =
      _$BatchRequestCountsCopyWithImpl;
  @useResult
  $Res call({int total, int completed, int failed});
}

/// @nodoc
class _$BatchRequestCountsCopyWithImpl<$Res>
    implements $BatchRequestCountsCopyWith<$Res> {
  _$BatchRequestCountsCopyWithImpl(this._self, this._then);

  final BatchRequestCounts _self;
  final $Res Function(BatchRequestCounts) _then;

  /// Create a copy of BatchRequestCounts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? completed = null,
    Object? failed = null,
  }) {
    return _then(_self.copyWith(
      total: null == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _self.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _self.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [BatchRequestCounts].
extension BatchRequestCountsPatterns on BatchRequestCounts {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BatchRequestCounts value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BatchRequestCounts() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BatchRequestCounts value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchRequestCounts():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BatchRequestCounts value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchRequestCounts() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int total, int completed, int failed)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BatchRequestCounts() when $default != null:
        return $default(_that.total, _that.completed, _that.failed);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int total, int completed, int failed) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchRequestCounts():
        return $default(_that.total, _that.completed, _that.failed);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(int total, int completed, int failed)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchRequestCounts() when $default != null:
        return $default(_that.total, _that.completed, _that.failed);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BatchRequestCounts extends BatchRequestCounts {
  const _BatchRequestCounts(
      {required this.total, required this.completed, required this.failed})
      : super._();
  factory _BatchRequestCounts.fromJson(Map<String, dynamic> json) =>
      _$BatchRequestCountsFromJson(json);

  /// Total number of requests in the batch.
  @override
  final int total;

  /// Number of requests that have been completed successfully.
  @override
  final int completed;

  /// Number of requests that have failed.
  @override
  final int failed;

  /// Create a copy of BatchRequestCounts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BatchRequestCountsCopyWith<_BatchRequestCounts> get copyWith =>
      __$BatchRequestCountsCopyWithImpl<_BatchRequestCounts>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BatchRequestCountsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BatchRequestCounts &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, total, completed, failed);

  @override
  String toString() {
    return 'BatchRequestCounts(total: $total, completed: $completed, failed: $failed)';
  }
}

/// @nodoc
abstract mixin class _$BatchRequestCountsCopyWith<$Res>
    implements $BatchRequestCountsCopyWith<$Res> {
  factory _$BatchRequestCountsCopyWith(
          _BatchRequestCounts value, $Res Function(_BatchRequestCounts) _then) =
      __$BatchRequestCountsCopyWithImpl;
  @override
  @useResult
  $Res call({int total, int completed, int failed});
}

/// @nodoc
class __$BatchRequestCountsCopyWithImpl<$Res>
    implements _$BatchRequestCountsCopyWith<$Res> {
  __$BatchRequestCountsCopyWithImpl(this._self, this._then);

  final _BatchRequestCounts _self;
  final $Res Function(_BatchRequestCounts) _then;

  /// Create a copy of BatchRequestCounts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? total = null,
    Object? completed = null,
    Object? failed = null,
  }) {
    return _then(_BatchRequestCounts(
      total: null == total
          ? _self.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _self.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _self.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
mixin _$BatchErrorsDataInner {
  /// An error code identifying the error type.
  @JsonKey(includeIfNull: false)
  String? get code;

  /// A human-readable message providing more details about the error.
  @JsonKey(includeIfNull: false)
  String? get message;

  /// The name of the parameter that caused the error, if applicable.
  @JsonKey(includeIfNull: false)
  String? get param;

  /// The line number of the input file where the error occurred, if applicable.
  @JsonKey(includeIfNull: false)
  int? get line;

  /// Create a copy of BatchErrorsDataInner
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BatchErrorsDataInnerCopyWith<BatchErrorsDataInner> get copyWith =>
      _$BatchErrorsDataInnerCopyWithImpl<BatchErrorsDataInner>(
          this as BatchErrorsDataInner, _$identity);

  /// Serializes this BatchErrorsDataInner to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BatchErrorsDataInner &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param) &&
            (identical(other.line, line) || other.line == line));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param, line);

  @override
  String toString() {
    return 'BatchErrorsDataInner(code: $code, message: $message, param: $param, line: $line)';
  }
}

/// @nodoc
abstract mixin class $BatchErrorsDataInnerCopyWith<$Res> {
  factory $BatchErrorsDataInnerCopyWith(BatchErrorsDataInner value,
          $Res Function(BatchErrorsDataInner) _then) =
      _$BatchErrorsDataInnerCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? code,
      @JsonKey(includeIfNull: false) String? message,
      @JsonKey(includeIfNull: false) String? param,
      @JsonKey(includeIfNull: false) int? line});
}

/// @nodoc
class _$BatchErrorsDataInnerCopyWithImpl<$Res>
    implements $BatchErrorsDataInnerCopyWith<$Res> {
  _$BatchErrorsDataInnerCopyWithImpl(this._self, this._then);

  final BatchErrorsDataInner _self;
  final $Res Function(BatchErrorsDataInner) _then;

  /// Create a copy of BatchErrorsDataInner
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = freezed,
    Object? param = freezed,
    Object? line = freezed,
  }) {
    return _then(_self.copyWith(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      param: freezed == param
          ? _self.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      line: freezed == line
          ? _self.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [BatchErrorsDataInner].
extension BatchErrorsDataInnerPatterns on BatchErrorsDataInner {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BatchErrorsDataInner value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BatchErrorsDataInner() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BatchErrorsDataInner value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrorsDataInner():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BatchErrorsDataInner value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrorsDataInner() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? code,
            @JsonKey(includeIfNull: false) String? message,
            @JsonKey(includeIfNull: false) String? param,
            @JsonKey(includeIfNull: false) int? line)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BatchErrorsDataInner() when $default != null:
        return $default(_that.code, _that.message, _that.param, _that.line);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? code,
            @JsonKey(includeIfNull: false) String? message,
            @JsonKey(includeIfNull: false) String? param,
            @JsonKey(includeIfNull: false) int? line)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrorsDataInner():
        return $default(_that.code, _that.message, _that.param, _that.line);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? code,
            @JsonKey(includeIfNull: false) String? message,
            @JsonKey(includeIfNull: false) String? param,
            @JsonKey(includeIfNull: false) int? line)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BatchErrorsDataInner() when $default != null:
        return $default(_that.code, _that.message, _that.param, _that.line);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BatchErrorsDataInner extends BatchErrorsDataInner {
  const _BatchErrorsDataInner(
      {@JsonKey(includeIfNull: false) this.code,
      @JsonKey(includeIfNull: false) this.message,
      @JsonKey(includeIfNull: false) this.param,
      @JsonKey(includeIfNull: false) this.line})
      : super._();
  factory _BatchErrorsDataInner.fromJson(Map<String, dynamic> json) =>
      _$BatchErrorsDataInnerFromJson(json);

  /// An error code identifying the error type.
  @override
  @JsonKey(includeIfNull: false)
  final String? code;

  /// A human-readable message providing more details about the error.
  @override
  @JsonKey(includeIfNull: false)
  final String? message;

  /// The name of the parameter that caused the error, if applicable.
  @override
  @JsonKey(includeIfNull: false)
  final String? param;

  /// The line number of the input file where the error occurred, if applicable.
  @override
  @JsonKey(includeIfNull: false)
  final int? line;

  /// Create a copy of BatchErrorsDataInner
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BatchErrorsDataInnerCopyWith<_BatchErrorsDataInner> get copyWith =>
      __$BatchErrorsDataInnerCopyWithImpl<_BatchErrorsDataInner>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BatchErrorsDataInnerToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BatchErrorsDataInner &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param) &&
            (identical(other.line, line) || other.line == line));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param, line);

  @override
  String toString() {
    return 'BatchErrorsDataInner(code: $code, message: $message, param: $param, line: $line)';
  }
}

/// @nodoc
abstract mixin class _$BatchErrorsDataInnerCopyWith<$Res>
    implements $BatchErrorsDataInnerCopyWith<$Res> {
  factory _$BatchErrorsDataInnerCopyWith(_BatchErrorsDataInner value,
          $Res Function(_BatchErrorsDataInner) _then) =
      __$BatchErrorsDataInnerCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? code,
      @JsonKey(includeIfNull: false) String? message,
      @JsonKey(includeIfNull: false) String? param,
      @JsonKey(includeIfNull: false) int? line});
}

/// @nodoc
class __$BatchErrorsDataInnerCopyWithImpl<$Res>
    implements _$BatchErrorsDataInnerCopyWith<$Res> {
  __$BatchErrorsDataInnerCopyWithImpl(this._self, this._then);

  final _BatchErrorsDataInner _self;
  final $Res Function(_BatchErrorsDataInner) _then;

  /// Create a copy of BatchErrorsDataInner
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? code = freezed,
    Object? message = freezed,
    Object? param = freezed,
    Object? line = freezed,
  }) {
    return _then(_BatchErrorsDataInner(
      code: freezed == code
          ? _self.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _self.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      param: freezed == param
          ? _self.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      line: freezed == line
          ? _self.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
mixin _$ListBatchesResponse {
  /// No Description
  List<Batch> get data;

  /// The ID of the first batch in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;

  /// The ID of the last batch in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;

  /// Whether there are more batches available.
  @JsonKey(name: 'has_more')
  bool get hasMore;

  /// The object type, which is always `list`.
  ListBatchesResponseObject get object;

  /// Create a copy of ListBatchesResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ListBatchesResponseCopyWith<ListBatchesResponse> get copyWith =>
      _$ListBatchesResponseCopyWithImpl<ListBatchesResponse>(
          this as ListBatchesResponse, _$identity);

  /// Serializes this ListBatchesResponse to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListBatchesResponse &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(data),
      firstId,
      lastId,
      hasMore,
      object);

  @override
  String toString() {
    return 'ListBatchesResponse(data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore, object: $object)';
  }
}

/// @nodoc
abstract mixin class $ListBatchesResponseCopyWith<$Res> {
  factory $ListBatchesResponseCopyWith(
          ListBatchesResponse value, $Res Function(ListBatchesResponse) _then) =
      _$ListBatchesResponseCopyWithImpl;
  @useResult
  $Res call(
      {List<Batch> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore,
      ListBatchesResponseObject object});
}

/// @nodoc
class _$ListBatchesResponseCopyWithImpl<$Res>
    implements $ListBatchesResponseCopyWith<$Res> {
  _$ListBatchesResponseCopyWithImpl(this._self, this._then);

  final ListBatchesResponse _self;
  final $Res Function(ListBatchesResponse) _then;

  /// Create a copy of ListBatchesResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_self.copyWith(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Batch>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListBatchesResponseObject,
    ));
  }
}

/// Adds pattern-matching-related methods to [ListBatchesResponse].
extension ListBatchesResponsePatterns on ListBatchesResponse {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ListBatchesResponse value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListBatchesResponse() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ListBatchesResponse value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListBatchesResponse():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ListBatchesResponse value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListBatchesResponse() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            List<Batch> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore,
            ListBatchesResponseObject object)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ListBatchesResponse() when $default != null:
        return $default(_that.data, _that.firstId, _that.lastId, _that.hasMore,
            _that.object);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            List<Batch> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore,
            ListBatchesResponseObject object)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListBatchesResponse():
        return $default(_that.data, _that.firstId, _that.lastId, _that.hasMore,
            _that.object);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            List<Batch> data,
            @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
            @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
            @JsonKey(name: 'has_more') bool hasMore,
            ListBatchesResponseObject object)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ListBatchesResponse() when $default != null:
        return $default(_that.data, _that.firstId, _that.lastId, _that.hasMore,
            _that.object);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ListBatchesResponse extends ListBatchesResponse {
  const _ListBatchesResponse(
      {required final List<Batch> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore,
      required this.object})
      : _data = data,
        super._();
  factory _ListBatchesResponse.fromJson(Map<String, dynamic> json) =>
      _$ListBatchesResponseFromJson(json);

  /// No Description
  final List<Batch> _data;

  /// No Description
  @override
  List<Batch> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first batch in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last batch in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more batches available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// The object type, which is always `list`.
  @override
  final ListBatchesResponseObject object;

  /// Create a copy of ListBatchesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ListBatchesResponseCopyWith<_ListBatchesResponse> get copyWith =>
      __$ListBatchesResponseCopyWithImpl<_ListBatchesResponse>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ListBatchesResponseToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ListBatchesResponse &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_data),
      firstId,
      lastId,
      hasMore,
      object);

  @override
  String toString() {
    return 'ListBatchesResponse(data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore, object: $object)';
  }
}

/// @nodoc
abstract mixin class _$ListBatchesResponseCopyWith<$Res>
    implements $ListBatchesResponseCopyWith<$Res> {
  factory _$ListBatchesResponseCopyWith(_ListBatchesResponse value,
          $Res Function(_ListBatchesResponse) _then) =
      __$ListBatchesResponseCopyWithImpl;
  @override
  @useResult
  $Res call(
      {List<Batch> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore,
      ListBatchesResponseObject object});
}

/// @nodoc
class __$ListBatchesResponseCopyWithImpl<$Res>
    implements _$ListBatchesResponseCopyWith<$Res> {
  __$ListBatchesResponseCopyWithImpl(this._self, this._then);

  final _ListBatchesResponse _self;
  final $Res Function(_ListBatchesResponse) _then;

  /// Create a copy of ListBatchesResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_ListBatchesResponse(
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Batch>,
      firstId: freezed == firstId
          ? _self.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _self.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _self.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _self.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListBatchesResponseObject,
    ));
  }
}

/// @nodoc
mixin _$WebSearchOptions {
  /// Approximate location parameters for the search.
  @JsonKey(name: 'user_location', includeIfNull: false)
  WebSearchOptionsUserLocation? get userLocation;

  /// High level guidance for the amount of context window space to use for the
  /// search. One of `low`, `medium`, or `high`. `medium` is the default.
  @JsonKey(name: 'search_context_size')
  WebSearchContextSize get searchContextSize;

  /// Create a copy of WebSearchOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $WebSearchOptionsCopyWith<WebSearchOptions> get copyWith =>
      _$WebSearchOptionsCopyWithImpl<WebSearchOptions>(
          this as WebSearchOptions, _$identity);

  /// Serializes this WebSearchOptions to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is WebSearchOptions &&
            (identical(other.userLocation, userLocation) ||
                other.userLocation == userLocation) &&
            (identical(other.searchContextSize, searchContextSize) ||
                other.searchContextSize == searchContextSize));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, userLocation, searchContextSize);

  @override
  String toString() {
    return 'WebSearchOptions(userLocation: $userLocation, searchContextSize: $searchContextSize)';
  }
}

/// @nodoc
abstract mixin class $WebSearchOptionsCopyWith<$Res> {
  factory $WebSearchOptionsCopyWith(
          WebSearchOptions value, $Res Function(WebSearchOptions) _then) =
      _$WebSearchOptionsCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'user_location', includeIfNull: false)
      WebSearchOptionsUserLocation? userLocation,
      @JsonKey(name: 'search_context_size')
      WebSearchContextSize searchContextSize});

  $WebSearchOptionsUserLocationCopyWith<$Res>? get userLocation;
}

/// @nodoc
class _$WebSearchOptionsCopyWithImpl<$Res>
    implements $WebSearchOptionsCopyWith<$Res> {
  _$WebSearchOptionsCopyWithImpl(this._self, this._then);

  final WebSearchOptions _self;
  final $Res Function(WebSearchOptions) _then;

  /// Create a copy of WebSearchOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userLocation = freezed,
    Object? searchContextSize = null,
  }) {
    return _then(_self.copyWith(
      userLocation: freezed == userLocation
          ? _self.userLocation
          : userLocation // ignore: cast_nullable_to_non_nullable
              as WebSearchOptionsUserLocation?,
      searchContextSize: null == searchContextSize
          ? _self.searchContextSize
          : searchContextSize // ignore: cast_nullable_to_non_nullable
              as WebSearchContextSize,
    ));
  }

  /// Create a copy of WebSearchOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WebSearchOptionsUserLocationCopyWith<$Res>? get userLocation {
    if (_self.userLocation == null) {
      return null;
    }

    return $WebSearchOptionsUserLocationCopyWith<$Res>(_self.userLocation!,
        (value) {
      return _then(_self.copyWith(userLocation: value));
    });
  }
}

/// Adds pattern-matching-related methods to [WebSearchOptions].
extension WebSearchOptionsPatterns on WebSearchOptions {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_WebSearchOptions value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptions() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_WebSearchOptions value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptions():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_WebSearchOptions value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptions() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'user_location', includeIfNull: false)
            WebSearchOptionsUserLocation? userLocation,
            @JsonKey(name: 'search_context_size')
            WebSearchContextSize searchContextSize)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptions() when $default != null:
        return $default(_that.userLocation, _that.searchContextSize);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'user_location', includeIfNull: false)
            WebSearchOptionsUserLocation? userLocation,
            @JsonKey(name: 'search_context_size')
            WebSearchContextSize searchContextSize)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptions():
        return $default(_that.userLocation, _that.searchContextSize);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'user_location', includeIfNull: false)
            WebSearchOptionsUserLocation? userLocation,
            @JsonKey(name: 'search_context_size')
            WebSearchContextSize searchContextSize)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptions() when $default != null:
        return $default(_that.userLocation, _that.searchContextSize);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _WebSearchOptions extends WebSearchOptions {
  const _WebSearchOptions(
      {@JsonKey(name: 'user_location', includeIfNull: false) this.userLocation,
      @JsonKey(name: 'search_context_size')
      this.searchContextSize = WebSearchContextSize.medium})
      : super._();
  factory _WebSearchOptions.fromJson(Map<String, dynamic> json) =>
      _$WebSearchOptionsFromJson(json);

  /// Approximate location parameters for the search.
  @override
  @JsonKey(name: 'user_location', includeIfNull: false)
  final WebSearchOptionsUserLocation? userLocation;

  /// High level guidance for the amount of context window space to use for the
  /// search. One of `low`, `medium`, or `high`. `medium` is the default.
  @override
  @JsonKey(name: 'search_context_size')
  final WebSearchContextSize searchContextSize;

  /// Create a copy of WebSearchOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$WebSearchOptionsCopyWith<_WebSearchOptions> get copyWith =>
      __$WebSearchOptionsCopyWithImpl<_WebSearchOptions>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$WebSearchOptionsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _WebSearchOptions &&
            (identical(other.userLocation, userLocation) ||
                other.userLocation == userLocation) &&
            (identical(other.searchContextSize, searchContextSize) ||
                other.searchContextSize == searchContextSize));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, userLocation, searchContextSize);

  @override
  String toString() {
    return 'WebSearchOptions(userLocation: $userLocation, searchContextSize: $searchContextSize)';
  }
}

/// @nodoc
abstract mixin class _$WebSearchOptionsCopyWith<$Res>
    implements $WebSearchOptionsCopyWith<$Res> {
  factory _$WebSearchOptionsCopyWith(
          _WebSearchOptions value, $Res Function(_WebSearchOptions) _then) =
      __$WebSearchOptionsCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'user_location', includeIfNull: false)
      WebSearchOptionsUserLocation? userLocation,
      @JsonKey(name: 'search_context_size')
      WebSearchContextSize searchContextSize});

  @override
  $WebSearchOptionsUserLocationCopyWith<$Res>? get userLocation;
}

/// @nodoc
class __$WebSearchOptionsCopyWithImpl<$Res>
    implements _$WebSearchOptionsCopyWith<$Res> {
  __$WebSearchOptionsCopyWithImpl(this._self, this._then);

  final _WebSearchOptions _self;
  final $Res Function(_WebSearchOptions) _then;

  /// Create a copy of WebSearchOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? userLocation = freezed,
    Object? searchContextSize = null,
  }) {
    return _then(_WebSearchOptions(
      userLocation: freezed == userLocation
          ? _self.userLocation
          : userLocation // ignore: cast_nullable_to_non_nullable
              as WebSearchOptionsUserLocation?,
      searchContextSize: null == searchContextSize
          ? _self.searchContextSize
          : searchContextSize // ignore: cast_nullable_to_non_nullable
              as WebSearchContextSize,
    ));
  }

  /// Create a copy of WebSearchOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WebSearchOptionsUserLocationCopyWith<$Res>? get userLocation {
    if (_self.userLocation == null) {
      return null;
    }

    return $WebSearchOptionsUserLocationCopyWith<$Res>(_self.userLocation!,
        (value) {
      return _then(_self.copyWith(userLocation: value));
    });
  }
}

/// @nodoc
mixin _$WebSearchOptionsUserLocation {
  /// The type of location approximation. Always `approximate`.
  WebSearchOptionsUserLocationType get type;

  /// Approximate location parameters for the search.
  WebSearchLocation get approximate;

  /// Create a copy of WebSearchOptionsUserLocation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $WebSearchOptionsUserLocationCopyWith<WebSearchOptionsUserLocation>
      get copyWith => _$WebSearchOptionsUserLocationCopyWithImpl<
              WebSearchOptionsUserLocation>(
          this as WebSearchOptionsUserLocation, _$identity);

  /// Serializes this WebSearchOptionsUserLocation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is WebSearchOptionsUserLocation &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.approximate, approximate) ||
                other.approximate == approximate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, approximate);

  @override
  String toString() {
    return 'WebSearchOptionsUserLocation(type: $type, approximate: $approximate)';
  }
}

/// @nodoc
abstract mixin class $WebSearchOptionsUserLocationCopyWith<$Res> {
  factory $WebSearchOptionsUserLocationCopyWith(
          WebSearchOptionsUserLocation value,
          $Res Function(WebSearchOptionsUserLocation) _then) =
      _$WebSearchOptionsUserLocationCopyWithImpl;
  @useResult
  $Res call(
      {WebSearchOptionsUserLocationType type, WebSearchLocation approximate});

  $WebSearchLocationCopyWith<$Res> get approximate;
}

/// @nodoc
class _$WebSearchOptionsUserLocationCopyWithImpl<$Res>
    implements $WebSearchOptionsUserLocationCopyWith<$Res> {
  _$WebSearchOptionsUserLocationCopyWithImpl(this._self, this._then);

  final WebSearchOptionsUserLocation _self;
  final $Res Function(WebSearchOptionsUserLocation) _then;

  /// Create a copy of WebSearchOptionsUserLocation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? approximate = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as WebSearchOptionsUserLocationType,
      approximate: null == approximate
          ? _self.approximate
          : approximate // ignore: cast_nullable_to_non_nullable
              as WebSearchLocation,
    ));
  }

  /// Create a copy of WebSearchOptionsUserLocation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WebSearchLocationCopyWith<$Res> get approximate {
    return $WebSearchLocationCopyWith<$Res>(_self.approximate, (value) {
      return _then(_self.copyWith(approximate: value));
    });
  }
}

/// Adds pattern-matching-related methods to [WebSearchOptionsUserLocation].
extension WebSearchOptionsUserLocationPatterns on WebSearchOptionsUserLocation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_WebSearchOptionsUserLocation value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptionsUserLocation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_WebSearchOptionsUserLocation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptionsUserLocation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_WebSearchOptionsUserLocation value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptionsUserLocation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(WebSearchOptionsUserLocationType type,
            WebSearchLocation approximate)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptionsUserLocation() when $default != null:
        return $default(_that.type, _that.approximate);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(WebSearchOptionsUserLocationType type,
            WebSearchLocation approximate)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptionsUserLocation():
        return $default(_that.type, _that.approximate);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(WebSearchOptionsUserLocationType type,
            WebSearchLocation approximate)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchOptionsUserLocation() when $default != null:
        return $default(_that.type, _that.approximate);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _WebSearchOptionsUserLocation extends WebSearchOptionsUserLocation {
  const _WebSearchOptionsUserLocation(
      {required this.type, required this.approximate})
      : super._();
  factory _WebSearchOptionsUserLocation.fromJson(Map<String, dynamic> json) =>
      _$WebSearchOptionsUserLocationFromJson(json);

  /// The type of location approximation. Always `approximate`.
  @override
  final WebSearchOptionsUserLocationType type;

  /// Approximate location parameters for the search.
  @override
  final WebSearchLocation approximate;

  /// Create a copy of WebSearchOptionsUserLocation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$WebSearchOptionsUserLocationCopyWith<_WebSearchOptionsUserLocation>
      get copyWith => __$WebSearchOptionsUserLocationCopyWithImpl<
          _WebSearchOptionsUserLocation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$WebSearchOptionsUserLocationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _WebSearchOptionsUserLocation &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.approximate, approximate) ||
                other.approximate == approximate));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, approximate);

  @override
  String toString() {
    return 'WebSearchOptionsUserLocation(type: $type, approximate: $approximate)';
  }
}

/// @nodoc
abstract mixin class _$WebSearchOptionsUserLocationCopyWith<$Res>
    implements $WebSearchOptionsUserLocationCopyWith<$Res> {
  factory _$WebSearchOptionsUserLocationCopyWith(
          _WebSearchOptionsUserLocation value,
          $Res Function(_WebSearchOptionsUserLocation) _then) =
      __$WebSearchOptionsUserLocationCopyWithImpl;
  @override
  @useResult
  $Res call(
      {WebSearchOptionsUserLocationType type, WebSearchLocation approximate});

  @override
  $WebSearchLocationCopyWith<$Res> get approximate;
}

/// @nodoc
class __$WebSearchOptionsUserLocationCopyWithImpl<$Res>
    implements _$WebSearchOptionsUserLocationCopyWith<$Res> {
  __$WebSearchOptionsUserLocationCopyWithImpl(this._self, this._then);

  final _WebSearchOptionsUserLocation _self;
  final $Res Function(_WebSearchOptionsUserLocation) _then;

  /// Create a copy of WebSearchOptionsUserLocation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? approximate = null,
  }) {
    return _then(_WebSearchOptionsUserLocation(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as WebSearchOptionsUserLocationType,
      approximate: null == approximate
          ? _self.approximate
          : approximate // ignore: cast_nullable_to_non_nullable
              as WebSearchLocation,
    ));
  }

  /// Create a copy of WebSearchOptionsUserLocation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WebSearchLocationCopyWith<$Res> get approximate {
    return $WebSearchLocationCopyWith<$Res>(_self.approximate, (value) {
      return _then(_self.copyWith(approximate: value));
    });
  }
}

/// @nodoc
mixin _$WebSearchLocation {
  /// The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`.
  @JsonKey(includeIfNull: false)
  String? get country;

  /// Free text input for the region of the user, e.g. `California`.
  @JsonKey(includeIfNull: false)
  String? get region;

  /// Free text input for the city of the user, e.g. `San Francisco`.
  @JsonKey(includeIfNull: false)
  String? get city;

  /// The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`.
  @JsonKey(includeIfNull: false)
  String? get timezone;

  /// Create a copy of WebSearchLocation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $WebSearchLocationCopyWith<WebSearchLocation> get copyWith =>
      _$WebSearchLocationCopyWithImpl<WebSearchLocation>(
          this as WebSearchLocation, _$identity);

  /// Serializes this WebSearchLocation to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is WebSearchLocation &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.region, region) || other.region == region) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.timezone, timezone) ||
                other.timezone == timezone));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, country, region, city, timezone);

  @override
  String toString() {
    return 'WebSearchLocation(country: $country, region: $region, city: $city, timezone: $timezone)';
  }
}

/// @nodoc
abstract mixin class $WebSearchLocationCopyWith<$Res> {
  factory $WebSearchLocationCopyWith(
          WebSearchLocation value, $Res Function(WebSearchLocation) _then) =
      _$WebSearchLocationCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? country,
      @JsonKey(includeIfNull: false) String? region,
      @JsonKey(includeIfNull: false) String? city,
      @JsonKey(includeIfNull: false) String? timezone});
}

/// @nodoc
class _$WebSearchLocationCopyWithImpl<$Res>
    implements $WebSearchLocationCopyWith<$Res> {
  _$WebSearchLocationCopyWithImpl(this._self, this._then);

  final WebSearchLocation _self;
  final $Res Function(WebSearchLocation) _then;

  /// Create a copy of WebSearchLocation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? country = freezed,
    Object? region = freezed,
    Object? city = freezed,
    Object? timezone = freezed,
  }) {
    return _then(_self.copyWith(
      country: freezed == country
          ? _self.country
          : country // ignore: cast_nullable_to_non_nullable
              as String?,
      region: freezed == region
          ? _self.region
          : region // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: freezed == timezone
          ? _self.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [WebSearchLocation].
extension WebSearchLocationPatterns on WebSearchLocation {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_WebSearchLocation value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _WebSearchLocation() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_WebSearchLocation value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchLocation():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_WebSearchLocation value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchLocation() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? country,
            @JsonKey(includeIfNull: false) String? region,
            @JsonKey(includeIfNull: false) String? city,
            @JsonKey(includeIfNull: false) String? timezone)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _WebSearchLocation() when $default != null:
        return $default(
            _that.country, _that.region, _that.city, _that.timezone);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? country,
            @JsonKey(includeIfNull: false) String? region,
            @JsonKey(includeIfNull: false) String? city,
            @JsonKey(includeIfNull: false) String? timezone)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchLocation():
        return $default(
            _that.country, _that.region, _that.city, _that.timezone);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? country,
            @JsonKey(includeIfNull: false) String? region,
            @JsonKey(includeIfNull: false) String? city,
            @JsonKey(includeIfNull: false) String? timezone)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _WebSearchLocation() when $default != null:
        return $default(
            _that.country, _that.region, _that.city, _that.timezone);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _WebSearchLocation extends WebSearchLocation {
  const _WebSearchLocation(
      {@JsonKey(includeIfNull: false) this.country,
      @JsonKey(includeIfNull: false) this.region,
      @JsonKey(includeIfNull: false) this.city,
      @JsonKey(includeIfNull: false) this.timezone})
      : super._();
  factory _WebSearchLocation.fromJson(Map<String, dynamic> json) =>
      _$WebSearchLocationFromJson(json);

  /// The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`.
  @override
  @JsonKey(includeIfNull: false)
  final String? country;

  /// Free text input for the region of the user, e.g. `California`.
  @override
  @JsonKey(includeIfNull: false)
  final String? region;

  /// Free text input for the city of the user, e.g. `San Francisco`.
  @override
  @JsonKey(includeIfNull: false)
  final String? city;

  /// The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`.
  @override
  @JsonKey(includeIfNull: false)
  final String? timezone;

  /// Create a copy of WebSearchLocation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$WebSearchLocationCopyWith<_WebSearchLocation> get copyWith =>
      __$WebSearchLocationCopyWithImpl<_WebSearchLocation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$WebSearchLocationToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _WebSearchLocation &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.region, region) || other.region == region) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.timezone, timezone) ||
                other.timezone == timezone));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, country, region, city, timezone);

  @override
  String toString() {
    return 'WebSearchLocation(country: $country, region: $region, city: $city, timezone: $timezone)';
  }
}

/// @nodoc
abstract mixin class _$WebSearchLocationCopyWith<$Res>
    implements $WebSearchLocationCopyWith<$Res> {
  factory _$WebSearchLocationCopyWith(
          _WebSearchLocation value, $Res Function(_WebSearchLocation) _then) =
      __$WebSearchLocationCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? country,
      @JsonKey(includeIfNull: false) String? region,
      @JsonKey(includeIfNull: false) String? city,
      @JsonKey(includeIfNull: false) String? timezone});
}

/// @nodoc
class __$WebSearchLocationCopyWithImpl<$Res>
    implements _$WebSearchLocationCopyWith<$Res> {
  __$WebSearchLocationCopyWithImpl(this._self, this._then);

  final _WebSearchLocation _self;
  final $Res Function(_WebSearchLocation) _then;

  /// Create a copy of WebSearchLocation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? country = freezed,
    Object? region = freezed,
    Object? city = freezed,
    Object? timezone = freezed,
  }) {
    return _then(_WebSearchLocation(
      country: freezed == country
          ? _self.country
          : country // ignore: cast_nullable_to_non_nullable
              as String?,
      region: freezed == region
          ? _self.region
          : region // ignore: cast_nullable_to_non_nullable
              as String?,
      city: freezed == city
          ? _self.city
          : city // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: freezed == timezone
          ? _self.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

ChatCompletionMessage _$ChatCompletionMessageFromJson(
    Map<String, dynamic> json) {
  switch (json['role']) {
    case 'developer':
      return ChatCompletionDeveloperMessage.fromJson(json);
    case 'system':
      return ChatCompletionSystemMessage.fromJson(json);
    case 'user':
      return ChatCompletionUserMessage.fromJson(json);
    case 'assistant':
      return ChatCompletionAssistantMessage.fromJson(json);
    case 'tool':
      return ChatCompletionToolMessage.fromJson(json);
    case 'function':
      return ChatCompletionFunctionMessage.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'role', 'ChatCompletionMessage',
          'Invalid union type "${json['role']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessage {
  /// The role of the messages author, in this case `developer`.
  ChatCompletionMessageRole get role;

  /// The contents of the developer message.
  @_ChatCompletionDeveloperMessageContentConverter()
  @_ChatCompletionUserMessageContentConverter()
  @JsonKey(includeIfNull: false)
  Object? get content;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageCopyWith<ChatCompletionMessage> get copyWith =>
      _$ChatCompletionMessageCopyWithImpl<ChatCompletionMessage>(
          this as ChatCompletionMessage, _$identity);

  /// Serializes this ChatCompletionMessage to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessage &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other.content, content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, role, const DeepCollectionEquality().hash(content));

  @override
  String toString() {
    return 'ChatCompletionMessage(role: $role, content: $content)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionMessageCopyWith(ChatCompletionMessage value,
          $Res Function(ChatCompletionMessage) _then) =
      _$ChatCompletionMessageCopyWithImpl;
  @useResult
  $Res call({ChatCompletionMessageRole role});
}

/// @nodoc
class _$ChatCompletionMessageCopyWithImpl<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  _$ChatCompletionMessageCopyWithImpl(this._self, this._then);

  final ChatCompletionMessage _self;
  final $Res Function(ChatCompletionMessage) _then;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
  }) {
    return _then(_self.copyWith(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionMessage].
extension ChatCompletionMessagePatterns on ChatCompletionMessage {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionDeveloperMessage value)? developer,
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessage() when developer != null:
        return developer(_that);
      case ChatCompletionSystemMessage() when system != null:
        return system(_that);
      case ChatCompletionUserMessage() when user != null:
        return user(_that);
      case ChatCompletionAssistantMessage() when assistant != null:
        return assistant(_that);
      case ChatCompletionToolMessage() when tool != null:
        return tool(_that);
      case ChatCompletionFunctionMessage() when function != null:
        return function(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionDeveloperMessage value) developer,
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessage():
        return developer(_that);
      case ChatCompletionSystemMessage():
        return system(_that);
      case ChatCompletionUserMessage():
        return user(_that);
      case ChatCompletionAssistantMessage():
        return assistant(_that);
      case ChatCompletionToolMessage():
        return tool(_that);
      case ChatCompletionFunctionMessage():
        return function(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionDeveloperMessage value)? developer,
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessage() when developer != null:
        return developer(_that);
      case ChatCompletionSystemMessage() when system != null:
        return system(_that);
      case ChatCompletionUserMessage() when user != null:
        return user(_that);
      case ChatCompletionAssistantMessage() when assistant != null:
        return assistant(_that);
      case ChatCompletionToolMessage() when tool != null:
        return tool(_that);
      case ChatCompletionFunctionMessage() when function != null:
        return function(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionDeveloperMessageContentConverter()
            ChatCompletionDeveloperMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        developer,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? refusal,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            ChatCompletionMessageToolCalls? toolCalls,
            @JsonKey(includeIfNull: false) List<Annotation>? annotations,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall,
            @JsonKey(includeIfNull: false)
            ChatCompletionAssistantMessageAudio? audio)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessage() when developer != null:
        return developer(_that.role, _that.content, _that.name);
      case ChatCompletionSystemMessage() when system != null:
        return system(_that.role, _that.content, _that.name);
      case ChatCompletionUserMessage() when user != null:
        return user(_that.role, _that.content, _that.name);
      case ChatCompletionAssistantMessage() when assistant != null:
        return assistant(
            _that.role,
            _that.content,
            _that.refusal,
            _that.name,
            _that.toolCalls,
            _that.annotations,
            _that.functionCall,
            _that.audio);
      case ChatCompletionToolMessage() when tool != null:
        return tool(_that.role, _that.content, _that.toolCallId);
      case ChatCompletionFunctionMessage() when function != null:
        return function(_that.role, _that.content, _that.name);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionDeveloperMessageContentConverter()
            ChatCompletionDeveloperMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        developer,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? refusal,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            ChatCompletionMessageToolCalls? toolCalls,
            @JsonKey(includeIfNull: false) List<Annotation>? annotations,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall,
            @JsonKey(includeIfNull: false)
            ChatCompletionAssistantMessageAudio? audio)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessage():
        return developer(_that.role, _that.content, _that.name);
      case ChatCompletionSystemMessage():
        return system(_that.role, _that.content, _that.name);
      case ChatCompletionUserMessage():
        return user(_that.role, _that.content, _that.name);
      case ChatCompletionAssistantMessage():
        return assistant(
            _that.role,
            _that.content,
            _that.refusal,
            _that.name,
            _that.toolCalls,
            _that.annotations,
            _that.functionCall,
            _that.audio);
      case ChatCompletionToolMessage():
        return tool(_that.role, _that.content, _that.toolCallId);
      case ChatCompletionFunctionMessage():
        return function(_that.role, _that.content, _that.name);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionDeveloperMessageContentConverter()
            ChatCompletionDeveloperMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        developer,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? refusal,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            ChatCompletionMessageToolCalls? toolCalls,
            @JsonKey(includeIfNull: false) List<Annotation>? annotations,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall,
            @JsonKey(includeIfNull: false)
            ChatCompletionAssistantMessageAudio? audio)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessage() when developer != null:
        return developer(_that.role, _that.content, _that.name);
      case ChatCompletionSystemMessage() when system != null:
        return system(_that.role, _that.content, _that.name);
      case ChatCompletionUserMessage() when user != null:
        return user(_that.role, _that.content, _that.name);
      case ChatCompletionAssistantMessage() when assistant != null:
        return assistant(
            _that.role,
            _that.content,
            _that.refusal,
            _that.name,
            _that.toolCalls,
            _that.annotations,
            _that.functionCall,
            _that.audio);
      case ChatCompletionToolMessage() when tool != null:
        return tool(_that.role, _that.content, _that.toolCallId);
      case ChatCompletionFunctionMessage() when function != null:
        return function(_that.role, _that.content, _that.name);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionDeveloperMessage extends ChatCompletionMessage {
  const ChatCompletionDeveloperMessage(
      {this.role = ChatCompletionMessageRole.developer,
      @_ChatCompletionDeveloperMessageContentConverter() required this.content,
      @JsonKey(includeIfNull: false) this.name})
      : super._();
  factory ChatCompletionDeveloperMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionDeveloperMessageFromJson(json);

  /// The role of the messages author, in this case `developer`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the developer message.
  @override
  @_ChatCompletionDeveloperMessageContentConverter()
  final ChatCompletionDeveloperMessageContent content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  final String? name;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionDeveloperMessageCopyWith<ChatCompletionDeveloperMessage>
      get copyWith => _$ChatCompletionDeveloperMessageCopyWithImpl<
          ChatCompletionDeveloperMessage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionDeveloperMessageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionDeveloperMessage &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @override
  String toString() {
    return 'ChatCompletionMessage.developer(role: $role, content: $content, name: $name)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionDeveloperMessageCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionDeveloperMessageCopyWith(
          ChatCompletionDeveloperMessage value,
          $Res Function(ChatCompletionDeveloperMessage) _then) =
      _$ChatCompletionDeveloperMessageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @_ChatCompletionDeveloperMessageContentConverter()
      ChatCompletionDeveloperMessageContent content,
      @JsonKey(includeIfNull: false) String? name});

  $ChatCompletionDeveloperMessageContentCopyWith<$Res> get content;
}

/// @nodoc
class _$ChatCompletionDeveloperMessageCopyWithImpl<$Res>
    implements $ChatCompletionDeveloperMessageCopyWith<$Res> {
  _$ChatCompletionDeveloperMessageCopyWithImpl(this._self, this._then);

  final ChatCompletionDeveloperMessage _self;
  final $Res Function(ChatCompletionDeveloperMessage) _then;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? name = freezed,
  }) {
    return _then(ChatCompletionDeveloperMessage(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as ChatCompletionDeveloperMessageContent,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionDeveloperMessageContentCopyWith<$Res> get content {
    return $ChatCompletionDeveloperMessageContentCopyWith<$Res>(_self.content,
        (value) {
      return _then(_self.copyWith(content: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionSystemMessage extends ChatCompletionMessage {
  const ChatCompletionSystemMessage(
      {this.role = ChatCompletionMessageRole.system,
      required this.content,
      @JsonKey(includeIfNull: false) this.name})
      : super._();
  factory ChatCompletionSystemMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionSystemMessageFromJson(json);

  /// The role of the messages author, in this case `system`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the system message.
  @override
  final String content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  final String? name;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionSystemMessageCopyWith<ChatCompletionSystemMessage>
      get copyWith => _$ChatCompletionSystemMessageCopyWithImpl<
          ChatCompletionSystemMessage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionSystemMessageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionSystemMessage &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @override
  String toString() {
    return 'ChatCompletionMessage.system(role: $role, content: $content, name: $name)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionSystemMessageCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionSystemMessageCopyWith(
          ChatCompletionSystemMessage value,
          $Res Function(ChatCompletionSystemMessage) _then) =
      _$ChatCompletionSystemMessageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String content,
      @JsonKey(includeIfNull: false) String? name});
}

/// @nodoc
class _$ChatCompletionSystemMessageCopyWithImpl<$Res>
    implements $ChatCompletionSystemMessageCopyWith<$Res> {
  _$ChatCompletionSystemMessageCopyWithImpl(this._self, this._then);

  final ChatCompletionSystemMessage _self;
  final $Res Function(ChatCompletionSystemMessage) _then;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? name = freezed,
  }) {
    return _then(ChatCompletionSystemMessage(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionUserMessage extends ChatCompletionMessage {
  const ChatCompletionUserMessage(
      {this.role = ChatCompletionMessageRole.user,
      @_ChatCompletionUserMessageContentConverter() required this.content,
      @JsonKey(includeIfNull: false) this.name})
      : super._();
  factory ChatCompletionUserMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionUserMessageFromJson(json);

  /// The role of the messages author, in this case `user`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the user message.
  @override
  @_ChatCompletionUserMessageContentConverter()
  final ChatCompletionUserMessageContent content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  final String? name;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionUserMessageCopyWith<ChatCompletionUserMessage> get copyWith =>
      _$ChatCompletionUserMessageCopyWithImpl<ChatCompletionUserMessage>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionUserMessageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionUserMessage &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @override
  String toString() {
    return 'ChatCompletionMessage.user(role: $role, content: $content, name: $name)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionUserMessageCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionUserMessageCopyWith(ChatCompletionUserMessage value,
          $Res Function(ChatCompletionUserMessage) _then) =
      _$ChatCompletionUserMessageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @_ChatCompletionUserMessageContentConverter()
      ChatCompletionUserMessageContent content,
      @JsonKey(includeIfNull: false) String? name});

  $ChatCompletionUserMessageContentCopyWith<$Res> get content;
}

/// @nodoc
class _$ChatCompletionUserMessageCopyWithImpl<$Res>
    implements $ChatCompletionUserMessageCopyWith<$Res> {
  _$ChatCompletionUserMessageCopyWithImpl(this._self, this._then);

  final ChatCompletionUserMessage _self;
  final $Res Function(ChatCompletionUserMessage) _then;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? name = freezed,
  }) {
    return _then(ChatCompletionUserMessage(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as ChatCompletionUserMessageContent,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionUserMessageContentCopyWith<$Res> get content {
    return $ChatCompletionUserMessageContentCopyWith<$Res>(_self.content,
        (value) {
      return _then(_self.copyWith(content: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionAssistantMessage extends ChatCompletionMessage {
  const ChatCompletionAssistantMessage(
      {this.role = ChatCompletionMessageRole.assistant,
      @JsonKey(includeIfNull: false) this.content,
      @JsonKey(includeIfNull: false) this.refusal,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final ChatCompletionMessageToolCalls? toolCalls,
      @JsonKey(includeIfNull: false) final List<Annotation>? annotations,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall,
      @JsonKey(includeIfNull: false) this.audio})
      : _toolCalls = toolCalls,
        _annotations = annotations,
        super._();
  factory ChatCompletionAssistantMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionAssistantMessageFromJson(json);

  /// The role of the messages author, in this case `assistant`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// The refusal message by the assistant.
  @JsonKey(includeIfNull: false)
  final String? refusal;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  final String? name;

  /// No Description
  final ChatCompletionMessageToolCalls? _toolCalls;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  ChatCompletionMessageToolCalls? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Annotations for the message, when applicable, as when using the
  /// [web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).
  final List<Annotation>? _annotations;

  /// Annotations for the message, when applicable, as when using the
  /// [web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).
  @JsonKey(includeIfNull: false)
  List<Annotation>? get annotations {
    final value = _annotations;
    if (value == null) return null;
    if (_annotations is EqualUnmodifiableListView) return _annotations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionMessageFunctionCall? functionCall;

  /// If the audio output modality is requested, this object contains data about the audio response from the model.
  /// [Learn more](https://platform.openai.com/docs/guides/audio).
  @JsonKey(includeIfNull: false)
  final ChatCompletionAssistantMessageAudio? audio;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionAssistantMessageCopyWith<ChatCompletionAssistantMessage>
      get copyWith => _$ChatCompletionAssistantMessageCopyWithImpl<
          ChatCompletionAssistantMessage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionAssistantMessageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionAssistantMessage &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.refusal, refusal) || other.refusal == refusal) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            const DeepCollectionEquality()
                .equals(other._annotations, _annotations) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            (identical(other.audio, audio) || other.audio == audio));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      role,
      content,
      refusal,
      name,
      const DeepCollectionEquality().hash(_toolCalls),
      const DeepCollectionEquality().hash(_annotations),
      functionCall,
      audio);

  @override
  String toString() {
    return 'ChatCompletionMessage.assistant(role: $role, content: $content, refusal: $refusal, name: $name, toolCalls: $toolCalls, annotations: $annotations, functionCall: $functionCall, audio: $audio)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionAssistantMessageCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionAssistantMessageCopyWith(
          ChatCompletionAssistantMessage value,
          $Res Function(ChatCompletionAssistantMessage) _then) =
      _$ChatCompletionAssistantMessageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @JsonKey(includeIfNull: false) String? content,
      @JsonKey(includeIfNull: false) String? refusal,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      ChatCompletionMessageToolCalls? toolCalls,
      @JsonKey(includeIfNull: false) List<Annotation>? annotations,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionMessageFunctionCall? functionCall,
      @JsonKey(includeIfNull: false)
      ChatCompletionAssistantMessageAudio? audio});

  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall;
  $ChatCompletionAssistantMessageAudioCopyWith<$Res>? get audio;
}

/// @nodoc
class _$ChatCompletionAssistantMessageCopyWithImpl<$Res>
    implements $ChatCompletionAssistantMessageCopyWith<$Res> {
  _$ChatCompletionAssistantMessageCopyWithImpl(this._self, this._then);

  final ChatCompletionAssistantMessage _self;
  final $Res Function(ChatCompletionAssistantMessage) _then;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? refusal = freezed,
    Object? name = freezed,
    Object? toolCalls = freezed,
    Object? annotations = freezed,
    Object? functionCall = freezed,
    Object? audio = freezed,
  }) {
    return _then(ChatCompletionAssistantMessage(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      refusal: freezed == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _self._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCalls?,
      annotations: freezed == annotations
          ? _self._annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      functionCall: freezed == functionCall
          ? _self.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall?,
      audio: freezed == audio
          ? _self.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessageAudio?,
    ));
  }

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_self.functionCall == null) {
      return null;
    }

    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(_self.functionCall!,
        (value) {
      return _then(_self.copyWith(functionCall: value));
    });
  }

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionAssistantMessageAudioCopyWith<$Res>? get audio {
    if (_self.audio == null) {
      return null;
    }

    return $ChatCompletionAssistantMessageAudioCopyWith<$Res>(_self.audio!,
        (value) {
      return _then(_self.copyWith(audio: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionToolMessage extends ChatCompletionMessage {
  const ChatCompletionToolMessage(
      {this.role = ChatCompletionMessageRole.tool,
      required this.content,
      @JsonKey(name: 'tool_call_id') required this.toolCallId})
      : super._();
  factory ChatCompletionToolMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionToolMessageFromJson(json);

  /// The role of the messages author, in this case `tool`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the tool message.
  @override
  final String content;

  /// Tool call that this message is responding to.
  @JsonKey(name: 'tool_call_id')
  final String toolCallId;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionToolMessageCopyWith<ChatCompletionToolMessage> get copyWith =>
      _$ChatCompletionToolMessageCopyWithImpl<ChatCompletionToolMessage>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionToolMessageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionToolMessage &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, toolCallId);

  @override
  String toString() {
    return 'ChatCompletionMessage.tool(role: $role, content: $content, toolCallId: $toolCallId)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionToolMessageCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionToolMessageCopyWith(ChatCompletionToolMessage value,
          $Res Function(ChatCompletionToolMessage) _then) =
      _$ChatCompletionToolMessageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String content,
      @JsonKey(name: 'tool_call_id') String toolCallId});
}

/// @nodoc
class _$ChatCompletionToolMessageCopyWithImpl<$Res>
    implements $ChatCompletionToolMessageCopyWith<$Res> {
  _$ChatCompletionToolMessageCopyWithImpl(this._self, this._then);

  final ChatCompletionToolMessage _self;
  final $Res Function(ChatCompletionToolMessage) _then;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? toolCallId = null,
  }) {
    return _then(ChatCompletionToolMessage(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      toolCallId: null == toolCallId
          ? _self.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionFunctionMessage extends ChatCompletionMessage {
  const ChatCompletionFunctionMessage(
      {this.role = ChatCompletionMessageRole.function,
      required this.content,
      required this.name})
      : super._();
  factory ChatCompletionFunctionMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionFunctionMessageFromJson(json);

  /// The role of the messages author, in this case `function`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the function message.
  @override
  final String? content;

  /// The name of the function to call.
  final String name;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionMessageCopyWith<ChatCompletionFunctionMessage>
      get copyWith => _$ChatCompletionFunctionMessageCopyWithImpl<
          ChatCompletionFunctionMessage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionFunctionMessageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionFunctionMessage &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @override
  String toString() {
    return 'ChatCompletionMessage.function(role: $role, content: $content, name: $name)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionFunctionMessageCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionFunctionMessageCopyWith(
          ChatCompletionFunctionMessage value,
          $Res Function(ChatCompletionFunctionMessage) _then) =
      _$ChatCompletionFunctionMessageCopyWithImpl;
  @override
  @useResult
  $Res call({ChatCompletionMessageRole role, String? content, String name});
}

/// @nodoc
class _$ChatCompletionFunctionMessageCopyWithImpl<$Res>
    implements $ChatCompletionFunctionMessageCopyWith<$Res> {
  _$ChatCompletionFunctionMessageCopyWithImpl(this._self, this._then);

  final ChatCompletionFunctionMessage _self;
  final $Res Function(ChatCompletionFunctionMessage) _then;

  /// Create a copy of ChatCompletionMessage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? name = null,
  }) {
    return _then(ChatCompletionFunctionMessage(
      role: null == role
          ? _self.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _self.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

ChatCompletionDeveloperMessageContent
    _$ChatCompletionDeveloperMessageContentFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'parts':
      return ChatCompletionDeveloperMessageContentParts.fromJson(json);
    case 'text':
      return ChatCompletionDeveloperMessageContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionDeveloperMessageContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionDeveloperMessageContent {
  Object get value;

  /// Serializes this ChatCompletionDeveloperMessageContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionDeveloperMessageContent &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ChatCompletionDeveloperMessageContent(value: $value)';
  }
}

/// @nodoc
class $ChatCompletionDeveloperMessageContentCopyWith<$Res> {
  $ChatCompletionDeveloperMessageContentCopyWith(
      ChatCompletionDeveloperMessageContent _,
      $Res Function(ChatCompletionDeveloperMessageContent) __);
}

/// Adds pattern-matching-related methods to [ChatCompletionDeveloperMessageContent].
extension ChatCompletionDeveloperMessageContentPatterns
    on ChatCompletionDeveloperMessageContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionDeveloperMessageContentParts value)? parts,
    TResult Function(ChatCompletionDeveloperMessageContentString value)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessageContentParts() when parts != null:
        return parts(_that);
      case ChatCompletionDeveloperMessageContentString() when text != null:
        return text(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionDeveloperMessageContentParts value)
        parts,
    required TResult Function(ChatCompletionDeveloperMessageContentString value)
        text,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessageContentParts():
        return parts(_that);
      case ChatCompletionDeveloperMessageContentString():
        return text(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionDeveloperMessageContentParts value)? parts,
    TResult? Function(ChatCompletionDeveloperMessageContentString value)? text,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessageContentParts() when parts != null:
        return parts(_that);
      case ChatCompletionDeveloperMessageContentString() when text != null:
        return text(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessageContentParts() when parts != null:
        return parts(_that.value);
      case ChatCompletionDeveloperMessageContentString() when text != null:
        return text(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) text,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessageContentParts():
        return parts(_that.value);
      case ChatCompletionDeveloperMessageContentString():
        return text(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? text,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionDeveloperMessageContentParts() when parts != null:
        return parts(_that.value);
      case ChatCompletionDeveloperMessageContentString() when text != null:
        return text(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionDeveloperMessageContentParts
    extends ChatCompletionDeveloperMessageContent {
  const ChatCompletionDeveloperMessageContentParts(
      final List<ChatCompletionMessageContentPart> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'parts',
        super._();
  factory ChatCompletionDeveloperMessageContentParts.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionDeveloperMessageContentPartsFromJson(json);

  final List<ChatCompletionMessageContentPart> _value;
  @override
  List<ChatCompletionMessageContentPart> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionDeveloperMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionDeveloperMessageContentPartsCopyWith<
          ChatCompletionDeveloperMessageContentParts>
      get copyWith => _$ChatCompletionDeveloperMessageContentPartsCopyWithImpl<
          ChatCompletionDeveloperMessageContentParts>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionDeveloperMessageContentPartsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionDeveloperMessageContentParts &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'ChatCompletionDeveloperMessageContent.parts(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionDeveloperMessageContentPartsCopyWith<$Res>
    implements $ChatCompletionDeveloperMessageContentCopyWith<$Res> {
  factory $ChatCompletionDeveloperMessageContentPartsCopyWith(
          ChatCompletionDeveloperMessageContentParts value,
          $Res Function(ChatCompletionDeveloperMessageContentParts) _then) =
      _$ChatCompletionDeveloperMessageContentPartsCopyWithImpl;
  @useResult
  $Res call({List<ChatCompletionMessageContentPart> value});
}

/// @nodoc
class _$ChatCompletionDeveloperMessageContentPartsCopyWithImpl<$Res>
    implements $ChatCompletionDeveloperMessageContentPartsCopyWith<$Res> {
  _$ChatCompletionDeveloperMessageContentPartsCopyWithImpl(
      this._self, this._then);

  final ChatCompletionDeveloperMessageContentParts _self;
  final $Res Function(ChatCompletionDeveloperMessageContentParts) _then;

  /// Create a copy of ChatCompletionDeveloperMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionDeveloperMessageContentParts(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageContentPart>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionDeveloperMessageContentString
    extends ChatCompletionDeveloperMessageContent {
  const ChatCompletionDeveloperMessageContentString(this.value,
      {final String? $type})
      : $type = $type ?? 'text',
        super._();
  factory ChatCompletionDeveloperMessageContentString.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionDeveloperMessageContentStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionDeveloperMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionDeveloperMessageContentStringCopyWith<
          ChatCompletionDeveloperMessageContentString>
      get copyWith => _$ChatCompletionDeveloperMessageContentStringCopyWithImpl<
          ChatCompletionDeveloperMessageContentString>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionDeveloperMessageContentStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionDeveloperMessageContentString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionDeveloperMessageContent.text(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionDeveloperMessageContentStringCopyWith<$Res>
    implements $ChatCompletionDeveloperMessageContentCopyWith<$Res> {
  factory $ChatCompletionDeveloperMessageContentStringCopyWith(
          ChatCompletionDeveloperMessageContentString value,
          $Res Function(ChatCompletionDeveloperMessageContentString) _then) =
      _$ChatCompletionDeveloperMessageContentStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$ChatCompletionDeveloperMessageContentStringCopyWithImpl<$Res>
    implements $ChatCompletionDeveloperMessageContentStringCopyWith<$Res> {
  _$ChatCompletionDeveloperMessageContentStringCopyWithImpl(
      this._self, this._then);

  final ChatCompletionDeveloperMessageContentString _self;
  final $Res Function(ChatCompletionDeveloperMessageContentString) _then;

  /// Create a copy of ChatCompletionDeveloperMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionDeveloperMessageContentString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

ChatCompletionUserMessageContent _$ChatCompletionUserMessageContentFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'parts':
      return ChatCompletionMessageContentParts.fromJson(json);
    case 'string':
      return ChatCompletionUserMessageContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionUserMessageContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionUserMessageContent {
  Object get value;

  /// Serializes this ChatCompletionUserMessageContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionUserMessageContent &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent(value: $value)';
  }
}

/// @nodoc
class $ChatCompletionUserMessageContentCopyWith<$Res> {
  $ChatCompletionUserMessageContentCopyWith(ChatCompletionUserMessageContent _,
      $Res Function(ChatCompletionUserMessageContent) __);
}

/// Adds pattern-matching-related methods to [ChatCompletionUserMessageContent].
extension ChatCompletionUserMessageContentPatterns
    on ChatCompletionUserMessageContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentParts() when parts != null:
        return parts(_that);
      case ChatCompletionUserMessageContentString() when string != null:
        return string(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentParts():
        return parts(_that);
      case ChatCompletionUserMessageContentString():
        return string(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentParts() when parts != null:
        return parts(_that);
      case ChatCompletionUserMessageContentString() when string != null:
        return string(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentParts() when parts != null:
        return parts(_that.value);
      case ChatCompletionUserMessageContentString() when string != null:
        return string(_that.value);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentParts():
        return parts(_that.value);
      case ChatCompletionUserMessageContentString():
        return string(_that.value);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentParts() when parts != null:
        return parts(_that.value);
      case ChatCompletionUserMessageContentString() when string != null:
        return string(_that.value);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionMessageContentParts
    extends ChatCompletionUserMessageContent {
  const ChatCompletionMessageContentParts(
      final List<ChatCompletionMessageContentPart> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'parts',
        super._();
  factory ChatCompletionMessageContentParts.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionMessageContentPartsFromJson(json);

  final List<ChatCompletionMessageContentPart> _value;
  @override
  List<ChatCompletionMessageContentPart> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionUserMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageContentPartsCopyWith<ChatCompletionMessageContentParts>
      get copyWith => _$ChatCompletionMessageContentPartsCopyWithImpl<
          ChatCompletionMessageContentParts>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageContentPartsToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageContentParts &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.parts(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageContentPartsCopyWith<$Res>
    implements $ChatCompletionUserMessageContentCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartsCopyWith(
          ChatCompletionMessageContentParts value,
          $Res Function(ChatCompletionMessageContentParts) _then) =
      _$ChatCompletionMessageContentPartsCopyWithImpl;
  @useResult
  $Res call({List<ChatCompletionMessageContentPart> value});
}

/// @nodoc
class _$ChatCompletionMessageContentPartsCopyWithImpl<$Res>
    implements $ChatCompletionMessageContentPartsCopyWith<$Res> {
  _$ChatCompletionMessageContentPartsCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageContentParts _self;
  final $Res Function(ChatCompletionMessageContentParts) _then;

  /// Create a copy of ChatCompletionUserMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionMessageContentParts(
      null == value
          ? _self._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageContentPart>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionUserMessageContentString
    extends ChatCompletionUserMessageContent {
  const ChatCompletionUserMessageContentString(this.value,
      {final String? $type})
      : $type = $type ?? 'string',
        super._();
  factory ChatCompletionUserMessageContentString.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionUserMessageContentStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of ChatCompletionUserMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionUserMessageContentStringCopyWith<
          ChatCompletionUserMessageContentString>
      get copyWith => _$ChatCompletionUserMessageContentStringCopyWithImpl<
          ChatCompletionUserMessageContentString>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionUserMessageContentStringToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionUserMessageContentString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.string(value: $value)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionUserMessageContentStringCopyWith<$Res>
    implements $ChatCompletionUserMessageContentCopyWith<$Res> {
  factory $ChatCompletionUserMessageContentStringCopyWith(
          ChatCompletionUserMessageContentString value,
          $Res Function(ChatCompletionUserMessageContentString) _then) =
      _$ChatCompletionUserMessageContentStringCopyWithImpl;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$ChatCompletionUserMessageContentStringCopyWithImpl<$Res>
    implements $ChatCompletionUserMessageContentStringCopyWith<$Res> {
  _$ChatCompletionUserMessageContentStringCopyWithImpl(this._self, this._then);

  final ChatCompletionUserMessageContentString _self;
  final $Res Function(ChatCompletionUserMessageContentString) _then;

  /// Create a copy of ChatCompletionUserMessageContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? value = null,
  }) {
    return _then(ChatCompletionUserMessageContentString(
      null == value
          ? _self.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionAssistantMessageAudio {
  /// Unique identifier for this audio response.
  String get id;

  /// The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server
  /// for use in multi-turn conversations.
  @JsonKey(name: 'expires_at')
  int get expiresAt;

  /// Base64 encoded audio bytes generated by the model, in the format specified in the request.
  String get data;

  /// Transcript of the audio generated by the model.
  String get transcript;

  /// Create a copy of ChatCompletionAssistantMessageAudio
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionAssistantMessageAudioCopyWith<
          ChatCompletionAssistantMessageAudio>
      get copyWith => _$ChatCompletionAssistantMessageAudioCopyWithImpl<
              ChatCompletionAssistantMessageAudio>(
          this as ChatCompletionAssistantMessageAudio, _$identity);

  /// Serializes this ChatCompletionAssistantMessageAudio to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionAssistantMessageAudio &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.transcript, transcript) ||
                other.transcript == transcript));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, expiresAt, data, transcript);

  @override
  String toString() {
    return 'ChatCompletionAssistantMessageAudio(id: $id, expiresAt: $expiresAt, data: $data, transcript: $transcript)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionAssistantMessageAudioCopyWith<$Res> {
  factory $ChatCompletionAssistantMessageAudioCopyWith(
          ChatCompletionAssistantMessageAudio value,
          $Res Function(ChatCompletionAssistantMessageAudio) _then) =
      _$ChatCompletionAssistantMessageAudioCopyWithImpl;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'expires_at') int expiresAt,
      String data,
      String transcript});
}

/// @nodoc
class _$ChatCompletionAssistantMessageAudioCopyWithImpl<$Res>
    implements $ChatCompletionAssistantMessageAudioCopyWith<$Res> {
  _$ChatCompletionAssistantMessageAudioCopyWithImpl(this._self, this._then);

  final ChatCompletionAssistantMessageAudio _self;
  final $Res Function(ChatCompletionAssistantMessageAudio) _then;

  /// Create a copy of ChatCompletionAssistantMessageAudio
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? expiresAt = null,
    Object? data = null,
    Object? transcript = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      expiresAt: null == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      transcript: null == transcript
          ? _self.transcript
          : transcript // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionAssistantMessageAudio].
extension ChatCompletionAssistantMessageAudioPatterns
    on ChatCompletionAssistantMessageAudio {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionAssistantMessageAudio value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAssistantMessageAudio() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionAssistantMessageAudio value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAssistantMessageAudio():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionAssistantMessageAudio value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAssistantMessageAudio() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String id, @JsonKey(name: 'expires_at') int expiresAt,
            String data, String transcript)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAssistantMessageAudio() when $default != null:
        return $default(
            _that.id, _that.expiresAt, _that.data, _that.transcript);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String id, @JsonKey(name: 'expires_at') int expiresAt,
            String data, String transcript)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAssistantMessageAudio():
        return $default(
            _that.id, _that.expiresAt, _that.data, _that.transcript);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String id, @JsonKey(name: 'expires_at') int expiresAt,
            String data, String transcript)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionAssistantMessageAudio() when $default != null:
        return $default(
            _that.id, _that.expiresAt, _that.data, _that.transcript);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionAssistantMessageAudio
    extends ChatCompletionAssistantMessageAudio {
  const _ChatCompletionAssistantMessageAudio(
      {required this.id,
      @JsonKey(name: 'expires_at') required this.expiresAt,
      required this.data,
      required this.transcript})
      : super._();
  factory _ChatCompletionAssistantMessageAudio.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionAssistantMessageAudioFromJson(json);

  /// Unique identifier for this audio response.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server
  /// for use in multi-turn conversations.
  @override
  @JsonKey(name: 'expires_at')
  final int expiresAt;

  /// Base64 encoded audio bytes generated by the model, in the format specified in the request.
  @override
  final String data;

  /// Transcript of the audio generated by the model.
  @override
  final String transcript;

  /// Create a copy of ChatCompletionAssistantMessageAudio
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionAssistantMessageAudioCopyWith<
          _ChatCompletionAssistantMessageAudio>
      get copyWith => __$ChatCompletionAssistantMessageAudioCopyWithImpl<
          _ChatCompletionAssistantMessageAudio>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionAssistantMessageAudioToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionAssistantMessageAudio &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.transcript, transcript) ||
                other.transcript == transcript));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, expiresAt, data, transcript);

  @override
  String toString() {
    return 'ChatCompletionAssistantMessageAudio(id: $id, expiresAt: $expiresAt, data: $data, transcript: $transcript)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionAssistantMessageAudioCopyWith<$Res>
    implements $ChatCompletionAssistantMessageAudioCopyWith<$Res> {
  factory _$ChatCompletionAssistantMessageAudioCopyWith(
          _ChatCompletionAssistantMessageAudio value,
          $Res Function(_ChatCompletionAssistantMessageAudio) _then) =
      __$ChatCompletionAssistantMessageAudioCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'expires_at') int expiresAt,
      String data,
      String transcript});
}

/// @nodoc
class __$ChatCompletionAssistantMessageAudioCopyWithImpl<$Res>
    implements _$ChatCompletionAssistantMessageAudioCopyWith<$Res> {
  __$ChatCompletionAssistantMessageAudioCopyWithImpl(this._self, this._then);

  final _ChatCompletionAssistantMessageAudio _self;
  final $Res Function(_ChatCompletionAssistantMessageAudio) _then;

  /// Create a copy of ChatCompletionAssistantMessageAudio
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? expiresAt = null,
    Object? data = null,
    Object? transcript = null,
  }) {
    return _then(_ChatCompletionAssistantMessageAudio(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      expiresAt: null == expiresAt
          ? _self.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      transcript: null == transcript
          ? _self.transcript
          : transcript // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

ChatCompletionMessageContentPart _$ChatCompletionMessageContentPartFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'text':
      return ChatCompletionMessageContentPartText.fromJson(json);
    case 'image_url':
      return ChatCompletionMessageContentPartImage.fromJson(json);
    case 'input_audio':
      return ChatCompletionMessageContentPartAudio.fromJson(json);
    case 'refusal':
      return ChatCompletionMessageContentPartRefusal.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChatCompletionMessageContentPart',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessageContentPart {
  /// The type of the content part, in this case `text`.
  ChatCompletionMessageContentPartType get type;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageContentPartCopyWith<ChatCompletionMessageContentPart>
      get copyWith => _$ChatCompletionMessageContentPartCopyWithImpl<
              ChatCompletionMessageContentPart>(
          this as ChatCompletionMessageContentPart, _$identity);

  /// Serializes this ChatCompletionMessageContentPart to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageContentPart &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartCopyWith(
          ChatCompletionMessageContentPart value,
          $Res Function(ChatCompletionMessageContentPart) _then) =
      _$ChatCompletionMessageContentPartCopyWithImpl;
  @useResult
  $Res call({ChatCompletionMessageContentPartType type});
}

/// @nodoc
class _$ChatCompletionMessageContentPartCopyWithImpl<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  _$ChatCompletionMessageContentPartCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageContentPart _self;
  final $Res Function(ChatCompletionMessageContentPart) _then;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionMessageContentPart].
extension ChatCompletionMessageContentPartPatterns
    on ChatCompletionMessageContentPart {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    TResult Function(ChatCompletionMessageContentPartAudio value)? audio,
    TResult Function(ChatCompletionMessageContentPartRefusal value)? refusal,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentPartText() when text != null:
        return text(_that);
      case ChatCompletionMessageContentPartImage() when image != null:
        return image(_that);
      case ChatCompletionMessageContentPartAudio() when audio != null:
        return audio(_that);
      case ChatCompletionMessageContentPartRefusal() when refusal != null:
        return refusal(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
    required TResult Function(ChatCompletionMessageContentPartAudio value)
        audio,
    required TResult Function(ChatCompletionMessageContentPartRefusal value)
        refusal,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentPartText():
        return text(_that);
      case ChatCompletionMessageContentPartImage():
        return image(_that);
      case ChatCompletionMessageContentPartAudio():
        return audio(_that);
      case ChatCompletionMessageContentPartRefusal():
        return refusal(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
    TResult? Function(ChatCompletionMessageContentPartAudio value)? audio,
    TResult? Function(ChatCompletionMessageContentPartRefusal value)? refusal,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentPartText() when text != null:
        return text(_that);
      case ChatCompletionMessageContentPartImage() when image != null:
        return image(_that);
      case ChatCompletionMessageContentPartAudio() when audio != null:
        return audio(_that);
      case ChatCompletionMessageContentPartRefusal() when refusal != null:
        return refusal(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    TResult Function(
            ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'input_audio')
            ChatCompletionMessageInputAudio inputAudio)?
        audio,
    TResult Function(ChatCompletionMessageContentPartType type, String refusal)?
        refusal,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentPartText() when text != null:
        return text(_that.type, _that.text);
      case ChatCompletionMessageContentPartImage() when image != null:
        return image(_that.type, _that.imageUrl);
      case ChatCompletionMessageContentPartAudio() when audio != null:
        return audio(_that.type, _that.inputAudio);
      case ChatCompletionMessageContentPartRefusal() when refusal != null:
        return refusal(_that.type, _that.refusal);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
    required TResult Function(
            ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'input_audio')
            ChatCompletionMessageInputAudio inputAudio)
        audio,
    required TResult Function(
            ChatCompletionMessageContentPartType type, String refusal)
        refusal,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentPartText():
        return text(_that.type, _that.text);
      case ChatCompletionMessageContentPartImage():
        return image(_that.type, _that.imageUrl);
      case ChatCompletionMessageContentPartAudio():
        return audio(_that.type, _that.inputAudio);
      case ChatCompletionMessageContentPartRefusal():
        return refusal(_that.type, _that.refusal);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    TResult? Function(
            ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'input_audio')
            ChatCompletionMessageInputAudio inputAudio)?
        audio,
    TResult? Function(
            ChatCompletionMessageContentPartType type, String refusal)?
        refusal,
  }) {
    final _that = this;
    switch (_that) {
      case ChatCompletionMessageContentPartText() when text != null:
        return text(_that.type, _that.text);
      case ChatCompletionMessageContentPartImage() when image != null:
        return image(_that.type, _that.imageUrl);
      case ChatCompletionMessageContentPartAudio() when audio != null:
        return audio(_that.type, _that.inputAudio);
      case ChatCompletionMessageContentPartRefusal() when refusal != null:
        return refusal(_that.type, _that.refusal);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionMessageContentPartText
    extends ChatCompletionMessageContentPart {
  const ChatCompletionMessageContentPartText(
      {this.type = ChatCompletionMessageContentPartType.text,
      required this.text})
      : super._();
  factory ChatCompletionMessageContentPartText.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionMessageContentPartTextFromJson(json);

  /// The type of the content part, in this case `text`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The text content.
  final String text;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageContentPartTextCopyWith<
          ChatCompletionMessageContentPartText>
      get copyWith => _$ChatCompletionMessageContentPartTextCopyWithImpl<
          ChatCompletionMessageContentPartText>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageContentPartTextToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageContentPartText &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.text(type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageContentPartTextCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartTextCopyWith(
          ChatCompletionMessageContentPartText value,
          $Res Function(ChatCompletionMessageContentPartText) _then) =
      _$ChatCompletionMessageContentPartTextCopyWithImpl;
  @override
  @useResult
  $Res call({ChatCompletionMessageContentPartType type, String text});
}

/// @nodoc
class _$ChatCompletionMessageContentPartTextCopyWithImpl<$Res>
    implements $ChatCompletionMessageContentPartTextCopyWith<$Res> {
  _$ChatCompletionMessageContentPartTextCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageContentPartText _self;
  final $Res Function(ChatCompletionMessageContentPartText) _then;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(ChatCompletionMessageContentPartText(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionMessageContentPartImage
    extends ChatCompletionMessageContentPart {
  const ChatCompletionMessageContentPartImage(
      {this.type = ChatCompletionMessageContentPartType.imageUrl,
      @JsonKey(name: 'image_url') required this.imageUrl})
      : super._();
  factory ChatCompletionMessageContentPartImage.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionMessageContentPartImageFromJson(json);

  /// The type of the content part, in this case `image_url`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The URL of the image.
  @JsonKey(name: 'image_url')
  final ChatCompletionMessageImageUrl imageUrl;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageContentPartImageCopyWith<
          ChatCompletionMessageContentPartImage>
      get copyWith => _$ChatCompletionMessageContentPartImageCopyWithImpl<
          ChatCompletionMessageContentPartImage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageContentPartImageToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageContentPartImage &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageUrl);

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.image(type: $type, imageUrl: $imageUrl)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageContentPartImageCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartImageCopyWith(
          ChatCompletionMessageContentPartImage value,
          $Res Function(ChatCompletionMessageContentPartImage) _then) =
      _$ChatCompletionMessageContentPartImageCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageContentPartType type,
      @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl});

  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl;
}

/// @nodoc
class _$ChatCompletionMessageContentPartImageCopyWithImpl<$Res>
    implements $ChatCompletionMessageContentPartImageCopyWith<$Res> {
  _$ChatCompletionMessageContentPartImageCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageContentPartImage _self;
  final $Res Function(ChatCompletionMessageContentPartImage) _then;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? imageUrl = null,
  }) {
    return _then(ChatCompletionMessageContentPartImage(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      imageUrl: null == imageUrl
          ? _self.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageUrl,
    ));
  }

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl {
    return $ChatCompletionMessageImageUrlCopyWith<$Res>(_self.imageUrl,
        (value) {
      return _then(_self.copyWith(imageUrl: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionMessageContentPartAudio
    extends ChatCompletionMessageContentPart {
  const ChatCompletionMessageContentPartAudio(
      {this.type = ChatCompletionMessageContentPartType.inputAudio,
      @JsonKey(name: 'input_audio') required this.inputAudio})
      : super._();
  factory ChatCompletionMessageContentPartAudio.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionMessageContentPartAudioFromJson(json);

  /// The type of the content part. Always `input_audio`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The audio input.
  @JsonKey(name: 'input_audio')
  final ChatCompletionMessageInputAudio inputAudio;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageContentPartAudioCopyWith<
          ChatCompletionMessageContentPartAudio>
      get copyWith => _$ChatCompletionMessageContentPartAudioCopyWithImpl<
          ChatCompletionMessageContentPartAudio>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageContentPartAudioToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageContentPartAudio &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.inputAudio, inputAudio) ||
                other.inputAudio == inputAudio));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, inputAudio);

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.audio(type: $type, inputAudio: $inputAudio)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageContentPartAudioCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartAudioCopyWith(
          ChatCompletionMessageContentPartAudio value,
          $Res Function(ChatCompletionMessageContentPartAudio) _then) =
      _$ChatCompletionMessageContentPartAudioCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageContentPartType type,
      @JsonKey(name: 'input_audio')
      ChatCompletionMessageInputAudio inputAudio});

  $ChatCompletionMessageInputAudioCopyWith<$Res> get inputAudio;
}

/// @nodoc
class _$ChatCompletionMessageContentPartAudioCopyWithImpl<$Res>
    implements $ChatCompletionMessageContentPartAudioCopyWith<$Res> {
  _$ChatCompletionMessageContentPartAudioCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageContentPartAudio _self;
  final $Res Function(ChatCompletionMessageContentPartAudio) _then;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? inputAudio = null,
  }) {
    return _then(ChatCompletionMessageContentPartAudio(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      inputAudio: null == inputAudio
          ? _self.inputAudio
          : inputAudio // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageInputAudio,
    ));
  }

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageInputAudioCopyWith<$Res> get inputAudio {
    return $ChatCompletionMessageInputAudioCopyWith<$Res>(_self.inputAudio,
        (value) {
      return _then(_self.copyWith(inputAudio: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class ChatCompletionMessageContentPartRefusal
    extends ChatCompletionMessageContentPart {
  const ChatCompletionMessageContentPartRefusal(
      {this.type = ChatCompletionMessageContentPartType.refusal,
      required this.refusal})
      : super._();
  factory ChatCompletionMessageContentPartRefusal.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionMessageContentPartRefusalFromJson(json);

  /// The type of the content part, in this case `refusal`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The refusal message generated by the model.
  final String refusal;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageContentPartRefusalCopyWith<
          ChatCompletionMessageContentPartRefusal>
      get copyWith => _$ChatCompletionMessageContentPartRefusalCopyWithImpl<
          ChatCompletionMessageContentPartRefusal>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageContentPartRefusalToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageContentPartRefusal &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.refusal, refusal) || other.refusal == refusal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, refusal);

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.refusal(type: $type, refusal: $refusal)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageContentPartRefusalCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartRefusalCopyWith(
          ChatCompletionMessageContentPartRefusal value,
          $Res Function(ChatCompletionMessageContentPartRefusal) _then) =
      _$ChatCompletionMessageContentPartRefusalCopyWithImpl;
  @override
  @useResult
  $Res call({ChatCompletionMessageContentPartType type, String refusal});
}

/// @nodoc
class _$ChatCompletionMessageContentPartRefusalCopyWithImpl<$Res>
    implements $ChatCompletionMessageContentPartRefusalCopyWith<$Res> {
  _$ChatCompletionMessageContentPartRefusalCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageContentPartRefusal _self;
  final $Res Function(ChatCompletionMessageContentPartRefusal) _then;

  /// Create a copy of ChatCompletionMessageContentPart
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? refusal = null,
  }) {
    return _then(ChatCompletionMessageContentPartRefusal(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      refusal: null == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionMessageImageUrl {
  /// Either a URL of the image or the base64 encoded image data.
  String get url;

  /// Specifies the detail level of the image. Learn more in the
  /// [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding).
  ChatCompletionMessageImageDetail get detail;

  /// Create a copy of ChatCompletionMessageImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageImageUrlCopyWith<ChatCompletionMessageImageUrl>
      get copyWith => _$ChatCompletionMessageImageUrlCopyWithImpl<
              ChatCompletionMessageImageUrl>(
          this as ChatCompletionMessageImageUrl, _$identity);

  /// Serializes this ChatCompletionMessageImageUrl to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageImageUrl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @override
  String toString() {
    return 'ChatCompletionMessageImageUrl(url: $url, detail: $detail)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory $ChatCompletionMessageImageUrlCopyWith(
          ChatCompletionMessageImageUrl value,
          $Res Function(ChatCompletionMessageImageUrl) _then) =
      _$ChatCompletionMessageImageUrlCopyWithImpl;
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class _$ChatCompletionMessageImageUrlCopyWithImpl<$Res>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  _$ChatCompletionMessageImageUrlCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageImageUrl _self;
  final $Res Function(ChatCompletionMessageImageUrl) _then;

  /// Create a copy of ChatCompletionMessageImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_self.copyWith(
      url: null == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _self.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionMessageImageUrl].
extension ChatCompletionMessageImageUrlPatterns
    on ChatCompletionMessageImageUrl {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageImageUrl value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageImageUrl() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageImageUrl value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageImageUrl():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionMessageImageUrl value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageImageUrl() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String url, ChatCompletionMessageImageDetail detail)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageImageUrl() when $default != null:
        return $default(_that.url, _that.detail);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String url, ChatCompletionMessageImageDetail detail)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageImageUrl():
        return $default(_that.url, _that.detail);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String url, ChatCompletionMessageImageDetail detail)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageImageUrl() when $default != null:
        return $default(_that.url, _that.detail);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionMessageImageUrl extends ChatCompletionMessageImageUrl {
  const _ChatCompletionMessageImageUrl(
      {required this.url, this.detail = ChatCompletionMessageImageDetail.auto})
      : super._();
  factory _ChatCompletionMessageImageUrl.fromJson(Map<String, dynamic> json) =>
      _$ChatCompletionMessageImageUrlFromJson(json);

  /// Either a URL of the image or the base64 encoded image data.
  @override
  final String url;

  /// Specifies the detail level of the image. Learn more in the
  /// [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding).
  @override
  @JsonKey()
  final ChatCompletionMessageImageDetail detail;

  /// Create a copy of ChatCompletionMessageImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionMessageImageUrlCopyWith<_ChatCompletionMessageImageUrl>
      get copyWith => __$ChatCompletionMessageImageUrlCopyWithImpl<
          _ChatCompletionMessageImageUrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageImageUrlToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionMessageImageUrl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @override
  String toString() {
    return 'ChatCompletionMessageImageUrl(url: $url, detail: $detail)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionMessageImageUrlCopyWith<$Res>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory _$ChatCompletionMessageImageUrlCopyWith(
          _ChatCompletionMessageImageUrl value,
          $Res Function(_ChatCompletionMessageImageUrl) _then) =
      __$ChatCompletionMessageImageUrlCopyWithImpl;
  @override
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class __$ChatCompletionMessageImageUrlCopyWithImpl<$Res>
    implements _$ChatCompletionMessageImageUrlCopyWith<$Res> {
  __$ChatCompletionMessageImageUrlCopyWithImpl(this._self, this._then);

  final _ChatCompletionMessageImageUrl _self;
  final $Res Function(_ChatCompletionMessageImageUrl) _then;

  /// Create a copy of ChatCompletionMessageImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_ChatCompletionMessageImageUrl(
      url: null == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _self.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ));
  }
}

/// @nodoc
mixin _$ChatCompletionMessageInputAudio {
  /// Base64 encoded audio data.
  String get data;

  /// The format of the encoded audio data. Currently supports "wav" and "mp3".
  ChatCompletionMessageInputAudioFormat get format;

  /// Create a copy of ChatCompletionMessageInputAudio
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageInputAudioCopyWith<ChatCompletionMessageInputAudio>
      get copyWith => _$ChatCompletionMessageInputAudioCopyWithImpl<
              ChatCompletionMessageInputAudio>(
          this as ChatCompletionMessageInputAudio, _$identity);

  /// Serializes this ChatCompletionMessageInputAudio to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChatCompletionMessageInputAudio &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.format, format) || other.format == format));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, data, format);

  @override
  String toString() {
    return 'ChatCompletionMessageInputAudio(data: $data, format: $format)';
  }
}

/// @nodoc
abstract mixin class $ChatCompletionMessageInputAudioCopyWith<$Res> {
  factory $ChatCompletionMessageInputAudioCopyWith(
          ChatCompletionMessageInputAudio value,
          $Res Function(ChatCompletionMessageInputAudio) _then) =
      _$ChatCompletionMessageInputAudioCopyWithImpl;
  @useResult
  $Res call({String data, ChatCompletionMessageInputAudioFormat format});
}

/// @nodoc
class _$ChatCompletionMessageInputAudioCopyWithImpl<$Res>
    implements $ChatCompletionMessageInputAudioCopyWith<$Res> {
  _$ChatCompletionMessageInputAudioCopyWithImpl(this._self, this._then);

  final ChatCompletionMessageInputAudio _self;
  final $Res Function(ChatCompletionMessageInputAudio) _then;

  /// Create a copy of ChatCompletionMessageInputAudio
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? format = null,
  }) {
    return _then(_self.copyWith(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      format: null == format
          ? _self.format
          : format // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageInputAudioFormat,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChatCompletionMessageInputAudio].
extension ChatCompletionMessageInputAudioPatterns
    on ChatCompletionMessageInputAudio {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageInputAudio value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageInputAudio() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ChatCompletionMessageInputAudio value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageInputAudio():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ChatCompletionMessageInputAudio value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageInputAudio() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String data, ChatCompletionMessageInputAudioFormat format)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageInputAudio() when $default != null:
        return $default(_that.data, _that.format);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String data, ChatCompletionMessageInputAudioFormat format)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageInputAudio():
        return $default(_that.data, _that.format);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String data, ChatCompletionMessageInputAudioFormat format)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ChatCompletionMessageInputAudio() when $default != null:
        return $default(_that.data, _that.format);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ChatCompletionMessageInputAudio extends ChatCompletionMessageInputAudio {
  const _ChatCompletionMessageInputAudio(
      {required this.data, required this.format})
      : super._();
  factory _ChatCompletionMessageInputAudio.fromJson(
          Map<String, dynamic> json) =>
      _$ChatCompletionMessageInputAudioFromJson(json);

  /// Base64 encoded audio data.
  @override
  final String data;

  /// The format of the encoded audio data. Currently supports "wav" and "mp3".
  @override
  final ChatCompletionMessageInputAudioFormat format;

  /// Create a copy of ChatCompletionMessageInputAudio
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ChatCompletionMessageInputAudioCopyWith<_ChatCompletionMessageInputAudio>
      get copyWith => __$ChatCompletionMessageInputAudioCopyWithImpl<
          _ChatCompletionMessageInputAudio>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ChatCompletionMessageInputAudioToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ChatCompletionMessageInputAudio &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.format, format) || other.format == format));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, data, format);

  @override
  String toString() {
    return 'ChatCompletionMessageInputAudio(data: $data, format: $format)';
  }
}

/// @nodoc
abstract mixin class _$ChatCompletionMessageInputAudioCopyWith<$Res>
    implements $ChatCompletionMessageInputAudioCopyWith<$Res> {
  factory _$ChatCompletionMessageInputAudioCopyWith(
          _ChatCompletionMessageInputAudio value,
          $Res Function(_ChatCompletionMessageInputAudio) _then) =
      __$ChatCompletionMessageInputAudioCopyWithImpl;
  @override
  @useResult
  $Res call({String data, ChatCompletionMessageInputAudioFormat format});
}

/// @nodoc
class __$ChatCompletionMessageInputAudioCopyWithImpl<$Res>
    implements _$ChatCompletionMessageInputAudioCopyWith<$Res> {
  __$ChatCompletionMessageInputAudioCopyWithImpl(this._self, this._then);

  final _ChatCompletionMessageInputAudio _self;
  final $Res Function(_ChatCompletionMessageInputAudio) _then;

  /// Create a copy of ChatCompletionMessageInputAudio
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
    Object? format = null,
  }) {
    return _then(_ChatCompletionMessageInputAudio(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
      format: null == format
          ? _self.format
          : format // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageInputAudioFormat,
    ));
  }
}

ResponseFormat _$ResponseFormatFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'text':
      return ResponseFormatText.fromJson(json);
    case 'json_object':
      return ResponseFormatJsonObject.fromJson(json);
    case 'json_schema':
      return ResponseFormatJsonSchema.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'ResponseFormat',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ResponseFormat {
  /// The type of response format being defined.
  ResponseFormatType get type;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ResponseFormatCopyWith<ResponseFormat> get copyWith =>
      _$ResponseFormatCopyWithImpl<ResponseFormat>(
          this as ResponseFormat, _$identity);

  /// Serializes this ResponseFormat to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ResponseFormat &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ResponseFormat(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ResponseFormatCopyWith<$Res> {
  factory $ResponseFormatCopyWith(
          ResponseFormat value, $Res Function(ResponseFormat) _then) =
      _$ResponseFormatCopyWithImpl;
  @useResult
  $Res call({ResponseFormatType type});
}

/// @nodoc
class _$ResponseFormatCopyWithImpl<$Res>
    implements $ResponseFormatCopyWith<$Res> {
  _$ResponseFormatCopyWithImpl(this._self, this._then);

  final ResponseFormat _self;
  final $Res Function(ResponseFormat) _then;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ResponseFormatType,
    ));
  }
}

/// Adds pattern-matching-related methods to [ResponseFormat].
extension ResponseFormatPatterns on ResponseFormat {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ResponseFormatText value)? text,
    TResult Function(ResponseFormatJsonObject value)? jsonObject,
    TResult Function(ResponseFormatJsonSchema value)? jsonSchema,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ResponseFormatText() when text != null:
        return text(_that);
      case ResponseFormatJsonObject() when jsonObject != null:
        return jsonObject(_that);
      case ResponseFormatJsonSchema() when jsonSchema != null:
        return jsonSchema(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ResponseFormatText value) text,
    required TResult Function(ResponseFormatJsonObject value) jsonObject,
    required TResult Function(ResponseFormatJsonSchema value) jsonSchema,
  }) {
    final _that = this;
    switch (_that) {
      case ResponseFormatText():
        return text(_that);
      case ResponseFormatJsonObject():
        return jsonObject(_that);
      case ResponseFormatJsonSchema():
        return jsonSchema(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ResponseFormatText value)? text,
    TResult? Function(ResponseFormatJsonObject value)? jsonObject,
    TResult? Function(ResponseFormatJsonSchema value)? jsonSchema,
  }) {
    final _that = this;
    switch (_that) {
      case ResponseFormatText() when text != null:
        return text(_that);
      case ResponseFormatJsonObject() when jsonObject != null:
        return jsonObject(_that);
      case ResponseFormatJsonSchema() when jsonSchema != null:
        return jsonSchema(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ResponseFormatType type)? text,
    TResult Function(ResponseFormatType type)? jsonObject,
    TResult Function(ResponseFormatType type,
            @JsonKey(name: 'json_schema') JsonSchemaObject jsonSchema)?
        jsonSchema,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ResponseFormatText() when text != null:
        return text(_that.type);
      case ResponseFormatJsonObject() when jsonObject != null:
        return jsonObject(_that.type);
      case ResponseFormatJsonSchema() when jsonSchema != null:
        return jsonSchema(_that.type, _that.jsonSchema);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ResponseFormatType type) text,
    required TResult Function(ResponseFormatType type) jsonObject,
    required TResult Function(ResponseFormatType type,
            @JsonKey(name: 'json_schema') JsonSchemaObject jsonSchema)
        jsonSchema,
  }) {
    final _that = this;
    switch (_that) {
      case ResponseFormatText():
        return text(_that.type);
      case ResponseFormatJsonObject():
        return jsonObject(_that.type);
      case ResponseFormatJsonSchema():
        return jsonSchema(_that.type, _that.jsonSchema);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ResponseFormatType type)? text,
    TResult? Function(ResponseFormatType type)? jsonObject,
    TResult? Function(ResponseFormatType type,
            @JsonKey(name: 'json_schema') JsonSchemaObject jsonSchema)?
        jsonSchema,
  }) {
    final _that = this;
    switch (_that) {
      case ResponseFormatText() when text != null:
        return text(_that.type);
      case ResponseFormatJsonObject() when jsonObject != null:
        return jsonObject(_that.type);
      case ResponseFormatJsonSchema() when jsonSchema != null:
        return jsonSchema(_that.type, _that.jsonSchema);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ResponseFormatText extends ResponseFormat {
  const ResponseFormatText({this.type = ResponseFormatType.text}) : super._();
  factory ResponseFormatText.fromJson(Map<String, dynamic> json) =>
      _$ResponseFormatTextFromJson(json);

  /// The type of response format being defined.
  @override
  @JsonKey()
  final ResponseFormatType type;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ResponseFormatTextCopyWith<ResponseFormatText> get copyWith =>
      _$ResponseFormatTextCopyWithImpl<ResponseFormatText>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ResponseFormatTextToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ResponseFormatText &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ResponseFormat.text(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ResponseFormatTextCopyWith<$Res>
    implements $ResponseFormatCopyWith<$Res> {
  factory $ResponseFormatTextCopyWith(
          ResponseFormatText value, $Res Function(ResponseFormatText) _then) =
      _$ResponseFormatTextCopyWithImpl;
  @override
  @useResult
  $Res call({ResponseFormatType type});
}

/// @nodoc
class _$ResponseFormatTextCopyWithImpl<$Res>
    implements $ResponseFormatTextCopyWith<$Res> {
  _$ResponseFormatTextCopyWithImpl(this._self, this._then);

  final ResponseFormatText _self;
  final $Res Function(ResponseFormatText) _then;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
  }) {
    return _then(ResponseFormatText(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ResponseFormatType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ResponseFormatJsonObject extends ResponseFormat {
  const ResponseFormatJsonObject({this.type = ResponseFormatType.jsonObject})
      : super._();
  factory ResponseFormatJsonObject.fromJson(Map<String, dynamic> json) =>
      _$ResponseFormatJsonObjectFromJson(json);

  /// The type of response format being defined.
  @override
  @JsonKey()
  final ResponseFormatType type;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ResponseFormatJsonObjectCopyWith<ResponseFormatJsonObject> get copyWith =>
      _$ResponseFormatJsonObjectCopyWithImpl<ResponseFormatJsonObject>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ResponseFormatJsonObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ResponseFormatJsonObject &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ResponseFormat.jsonObject(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ResponseFormatJsonObjectCopyWith<$Res>
    implements $ResponseFormatCopyWith<$Res> {
  factory $ResponseFormatJsonObjectCopyWith(ResponseFormatJsonObject value,
          $Res Function(ResponseFormatJsonObject) _then) =
      _$ResponseFormatJsonObjectCopyWithImpl;
  @override
  @useResult
  $Res call({ResponseFormatType type});
}

/// @nodoc
class _$ResponseFormatJsonObjectCopyWithImpl<$Res>
    implements $ResponseFormatJsonObjectCopyWith<$Res> {
  _$ResponseFormatJsonObjectCopyWithImpl(this._self, this._then);

  final ResponseFormatJsonObject _self;
  final $Res Function(ResponseFormatJsonObject) _then;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
  }) {
    return _then(ResponseFormatJsonObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ResponseFormatType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class ResponseFormatJsonSchema extends ResponseFormat {
  const ResponseFormatJsonSchema(
      {this.type = ResponseFormatType.jsonSchema,
      @JsonKey(name: 'json_schema') required this.jsonSchema})
      : super._();
  factory ResponseFormatJsonSchema.fromJson(Map<String, dynamic> json) =>
      _$ResponseFormatJsonSchemaFromJson(json);

  /// The type of response format being defined.
  @override
  @JsonKey()
  final ResponseFormatType type;

  /// A JSON Schema object.
  @JsonKey(name: 'json_schema')
  final JsonSchemaObject jsonSchema;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ResponseFormatJsonSchemaCopyWith<ResponseFormatJsonSchema> get copyWith =>
      _$ResponseFormatJsonSchemaCopyWithImpl<ResponseFormatJsonSchema>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ResponseFormatJsonSchemaToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ResponseFormatJsonSchema &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.jsonSchema, jsonSchema) ||
                other.jsonSchema == jsonSchema));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, jsonSchema);

  @override
  String toString() {
    return 'ResponseFormat.jsonSchema(type: $type, jsonSchema: $jsonSchema)';
  }
}

/// @nodoc
abstract mixin class $ResponseFormatJsonSchemaCopyWith<$Res>
    implements $ResponseFormatCopyWith<$Res> {
  factory $ResponseFormatJsonSchemaCopyWith(ResponseFormatJsonSchema value,
          $Res Function(ResponseFormatJsonSchema) _then) =
      _$ResponseFormatJsonSchemaCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ResponseFormatType type,
      @JsonKey(name: 'json_schema') JsonSchemaObject jsonSchema});

  $JsonSchemaObjectCopyWith<$Res> get jsonSchema;
}

/// @nodoc
class _$ResponseFormatJsonSchemaCopyWithImpl<$Res>
    implements $ResponseFormatJsonSchemaCopyWith<$Res> {
  _$ResponseFormatJsonSchemaCopyWithImpl(this._self, this._then);

  final ResponseFormatJsonSchema _self;
  final $Res Function(ResponseFormatJsonSchema) _then;

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? jsonSchema = null,
  }) {
    return _then(ResponseFormatJsonSchema(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ResponseFormatType,
      jsonSchema: null == jsonSchema
          ? _self.jsonSchema
          : jsonSchema // ignore: cast_nullable_to_non_nullable
              as JsonSchemaObject,
    ));
  }

  /// Create a copy of ResponseFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $JsonSchemaObjectCopyWith<$Res> get jsonSchema {
    return $JsonSchemaObjectCopyWith<$Res>(_self.jsonSchema, (value) {
      return _then(_self.copyWith(jsonSchema: value));
    });
  }
}

ModerationInputObject _$ModerationInputObjectFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'image_url':
      return ModerationInputObjectImageUrl.fromJson(json);
    case 'text':
      return ModerationInputObjectText.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'ModerationInputObject',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ModerationInputObject {
  /// The type of the input object.
  ModerationInputObjectType get type;

  /// Create a copy of ModerationInputObject
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationInputObjectCopyWith<ModerationInputObject> get copyWith =>
      _$ModerationInputObjectCopyWithImpl<ModerationInputObject>(
          this as ModerationInputObject, _$identity);

  /// Serializes this ModerationInputObject to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInputObject &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ModerationInputObject(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ModerationInputObjectCopyWith<$Res> {
  factory $ModerationInputObjectCopyWith(ModerationInputObject value,
          $Res Function(ModerationInputObject) _then) =
      _$ModerationInputObjectCopyWithImpl;
  @useResult
  $Res call({ModerationInputObjectType type});
}

/// @nodoc
class _$ModerationInputObjectCopyWithImpl<$Res>
    implements $ModerationInputObjectCopyWith<$Res> {
  _$ModerationInputObjectCopyWithImpl(this._self, this._then);

  final ModerationInputObject _self;
  final $Res Function(ModerationInputObject) _then;

  /// Create a copy of ModerationInputObject
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ModerationInputObjectType,
    ));
  }
}

/// Adds pattern-matching-related methods to [ModerationInputObject].
extension ModerationInputObjectPatterns on ModerationInputObject {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputObjectImageUrl value)? imageUrl,
    TResult Function(ModerationInputObjectText value)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputObjectImageUrl() when imageUrl != null:
        return imageUrl(_that);
      case ModerationInputObjectText() when text != null:
        return text(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputObjectImageUrl value) imageUrl,
    required TResult Function(ModerationInputObjectText value) text,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputObjectImageUrl():
        return imageUrl(_that);
      case ModerationInputObjectText():
        return text(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputObjectImageUrl value)? imageUrl,
    TResult? Function(ModerationInputObjectText value)? text,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputObjectImageUrl() when imageUrl != null:
        return imageUrl(_that);
      case ModerationInputObjectText() when text != null:
        return text(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            ModerationInputObjectType type,
            @JsonKey(name: 'image_url')
            ModerationInputObjectImageUrlImageUrl imageUrl)?
        imageUrl,
    TResult Function(ModerationInputObjectType type, String text)? text,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputObjectImageUrl() when imageUrl != null:
        return imageUrl(_that.type, _that.imageUrl);
      case ModerationInputObjectText() when text != null:
        return text(_that.type, _that.text);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ModerationInputObjectType type,
            @JsonKey(name: 'image_url')
            ModerationInputObjectImageUrlImageUrl imageUrl)
        imageUrl,
    required TResult Function(ModerationInputObjectType type, String text) text,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputObjectImageUrl():
        return imageUrl(_that.type, _that.imageUrl);
      case ModerationInputObjectText():
        return text(_that.type, _that.text);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            ModerationInputObjectType type,
            @JsonKey(name: 'image_url')
            ModerationInputObjectImageUrlImageUrl imageUrl)?
        imageUrl,
    TResult? Function(ModerationInputObjectType type, String text)? text,
  }) {
    final _that = this;
    switch (_that) {
      case ModerationInputObjectImageUrl() when imageUrl != null:
        return imageUrl(_that.type, _that.imageUrl);
      case ModerationInputObjectText() when text != null:
        return text(_that.type, _that.text);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ModerationInputObjectImageUrl extends ModerationInputObject {
  const ModerationInputObjectImageUrl(
      {this.type = ModerationInputObjectType.imageUrl,
      @JsonKey(name: 'image_url') required this.imageUrl})
      : super._();
  factory ModerationInputObjectImageUrl.fromJson(Map<String, dynamic> json) =>
      _$ModerationInputObjectImageUrlFromJson(json);

  /// The type of the input object.
  @override
  @JsonKey()
  final ModerationInputObjectType type;

  /// Contains either an image URL or a data URL for a base64 encoded image.
  @JsonKey(name: 'image_url')
  final ModerationInputObjectImageUrlImageUrl imageUrl;

  /// Create a copy of ModerationInputObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationInputObjectImageUrlCopyWith<ModerationInputObjectImageUrl>
      get copyWith => _$ModerationInputObjectImageUrlCopyWithImpl<
          ModerationInputObjectImageUrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationInputObjectImageUrlToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInputObjectImageUrl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageUrl);

  @override
  String toString() {
    return 'ModerationInputObject.imageUrl(type: $type, imageUrl: $imageUrl)';
  }
}

/// @nodoc
abstract mixin class $ModerationInputObjectImageUrlCopyWith<$Res>
    implements $ModerationInputObjectCopyWith<$Res> {
  factory $ModerationInputObjectImageUrlCopyWith(
          ModerationInputObjectImageUrl value,
          $Res Function(ModerationInputObjectImageUrl) _then) =
      _$ModerationInputObjectImageUrlCopyWithImpl;
  @override
  @useResult
  $Res call(
      {ModerationInputObjectType type,
      @JsonKey(name: 'image_url')
      ModerationInputObjectImageUrlImageUrl imageUrl});

  $ModerationInputObjectImageUrlImageUrlCopyWith<$Res> get imageUrl;
}

/// @nodoc
class _$ModerationInputObjectImageUrlCopyWithImpl<$Res>
    implements $ModerationInputObjectImageUrlCopyWith<$Res> {
  _$ModerationInputObjectImageUrlCopyWithImpl(this._self, this._then);

  final ModerationInputObjectImageUrl _self;
  final $Res Function(ModerationInputObjectImageUrl) _then;

  /// Create a copy of ModerationInputObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? imageUrl = null,
  }) {
    return _then(ModerationInputObjectImageUrl(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ModerationInputObjectType,
      imageUrl: null == imageUrl
          ? _self.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as ModerationInputObjectImageUrlImageUrl,
    ));
  }

  /// Create a copy of ModerationInputObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModerationInputObjectImageUrlImageUrlCopyWith<$Res> get imageUrl {
    return $ModerationInputObjectImageUrlImageUrlCopyWith<$Res>(_self.imageUrl,
        (value) {
      return _then(_self.copyWith(imageUrl: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class ModerationInputObjectText extends ModerationInputObject {
  const ModerationInputObjectText(
      {this.type = ModerationInputObjectType.text, required this.text})
      : super._();
  factory ModerationInputObjectText.fromJson(Map<String, dynamic> json) =>
      _$ModerationInputObjectTextFromJson(json);

  /// The type of the input object.
  @override
  @JsonKey()
  final ModerationInputObjectType type;

  /// A string of text to classify.
  final String text;

  /// Create a copy of ModerationInputObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationInputObjectTextCopyWith<ModerationInputObjectText> get copyWith =>
      _$ModerationInputObjectTextCopyWithImpl<ModerationInputObjectText>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationInputObjectTextToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInputObjectText &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @override
  String toString() {
    return 'ModerationInputObject.text(type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class $ModerationInputObjectTextCopyWith<$Res>
    implements $ModerationInputObjectCopyWith<$Res> {
  factory $ModerationInputObjectTextCopyWith(ModerationInputObjectText value,
          $Res Function(ModerationInputObjectText) _then) =
      _$ModerationInputObjectTextCopyWithImpl;
  @override
  @useResult
  $Res call({ModerationInputObjectType type, String text});
}

/// @nodoc
class _$ModerationInputObjectTextCopyWithImpl<$Res>
    implements $ModerationInputObjectTextCopyWith<$Res> {
  _$ModerationInputObjectTextCopyWithImpl(this._self, this._then);

  final ModerationInputObjectText _self;
  final $Res Function(ModerationInputObjectText) _then;

  /// Create a copy of ModerationInputObject
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(ModerationInputObjectText(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as ModerationInputObjectType,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
mixin _$ModerationInputObjectImageUrlImageUrl {
  /// Either a URL of the image or the base64 encoded image data.
  String get url;

  /// Create a copy of ModerationInputObjectImageUrlImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ModerationInputObjectImageUrlImageUrlCopyWith<
          ModerationInputObjectImageUrlImageUrl>
      get copyWith => _$ModerationInputObjectImageUrlImageUrlCopyWithImpl<
              ModerationInputObjectImageUrlImageUrl>(
          this as ModerationInputObjectImageUrlImageUrl, _$identity);

  /// Serializes this ModerationInputObjectImageUrlImageUrl to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ModerationInputObjectImageUrlImageUrl &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url);

  @override
  String toString() {
    return 'ModerationInputObjectImageUrlImageUrl(url: $url)';
  }
}

/// @nodoc
abstract mixin class $ModerationInputObjectImageUrlImageUrlCopyWith<$Res> {
  factory $ModerationInputObjectImageUrlImageUrlCopyWith(
          ModerationInputObjectImageUrlImageUrl value,
          $Res Function(ModerationInputObjectImageUrlImageUrl) _then) =
      _$ModerationInputObjectImageUrlImageUrlCopyWithImpl;
  @useResult
  $Res call({String url});
}

/// @nodoc
class _$ModerationInputObjectImageUrlImageUrlCopyWithImpl<$Res>
    implements $ModerationInputObjectImageUrlImageUrlCopyWith<$Res> {
  _$ModerationInputObjectImageUrlImageUrlCopyWithImpl(this._self, this._then);

  final ModerationInputObjectImageUrlImageUrl _self;
  final $Res Function(ModerationInputObjectImageUrlImageUrl) _then;

  /// Create a copy of ModerationInputObjectImageUrlImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
  }) {
    return _then(_self.copyWith(
      url: null == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ModerationInputObjectImageUrlImageUrl].
extension ModerationInputObjectImageUrlImageUrlPatterns
    on ModerationInputObjectImageUrlImageUrl {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_ModerationInputObjectImageUrlImageUrl value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationInputObjectImageUrlImageUrl() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_ModerationInputObjectImageUrlImageUrl value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationInputObjectImageUrlImageUrl():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_ModerationInputObjectImageUrlImageUrl value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationInputObjectImageUrlImageUrl() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String url)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _ModerationInputObjectImageUrlImageUrl() when $default != null:
        return $default(_that.url);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String url) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationInputObjectImageUrlImageUrl():
        return $default(_that.url);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String url)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _ModerationInputObjectImageUrlImageUrl() when $default != null:
        return $default(_that.url);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _ModerationInputObjectImageUrlImageUrl
    extends ModerationInputObjectImageUrlImageUrl {
  const _ModerationInputObjectImageUrlImageUrl({required this.url}) : super._();
  factory _ModerationInputObjectImageUrlImageUrl.fromJson(
          Map<String, dynamic> json) =>
      _$ModerationInputObjectImageUrlImageUrlFromJson(json);

  /// Either a URL of the image or the base64 encoded image data.
  @override
  final String url;

  /// Create a copy of ModerationInputObjectImageUrlImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$ModerationInputObjectImageUrlImageUrlCopyWith<
          _ModerationInputObjectImageUrlImageUrl>
      get copyWith => __$ModerationInputObjectImageUrlImageUrlCopyWithImpl<
          _ModerationInputObjectImageUrlImageUrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ModerationInputObjectImageUrlImageUrlToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ModerationInputObjectImageUrlImageUrl &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, url);

  @override
  String toString() {
    return 'ModerationInputObjectImageUrlImageUrl(url: $url)';
  }
}

/// @nodoc
abstract mixin class _$ModerationInputObjectImageUrlImageUrlCopyWith<$Res>
    implements $ModerationInputObjectImageUrlImageUrlCopyWith<$Res> {
  factory _$ModerationInputObjectImageUrlImageUrlCopyWith(
          _ModerationInputObjectImageUrlImageUrl value,
          $Res Function(_ModerationInputObjectImageUrlImageUrl) _then) =
      __$ModerationInputObjectImageUrlImageUrlCopyWithImpl;
  @override
  @useResult
  $Res call({String url});
}

/// @nodoc
class __$ModerationInputObjectImageUrlImageUrlCopyWithImpl<$Res>
    implements _$ModerationInputObjectImageUrlImageUrlCopyWith<$Res> {
  __$ModerationInputObjectImageUrlImageUrlCopyWithImpl(this._self, this._then);

  final _ModerationInputObjectImageUrlImageUrl _self;
  final $Res Function(_ModerationInputObjectImageUrlImageUrl) _then;

  /// Create a copy of ModerationInputObjectImageUrlImageUrl
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? url = null,
  }) {
    return _then(_ModerationInputObjectImageUrlImageUrl(
      url: null == url
          ? _self.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

AssistantTools _$AssistantToolsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return AssistantToolsCodeInterpreter.fromJson(json);
    case 'file_search':
      return AssistantToolsFileSearch.fromJson(json);
    case 'function':
      return AssistantToolsFunction.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'AssistantTools',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$AssistantTools {
  /// The type of tool being defined: `code_interpreter`
  String get type;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantToolsCopyWith<AssistantTools> get copyWith =>
      _$AssistantToolsCopyWithImpl<AssistantTools>(
          this as AssistantTools, _$identity);

  /// Serializes this AssistantTools to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantTools &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'AssistantTools(type: $type)';
  }
}

/// @nodoc
abstract mixin class $AssistantToolsCopyWith<$Res> {
  factory $AssistantToolsCopyWith(
          AssistantTools value, $Res Function(AssistantTools) _then) =
      _$AssistantToolsCopyWithImpl;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$AssistantToolsCopyWithImpl<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  _$AssistantToolsCopyWithImpl(this._self, this._then);

  final AssistantTools _self;
  final $Res Function(AssistantTools) _then;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [AssistantTools].
extension AssistantToolsPatterns on AssistantTools {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsFileSearch value)? fileSearch,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AssistantToolsCodeInterpreter() when codeInterpreter != null:
        return codeInterpreter(_that);
      case AssistantToolsFileSearch() when fileSearch != null:
        return fileSearch(_that);
      case AssistantToolsFunction() when function != null:
        return function(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsFileSearch value) fileSearch,
    required TResult Function(AssistantToolsFunction value) function,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantToolsCodeInterpreter():
        return codeInterpreter(_that);
      case AssistantToolsFileSearch():
        return fileSearch(_that);
      case AssistantToolsFunction():
        return function(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsFileSearch value)? fileSearch,
    TResult? Function(AssistantToolsFunction value)? function,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantToolsCodeInterpreter() when codeInterpreter != null:
        return codeInterpreter(_that);
      case AssistantToolsFileSearch() when fileSearch != null:
        return fileSearch(_that);
      case AssistantToolsFunction() when function != null:
        return function(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AssistantToolsCodeInterpreter() when codeInterpreter != null:
        return codeInterpreter(_that.type);
      case AssistantToolsFileSearch() when fileSearch != null:
        return fileSearch(_that.type, _that.fileSearch);
      case AssistantToolsFunction() when function != null:
        return function(_that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)
        fileSearch,
    required TResult Function(String type, FunctionObject function) function,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantToolsCodeInterpreter():
        return codeInterpreter(_that.type);
      case AssistantToolsFileSearch():
        return fileSearch(_that.type, _that.fileSearch);
      case AssistantToolsFunction():
        return function(_that.type, _that.function);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult? Function(String type, FunctionObject function)? function,
  }) {
    final _that = this;
    switch (_that) {
      case AssistantToolsCodeInterpreter() when codeInterpreter != null:
        return codeInterpreter(_that.type);
      case AssistantToolsFileSearch() when fileSearch != null:
        return fileSearch(_that.type, _that.fileSearch);
      case AssistantToolsFunction() when function != null:
        return function(_that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class AssistantToolsCodeInterpreter extends AssistantTools {
  const AssistantToolsCodeInterpreter({this.type = 'code_interpreter'})
      : super._();
  factory AssistantToolsCodeInterpreter.fromJson(Map<String, dynamic> json) =>
      _$AssistantToolsCodeInterpreterFromJson(json);

  /// The type of tool being defined: `code_interpreter`
  @override
  @JsonKey()
  final String type;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantToolsCodeInterpreterCopyWith<AssistantToolsCodeInterpreter>
      get copyWith => _$AssistantToolsCodeInterpreterCopyWithImpl<
          AssistantToolsCodeInterpreter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantToolsCodeInterpreterToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantToolsCodeInterpreter &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'AssistantTools.codeInterpreter(type: $type)';
  }
}

/// @nodoc
abstract mixin class $AssistantToolsCodeInterpreterCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory $AssistantToolsCodeInterpreterCopyWith(
          AssistantToolsCodeInterpreter value,
          $Res Function(AssistantToolsCodeInterpreter) _then) =
      _$AssistantToolsCodeInterpreterCopyWithImpl;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$AssistantToolsCodeInterpreterCopyWithImpl<$Res>
    implements $AssistantToolsCodeInterpreterCopyWith<$Res> {
  _$AssistantToolsCodeInterpreterCopyWithImpl(this._self, this._then);

  final AssistantToolsCodeInterpreter _self;
  final $Res Function(AssistantToolsCodeInterpreter) _then;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
  }) {
    return _then(AssistantToolsCodeInterpreter(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class AssistantToolsFileSearch extends AssistantTools {
  const AssistantToolsFileSearch(
      {required this.type,
      @JsonKey(name: 'file_search', includeIfNull: false) this.fileSearch})
      : super._();
  factory AssistantToolsFileSearch.fromJson(Map<String, dynamic> json) =>
      _$AssistantToolsFileSearchFromJson(json);

  /// The type of tool being defined: `file_search`
  @override
  final String type;

  /// Overrides for the file search tool.
  @JsonKey(name: 'file_search', includeIfNull: false)
  final AssistantToolsFileSearchFileSearch? fileSearch;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantToolsFileSearchCopyWith<AssistantToolsFileSearch> get copyWith =>
      _$AssistantToolsFileSearchCopyWithImpl<AssistantToolsFileSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantToolsFileSearchToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantToolsFileSearch &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.fileSearch, fileSearch) ||
                other.fileSearch == fileSearch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, fileSearch);

  @override
  String toString() {
    return 'AssistantTools.fileSearch(type: $type, fileSearch: $fileSearch)';
  }
}

/// @nodoc
abstract mixin class $AssistantToolsFileSearchCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory $AssistantToolsFileSearchCopyWith(AssistantToolsFileSearch value,
          $Res Function(AssistantToolsFileSearch) _then) =
      _$AssistantToolsFileSearchCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'file_search', includeIfNull: false)
      AssistantToolsFileSearchFileSearch? fileSearch});

  $AssistantToolsFileSearchFileSearchCopyWith<$Res>? get fileSearch;
}

/// @nodoc
class _$AssistantToolsFileSearchCopyWithImpl<$Res>
    implements $AssistantToolsFileSearchCopyWith<$Res> {
  _$AssistantToolsFileSearchCopyWithImpl(this._self, this._then);

  final AssistantToolsFileSearch _self;
  final $Res Function(AssistantToolsFileSearch) _then;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? fileSearch = freezed,
  }) {
    return _then(AssistantToolsFileSearch(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      fileSearch: freezed == fileSearch
          ? _self.fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as AssistantToolsFileSearchFileSearch?,
    ));
  }

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AssistantToolsFileSearchFileSearchCopyWith<$Res>? get fileSearch {
    if (_self.fileSearch == null) {
      return null;
    }

    return $AssistantToolsFileSearchFileSearchCopyWith<$Res>(_self.fileSearch!,
        (value) {
      return _then(_self.copyWith(fileSearch: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class AssistantToolsFunction extends AssistantTools {
  const AssistantToolsFunction({this.type = 'function', required this.function})
      : super._();
  factory AssistantToolsFunction.fromJson(Map<String, dynamic> json) =>
      _$AssistantToolsFunctionFromJson(json);

  /// The type of tool being defined: `function`
  @override
  @JsonKey()
  final String type;

  /// A function that the model may call.
  final FunctionObject function;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantToolsFunctionCopyWith<AssistantToolsFunction> get copyWith =>
      _$AssistantToolsFunctionCopyWithImpl<AssistantToolsFunction>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantToolsFunctionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantToolsFunction &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @override
  String toString() {
    return 'AssistantTools.function(type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $AssistantToolsFunctionCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory $AssistantToolsFunctionCopyWith(AssistantToolsFunction value,
          $Res Function(AssistantToolsFunction) _then) =
      _$AssistantToolsFunctionCopyWithImpl;
  @override
  @useResult
  $Res call({String type, FunctionObject function});

  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class _$AssistantToolsFunctionCopyWithImpl<$Res>
    implements $AssistantToolsFunctionCopyWith<$Res> {
  _$AssistantToolsFunctionCopyWithImpl(this._self, this._then);

  final AssistantToolsFunction _self;
  final $Res Function(AssistantToolsFunction) _then;

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(AssistantToolsFunction(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }

  /// Create a copy of AssistantTools
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_self.function, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$AssistantToolsFileSearchFileSearch {
  /// The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models
  /// and 5 for gpt-3.5-turbo. This number should be between 1 and 50 inclusive.
  ///
  /// Note that the file search tool may output fewer than `max_num_results` results. See the
  /// [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings)
  /// for more information.
  @JsonKey(name: 'max_num_results', includeIfNull: false)
  int? get maxNumResults;

  /// The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and
  /// a score_threshold of 0.
  ///
  /// See the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings)
  /// for more information.
  @JsonKey(name: 'ranking_options', includeIfNull: false)
  FileSearchRankingOptions? get rankingOptions;

  /// Create a copy of AssistantToolsFileSearchFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantToolsFileSearchFileSearchCopyWith<
          AssistantToolsFileSearchFileSearch>
      get copyWith => _$AssistantToolsFileSearchFileSearchCopyWithImpl<
              AssistantToolsFileSearchFileSearch>(
          this as AssistantToolsFileSearchFileSearch, _$identity);

  /// Serializes this AssistantToolsFileSearchFileSearch to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantToolsFileSearchFileSearch &&
            (identical(other.maxNumResults, maxNumResults) ||
                other.maxNumResults == maxNumResults) &&
            (identical(other.rankingOptions, rankingOptions) ||
                other.rankingOptions == rankingOptions));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, maxNumResults, rankingOptions);

  @override
  String toString() {
    return 'AssistantToolsFileSearchFileSearch(maxNumResults: $maxNumResults, rankingOptions: $rankingOptions)';
  }
}

/// @nodoc
abstract mixin class $AssistantToolsFileSearchFileSearchCopyWith<$Res> {
  factory $AssistantToolsFileSearchFileSearchCopyWith(
          AssistantToolsFileSearchFileSearch value,
          $Res Function(AssistantToolsFileSearchFileSearch) _then) =
      _$AssistantToolsFileSearchFileSearchCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(name: 'max_num_results', includeIfNull: false)
      int? maxNumResults,
      @JsonKey(name: 'ranking_options', includeIfNull: false)
      FileSearchRankingOptions? rankingOptions});

  $FileSearchRankingOptionsCopyWith<$Res>? get rankingOptions;
}

/// @nodoc
class _$AssistantToolsFileSearchFileSearchCopyWithImpl<$Res>
    implements $AssistantToolsFileSearchFileSearchCopyWith<$Res> {
  _$AssistantToolsFileSearchFileSearchCopyWithImpl(this._self, this._then);

  final AssistantToolsFileSearchFileSearch _self;
  final $Res Function(AssistantToolsFileSearchFileSearch) _then;

  /// Create a copy of AssistantToolsFileSearchFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? maxNumResults = freezed,
    Object? rankingOptions = freezed,
  }) {
    return _then(_self.copyWith(
      maxNumResults: freezed == maxNumResults
          ? _self.maxNumResults
          : maxNumResults // ignore: cast_nullable_to_non_nullable
              as int?,
      rankingOptions: freezed == rankingOptions
          ? _self.rankingOptions
          : rankingOptions // ignore: cast_nullable_to_non_nullable
              as FileSearchRankingOptions?,
    ));
  }

  /// Create a copy of AssistantToolsFileSearchFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileSearchRankingOptionsCopyWith<$Res>? get rankingOptions {
    if (_self.rankingOptions == null) {
      return null;
    }

    return $FileSearchRankingOptionsCopyWith<$Res>(_self.rankingOptions!,
        (value) {
      return _then(_self.copyWith(rankingOptions: value));
    });
  }
}

/// Adds pattern-matching-related methods to [AssistantToolsFileSearchFileSearch].
extension AssistantToolsFileSearchFileSearchPatterns
    on AssistantToolsFileSearchFileSearch {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_AssistantToolsFileSearchFileSearch value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantToolsFileSearchFileSearch() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_AssistantToolsFileSearchFileSearch value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantToolsFileSearchFileSearch():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_AssistantToolsFileSearchFileSearch value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantToolsFileSearchFileSearch() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'max_num_results', includeIfNull: false)
            int? maxNumResults,
            @JsonKey(name: 'ranking_options', includeIfNull: false)
            FileSearchRankingOptions? rankingOptions)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _AssistantToolsFileSearchFileSearch() when $default != null:
        return $default(_that.maxNumResults, _that.rankingOptions);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'max_num_results', includeIfNull: false)
            int? maxNumResults,
            @JsonKey(name: 'ranking_options', includeIfNull: false)
            FileSearchRankingOptions? rankingOptions)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantToolsFileSearchFileSearch():
        return $default(_that.maxNumResults, _that.rankingOptions);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'max_num_results', includeIfNull: false)
            int? maxNumResults,
            @JsonKey(name: 'ranking_options', includeIfNull: false)
            FileSearchRankingOptions? rankingOptions)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _AssistantToolsFileSearchFileSearch() when $default != null:
        return $default(_that.maxNumResults, _that.rankingOptions);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _AssistantToolsFileSearchFileSearch
    extends AssistantToolsFileSearchFileSearch {
  const _AssistantToolsFileSearchFileSearch(
      {@JsonKey(name: 'max_num_results', includeIfNull: false)
      this.maxNumResults,
      @JsonKey(name: 'ranking_options', includeIfNull: false)
      this.rankingOptions})
      : super._();
  factory _AssistantToolsFileSearchFileSearch.fromJson(
          Map<String, dynamic> json) =>
      _$AssistantToolsFileSearchFileSearchFromJson(json);

  /// The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models
  /// and 5 for gpt-3.5-turbo. This number should be between 1 and 50 inclusive.
  ///
  /// Note that the file search tool may output fewer than `max_num_results` results. See the
  /// [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings)
  /// for more information.
  @override
  @JsonKey(name: 'max_num_results', includeIfNull: false)
  final int? maxNumResults;

  /// The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and
  /// a score_threshold of 0.
  ///
  /// See the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings)
  /// for more information.
  @override
  @JsonKey(name: 'ranking_options', includeIfNull: false)
  final FileSearchRankingOptions? rankingOptions;

  /// Create a copy of AssistantToolsFileSearchFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$AssistantToolsFileSearchFileSearchCopyWith<
          _AssistantToolsFileSearchFileSearch>
      get copyWith => __$AssistantToolsFileSearchFileSearchCopyWithImpl<
          _AssistantToolsFileSearchFileSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AssistantToolsFileSearchFileSearchToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AssistantToolsFileSearchFileSearch &&
            (identical(other.maxNumResults, maxNumResults) ||
                other.maxNumResults == maxNumResults) &&
            (identical(other.rankingOptions, rankingOptions) ||
                other.rankingOptions == rankingOptions));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, maxNumResults, rankingOptions);

  @override
  String toString() {
    return 'AssistantToolsFileSearchFileSearch(maxNumResults: $maxNumResults, rankingOptions: $rankingOptions)';
  }
}

/// @nodoc
abstract mixin class _$AssistantToolsFileSearchFileSearchCopyWith<$Res>
    implements $AssistantToolsFileSearchFileSearchCopyWith<$Res> {
  factory _$AssistantToolsFileSearchFileSearchCopyWith(
          _AssistantToolsFileSearchFileSearch value,
          $Res Function(_AssistantToolsFileSearchFileSearch) _then) =
      __$AssistantToolsFileSearchFileSearchCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'max_num_results', includeIfNull: false)
      int? maxNumResults,
      @JsonKey(name: 'ranking_options', includeIfNull: false)
      FileSearchRankingOptions? rankingOptions});

  @override
  $FileSearchRankingOptionsCopyWith<$Res>? get rankingOptions;
}

/// @nodoc
class __$AssistantToolsFileSearchFileSearchCopyWithImpl<$Res>
    implements _$AssistantToolsFileSearchFileSearchCopyWith<$Res> {
  __$AssistantToolsFileSearchFileSearchCopyWithImpl(this._self, this._then);

  final _AssistantToolsFileSearchFileSearch _self;
  final $Res Function(_AssistantToolsFileSearchFileSearch) _then;

  /// Create a copy of AssistantToolsFileSearchFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? maxNumResults = freezed,
    Object? rankingOptions = freezed,
  }) {
    return _then(_AssistantToolsFileSearchFileSearch(
      maxNumResults: freezed == maxNumResults
          ? _self.maxNumResults
          : maxNumResults // ignore: cast_nullable_to_non_nullable
              as int?,
      rankingOptions: freezed == rankingOptions
          ? _self.rankingOptions
          : rankingOptions // ignore: cast_nullable_to_non_nullable
              as FileSearchRankingOptions?,
    ));
  }

  /// Create a copy of AssistantToolsFileSearchFileSearch
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileSearchRankingOptionsCopyWith<$Res>? get rankingOptions {
    if (_self.rankingOptions == null) {
      return null;
    }

    return $FileSearchRankingOptionsCopyWith<$Res>(_self.rankingOptions!,
        (value) {
      return _then(_self.copyWith(rankingOptions: value));
    });
  }
}

MessageContent _$MessageContentFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'image_file':
      return MessageContentImageFileObject.fromJson(json);
    case 'image_url':
      return MessageContentImageUrlObject.fromJson(json);
    case 'text':
      return MessageContentTextObject.fromJson(json);
    case 'refusal':
      return MessageContentRefusalObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'MessageContent',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageContent {
  /// Always `image_file`.
  String get type;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentCopyWith<MessageContent> get copyWith =>
      _$MessageContentCopyWithImpl<MessageContent>(
          this as MessageContent, _$identity);

  /// Serializes this MessageContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContent &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'MessageContent(type: $type)';
  }
}

/// @nodoc
abstract mixin class $MessageContentCopyWith<$Res> {
  factory $MessageContentCopyWith(
          MessageContent value, $Res Function(MessageContent) _then) =
      _$MessageContentCopyWithImpl;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$MessageContentCopyWithImpl<$Res>
    implements $MessageContentCopyWith<$Res> {
  _$MessageContentCopyWithImpl(this._self, this._then);

  final MessageContent _self;
  final $Res Function(MessageContent) _then;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageContent].
extension MessageContentPatterns on MessageContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentImageUrlObject value)? imageUrl,
    TResult Function(MessageContentTextObject value)? text,
    TResult Function(MessageContentRefusalObject value)? refusal,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentImageFileObject() when imageFile != null:
        return imageFile(_that);
      case MessageContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that);
      case MessageContentTextObject() when text != null:
        return text(_that);
      case MessageContentRefusalObject() when refusal != null:
        return refusal(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentImageUrlObject value) imageUrl,
    required TResult Function(MessageContentTextObject value) text,
    required TResult Function(MessageContentRefusalObject value) refusal,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentImageFileObject():
        return imageFile(_that);
      case MessageContentImageUrlObject():
        return imageUrl(_that);
      case MessageContentTextObject():
        return text(_that);
      case MessageContentRefusalObject():
        return refusal(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentImageUrlObject value)? imageUrl,
    TResult? Function(MessageContentTextObject value)? text,
    TResult? Function(MessageContentRefusalObject value)? refusal,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentImageFileObject() when imageFile != null:
        return imageFile(_that);
      case MessageContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that);
      case MessageContentTextObject() when text != null:
        return text(_that);
      case MessageContentRefusalObject() when refusal != null:
        return refusal(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult Function(String type, MessageContentText text)? text,
    TResult Function(String type, String refusal)? refusal,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentImageFileObject() when imageFile != null:
        return imageFile(_that.type, _that.imageFile);
      case MessageContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that.type, _that.imageUrl);
      case MessageContentTextObject() when text != null:
        return text(_that.type, _that.text);
      case MessageContentRefusalObject() when refusal != null:
        return refusal(_that.type, _that.refusal);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)
        imageUrl,
    required TResult Function(String type, MessageContentText text) text,
    required TResult Function(String type, String refusal) refusal,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentImageFileObject():
        return imageFile(_that.type, _that.imageFile);
      case MessageContentImageUrlObject():
        return imageUrl(_that.type, _that.imageUrl);
      case MessageContentTextObject():
        return text(_that.type, _that.text);
      case MessageContentRefusalObject():
        return refusal(_that.type, _that.refusal);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult? Function(String type, MessageContentText text)? text,
    TResult? Function(String type, String refusal)? refusal,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentImageFileObject() when imageFile != null:
        return imageFile(_that.type, _that.imageFile);
      case MessageContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that.type, _that.imageUrl);
      case MessageContentTextObject() when text != null:
        return text(_that.type, _that.text);
      case MessageContentRefusalObject() when refusal != null:
        return refusal(_that.type, _that.refusal);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class MessageContentImageFileObject extends MessageContent {
  const MessageContentImageFileObject(
      {this.type = 'image_file',
      @JsonKey(name: 'image_file') required this.imageFile})
      : super._();
  factory MessageContentImageFileObject.fromJson(Map<String, dynamic> json) =>
      _$MessageContentImageFileObjectFromJson(json);

  /// Always `image_file`.
  @override
  @JsonKey()
  final String type;

  /// The image file that is part of a message.
  @JsonKey(name: 'image_file')
  final MessageContentImageFile imageFile;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentImageFileObjectCopyWith<MessageContentImageFileObject>
      get copyWith => _$MessageContentImageFileObjectCopyWithImpl<
          MessageContentImageFileObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentImageFileObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentImageFileObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageFile, imageFile) ||
                other.imageFile == imageFile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageFile);

  @override
  String toString() {
    return 'MessageContent.imageFile(type: $type, imageFile: $imageFile)';
  }
}

/// @nodoc
abstract mixin class $MessageContentImageFileObjectCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory $MessageContentImageFileObjectCopyWith(
          MessageContentImageFileObject value,
          $Res Function(MessageContentImageFileObject) _then) =
      _$MessageContentImageFileObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'image_file') MessageContentImageFile imageFile});

  $MessageContentImageFileCopyWith<$Res> get imageFile;
}

/// @nodoc
class _$MessageContentImageFileObjectCopyWithImpl<$Res>
    implements $MessageContentImageFileObjectCopyWith<$Res> {
  _$MessageContentImageFileObjectCopyWithImpl(this._self, this._then);

  final MessageContentImageFileObject _self;
  final $Res Function(MessageContentImageFileObject) _then;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? imageFile = null,
  }) {
    return _then(MessageContentImageFileObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageFile: null == imageFile
          ? _self.imageFile
          : imageFile // ignore: cast_nullable_to_non_nullable
              as MessageContentImageFile,
    ));
  }

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageFileCopyWith<$Res> get imageFile {
    return $MessageContentImageFileCopyWith<$Res>(_self.imageFile, (value) {
      return _then(_self.copyWith(imageFile: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageContentImageUrlObject extends MessageContent {
  const MessageContentImageUrlObject(
      {this.type = 'image_url',
      @JsonKey(name: 'image_url') required this.imageUrl})
      : super._();
  factory MessageContentImageUrlObject.fromJson(Map<String, dynamic> json) =>
      _$MessageContentImageUrlObjectFromJson(json);

  /// The type of the content part. Always `image_url`.
  @override
  @JsonKey()
  final String type;

  /// The image URL part of a message.
  @JsonKey(name: 'image_url')
  final MessageContentImageUrl imageUrl;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentImageUrlObjectCopyWith<MessageContentImageUrlObject>
      get copyWith => _$MessageContentImageUrlObjectCopyWithImpl<
          MessageContentImageUrlObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentImageUrlObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentImageUrlObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageUrl);

  @override
  String toString() {
    return 'MessageContent.imageUrl(type: $type, imageUrl: $imageUrl)';
  }
}

/// @nodoc
abstract mixin class $MessageContentImageUrlObjectCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory $MessageContentImageUrlObjectCopyWith(
          MessageContentImageUrlObject value,
          $Res Function(MessageContentImageUrlObject) _then) =
      _$MessageContentImageUrlObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl});

  $MessageContentImageUrlCopyWith<$Res> get imageUrl;
}

/// @nodoc
class _$MessageContentImageUrlObjectCopyWithImpl<$Res>
    implements $MessageContentImageUrlObjectCopyWith<$Res> {
  _$MessageContentImageUrlObjectCopyWithImpl(this._self, this._then);

  final MessageContentImageUrlObject _self;
  final $Res Function(MessageContentImageUrlObject) _then;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? imageUrl = null,
  }) {
    return _then(MessageContentImageUrlObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageUrl: null == imageUrl
          ? _self.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as MessageContentImageUrl,
    ));
  }

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageUrlCopyWith<$Res> get imageUrl {
    return $MessageContentImageUrlCopyWith<$Res>(_self.imageUrl, (value) {
      return _then(_self.copyWith(imageUrl: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageContentTextObject extends MessageContent {
  const MessageContentTextObject({this.type = 'text', required this.text})
      : super._();
  factory MessageContentTextObject.fromJson(Map<String, dynamic> json) =>
      _$MessageContentTextObjectFromJson(json);

  /// Always `text`.
  @override
  @JsonKey()
  final String type;

  /// The text content that is part of a message.
  final MessageContentText text;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentTextObjectCopyWith<MessageContentTextObject> get copyWith =>
      _$MessageContentTextObjectCopyWithImpl<MessageContentTextObject>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentTextObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentTextObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @override
  String toString() {
    return 'MessageContent.text(type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class $MessageContentTextObjectCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory $MessageContentTextObjectCopyWith(MessageContentTextObject value,
          $Res Function(MessageContentTextObject) _then) =
      _$MessageContentTextObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String type, MessageContentText text});

  $MessageContentTextCopyWith<$Res> get text;
}

/// @nodoc
class _$MessageContentTextObjectCopyWithImpl<$Res>
    implements $MessageContentTextObjectCopyWith<$Res> {
  _$MessageContentTextObjectCopyWithImpl(this._self, this._then);

  final MessageContentTextObject _self;
  final $Res Function(MessageContentTextObject) _then;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(MessageContentTextObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as MessageContentText,
    ));
  }

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextCopyWith<$Res> get text {
    return $MessageContentTextCopyWith<$Res>(_self.text, (value) {
      return _then(_self.copyWith(text: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageContentRefusalObject extends MessageContent {
  const MessageContentRefusalObject({required this.type, required this.refusal})
      : super._();
  factory MessageContentRefusalObject.fromJson(Map<String, dynamic> json) =>
      _$MessageContentRefusalObjectFromJson(json);

  /// Always `refusal`.
  @override
  final String type;

  /// No Description
  final String refusal;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentRefusalObjectCopyWith<MessageContentRefusalObject>
      get copyWith => _$MessageContentRefusalObjectCopyWithImpl<
          MessageContentRefusalObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentRefusalObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentRefusalObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.refusal, refusal) || other.refusal == refusal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, refusal);

  @override
  String toString() {
    return 'MessageContent.refusal(type: $type, refusal: $refusal)';
  }
}

/// @nodoc
abstract mixin class $MessageContentRefusalObjectCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory $MessageContentRefusalObjectCopyWith(
          MessageContentRefusalObject value,
          $Res Function(MessageContentRefusalObject) _then) =
      _$MessageContentRefusalObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String type, String refusal});
}

/// @nodoc
class _$MessageContentRefusalObjectCopyWithImpl<$Res>
    implements $MessageContentRefusalObjectCopyWith<$Res> {
  _$MessageContentRefusalObjectCopyWithImpl(this._self, this._then);

  final MessageContentRefusalObject _self;
  final $Res Function(MessageContentRefusalObject) _then;

  /// Create a copy of MessageContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? refusal = null,
  }) {
    return _then(MessageContentRefusalObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      refusal: null == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

MessageDeltaContent _$MessageDeltaContentFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'image_file':
      return MessageDeltaContentImageFileObject.fromJson(json);
    case 'text':
      return MessageDeltaContentTextObject.fromJson(json);
    case 'refusal':
      return MessageDeltaContentRefusalObject.fromJson(json);
    case 'image_url':
      return MessageDeltaContentImageUrlObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'MessageDeltaContent',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageDeltaContent {
  /// The index of the content part in the message.
  int get index;

  /// Always `image_file`.
  String get type;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentCopyWith<MessageDeltaContent> get copyWith =>
      _$MessageDeltaContentCopyWithImpl<MessageDeltaContent>(
          this as MessageDeltaContent, _$identity);

  /// Serializes this MessageDeltaContent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContent &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type);

  @override
  String toString() {
    return 'MessageDeltaContent(index: $index, type: $type)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentCopyWith<$Res> {
  factory $MessageDeltaContentCopyWith(
          MessageDeltaContent value, $Res Function(MessageDeltaContent) _then) =
      _$MessageDeltaContentCopyWithImpl;
  @useResult
  $Res call({int index, String type});
}

/// @nodoc
class _$MessageDeltaContentCopyWithImpl<$Res>
    implements $MessageDeltaContentCopyWith<$Res> {
  _$MessageDeltaContentCopyWithImpl(this._self, this._then);

  final MessageDeltaContent _self;
  final $Res Function(MessageDeltaContent) _then;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageDeltaContent].
extension MessageDeltaContentPatterns on MessageDeltaContent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult Function(MessageDeltaContentTextObject value)? text,
    TResult Function(MessageDeltaContentRefusalObject value)? refusal,
    TResult Function(MessageDeltaContentImageUrlObject value)? imageUrl,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentImageFileObject() when imageFile != null:
        return imageFile(_that);
      case MessageDeltaContentTextObject() when text != null:
        return text(_that);
      case MessageDeltaContentRefusalObject() when refusal != null:
        return refusal(_that);
      case MessageDeltaContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageDeltaContentImageFileObject value)
        imageFile,
    required TResult Function(MessageDeltaContentTextObject value) text,
    required TResult Function(MessageDeltaContentRefusalObject value) refusal,
    required TResult Function(MessageDeltaContentImageUrlObject value) imageUrl,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentImageFileObject():
        return imageFile(_that);
      case MessageDeltaContentTextObject():
        return text(_that);
      case MessageDeltaContentRefusalObject():
        return refusal(_that);
      case MessageDeltaContentImageUrlObject():
        return imageUrl(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult? Function(MessageDeltaContentTextObject value)? text,
    TResult? Function(MessageDeltaContentRefusalObject value)? refusal,
    TResult? Function(MessageDeltaContentImageUrlObject value)? imageUrl,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentImageFileObject() when imageFile != null:
        return imageFile(_that);
      case MessageDeltaContentTextObject() when text != null:
        return text(_that);
      case MessageDeltaContentRefusalObject() when refusal != null:
        return refusal(_that);
      case MessageDeltaContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) String? refusal)?
        refusal,
    TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_url', includeIfNull: false)
            MessageContentImageUrl? imageUrl)?
        imageUrl,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentImageFileObject() when imageFile != null:
        return imageFile(_that.index, _that.type, _that.imageFile);
      case MessageDeltaContentTextObject() when text != null:
        return text(_that.index, _that.type, _that.text);
      case MessageDeltaContentRefusalObject() when refusal != null:
        return refusal(_that.index, _that.type, _that.refusal);
      case MessageDeltaContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that.index, _that.type, _that.imageUrl);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)
        imageFile,
    required TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)
        text,
    required TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) String? refusal)
        refusal,
    required TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_url', includeIfNull: false)
            MessageContentImageUrl? imageUrl)
        imageUrl,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentImageFileObject():
        return imageFile(_that.index, _that.type, _that.imageFile);
      case MessageDeltaContentTextObject():
        return text(_that.index, _that.type, _that.text);
      case MessageDeltaContentRefusalObject():
        return refusal(_that.index, _that.type, _that.refusal);
      case MessageDeltaContentImageUrlObject():
        return imageUrl(_that.index, _that.type, _that.imageUrl);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) String? refusal)?
        refusal,
    TResult? Function(
            int index,
            String type,
            @JsonKey(name: 'image_url', includeIfNull: false)
            MessageContentImageUrl? imageUrl)?
        imageUrl,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentImageFileObject() when imageFile != null:
        return imageFile(_that.index, _that.type, _that.imageFile);
      case MessageDeltaContentTextObject() when text != null:
        return text(_that.index, _that.type, _that.text);
      case MessageDeltaContentRefusalObject() when refusal != null:
        return refusal(_that.index, _that.type, _that.refusal);
      case MessageDeltaContentImageUrlObject() when imageUrl != null:
        return imageUrl(_that.index, _that.type, _that.imageUrl);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class MessageDeltaContentImageFileObject extends MessageDeltaContent {
  const MessageDeltaContentImageFileObject(
      {required this.index,
      required this.type,
      @JsonKey(name: 'image_file', includeIfNull: false) this.imageFile})
      : super._();
  factory MessageDeltaContentImageFileObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageDeltaContentImageFileObjectFromJson(json);

  /// The index of the content part in the message.
  @override
  final int index;

  /// Always `image_file`.
  @override
  final String type;

  /// The image file that is part of a message.
  @JsonKey(name: 'image_file', includeIfNull: false)
  final MessageContentImageFile? imageFile;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentImageFileObjectCopyWith<
          MessageDeltaContentImageFileObject>
      get copyWith => _$MessageDeltaContentImageFileObjectCopyWithImpl<
          MessageDeltaContentImageFileObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentImageFileObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentImageFileObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageFile, imageFile) ||
                other.imageFile == imageFile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, imageFile);

  @override
  String toString() {
    return 'MessageDeltaContent.imageFile(index: $index, type: $type, imageFile: $imageFile)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentImageFileObjectCopyWith<$Res>
    implements $MessageDeltaContentCopyWith<$Res> {
  factory $MessageDeltaContentImageFileObjectCopyWith(
          MessageDeltaContentImageFileObject value,
          $Res Function(MessageDeltaContentImageFileObject) _then) =
      _$MessageDeltaContentImageFileObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(name: 'image_file', includeIfNull: false)
      MessageContentImageFile? imageFile});

  $MessageContentImageFileCopyWith<$Res>? get imageFile;
}

/// @nodoc
class _$MessageDeltaContentImageFileObjectCopyWithImpl<$Res>
    implements $MessageDeltaContentImageFileObjectCopyWith<$Res> {
  _$MessageDeltaContentImageFileObjectCopyWithImpl(this._self, this._then);

  final MessageDeltaContentImageFileObject _self;
  final $Res Function(MessageDeltaContentImageFileObject) _then;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? imageFile = freezed,
  }) {
    return _then(MessageDeltaContentImageFileObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageFile: freezed == imageFile
          ? _self.imageFile
          : imageFile // ignore: cast_nullable_to_non_nullable
              as MessageContentImageFile?,
    ));
  }

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageFileCopyWith<$Res>? get imageFile {
    if (_self.imageFile == null) {
      return null;
    }

    return $MessageContentImageFileCopyWith<$Res>(_self.imageFile!, (value) {
      return _then(_self.copyWith(imageFile: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageDeltaContentTextObject extends MessageDeltaContent {
  const MessageDeltaContentTextObject(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.text})
      : super._();
  factory MessageDeltaContentTextObject.fromJson(Map<String, dynamic> json) =>
      _$MessageDeltaContentTextObjectFromJson(json);

  /// The index of the content part in the message.
  @override
  final int index;

  /// Always `text`.
  @override
  final String type;

  /// The text content that is part of a message.
  @JsonKey(includeIfNull: false)
  final MessageDeltaContentText? text;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextObjectCopyWith<MessageDeltaContentTextObject>
      get copyWith => _$MessageDeltaContentTextObjectCopyWithImpl<
          MessageDeltaContentTextObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentTextObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentTextObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, text);

  @override
  String toString() {
    return 'MessageDeltaContent.text(index: $index, type: $type, text: $text)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentTextObjectCopyWith<$Res>
    implements $MessageDeltaContentCopyWith<$Res> {
  factory $MessageDeltaContentTextObjectCopyWith(
          MessageDeltaContentTextObject value,
          $Res Function(MessageDeltaContentTextObject) _then) =
      _$MessageDeltaContentTextObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) MessageDeltaContentText? text});

  $MessageDeltaContentTextCopyWith<$Res>? get text;
}

/// @nodoc
class _$MessageDeltaContentTextObjectCopyWithImpl<$Res>
    implements $MessageDeltaContentTextObjectCopyWith<$Res> {
  _$MessageDeltaContentTextObjectCopyWithImpl(this._self, this._then);

  final MessageDeltaContentTextObject _self;
  final $Res Function(MessageDeltaContentTextObject) _then;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
  }) {
    return _then(MessageDeltaContentTextObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as MessageDeltaContentText?,
    ));
  }

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextCopyWith<$Res>? get text {
    if (_self.text == null) {
      return null;
    }

    return $MessageDeltaContentTextCopyWith<$Res>(_self.text!, (value) {
      return _then(_self.copyWith(text: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageDeltaContentRefusalObject extends MessageDeltaContent {
  const MessageDeltaContentRefusalObject(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.refusal})
      : super._();
  factory MessageDeltaContentRefusalObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageDeltaContentRefusalObjectFromJson(json);

  /// The index of the refusal part in the message.
  @override
  final int index;

  /// Always `refusal`.
  @override
  final String type;

  /// The refusal content generated by the assistant.
  @JsonKey(includeIfNull: false)
  final String? refusal;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentRefusalObjectCopyWith<MessageDeltaContentRefusalObject>
      get copyWith => _$MessageDeltaContentRefusalObjectCopyWithImpl<
          MessageDeltaContentRefusalObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentRefusalObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentRefusalObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.refusal, refusal) || other.refusal == refusal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, refusal);

  @override
  String toString() {
    return 'MessageDeltaContent.refusal(index: $index, type: $type, refusal: $refusal)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentRefusalObjectCopyWith<$Res>
    implements $MessageDeltaContentCopyWith<$Res> {
  factory $MessageDeltaContentRefusalObjectCopyWith(
          MessageDeltaContentRefusalObject value,
          $Res Function(MessageDeltaContentRefusalObject) _then) =
      _$MessageDeltaContentRefusalObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index, String type, @JsonKey(includeIfNull: false) String? refusal});
}

/// @nodoc
class _$MessageDeltaContentRefusalObjectCopyWithImpl<$Res>
    implements $MessageDeltaContentRefusalObjectCopyWith<$Res> {
  _$MessageDeltaContentRefusalObjectCopyWithImpl(this._self, this._then);

  final MessageDeltaContentRefusalObject _self;
  final $Res Function(MessageDeltaContentRefusalObject) _then;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? refusal = freezed,
  }) {
    return _then(MessageDeltaContentRefusalObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      refusal: freezed == refusal
          ? _self.refusal
          : refusal // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class MessageDeltaContentImageUrlObject extends MessageDeltaContent {
  const MessageDeltaContentImageUrlObject(
      {required this.index,
      required this.type,
      @JsonKey(name: 'image_url', includeIfNull: false) this.imageUrl})
      : super._();
  factory MessageDeltaContentImageUrlObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageDeltaContentImageUrlObjectFromJson(json);

  /// The index of the content part in the message.
  @override
  final int index;

  /// Always `image_url`.
  @override
  final String type;

  /// The image URL part of a message.
  @JsonKey(name: 'image_url', includeIfNull: false)
  final MessageContentImageUrl? imageUrl;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentImageUrlObjectCopyWith<MessageDeltaContentImageUrlObject>
      get copyWith => _$MessageDeltaContentImageUrlObjectCopyWithImpl<
          MessageDeltaContentImageUrlObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentImageUrlObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentImageUrlObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, imageUrl);

  @override
  String toString() {
    return 'MessageDeltaContent.imageUrl(index: $index, type: $type, imageUrl: $imageUrl)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentImageUrlObjectCopyWith<$Res>
    implements $MessageDeltaContentCopyWith<$Res> {
  factory $MessageDeltaContentImageUrlObjectCopyWith(
          MessageDeltaContentImageUrlObject value,
          $Res Function(MessageDeltaContentImageUrlObject) _then) =
      _$MessageDeltaContentImageUrlObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(name: 'image_url', includeIfNull: false)
      MessageContentImageUrl? imageUrl});

  $MessageContentImageUrlCopyWith<$Res>? get imageUrl;
}

/// @nodoc
class _$MessageDeltaContentImageUrlObjectCopyWithImpl<$Res>
    implements $MessageDeltaContentImageUrlObjectCopyWith<$Res> {
  _$MessageDeltaContentImageUrlObjectCopyWithImpl(this._self, this._then);

  final MessageDeltaContentImageUrlObject _self;
  final $Res Function(MessageDeltaContentImageUrlObject) _then;

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? imageUrl = freezed,
  }) {
    return _then(MessageDeltaContentImageUrlObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageUrl: freezed == imageUrl
          ? _self.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as MessageContentImageUrl?,
    ));
  }

  /// Create a copy of MessageDeltaContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageUrlCopyWith<$Res>? get imageUrl {
    if (_self.imageUrl == null) {
      return null;
    }

    return $MessageContentImageUrlCopyWith<$Res>(_self.imageUrl!, (value) {
      return _then(_self.copyWith(imageUrl: value));
    });
  }
}

MessageContentTextAnnotations _$MessageContentTextAnnotationsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'file_citation':
      return MessageContentTextAnnotationsFileCitationObject.fromJson(json);
    case 'file_path':
      return MessageContentTextAnnotationsFilePathObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'MessageContentTextAnnotations',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageContentTextAnnotations {
  /// Always `file_citation`.
  String get type;

  /// The text in the message content that needs to be replaced.
  String get text;

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index')
  int get startIndex;

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index')
  int get endIndex;

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsCopyWith<MessageContentTextAnnotations>
      get copyWith => _$MessageContentTextAnnotationsCopyWithImpl<
              MessageContentTextAnnotations>(
          this as MessageContentTextAnnotations, _$identity);

  /// Serializes this MessageContentTextAnnotations to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentTextAnnotations &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, text, startIndex, endIndex);

  @override
  String toString() {
    return 'MessageContentTextAnnotations(type: $type, text: $text, startIndex: $startIndex, endIndex: $endIndex)';
  }
}

/// @nodoc
abstract mixin class $MessageContentTextAnnotationsCopyWith<$Res> {
  factory $MessageContentTextAnnotationsCopyWith(
          MessageContentTextAnnotations value,
          $Res Function(MessageContentTextAnnotations) _then) =
      _$MessageContentTextAnnotationsCopyWithImpl;
  @useResult
  $Res call(
      {String type,
      String text,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});
}

/// @nodoc
class _$MessageContentTextAnnotationsCopyWithImpl<$Res>
    implements $MessageContentTextAnnotationsCopyWith<$Res> {
  _$MessageContentTextAnnotationsCopyWithImpl(this._self, this._then);

  final MessageContentTextAnnotations _self;
  final $Res Function(MessageContentTextAnnotations) _then;

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      startIndex: null == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageContentTextAnnotations].
extension MessageContentTextAnnotationsPatterns
    on MessageContentTextAnnotations {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that);
      case MessageContentTextAnnotationsFilePathObject() when filePath != null:
        return filePath(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(MessageContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentTextAnnotationsFileCitationObject():
        return fileCitation(_that);
      case MessageContentTextAnnotationsFilePathObject():
        return filePath(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that);
      case MessageContentTextAnnotationsFilePathObject() when filePath != null:
        return filePath(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that.type, _that.text, _that.fileCitation,
            _that.startIndex, _that.endIndex);
      case MessageContentTextAnnotationsFilePathObject() when filePath != null:
        return filePath(_that.type, _that.text, _that.filePath,
            _that.startIndex, _that.endIndex);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        fileCitation,
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentTextAnnotationsFileCitationObject():
        return fileCitation(_that.type, _that.text, _that.fileCitation,
            _that.startIndex, _that.endIndex);
      case MessageContentTextAnnotationsFilePathObject():
        return filePath(_that.type, _that.text, _that.filePath,
            _that.startIndex, _that.endIndex);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that.type, _that.text, _that.fileCitation,
            _that.startIndex, _that.endIndex);
      case MessageContentTextAnnotationsFilePathObject() when filePath != null:
        return filePath(_that.type, _that.text, _that.filePath,
            _that.startIndex, _that.endIndex);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class MessageContentTextAnnotationsFileCitationObject
    extends MessageContentTextAnnotations {
  const MessageContentTextAnnotationsFileCitationObject(
      {required this.type,
      required this.text,
      @JsonKey(name: 'file_citation') required this.fileCitation,
      @JsonKey(name: 'start_index') required this.startIndex,
      @JsonKey(name: 'end_index') required this.endIndex})
      : super._();
  factory MessageContentTextAnnotationsFileCitationObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageContentTextAnnotationsFileCitationObjectFromJson(json);

  /// Always `file_citation`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  final String text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @JsonKey(name: 'file_citation')
  final MessageContentTextAnnotationsFileCitation fileCitation;

  /// The start index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'start_index')
  final int startIndex;

  /// The end index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'end_index')
  final int endIndex;

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFileCitationObjectCopyWith<
          MessageContentTextAnnotationsFileCitationObject>
      get copyWith =>
          _$MessageContentTextAnnotationsFileCitationObjectCopyWithImpl<
                  MessageContentTextAnnotationsFileCitationObject>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentTextAnnotationsFileCitationObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentTextAnnotationsFileCitationObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.fileCitation, fileCitation) ||
                other.fileCitation == fileCitation) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, text, fileCitation, startIndex, endIndex);

  @override
  String toString() {
    return 'MessageContentTextAnnotations.fileCitation(type: $type, text: $text, fileCitation: $fileCitation, startIndex: $startIndex, endIndex: $endIndex)';
  }
}

/// @nodoc
abstract mixin class $MessageContentTextAnnotationsFileCitationObjectCopyWith<
    $Res> implements $MessageContentTextAnnotationsCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFileCitationObjectCopyWith(
          MessageContentTextAnnotationsFileCitationObject value,
          $Res Function(MessageContentTextAnnotationsFileCitationObject)
              _then) =
      _$MessageContentTextAnnotationsFileCitationObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      String text,
      @JsonKey(name: 'file_citation')
      MessageContentTextAnnotationsFileCitation fileCitation,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});

  $MessageContentTextAnnotationsFileCitationCopyWith<$Res> get fileCitation;
}

/// @nodoc
class _$MessageContentTextAnnotationsFileCitationObjectCopyWithImpl<$Res>
    implements $MessageContentTextAnnotationsFileCitationObjectCopyWith<$Res> {
  _$MessageContentTextAnnotationsFileCitationObjectCopyWithImpl(
      this._self, this._then);

  final MessageContentTextAnnotationsFileCitationObject _self;
  final $Res Function(MessageContentTextAnnotationsFileCitationObject) _then;

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? fileCitation = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(MessageContentTextAnnotationsFileCitationObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      fileCitation: null == fileCitation
          ? _self.fileCitation
          : fileCitation // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFileCitation,
      startIndex: null == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFileCitationCopyWith<$Res> get fileCitation {
    return $MessageContentTextAnnotationsFileCitationCopyWith<$Res>(
        _self.fileCitation, (value) {
      return _then(_self.copyWith(fileCitation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageContentTextAnnotationsFilePathObject
    extends MessageContentTextAnnotations {
  const MessageContentTextAnnotationsFilePathObject(
      {required this.type,
      required this.text,
      @JsonKey(name: 'file_path') required this.filePath,
      @JsonKey(name: 'start_index') required this.startIndex,
      @JsonKey(name: 'end_index') required this.endIndex})
      : super._();
  factory MessageContentTextAnnotationsFilePathObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageContentTextAnnotationsFilePathObjectFromJson(json);

  /// Always `file_path`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  final String text;

  /// No Description
  @JsonKey(name: 'file_path')
  final MessageContentTextAnnotationsFilePath filePath;

  /// No Description
  @override
  @JsonKey(name: 'start_index')
  final int startIndex;

  /// No Description
  @override
  @JsonKey(name: 'end_index')
  final int endIndex;

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFilePathObjectCopyWith<
          MessageContentTextAnnotationsFilePathObject>
      get copyWith => _$MessageContentTextAnnotationsFilePathObjectCopyWithImpl<
          MessageContentTextAnnotationsFilePathObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentTextAnnotationsFilePathObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentTextAnnotationsFilePathObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.filePath, filePath) ||
                other.filePath == filePath) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, text, filePath, startIndex, endIndex);

  @override
  String toString() {
    return 'MessageContentTextAnnotations.filePath(type: $type, text: $text, filePath: $filePath, startIndex: $startIndex, endIndex: $endIndex)';
  }
}

/// @nodoc
abstract mixin class $MessageContentTextAnnotationsFilePathObjectCopyWith<$Res>
    implements $MessageContentTextAnnotationsCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFilePathObjectCopyWith(
          MessageContentTextAnnotationsFilePathObject value,
          $Res Function(MessageContentTextAnnotationsFilePathObject) _then) =
      _$MessageContentTextAnnotationsFilePathObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      String text,
      @JsonKey(name: 'file_path')
      MessageContentTextAnnotationsFilePath filePath,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});

  $MessageContentTextAnnotationsFilePathCopyWith<$Res> get filePath;
}

/// @nodoc
class _$MessageContentTextAnnotationsFilePathObjectCopyWithImpl<$Res>
    implements $MessageContentTextAnnotationsFilePathObjectCopyWith<$Res> {
  _$MessageContentTextAnnotationsFilePathObjectCopyWithImpl(
      this._self, this._then);

  final MessageContentTextAnnotationsFilePathObject _self;
  final $Res Function(MessageContentTextAnnotationsFilePathObject) _then;

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? filePath = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(MessageContentTextAnnotationsFilePathObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      filePath: null == filePath
          ? _self.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFilePath,
      startIndex: null == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  /// Create a copy of MessageContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFilePathCopyWith<$Res> get filePath {
    return $MessageContentTextAnnotationsFilePathCopyWith<$Res>(_self.filePath,
        (value) {
      return _then(_self.copyWith(filePath: value));
    });
  }
}

/// @nodoc
mixin _$MessageContentTextAnnotationsFilePath {
  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id')
  String get fileId;

  /// Create a copy of MessageContentTextAnnotationsFilePath
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFilePathCopyWith<
          MessageContentTextAnnotationsFilePath>
      get copyWith => _$MessageContentTextAnnotationsFilePathCopyWithImpl<
              MessageContentTextAnnotationsFilePath>(
          this as MessageContentTextAnnotationsFilePath, _$identity);

  /// Serializes this MessageContentTextAnnotationsFilePath to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageContentTextAnnotationsFilePath &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFilePath(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFilePathCopyWith(
          MessageContentTextAnnotationsFilePath value,
          $Res Function(MessageContentTextAnnotationsFilePath) _then) =
      _$MessageContentTextAnnotationsFilePathCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res>
    implements $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  _$MessageContentTextAnnotationsFilePathCopyWithImpl(this._self, this._then);

  final MessageContentTextAnnotationsFilePath _self;
  final $Res Function(MessageContentTextAnnotationsFilePath) _then;

  /// Create a copy of MessageContentTextAnnotationsFilePath
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_self.copyWith(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageContentTextAnnotationsFilePath].
extension MessageContentTextAnnotationsFilePathPatterns
    on MessageContentTextAnnotationsFilePath {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MessageContentTextAnnotationsFilePath value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFilePath() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MessageContentTextAnnotationsFilePath value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFilePath():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MessageContentTextAnnotationsFilePath value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFilePath() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFilePath() when $default != null:
        return $default(_that.fileId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(@JsonKey(name: 'file_id') String fileId) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFilePath():
        return $default(_that.fileId);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(@JsonKey(name: 'file_id') String fileId)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageContentTextAnnotationsFilePath() when $default != null:
        return $default(_that.fileId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageContentTextAnnotationsFilePath
    extends MessageContentTextAnnotationsFilePath {
  const _MessageContentTextAnnotationsFilePath(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();
  factory _MessageContentTextAnnotationsFilePath.fromJson(
          Map<String, dynamic> json) =>
      _$MessageContentTextAnnotationsFilePathFromJson(json);

  /// The ID of the file that was generated.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// Create a copy of MessageContentTextAnnotationsFilePath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageContentTextAnnotationsFilePathCopyWith<
          _MessageContentTextAnnotationsFilePath>
      get copyWith => __$MessageContentTextAnnotationsFilePathCopyWithImpl<
          _MessageContentTextAnnotationsFilePath>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageContentTextAnnotationsFilePathToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MessageContentTextAnnotationsFilePath &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFilePath(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class _$MessageContentTextAnnotationsFilePathCopyWith<$Res>
    implements $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  factory _$MessageContentTextAnnotationsFilePathCopyWith(
          _MessageContentTextAnnotationsFilePath value,
          $Res Function(_MessageContentTextAnnotationsFilePath) _then) =
      __$MessageContentTextAnnotationsFilePathCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res>
    implements _$MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  __$MessageContentTextAnnotationsFilePathCopyWithImpl(this._self, this._then);

  final _MessageContentTextAnnotationsFilePath _self;
  final $Res Function(_MessageContentTextAnnotationsFilePath) _then;

  /// Create a copy of MessageContentTextAnnotationsFilePath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_MessageContentTextAnnotationsFilePath(
      fileId: null == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

MessageDeltaContentTextAnnotations _$MessageDeltaContentTextAnnotationsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'file_citation':
      return MessageDeltaContentTextAnnotationsFileCitationObject.fromJson(
          json);
    case 'file_path':
      return MessageDeltaContentTextAnnotationsFilePathObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'MessageDeltaContentTextAnnotations',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageDeltaContentTextAnnotations {
  /// The index of the annotation in the text content part.
  int get index;

  /// Always `file_citation`.
  String get type;

  /// The text in the message content that needs to be replaced.
  @JsonKey(includeIfNull: false)
  String? get text;

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index', includeIfNull: false)
  int? get startIndex;

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index', includeIfNull: false)
  int? get endIndex;

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsCopyWith<
          MessageDeltaContentTextAnnotations>
      get copyWith => _$MessageDeltaContentTextAnnotationsCopyWithImpl<
              MessageDeltaContentTextAnnotations>(
          this as MessageDeltaContentTextAnnotations, _$identity);

  /// Serializes this MessageDeltaContentTextAnnotations to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentTextAnnotations &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, index, type, text, startIndex, endIndex);

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotations(index: $index, type: $type, text: $text, startIndex: $startIndex, endIndex: $endIndex)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  factory $MessageDeltaContentTextAnnotationsCopyWith(
          MessageDeltaContentTextAnnotations value,
          $Res Function(MessageDeltaContentTextAnnotations) _then) =
      _$MessageDeltaContentTextAnnotationsCopyWithImpl;
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) String? text,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex});
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsCopyWithImpl<$Res>
    implements $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  _$MessageDeltaContentTextAnnotationsCopyWithImpl(this._self, this._then);

  final MessageDeltaContentTextAnnotations _self;
  final $Res Function(MessageDeltaContentTextAnnotations) _then;

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
    Object? startIndex = freezed,
    Object? endIndex = freezed,
  }) {
    return _then(_self.copyWith(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      startIndex: freezed == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      endIndex: freezed == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageDeltaContentTextAnnotations].
extension MessageDeltaContentTextAnnotationsPatterns
    on MessageDeltaContentTextAnnotations {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that);
      case MessageDeltaContentTextAnnotationsFilePathObject()
          when filePath != null:
        return filePath(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(
            MessageDeltaContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentTextAnnotationsFileCitationObject():
        return fileCitation(_that);
      case MessageDeltaContentTextAnnotationsFilePathObject():
        return filePath(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that);
      case MessageDeltaContentTextAnnotationsFilePathObject()
          when filePath != null:
        return filePath(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that.index, _that.type, _that.text,
            _that.fileCitation, _that.startIndex, _that.endIndex);
      case MessageDeltaContentTextAnnotationsFilePathObject()
          when filePath != null:
        return filePath(_that.index, _that.type, _that.text, _that.filePath,
            _that.startIndex, _that.endIndex);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        fileCitation,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentTextAnnotationsFileCitationObject():
        return fileCitation(_that.index, _that.type, _that.text,
            _that.fileCitation, _that.startIndex, _that.endIndex);
      case MessageDeltaContentTextAnnotationsFilePathObject():
        return filePath(_that.index, _that.type, _that.text, _that.filePath,
            _that.startIndex, _that.endIndex);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
  }) {
    final _that = this;
    switch (_that) {
      case MessageDeltaContentTextAnnotationsFileCitationObject()
          when fileCitation != null:
        return fileCitation(_that.index, _that.type, _that.text,
            _that.fileCitation, _that.startIndex, _that.endIndex);
      case MessageDeltaContentTextAnnotationsFilePathObject()
          when filePath != null:
        return filePath(_that.index, _that.type, _that.text, _that.filePath,
            _that.startIndex, _that.endIndex);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class MessageDeltaContentTextAnnotationsFileCitationObject
    extends MessageDeltaContentTextAnnotations {
  const MessageDeltaContentTextAnnotationsFileCitationObject(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.text,
      @JsonKey(name: 'file_citation', includeIfNull: false) this.fileCitation,
      @JsonKey(name: 'start_index', includeIfNull: false) this.startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) this.endIndex})
      : super._();
  factory MessageDeltaContentTextAnnotationsFileCitationObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageDeltaContentTextAnnotationsFileCitationObjectFromJson(json);

  /// The index of the annotation in the text content part.
  @override
  final int index;

  /// Always `file_citation`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  @JsonKey(includeIfNull: false)
  final String? text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @JsonKey(name: 'file_citation', includeIfNull: false)
  final MessageDeltaContentTextAnnotationsFileCitation? fileCitation;

  /// The start index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'start_index', includeIfNull: false)
  final int? startIndex;

  /// The end index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'end_index', includeIfNull: false)
  final int? endIndex;

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFileCitationObjectCopyWith<
          MessageDeltaContentTextAnnotationsFileCitationObject>
      get copyWith =>
          _$MessageDeltaContentTextAnnotationsFileCitationObjectCopyWithImpl<
                  MessageDeltaContentTextAnnotationsFileCitationObject>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentTextAnnotationsFileCitationObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentTextAnnotationsFileCitationObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.fileCitation, fileCitation) ||
                other.fileCitation == fileCitation) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, index, type, text, fileCitation, startIndex, endIndex);

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotations.fileCitation(index: $index, type: $type, text: $text, fileCitation: $fileCitation, startIndex: $startIndex, endIndex: $endIndex)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentTextAnnotationsFileCitationObjectCopyWith<
    $Res> implements $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  factory $MessageDeltaContentTextAnnotationsFileCitationObjectCopyWith(
          MessageDeltaContentTextAnnotationsFileCitationObject value,
          $Res Function(MessageDeltaContentTextAnnotationsFileCitationObject)
              _then) =
      _$MessageDeltaContentTextAnnotationsFileCitationObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) String? text,
      @JsonKey(name: 'file_citation', includeIfNull: false)
      MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex});

  $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res>?
      get fileCitation;
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsFileCitationObjectCopyWithImpl<$Res>
    implements
        $MessageDeltaContentTextAnnotationsFileCitationObjectCopyWith<$Res> {
  _$MessageDeltaContentTextAnnotationsFileCitationObjectCopyWithImpl(
      this._self, this._then);

  final MessageDeltaContentTextAnnotationsFileCitationObject _self;
  final $Res Function(MessageDeltaContentTextAnnotationsFileCitationObject)
      _then;

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
    Object? fileCitation = freezed,
    Object? startIndex = freezed,
    Object? endIndex = freezed,
  }) {
    return _then(MessageDeltaContentTextAnnotationsFileCitationObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      fileCitation: freezed == fileCitation
          ? _self.fileCitation
          : fileCitation // ignore: cast_nullable_to_non_nullable
              as MessageDeltaContentTextAnnotationsFileCitation?,
      startIndex: freezed == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      endIndex: freezed == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res>?
      get fileCitation {
    if (_self.fileCitation == null) {
      return null;
    }

    return $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res>(
        _self.fileCitation!, (value) {
      return _then(_self.copyWith(fileCitation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageDeltaContentTextAnnotationsFilePathObject
    extends MessageDeltaContentTextAnnotations {
  const MessageDeltaContentTextAnnotationsFilePathObject(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.text,
      @JsonKey(name: 'file_path', includeIfNull: false) this.filePath,
      @JsonKey(name: 'start_index', includeIfNull: false) this.startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) this.endIndex})
      : super._();
  factory MessageDeltaContentTextAnnotationsFilePathObject.fromJson(
          Map<String, dynamic> json) =>
      _$MessageDeltaContentTextAnnotationsFilePathObjectFromJson(json);

  /// The index of the annotation in the text content part.
  @override
  final int index;

  /// Always `file_path`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  @JsonKey(includeIfNull: false)
  final String? text;

  /// No Description
  @JsonKey(name: 'file_path', includeIfNull: false)
  final MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath;

  /// No Description
  @override
  @JsonKey(name: 'start_index', includeIfNull: false)
  final int? startIndex;

  /// No Description
  @override
  @JsonKey(name: 'end_index', includeIfNull: false)
  final int? endIndex;

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFilePathObjectCopyWith<
          MessageDeltaContentTextAnnotationsFilePathObject>
      get copyWith =>
          _$MessageDeltaContentTextAnnotationsFilePathObjectCopyWithImpl<
                  MessageDeltaContentTextAnnotationsFilePathObject>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentTextAnnotationsFilePathObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentTextAnnotationsFilePathObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.filePath, filePath) ||
                other.filePath == filePath) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, index, type, text, filePath, startIndex, endIndex);

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotations.filePath(index: $index, type: $type, text: $text, filePath: $filePath, startIndex: $startIndex, endIndex: $endIndex)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentTextAnnotationsFilePathObjectCopyWith<
    $Res> implements $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  factory $MessageDeltaContentTextAnnotationsFilePathObjectCopyWith(
          MessageDeltaContentTextAnnotationsFilePathObject value,
          $Res Function(MessageDeltaContentTextAnnotationsFilePathObject)
              _then) =
      _$MessageDeltaContentTextAnnotationsFilePathObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) String? text,
      @JsonKey(name: 'file_path', includeIfNull: false)
      MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex});

  $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<$Res>?
      get filePath;
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsFilePathObjectCopyWithImpl<$Res>
    implements $MessageDeltaContentTextAnnotationsFilePathObjectCopyWith<$Res> {
  _$MessageDeltaContentTextAnnotationsFilePathObjectCopyWithImpl(
      this._self, this._then);

  final MessageDeltaContentTextAnnotationsFilePathObject _self;
  final $Res Function(MessageDeltaContentTextAnnotationsFilePathObject) _then;

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
    Object? filePath = freezed,
    Object? startIndex = freezed,
    Object? endIndex = freezed,
  }) {
    return _then(MessageDeltaContentTextAnnotationsFilePathObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _self.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      filePath: freezed == filePath
          ? _self.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as MessageDeltaContentTextAnnotationsFilePathObjectFilePath?,
      startIndex: freezed == startIndex
          ? _self.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      endIndex: freezed == endIndex
          ? _self.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  /// Create a copy of MessageDeltaContentTextAnnotations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<$Res>?
      get filePath {
    if (_self.filePath == null) {
      return null;
    }

    return $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
        $Res>(_self.filePath!, (value) {
      return _then(_self.copyWith(filePath: value));
    });
  }
}

/// @nodoc
mixin _$MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;

  /// Create a copy of MessageDeltaContentTextAnnotationsFilePathObjectFilePath
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
          MessageDeltaContentTextAnnotationsFilePathObjectFilePath>
      get copyWith =>
          _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl<
                  MessageDeltaContentTextAnnotationsFilePathObjectFilePath>(
              this as MessageDeltaContentTextAnnotationsFilePathObjectFilePath,
              _$identity);

  /// Serializes this MessageDeltaContentTextAnnotationsFilePathObjectFilePath to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageDeltaContentTextAnnotationsFilePathObjectFilePath &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotationsFilePathObjectFilePath(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
    $Res> {
  factory $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith(
          MessageDeltaContentTextAnnotationsFilePathObjectFilePath value,
          $Res Function(
                  MessageDeltaContentTextAnnotationsFilePathObjectFilePath)
              _then) =
      _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl;
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl<
        $Res>
    implements
        $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
            $Res> {
  _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl(
      this._self, this._then);

  final MessageDeltaContentTextAnnotationsFilePathObjectFilePath _self;
  final $Res Function(MessageDeltaContentTextAnnotationsFilePathObjectFilePath)
      _then;

  /// Create a copy of MessageDeltaContentTextAnnotationsFilePathObjectFilePath
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_self.copyWith(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [MessageDeltaContentTextAnnotationsFilePathObjectFilePath].
extension MessageDeltaContentTextAnnotationsFilePathObjectFilePathPatterns
    on MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(
            _MessageDeltaContentTextAnnotationsFilePathObjectFilePath value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFilePathObjectFilePath()
          when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(
            _MessageDeltaContentTextAnnotationsFilePathObjectFilePath value)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFilePathObjectFilePath():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(
            _MessageDeltaContentTextAnnotationsFilePathObjectFilePath value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFilePathObjectFilePath()
          when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFilePathObjectFilePath()
          when $default != null:
        return $default(_that.fileId);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFilePathObjectFilePath():
        return $default(_that.fileId);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(name: 'file_id', includeIfNull: false) String? fileId)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _MessageDeltaContentTextAnnotationsFilePathObjectFilePath()
          when $default != null:
        return $default(_that.fileId);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _MessageDeltaContentTextAnnotationsFilePathObjectFilePath
    extends MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
  const _MessageDeltaContentTextAnnotationsFilePathObjectFilePath(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId})
      : super._();
  factory _MessageDeltaContentTextAnnotationsFilePathObjectFilePath.fromJson(
          Map<String, dynamic> json) =>
      _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathFromJson(json);

  /// The ID of the file that was generated.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  /// Create a copy of MessageDeltaContentTextAnnotationsFilePathObjectFilePath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
          _MessageDeltaContentTextAnnotationsFilePathObjectFilePath>
      get copyWith =>
          __$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl<
                  _MessageDeltaContentTextAnnotationsFilePathObjectFilePath>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _MessageDeltaContentTextAnnotationsFilePathObjectFilePath &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotationsFilePathObjectFilePath(fileId: $fileId)';
  }
}

/// @nodoc
abstract mixin class _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
        $Res>
    implements
        $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
            $Res> {
  factory _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith(
          _MessageDeltaContentTextAnnotationsFilePathObjectFilePath value,
          $Res Function(
                  _MessageDeltaContentTextAnnotationsFilePathObjectFilePath)
              _then) =
      __$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class __$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl<
        $Res>
    implements
        _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
            $Res> {
  __$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl(
      this._self, this._then);

  final _MessageDeltaContentTextAnnotationsFilePathObjectFilePath _self;
  final $Res Function(_MessageDeltaContentTextAnnotationsFilePathObjectFilePath)
      _then;

  /// Create a copy of MessageDeltaContentTextAnnotationsFilePathObjectFilePath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_MessageDeltaContentTextAnnotationsFilePathObjectFilePath(
      fileId: freezed == fileId
          ? _self.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

RunStepDetails _$RunStepDetailsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'message_creation':
      return RunStepDetailsMessageCreationObject.fromJson(json);
    case 'tool_calls':
      return RunStepDetailsToolCallsObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDetails',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetails {
  /// Always `message_creation`.
  String get type;

  /// Create a copy of RunStepDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsCopyWith<RunStepDetails> get copyWith =>
      _$RunStepDetailsCopyWithImpl<RunStepDetails>(
          this as RunStepDetails, _$identity);

  /// Serializes this RunStepDetails to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetails &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'RunStepDetails(type: $type)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsCopyWith<$Res> {
  factory $RunStepDetailsCopyWith(
          RunStepDetails value, $Res Function(RunStepDetails) _then) =
      _$RunStepDetailsCopyWithImpl;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$RunStepDetailsCopyWithImpl<$Res>
    implements $RunStepDetailsCopyWith<$Res> {
  _$RunStepDetailsCopyWithImpl(this._self, this._then);

  final RunStepDetails _self;
  final $Res Function(RunStepDetails) _then;

  /// Create a copy of RunStepDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetails].
extension RunStepDetailsPatterns on RunStepDetails {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsMessageCreationObject() when messageCreation != null:
        return messageCreation(_that);
      case RunStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDetailsToolCallsObject value) toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsMessageCreationObject():
        return messageCreation(_that);
      case RunStepDetailsToolCallsObject():
        return toolCalls(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDetailsToolCallsObject value)? toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsMessageCreationObject() when messageCreation != null:
        return messageCreation(_that);
      case RunStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsMessageCreationObject() when messageCreation != null:
        return messageCreation(_that.type, _that.messageCreation);
      case RunStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that.type, _that.toolCalls);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)
        toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsMessageCreationObject():
        return messageCreation(_that.type, _that.messageCreation);
      case RunStepDetailsToolCallsObject():
        return toolCalls(_that.type, _that.toolCalls);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsMessageCreationObject() when messageCreation != null:
        return messageCreation(_that.type, _that.messageCreation);
      case RunStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that.type, _that.toolCalls);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDetailsMessageCreationObject extends RunStepDetails {
  const RunStepDetailsMessageCreationObject(
      {required this.type,
      @JsonKey(name: 'message_creation') required this.messageCreation})
      : super._();
  factory RunStepDetailsMessageCreationObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsMessageCreationObjectFromJson(json);

  /// Always `message_creation`.
  @override
  final String type;

  /// Details of the message creation by the run step.
  @JsonKey(name: 'message_creation')
  final RunStepDetailsMessageCreation messageCreation;

  /// Create a copy of RunStepDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsMessageCreationObjectCopyWith<
          RunStepDetailsMessageCreationObject>
      get copyWith => _$RunStepDetailsMessageCreationObjectCopyWithImpl<
          RunStepDetailsMessageCreationObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsMessageCreationObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsMessageCreationObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.messageCreation, messageCreation) ||
                other.messageCreation == messageCreation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, messageCreation);

  @override
  String toString() {
    return 'RunStepDetails.messageCreation(type: $type, messageCreation: $messageCreation)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsMessageCreationObjectCopyWith<$Res>
    implements $RunStepDetailsCopyWith<$Res> {
  factory $RunStepDetailsMessageCreationObjectCopyWith(
          RunStepDetailsMessageCreationObject value,
          $Res Function(RunStepDetailsMessageCreationObject) _then) =
      _$RunStepDetailsMessageCreationObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'message_creation')
      RunStepDetailsMessageCreation messageCreation});

  $RunStepDetailsMessageCreationCopyWith<$Res> get messageCreation;
}

/// @nodoc
class _$RunStepDetailsMessageCreationObjectCopyWithImpl<$Res>
    implements $RunStepDetailsMessageCreationObjectCopyWith<$Res> {
  _$RunStepDetailsMessageCreationObjectCopyWithImpl(this._self, this._then);

  final RunStepDetailsMessageCreationObject _self;
  final $Res Function(RunStepDetailsMessageCreationObject) _then;

  /// Create a copy of RunStepDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? messageCreation = null,
  }) {
    return _then(RunStepDetailsMessageCreationObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      messageCreation: null == messageCreation
          ? _self.messageCreation
          : messageCreation // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsMessageCreation,
    ));
  }

  /// Create a copy of RunStepDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsMessageCreationCopyWith<$Res> get messageCreation {
    return $RunStepDetailsMessageCreationCopyWith<$Res>(_self.messageCreation,
        (value) {
      return _then(_self.copyWith(messageCreation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDetailsToolCallsObject extends RunStepDetails {
  const RunStepDetailsToolCallsObject(
      {required this.type,
      @JsonKey(name: 'tool_calls')
      required final List<RunStepDetailsToolCalls> toolCalls})
      : _toolCalls = toolCalls,
        super._();
  factory RunStepDetailsToolCallsObject.fromJson(Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsObjectFromJson(json);

  /// Always `tool_calls`.
  @override
  final String type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  final List<RunStepDetailsToolCalls> _toolCalls;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  @JsonKey(name: 'tool_calls')
  List<RunStepDetailsToolCalls> get toolCalls {
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolCalls);
  }

  /// Create a copy of RunStepDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsObjectCopyWith<RunStepDetailsToolCallsObject>
      get copyWith => _$RunStepDetailsToolCallsObjectCopyWithImpl<
          RunStepDetailsToolCallsObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsObject &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, type, const DeepCollectionEquality().hash(_toolCalls));

  @override
  String toString() {
    return 'RunStepDetails.toolCalls(type: $type, toolCalls: $toolCalls)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsObjectCopyWith<$Res>
    implements $RunStepDetailsCopyWith<$Res> {
  factory $RunStepDetailsToolCallsObjectCopyWith(
          RunStepDetailsToolCallsObject value,
          $Res Function(RunStepDetailsToolCallsObject) _then) =
      _$RunStepDetailsToolCallsObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'tool_calls') List<RunStepDetailsToolCalls> toolCalls});
}

/// @nodoc
class _$RunStepDetailsToolCallsObjectCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsObjectCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsObject _self;
  final $Res Function(RunStepDetailsToolCallsObject) _then;

  /// Create a copy of RunStepDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? toolCalls = null,
  }) {
    return _then(RunStepDetailsToolCallsObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      toolCalls: null == toolCalls
          ? _self._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCalls>,
    ));
  }
}

RunStepDeltaDetails _$RunStepDeltaDetailsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'message_creation':
      return RunStepDeltaStepDetailsMessageCreationObject.fromJson(json);
    case 'tool_calls':
      return RunStepDeltaStepDetailsToolCallsObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDeltaDetails',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDeltaDetails {
  /// Always `message_creation`.
  String get type;

  /// Create a copy of RunStepDeltaDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaDetailsCopyWith<RunStepDeltaDetails> get copyWith =>
      _$RunStepDeltaDetailsCopyWithImpl<RunStepDeltaDetails>(
          this as RunStepDeltaDetails, _$identity);

  /// Serializes this RunStepDeltaDetails to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaDetails &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'RunStepDeltaDetails(type: $type)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaDetailsCopyWith<$Res> {
  factory $RunStepDeltaDetailsCopyWith(
          RunStepDeltaDetails value, $Res Function(RunStepDeltaDetails) _then) =
      _$RunStepDeltaDetailsCopyWithImpl;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$RunStepDeltaDetailsCopyWithImpl<$Res>
    implements $RunStepDeltaDetailsCopyWith<$Res> {
  _$RunStepDeltaDetailsCopyWithImpl(this._self, this._then);

  final RunStepDeltaDetails _self;
  final $Res Function(RunStepDeltaDetails) _then;

  /// Create a copy of RunStepDeltaDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaDetails].
extension RunStepDeltaDetailsPatterns on RunStepDeltaDetails {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsMessageCreationObject()
          when messageCreation != null:
        return messageCreation(_that);
      case RunStepDeltaStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDeltaStepDetailsToolCallsObject value)
        toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsMessageCreationObject():
        return messageCreation(_that);
      case RunStepDeltaStepDetailsToolCallsObject():
        return toolCalls(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsMessageCreationObject()
          when messageCreation != null:
        return messageCreation(_that);
      case RunStepDeltaStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsMessageCreationObject()
          when messageCreation != null:
        return messageCreation(_that.type, _that.messageCreation);
      case RunStepDeltaStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that.type, _that.toolCalls);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)
        toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsMessageCreationObject():
        return messageCreation(_that.type, _that.messageCreation);
      case RunStepDeltaStepDetailsToolCallsObject():
        return toolCalls(_that.type, _that.toolCalls);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsMessageCreationObject()
          when messageCreation != null:
        return messageCreation(_that.type, _that.messageCreation);
      case RunStepDeltaStepDetailsToolCallsObject() when toolCalls != null:
        return toolCalls(_that.type, _that.toolCalls);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDeltaStepDetailsMessageCreationObject extends RunStepDeltaDetails {
  const RunStepDeltaStepDetailsMessageCreationObject(
      {required this.type,
      @JsonKey(name: 'message_creation', includeIfNull: false)
      this.messageCreation})
      : super._();
  factory RunStepDeltaStepDetailsMessageCreationObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsMessageCreationObjectFromJson(json);

  /// Always `message_creation`.
  @override
  final String type;

  /// Details of the message creation by the run step.
  @JsonKey(name: 'message_creation', includeIfNull: false)
  final RunStepDeltaStepDetailsMessageCreation? messageCreation;

  /// Create a copy of RunStepDeltaDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsMessageCreationObjectCopyWith<
          RunStepDeltaStepDetailsMessageCreationObject>
      get copyWith =>
          _$RunStepDeltaStepDetailsMessageCreationObjectCopyWithImpl<
              RunStepDeltaStepDetailsMessageCreationObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsMessageCreationObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsMessageCreationObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.messageCreation, messageCreation) ||
                other.messageCreation == messageCreation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, messageCreation);

  @override
  String toString() {
    return 'RunStepDeltaDetails.messageCreation(type: $type, messageCreation: $messageCreation)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsMessageCreationObjectCopyWith<$Res>
    implements $RunStepDeltaDetailsCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsMessageCreationObjectCopyWith(
          RunStepDeltaStepDetailsMessageCreationObject value,
          $Res Function(RunStepDeltaStepDetailsMessageCreationObject) _then) =
      _$RunStepDeltaStepDetailsMessageCreationObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'message_creation', includeIfNull: false)
      RunStepDeltaStepDetailsMessageCreation? messageCreation});

  $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res>? get messageCreation;
}

/// @nodoc
class _$RunStepDeltaStepDetailsMessageCreationObjectCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsMessageCreationObjectCopyWith<$Res> {
  _$RunStepDeltaStepDetailsMessageCreationObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsMessageCreationObject _self;
  final $Res Function(RunStepDeltaStepDetailsMessageCreationObject) _then;

  /// Create a copy of RunStepDeltaDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? messageCreation = freezed,
  }) {
    return _then(RunStepDeltaStepDetailsMessageCreationObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      messageCreation: freezed == messageCreation
          ? _self.messageCreation
          : messageCreation // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsMessageCreation?,
    ));
  }

  /// Create a copy of RunStepDeltaDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res>? get messageCreation {
    if (_self.messageCreation == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res>(
        _self.messageCreation!, (value) {
      return _then(_self.copyWith(messageCreation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDeltaStepDetailsToolCallsObject extends RunStepDeltaDetails {
  const RunStepDeltaStepDetailsToolCallsObject(
      {required this.type,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<RunStepDeltaStepDetailsToolCalls>? toolCalls})
      : _toolCalls = toolCalls,
        super._();
  factory RunStepDeltaStepDetailsToolCallsObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsObjectFromJson(json);

  /// Always `tool_calls`.
  @override
  final String type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  final List<RunStepDeltaStepDetailsToolCalls>? _toolCalls;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCalls>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of RunStepDeltaDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsObjectCopyWith<
          RunStepDeltaStepDetailsToolCallsObject>
      get copyWith => _$RunStepDeltaStepDetailsToolCallsObjectCopyWithImpl<
          RunStepDeltaStepDetailsToolCallsObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsObject &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, type, const DeepCollectionEquality().hash(_toolCalls));

  @override
  String toString() {
    return 'RunStepDeltaDetails.toolCalls(type: $type, toolCalls: $toolCalls)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsObjectCopyWith<$Res>
    implements $RunStepDeltaDetailsCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsObjectCopyWith(
          RunStepDeltaStepDetailsToolCallsObject value,
          $Res Function(RunStepDeltaStepDetailsToolCallsObject) _then) =
      _$RunStepDeltaStepDetailsToolCallsObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<RunStepDeltaStepDetailsToolCalls>? toolCalls});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsObjectCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsObjectCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsObjectCopyWithImpl(this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsObject _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsObject) _then;

  /// Create a copy of RunStepDeltaDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? toolCalls = freezed,
  }) {
    return _then(RunStepDeltaStepDetailsToolCallsObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      toolCalls: freezed == toolCalls
          ? _self._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunStepDeltaStepDetailsToolCalls>?,
    ));
  }
}

RunStepDetailsToolCalls _$RunStepDetailsToolCallsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return RunStepDetailsToolCallsCodeObject.fromJson(json);
    case 'file_search':
      return RunStepDetailsToolCallsFileSearchObject.fromJson(json);
    case 'function':
      return RunStepDetailsToolCallsFunctionObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDetailsToolCalls',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCalls {
  /// The ID of the tool call.
  String get id;

  /// Always `code_interpreter`.
  String get type;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCopyWith<RunStepDetailsToolCalls> get copyWith =>
      _$RunStepDetailsToolCallsCopyWithImpl<RunStepDetailsToolCalls>(
          this as RunStepDetailsToolCalls, _$identity);

  /// Serializes this RunStepDetailsToolCalls to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCalls &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type);

  @override
  String toString() {
    return 'RunStepDetailsToolCalls(id: $id, type: $type)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCopyWith(RunStepDetailsToolCalls value,
          $Res Function(RunStepDetailsToolCalls) _then) =
      _$RunStepDetailsToolCallsCopyWithImpl;
  @useResult
  $Res call({String id, String type});
}

/// @nodoc
class _$RunStepDetailsToolCallsCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  _$RunStepDetailsToolCallsCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCalls _self;
  final $Res Function(RunStepDetailsToolCalls) _then;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCalls].
extension RunStepDetailsToolCallsPatterns on RunStepDetailsToolCalls {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsFileSearchObject value)? fileSearch,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeObject() when codeInterpreter != null:
        return codeInterpreter(_that);
      case RunStepDetailsToolCallsFileSearchObject() when fileSearch != null:
        return fileSearch(_that);
      case RunStepDetailsToolCallsFunctionObject() when function != null:
        return function(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeObject():
        return codeInterpreter(_that);
      case RunStepDetailsToolCallsFileSearchObject():
        return fileSearch(_that);
      case RunStepDetailsToolCallsFunctionObject():
        return function(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeObject() when codeInterpreter != null:
        return codeInterpreter(_that);
      case RunStepDetailsToolCallsFileSearchObject() when fileSearch != null:
        return fileSearch(_that);
      case RunStepDetailsToolCallsFunctionObject() when function != null:
        return function(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(
            String id,
            String type,
            @JsonKey(name: 'file_search')
            RunStepDetailsToolCallsFileSearch fileSearch)?
        fileSearch,
    TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeObject() when codeInterpreter != null:
        return codeInterpreter(_that.id, _that.type, _that.codeInterpreter);
      case RunStepDetailsToolCallsFileSearchObject() when fileSearch != null:
        return fileSearch(_that.id, _that.type, _that.fileSearch);
      case RunStepDetailsToolCallsFunctionObject() when function != null:
        return function(_that.id, _that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(
            String id,
            String type,
            @JsonKey(name: 'file_search')
            RunStepDetailsToolCallsFileSearch fileSearch)
        fileSearch,
    required TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)
        function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeObject():
        return codeInterpreter(_that.id, _that.type, _that.codeInterpreter);
      case RunStepDetailsToolCallsFileSearchObject():
        return fileSearch(_that.id, _that.type, _that.fileSearch);
      case RunStepDetailsToolCallsFunctionObject():
        return function(_that.id, _that.type, _that.function);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            String id,
            String type,
            @JsonKey(name: 'file_search')
            RunStepDetailsToolCallsFileSearch fileSearch)?
        fileSearch,
    TResult? Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeObject() when codeInterpreter != null:
        return codeInterpreter(_that.id, _that.type, _that.codeInterpreter);
      case RunStepDetailsToolCallsFileSearchObject() when fileSearch != null:
        return fileSearch(_that.id, _that.type, _that.fileSearch);
      case RunStepDetailsToolCallsFunctionObject() when function != null:
        return function(_that.id, _that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDetailsToolCallsCodeObject extends RunStepDetailsToolCalls {
  const RunStepDetailsToolCallsCodeObject(
      {required this.id,
      required this.type,
      @JsonKey(name: 'code_interpreter') required this.codeInterpreter})
      : super._();
  factory RunStepDetailsToolCallsCodeObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsCodeObjectFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// Always `code_interpreter`.
  @override
  final String type;

  /// The Code Interpreter tool call definition.
  @JsonKey(name: 'code_interpreter')
  final RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeObjectCopyWith<RunStepDetailsToolCallsCodeObject>
      get copyWith => _$RunStepDetailsToolCallsCodeObjectCopyWithImpl<
          RunStepDetailsToolCallsCodeObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsCodeObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsCodeObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, codeInterpreter);

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.codeInterpreter(id: $id, type: $type, codeInterpreter: $codeInterpreter)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsCodeObjectCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeObjectCopyWith(
          RunStepDetailsToolCallsCodeObject value,
          $Res Function(RunStepDetailsToolCallsCodeObject) _then) =
      _$RunStepDetailsToolCallsCodeObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      String type,
      @JsonKey(name: 'code_interpreter')
      RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter});

  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>
      get codeInterpreter;
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeObjectCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsCodeObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeObjectCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsCodeObject _self;
  final $Res Function(RunStepDetailsToolCallsCodeObject) _then;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? codeInterpreter = null,
  }) {
    return _then(RunStepDetailsToolCallsCodeObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      codeInterpreter: null == codeInterpreter
          ? _self.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeObjectCodeInterpreter,
    ));
  }

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>
      get codeInterpreter {
    return $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>(
        _self.codeInterpreter, (value) {
      return _then(_self.copyWith(codeInterpreter: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDetailsToolCallsFileSearchObject extends RunStepDetailsToolCalls {
  const RunStepDetailsToolCallsFileSearchObject(
      {required this.id,
      required this.type,
      @JsonKey(name: 'file_search') required this.fileSearch})
      : super._();
  factory RunStepDetailsToolCallsFileSearchObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsFileSearchObjectFromJson(json);

  /// The ID of the tool call object.
  @override
  final String id;

  /// The type of tool call. This is always going to be `file_search` for this type of tool call.
  @override
  final String type;

  /// The definition of the file search that was called.
  @JsonKey(name: 'file_search')
  final RunStepDetailsToolCallsFileSearch fileSearch;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchObjectCopyWith<
          RunStepDetailsToolCallsFileSearchObject>
      get copyWith => _$RunStepDetailsToolCallsFileSearchObjectCopyWithImpl<
          RunStepDetailsToolCallsFileSearchObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsFileSearchObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsFileSearchObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.fileSearch, fileSearch) ||
                other.fileSearch == fileSearch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, fileSearch);

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.fileSearch(id: $id, type: $type, fileSearch: $fileSearch)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsFileSearchObjectCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDetailsToolCallsFileSearchObjectCopyWith(
          RunStepDetailsToolCallsFileSearchObject value,
          $Res Function(RunStepDetailsToolCallsFileSearchObject) _then) =
      _$RunStepDetailsToolCallsFileSearchObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      String type,
      @JsonKey(name: 'file_search')
      RunStepDetailsToolCallsFileSearch fileSearch});

  $RunStepDetailsToolCallsFileSearchCopyWith<$Res> get fileSearch;
}

/// @nodoc
class _$RunStepDetailsToolCallsFileSearchObjectCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsFileSearchObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsFileSearchObjectCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsFileSearchObject _self;
  final $Res Function(RunStepDetailsToolCallsFileSearchObject) _then;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? fileSearch = null,
  }) {
    return _then(RunStepDetailsToolCallsFileSearchObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      fileSearch: null == fileSearch
          ? _self.fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsFileSearch,
    ));
  }

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFileSearchCopyWith<$Res> get fileSearch {
    return $RunStepDetailsToolCallsFileSearchCopyWith<$Res>(_self.fileSearch,
        (value) {
      return _then(_self.copyWith(fileSearch: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDetailsToolCallsFunctionObject extends RunStepDetailsToolCalls {
  const RunStepDetailsToolCallsFunctionObject(
      {required this.id, required this.type, required this.function})
      : super._();
  factory RunStepDetailsToolCallsFunctionObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsFunctionObjectFromJson(json);

  /// The ID of the tool call object.
  @override
  final String id;

  /// Always `function`.
  @override
  final String type;

  /// The definition of the function that was called.
  final RunStepDetailsToolCallsFunction function;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFunctionObjectCopyWith<
          RunStepDetailsToolCallsFunctionObject>
      get copyWith => _$RunStepDetailsToolCallsFunctionObjectCopyWithImpl<
          RunStepDetailsToolCallsFunctionObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsFunctionObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsFunctionObject &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.function(id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsFunctionObjectCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDetailsToolCallsFunctionObjectCopyWith(
          RunStepDetailsToolCallsFunctionObject value,
          $Res Function(RunStepDetailsToolCallsFunctionObject) _then) =
      _$RunStepDetailsToolCallsFunctionObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String id, String type, RunStepDetailsToolCallsFunction function});

  $RunStepDetailsToolCallsFunctionCopyWith<$Res> get function;
}

/// @nodoc
class _$RunStepDetailsToolCallsFunctionObjectCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsFunctionObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsFunctionObjectCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsFunctionObject _self;
  final $Res Function(RunStepDetailsToolCallsFunctionObject) _then;

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(RunStepDetailsToolCallsFunctionObject(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      function: null == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsFunction,
    ));
  }

  /// Create a copy of RunStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFunctionCopyWith<$Res> get function {
    return $RunStepDetailsToolCallsFunctionCopyWith<$Res>(_self.function,
        (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsFunction {
  /// The name of the function.
  String get name;

  /// The arguments passed to the function.
  String get arguments;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  String? get output;

  /// Create a copy of RunStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFunctionCopyWith<RunStepDetailsToolCallsFunction>
      get copyWith => _$RunStepDetailsToolCallsFunctionCopyWithImpl<
              RunStepDetailsToolCallsFunction>(
          this as RunStepDetailsToolCallsFunction, _$identity);

  /// Serializes this RunStepDetailsToolCallsFunction to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsFunction &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments, output);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFunction(name: $name, arguments: $arguments, output: $output)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory $RunStepDetailsToolCallsFunctionCopyWith(
          RunStepDetailsToolCallsFunction value,
          $Res Function(RunStepDetailsToolCallsFunction) _then) =
      _$RunStepDetailsToolCallsFunctionCopyWithImpl;
  @useResult
  $Res call({String name, String arguments, String? output});
}

/// @nodoc
class _$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  _$RunStepDetailsToolCallsFunctionCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsFunction _self;
  final $Res Function(RunStepDetailsToolCallsFunction) _then;

  /// Create a copy of RunStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
    Object? output = freezed,
  }) {
    return _then(_self.copyWith(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
      output: freezed == output
          ? _self.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsFunction].
extension RunStepDetailsToolCallsFunctionPatterns
    on RunStepDetailsToolCallsFunction {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFunction value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFunction() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDetailsToolCallsFunction value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFunction():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDetailsToolCallsFunction value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFunction() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String name, String arguments, String? output)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFunction() when $default != null:
        return $default(_that.name, _that.arguments, _that.output);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String name, String arguments, String? output) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFunction():
        return $default(_that.name, _that.arguments, _that.output);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String name, String arguments, String? output)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDetailsToolCallsFunction() when $default != null:
        return $default(_that.name, _that.arguments, _that.output);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDetailsToolCallsFunction extends RunStepDetailsToolCallsFunction {
  const _RunStepDetailsToolCallsFunction(
      {required this.name, required this.arguments, required this.output})
      : super._();
  factory _RunStepDetailsToolCallsFunction.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsFunctionFromJson(json);

  /// The name of the function.
  @override
  final String name;

  /// The arguments passed to the function.
  @override
  final String arguments;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @override
  final String? output;

  /// Create a copy of RunStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDetailsToolCallsFunctionCopyWith<_RunStepDetailsToolCallsFunction>
      get copyWith => __$RunStepDetailsToolCallsFunctionCopyWithImpl<
          _RunStepDetailsToolCallsFunction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsFunctionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDetailsToolCallsFunction &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments, output);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFunction(name: $name, arguments: $arguments, output: $output)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDetailsToolCallsFunctionCopyWith<$Res>
    implements $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory _$RunStepDetailsToolCallsFunctionCopyWith(
          _RunStepDetailsToolCallsFunction value,
          $Res Function(_RunStepDetailsToolCallsFunction) _then) =
      __$RunStepDetailsToolCallsFunctionCopyWithImpl;
  @override
  @useResult
  $Res call({String name, String arguments, String? output});
}

/// @nodoc
class __$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res>
    implements _$RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  __$RunStepDetailsToolCallsFunctionCopyWithImpl(this._self, this._then);

  final _RunStepDetailsToolCallsFunction _self;
  final $Res Function(_RunStepDetailsToolCallsFunction) _then;

  /// Create a copy of RunStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = null,
    Object? arguments = null,
    Object? output = freezed,
  }) {
    return _then(_RunStepDetailsToolCallsFunction(
      name: null == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
      output: freezed == output
          ? _self.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

RunStepDeltaStepDetailsToolCalls _$RunStepDeltaStepDetailsToolCallsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return RunStepDeltaStepDetailsToolCallsCodeObject.fromJson(json);
    case 'file_search':
      return RunStepDeltaStepDetailsToolCallsFileSearchObject.fromJson(json);
    case 'function':
      return RunStepDeltaStepDetailsToolCallsFunctionObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'RunStepDeltaStepDetailsToolCalls',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCalls {
  /// The index of the tool call in the tool calls array.
  int get index;

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id;

  /// Always `code_interpreter`.
  String get type;

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCopyWith<RunStepDeltaStepDetailsToolCalls>
      get copyWith => _$RunStepDeltaStepDetailsToolCallsCopyWithImpl<
              RunStepDeltaStepDetailsToolCalls>(
          this as RunStepDeltaStepDetailsToolCalls, _$identity);

  /// Serializes this RunStepDeltaStepDetailsToolCalls to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCalls &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCalls(index: $index, id: $id, type: $type)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCopyWith(
          RunStepDeltaStepDetailsToolCalls value,
          $Res Function(RunStepDeltaStepDetailsToolCalls) _then) =
      _$RunStepDeltaStepDetailsToolCallsCopyWithImpl;
  @useResult
  $Res call(
      {int index, @JsonKey(includeIfNull: false) String? id, String type});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCopyWithImpl(this._self, this._then);

  final RunStepDeltaStepDetailsToolCalls _self;
  final $Res Function(RunStepDeltaStepDetailsToolCalls) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaStepDetailsToolCalls].
extension RunStepDeltaStepDetailsToolCallsPatterns
    on RunStepDeltaStepDetailsToolCalls {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeObject()
          when codeInterpreter != null:
        return codeInterpreter(_that);
      case RunStepDeltaStepDetailsToolCallsFileSearchObject()
          when fileSearch != null:
        return fileSearch(_that);
      case RunStepDeltaStepDetailsToolCallsFunctionObject()
          when function != null:
        return function(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeObject():
        return codeInterpreter(_that);
      case RunStepDeltaStepDetailsToolCallsFileSearchObject():
        return fileSearch(_that);
      case RunStepDeltaStepDetailsToolCallsFunctionObject():
        return function(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeObject()
          when codeInterpreter != null:
        return codeInterpreter(_that);
      case RunStepDeltaStepDetailsToolCallsFileSearchObject()
          when fileSearch != null:
        return fileSearch(_that);
      case RunStepDeltaStepDetailsToolCallsFunctionObject()
          when function != null:
        return function(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeObject()
          when codeInterpreter != null:
        return codeInterpreter(
            _that.index, _that.id, _that.type, _that.codeInterpreter);
      case RunStepDeltaStepDetailsToolCallsFileSearchObject()
          when fileSearch != null:
        return fileSearch(_that.index, _that.id, _that.type, _that.fileSearch);
      case RunStepDeltaStepDetailsToolCallsFunctionObject()
          when function != null:
        return function(_that.index, _that.id, _that.type, _that.function);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)
        codeInterpreter,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)
        function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeObject():
        return codeInterpreter(
            _that.index, _that.id, _that.type, _that.codeInterpreter);
      case RunStepDeltaStepDetailsToolCallsFileSearchObject():
        return fileSearch(_that.index, _that.id, _that.type, _that.fileSearch);
      case RunStepDeltaStepDetailsToolCallsFunctionObject():
        return function(_that.index, _that.id, _that.type, _that.function);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeObject()
          when codeInterpreter != null:
        return codeInterpreter(
            _that.index, _that.id, _that.type, _that.codeInterpreter);
      case RunStepDeltaStepDetailsToolCallsFileSearchObject()
          when fileSearch != null:
        return fileSearch(_that.index, _that.id, _that.type, _that.fileSearch);
      case RunStepDeltaStepDetailsToolCallsFunctionObject()
          when function != null:
        return function(_that.index, _that.id, _that.type, _that.function);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDeltaStepDetailsToolCallsCodeObject
    extends RunStepDeltaStepDetailsToolCalls {
  const RunStepDeltaStepDetailsToolCallsCodeObject(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      required this.type,
      @JsonKey(name: 'code_interpreter', includeIfNull: false)
      this.codeInterpreter})
      : super._();
  factory RunStepDeltaStepDetailsToolCallsCodeObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsCodeObjectFromJson(json);

  /// The index of the tool call in the tool calls array.
  @override
  final int index;

  /// The ID of the tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// Always `code_interpreter`.
  @override
  final String type;

  /// The Code Interpreter tool call definition. - outputs
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  final RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
      codeInterpreter;

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeObjectCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeObject>
      get copyWith => _$RunStepDeltaStepDetailsToolCallsCodeObjectCopyWithImpl<
          RunStepDeltaStepDetailsToolCallsCodeObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsCodeObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsCodeObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, index, id, type, codeInterpreter);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCalls.codeInterpreter(index: $index, id: $id, type: $type, codeInterpreter: $codeInterpreter)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsCodeObjectCopyWith<$Res>
    implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeObjectCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeObject value,
          $Res Function(RunStepDeltaStepDetailsToolCallsCodeObject) _then) =
      _$RunStepDeltaStepDetailsToolCallsCodeObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      String type,
      @JsonKey(name: 'code_interpreter', includeIfNull: false)
      RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
          codeInterpreter});

  $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>?
      get codeInterpreter;
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeObjectCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsCodeObjectCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsCodeObject _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsCodeObject) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
    Object? codeInterpreter = freezed,
  }) {
    return _then(RunStepDeltaStepDetailsToolCallsCodeObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      codeInterpreter: freezed == codeInterpreter
          ? _self.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?,
    ));
  }

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>?
      get codeInterpreter {
    if (_self.codeInterpreter == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
        $Res>(_self.codeInterpreter!, (value) {
      return _then(_self.copyWith(codeInterpreter: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDeltaStepDetailsToolCallsFileSearchObject
    extends RunStepDeltaStepDetailsToolCalls {
  const RunStepDeltaStepDetailsToolCallsFileSearchObject(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      required this.type,
      @JsonKey(name: 'file_search')
      required final Map<String, dynamic> fileSearch})
      : _fileSearch = fileSearch,
        super._();
  factory RunStepDeltaStepDetailsToolCallsFileSearchObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsFileSearchObjectFromJson(json);

  /// The index of the tool call in the tool calls array.
  @override
  final int index;

  /// The ID of the tool call object.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The type of tool call. This is always going to be `file_search` for this type of tool call.
  @override
  final String type;

  /// For now, this is always going to be an empty object.
  final Map<String, dynamic> _fileSearch;

  /// For now, this is always going to be an empty object.
  @JsonKey(name: 'file_search')
  Map<String, dynamic> get fileSearch {
    if (_fileSearch is EqualUnmodifiableMapView) return _fileSearch;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_fileSearch);
  }

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWith<
          RunStepDeltaStepDetailsToolCallsFileSearchObject>
      get copyWith =>
          _$RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWithImpl<
                  RunStepDeltaStepDetailsToolCallsFileSearchObject>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsFileSearchObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsFileSearchObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._fileSearch, _fileSearch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type,
      const DeepCollectionEquality().hash(_fileSearch));

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCalls.fileSearch(index: $index, id: $id, type: $type, fileSearch: $fileSearch)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWith(
          RunStepDeltaStepDetailsToolCallsFileSearchObject value,
          $Res Function(RunStepDeltaStepDetailsToolCallsFileSearchObject)
              _then) =
      _$RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      String type,
      @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsFileSearchObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsFileSearchObject _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsFileSearchObject) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
    Object? fileSearch = null,
  }) {
    return _then(RunStepDeltaStepDetailsToolCallsFileSearchObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      fileSearch: null == fileSearch
          ? _self._fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDeltaStepDetailsToolCallsFunctionObject
    extends RunStepDeltaStepDetailsToolCalls {
  const RunStepDeltaStepDetailsToolCallsFunctionObject(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      required this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();
  factory RunStepDeltaStepDetailsToolCallsFunctionObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsFunctionObjectFromJson(json);

  /// The index of the tool call in the tool calls array.
  @override
  final int index;

  /// The ID of the tool call object.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// Always `function`.
  @override
  final String type;

  /// The definition of the function that was called.
  @JsonKey(includeIfNull: false)
  final RunStepDeltaStepDetailsToolCallsFunction? function;

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWith<
          RunStepDeltaStepDetailsToolCallsFunctionObject>
      get copyWith =>
          _$RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWithImpl<
              RunStepDeltaStepDetailsToolCallsFunctionObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsFunctionObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsFunctionObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCalls.function(index: $index, id: $id, type: $type, function: $function)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWith(
          RunStepDeltaStepDetailsToolCallsFunctionObject value,
          $Res Function(RunStepDeltaStepDetailsToolCallsFunctionObject) _then) =
      _$RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      String type,
      @JsonKey(includeIfNull: false)
      RunStepDeltaStepDetailsToolCallsFunction? function});

  $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res>? get function;
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsFunctionObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsFunctionObject _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsFunctionObject) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
    Object? function = freezed,
  }) {
    return _then(RunStepDeltaStepDetailsToolCallsFunctionObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      function: freezed == function
          ? _self.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsToolCallsFunction?,
    ));
  }

  /// Create a copy of RunStepDeltaStepDetailsToolCalls
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res>? get function {
    if (_self.function == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res>(
        _self.function!, (value) {
      return _then(_self.copyWith(function: value));
    });
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsFunction {
  /// The name of the function.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// The arguments passed to the function.
  @JsonKey(includeIfNull: false)
  String? get arguments;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @JsonKey(includeIfNull: false)
  String? get output;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<
          RunStepDeltaStepDetailsToolCallsFunction>
      get copyWith => _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl<
              RunStepDeltaStepDetailsToolCallsFunction>(
          this as RunStepDeltaStepDetailsToolCallsFunction, _$identity);

  /// Serializes this RunStepDeltaStepDetailsToolCallsFunction to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsFunction &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments, output);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsFunction(name: $name, arguments: $arguments, output: $output)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsFunctionCopyWith(
          RunStepDeltaStepDetailsToolCallsFunction value,
          $Res Function(RunStepDeltaStepDetailsToolCallsFunction) _then) =
      _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsFunction _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsFunction) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
    Object? output = freezed,
  }) {
    return _then(_self.copyWith(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _self.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaStepDetailsToolCallsFunction].
extension RunStepDeltaStepDetailsToolCallsFunctionPatterns
    on RunStepDeltaStepDetailsToolCallsFunction {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RunStepDeltaStepDetailsToolCallsFunction value)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsFunction() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RunStepDeltaStepDetailsToolCallsFunction value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsFunction():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RunStepDeltaStepDetailsToolCallsFunction value)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsFunction() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? arguments,
            @JsonKey(includeIfNull: false) String? output)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsFunction() when $default != null:
        return $default(_that.name, _that.arguments, _that.output);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? arguments,
            @JsonKey(includeIfNull: false) String? output)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsFunction():
        return $default(_that.name, _that.arguments, _that.output);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(includeIfNull: false) String? arguments,
            @JsonKey(includeIfNull: false) String? output)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _RunStepDeltaStepDetailsToolCallsFunction() when $default != null:
        return $default(_that.name, _that.arguments, _that.output);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _RunStepDeltaStepDetailsToolCallsFunction
    extends RunStepDeltaStepDetailsToolCallsFunction {
  const _RunStepDeltaStepDetailsToolCallsFunction(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.arguments,
      @JsonKey(includeIfNull: false) this.output})
      : super._();
  factory _RunStepDeltaStepDetailsToolCallsFunction.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsFunctionFromJson(json);

  /// The name of the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The arguments passed to the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? arguments;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @override
  @JsonKey(includeIfNull: false)
  final String? output;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$RunStepDeltaStepDetailsToolCallsFunctionCopyWith<
          _RunStepDeltaStepDetailsToolCallsFunction>
      get copyWith => __$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl<
          _RunStepDeltaStepDetailsToolCallsFunction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsFunctionToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RunStepDeltaStepDetailsToolCallsFunction &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments, output);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsFunction(name: $name, arguments: $arguments, output: $output)';
  }
}

/// @nodoc
abstract mixin class _$RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res>
    implements $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory _$RunStepDeltaStepDetailsToolCallsFunctionCopyWith(
          _RunStepDeltaStepDetailsToolCallsFunction value,
          $Res Function(_RunStepDeltaStepDetailsToolCallsFunction) _then) =
      __$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class __$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl<$Res>
    implements _$RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res> {
  __$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl(
      this._self, this._then);

  final _RunStepDeltaStepDetailsToolCallsFunction _self;
  final $Res Function(_RunStepDeltaStepDetailsToolCallsFunction) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsFunction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
    Object? output = freezed,
  }) {
    return _then(_RunStepDeltaStepDetailsToolCallsFunction(
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _self.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _self.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

RunStepDetailsToolCallsCodeOutput _$RunStepDetailsToolCallsCodeOutputFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'logs':
      return RunStepDetailsToolCallsCodeOutputLogsObject.fromJson(json);
    case 'image':
      return RunStepDetailsToolCallsCodeOutputImageObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'RunStepDetailsToolCallsCodeOutput',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeOutput {
  /// Always `logs`.
  String get type;

  /// Create a copy of RunStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeOutputCopyWith<RunStepDetailsToolCallsCodeOutput>
      get copyWith => _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<
              RunStepDetailsToolCallsCodeOutput>(
          this as RunStepDetailsToolCallsCodeOutput, _$identity);

  /// Serializes this RunStepDetailsToolCallsCodeOutput to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsCodeOutput &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutput(type: $type)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputCopyWith(
          RunStepDetailsToolCallsCodeOutput value,
          $Res Function(RunStepDetailsToolCallsCodeOutput) _then) =
      _$RunStepDetailsToolCallsCodeOutputCopyWithImpl;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputCopyWithImpl(this._self, this._then);

  final RunStepDetailsToolCallsCodeOutput _self;
  final $Res Function(RunStepDetailsToolCallsCodeOutput) _then;

  /// Create a copy of RunStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDetailsToolCallsCodeOutput].
extension RunStepDetailsToolCallsCodeOutputPatterns
    on RunStepDetailsToolCallsCodeOutput {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObject value)? image,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeOutputLogsObject() when logs != null:
        return logs(_that);
      case RunStepDetailsToolCallsCodeOutputImageObject() when image != null:
        return image(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeOutputLogsObject():
        return logs(_that);
      case RunStepDetailsToolCallsCodeOutputImageObject():
        return image(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeOutputLogsObject() when logs != null:
        return logs(_that);
      case RunStepDetailsToolCallsCodeOutputImageObject() when image != null:
        return image(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, String logs)? logs,
    TResult Function(String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeOutputLogsObject() when logs != null:
        return logs(_that.type, _that.logs);
      case RunStepDetailsToolCallsCodeOutputImageObject() when image != null:
        return image(_that.type, _that.image);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, String logs) logs,
    required TResult Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeOutputLogsObject():
        return logs(_that.type, _that.logs);
      case RunStepDetailsToolCallsCodeOutputImageObject():
        return image(_that.type, _that.image);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, String logs)? logs,
    TResult? Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDetailsToolCallsCodeOutputLogsObject() when logs != null:
        return logs(_that.type, _that.logs);
      case RunStepDetailsToolCallsCodeOutputImageObject() when image != null:
        return image(_that.type, _that.image);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDetailsToolCallsCodeOutputLogsObject
    extends RunStepDetailsToolCallsCodeOutput {
  const RunStepDetailsToolCallsCodeOutputLogsObject(
      {required this.type, required this.logs})
      : super._();
  factory RunStepDetailsToolCallsCodeOutputLogsObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsCodeOutputLogsObjectFromJson(json);

  /// Always `logs`.
  @override
  final String type;

  /// The text output from the Code Interpreter tool call.
  final String logs;

  /// Create a copy of RunStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeOutputLogsObjectCopyWith<
          RunStepDetailsToolCallsCodeOutputLogsObject>
      get copyWith => _$RunStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl<
          RunStepDetailsToolCallsCodeOutputLogsObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsCodeOutputLogsObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsCodeOutputLogsObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.logs, logs) || other.logs == logs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, logs);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutput.logs(type: $type, logs: $logs)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsCodeOutputLogsObjectCopyWith<$Res>
    implements $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputLogsObjectCopyWith(
          RunStepDetailsToolCallsCodeOutputLogsObject value,
          $Res Function(RunStepDetailsToolCallsCodeOutputLogsObject) _then) =
      _$RunStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String type, String logs});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsCodeOutputLogsObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDetailsToolCallsCodeOutputLogsObject _self;
  final $Res Function(RunStepDetailsToolCallsCodeOutputLogsObject) _then;

  /// Create a copy of RunStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? logs = null,
  }) {
    return _then(RunStepDetailsToolCallsCodeOutputLogsObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      logs: null == logs
          ? _self.logs
          : logs // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDetailsToolCallsCodeOutputImageObject
    extends RunStepDetailsToolCallsCodeOutput {
  const RunStepDetailsToolCallsCodeOutputImageObject(
      {required this.type, required this.image})
      : super._();
  factory RunStepDetailsToolCallsCodeOutputImageObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDetailsToolCallsCodeOutputImageObjectFromJson(json);

  /// Always `image`.
  @override
  final String type;

  /// Code interpreter image output.
  final RunStepDetailsToolCallsCodeOutputImage image;

  /// Create a copy of RunStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeOutputImageObjectCopyWith<
          RunStepDetailsToolCallsCodeOutputImageObject>
      get copyWith =>
          _$RunStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl<
              RunStepDetailsToolCallsCodeOutputImageObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDetailsToolCallsCodeOutputImageObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDetailsToolCallsCodeOutputImageObject &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, image);

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutput.image(type: $type, image: $image)';
  }
}

/// @nodoc
abstract mixin class $RunStepDetailsToolCallsCodeOutputImageObjectCopyWith<$Res>
    implements $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputImageObjectCopyWith(
          RunStepDetailsToolCallsCodeOutputImageObject value,
          $Res Function(RunStepDetailsToolCallsCodeOutputImageObject) _then) =
      _$RunStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl;
  @override
  @useResult
  $Res call({String type, RunStepDetailsToolCallsCodeOutputImage image});

  $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> get image;
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl<$Res>
    implements $RunStepDetailsToolCallsCodeOutputImageObjectCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDetailsToolCallsCodeOutputImageObject _self;
  final $Res Function(RunStepDetailsToolCallsCodeOutputImageObject) _then;

  /// Create a copy of RunStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? image = null,
  }) {
    return _then(RunStepDetailsToolCallsCodeOutputImageObject(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      image: null == image
          ? _self.image
          : image // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeOutputImage,
    ));
  }

  /// Create a copy of RunStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> get image {
    return $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res>(_self.image,
        (value) {
      return _then(_self.copyWith(image: value));
    });
  }
}

RunStepDeltaStepDetailsToolCallsCodeOutput
    _$RunStepDeltaStepDetailsToolCallsCodeOutputFromJson(
        Map<String, dynamic> json) {
  switch (json['type']) {
    case 'logs':
      return RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject.fromJson(
          json);
    case 'image':
      return RunStepDeltaStepDetailsToolCallsCodeOutputImageObject.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'RunStepDeltaStepDetailsToolCallsCodeOutput',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsCodeOutput {
  /// The index of the output in the outputs array.
  int get index;

  /// Always `logs`.
  String get type;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeOutput>
      get copyWith => _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl<
              RunStepDeltaStepDetailsToolCallsCodeOutput>(
          this as RunStepDeltaStepDetailsToolCallsCodeOutput, _$identity);

  /// Serializes this RunStepDeltaStepDetailsToolCallsCodeOutput to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsCodeOutput &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutput(index: $index, type: $type)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeOutput value,
          $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutput) _then) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl;
  @useResult
  $Res call({int index, String type});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl<$Res>
    implements $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsCodeOutput _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutput) _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [RunStepDeltaStepDetailsToolCallsCodeOutput].
extension RunStepDeltaStepDetailsToolCallsCodeOutputPatterns
    on RunStepDeltaStepDetailsToolCallsCodeOutput {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject()
          when logs != null:
        return logs(_that);
      case RunStepDeltaStepDetailsToolCallsCodeOutputImageObject()
          when image != null:
        return image(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject():
        return logs(_that);
      case RunStepDeltaStepDetailsToolCallsCodeOutputImageObject():
        return image(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject()
          when logs != null:
        return logs(_that);
      case RunStepDeltaStepDetailsToolCallsCodeOutputImageObject()
          when image != null:
        return image(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject()
          when logs != null:
        return logs(_that.index, _that.type, _that.logs);
      case RunStepDeltaStepDetailsToolCallsCodeOutputImageObject()
          when image != null:
        return image(_that.index, _that.type, _that.image);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index, String type, @JsonKey(includeIfNull: false) String? logs)
        logs,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject():
        return logs(_that.index, _that.type, _that.logs);
      case RunStepDeltaStepDetailsToolCallsCodeOutputImageObject():
        return image(_that.index, _that.type, _that.image);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
  }) {
    final _that = this;
    switch (_that) {
      case RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject()
          when logs != null:
        return logs(_that.index, _that.type, _that.logs);
      case RunStepDeltaStepDetailsToolCallsCodeOutputImageObject()
          when image != null:
        return image(_that.index, _that.type, _that.image);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
    extends RunStepDeltaStepDetailsToolCallsCodeOutput {
  const RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.logs})
      : super._();
  factory RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectFromJson(json);

  /// The index of the output in the outputs array.
  @override
  final int index;

  /// Always `logs`.
  @override
  final String type;

  /// The text output from the Code Interpreter tool call.
  @JsonKey(includeIfNull: false)
  final String? logs;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject>
      get copyWith =>
          _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl<
                  RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.logs, logs) || other.logs == logs));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, logs);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutput.logs(index: $index, type: $type, logs: $logs)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value,
          $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject)
              _then) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index, String type, @JsonKey(includeIfNull: false) String? logs});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl<$Res>
    implements
        $RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject)
      _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? logs = freezed,
  }) {
    return _then(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      logs: freezed == logs
          ? _self.logs
          : logs // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
    extends RunStepDeltaStepDetailsToolCallsCodeOutput {
  const RunStepDeltaStepDetailsToolCallsCodeOutputImageObject(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.image})
      : super._();
  factory RunStepDeltaStepDetailsToolCallsCodeOutputImageObject.fromJson(
          Map<String, dynamic> json) =>
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectFromJson(json);

  /// The index of the output in the outputs array.
  @override
  final int index;

  /// Always `image`.
  @override
  final String type;

  /// Code interpreter image output.
  @JsonKey(includeIfNull: false)
  final RunStepDeltaStepDetailsToolCallsCodeOutputImage? image;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeOutputImageObject>
      get copyWith =>
          _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl<
                  RunStepDeltaStepDetailsToolCallsCodeOutputImageObject>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepDeltaStepDetailsToolCallsCodeOutputImageObject &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, image);

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutput.image(index: $index, type: $type, image: $image)';
  }
}

/// @nodoc
abstract mixin class $RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value,
          $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject)
              _then) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false)
      RunStepDeltaStepDetailsToolCallsCodeOutputImage? image});

  $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res>? get image;
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl<$Res>
    implements
        $RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectCopyWithImpl(
      this._self, this._then);

  final RunStepDeltaStepDetailsToolCallsCodeOutputImageObject _self;
  final $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject)
      _then;

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? image = freezed,
  }) {
    return _then(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject(
      index: null == index
          ? _self.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _self.image
          : image // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsToolCallsCodeOutputImage?,
    ));
  }

  /// Create a copy of RunStepDeltaStepDetailsToolCallsCodeOutput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res>? get image {
    if (_self.image == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res>(
        _self.image!, (value) {
      return _then(_self.copyWith(image: value));
    });
  }
}

ChunkingStrategyRequestParam _$ChunkingStrategyRequestParamFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'auto':
      return AutoChunkingStrategyRequestParam.fromJson(json);
    case 'static':
      return StaticChunkingStrategyRequestParam.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChunkingStrategyRequestParam',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChunkingStrategyRequestParam {
  /// Always `auto`.
  String get type;

  /// Create a copy of ChunkingStrategyRequestParam
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<ChunkingStrategyRequestParam>
      get copyWith => _$ChunkingStrategyRequestParamCopyWithImpl<
              ChunkingStrategyRequestParam>(
          this as ChunkingStrategyRequestParam, _$identity);

  /// Serializes this ChunkingStrategyRequestParam to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChunkingStrategyRequestParam &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ChunkingStrategyRequestParam(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ChunkingStrategyRequestParamCopyWith<$Res> {
  factory $ChunkingStrategyRequestParamCopyWith(
          ChunkingStrategyRequestParam value,
          $Res Function(ChunkingStrategyRequestParam) _then) =
      _$ChunkingStrategyRequestParamCopyWithImpl;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$ChunkingStrategyRequestParamCopyWithImpl<$Res>
    implements $ChunkingStrategyRequestParamCopyWith<$Res> {
  _$ChunkingStrategyRequestParamCopyWithImpl(this._self, this._then);

  final ChunkingStrategyRequestParam _self;
  final $Res Function(ChunkingStrategyRequestParam) _then;

  /// Create a copy of ChunkingStrategyRequestParam
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChunkingStrategyRequestParam].
extension ChunkingStrategyRequestParamPatterns on ChunkingStrategyRequestParam {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult Function(StaticChunkingStrategyRequestParam value)? static,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AutoChunkingStrategyRequestParam() when auto != null:
        return auto(_that);
      case StaticChunkingStrategyRequestParam() when static != null:
        return static(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AutoChunkingStrategyRequestParam value) auto,
    required TResult Function(StaticChunkingStrategyRequestParam value) static,
  }) {
    final _that = this;
    switch (_that) {
      case AutoChunkingStrategyRequestParam():
        return auto(_that);
      case StaticChunkingStrategyRequestParam():
        return static(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult? Function(StaticChunkingStrategyRequestParam value)? static,
  }) {
    final _that = this;
    switch (_that) {
      case AutoChunkingStrategyRequestParam() when auto != null:
        return auto(_that);
      case StaticChunkingStrategyRequestParam() when static != null:
        return static(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? auto,
    TResult Function(String type, StaticChunkingStrategy static)? static,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case AutoChunkingStrategyRequestParam() when auto != null:
        return auto(_that.type);
      case StaticChunkingStrategyRequestParam() when static != null:
        return static(_that.type, _that.static);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) auto,
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
  }) {
    final _that = this;
    switch (_that) {
      case AutoChunkingStrategyRequestParam():
        return auto(_that.type);
      case StaticChunkingStrategyRequestParam():
        return static(_that.type, _that.static);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? auto,
    TResult? Function(String type, StaticChunkingStrategy static)? static,
  }) {
    final _that = this;
    switch (_that) {
      case AutoChunkingStrategyRequestParam() when auto != null:
        return auto(_that.type);
      case StaticChunkingStrategyRequestParam() when static != null:
        return static(_that.type, _that.static);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class AutoChunkingStrategyRequestParam extends ChunkingStrategyRequestParam {
  const AutoChunkingStrategyRequestParam({required this.type}) : super._();
  factory AutoChunkingStrategyRequestParam.fromJson(
          Map<String, dynamic> json) =>
      _$AutoChunkingStrategyRequestParamFromJson(json);

  /// Always `auto`.
  @override
  final String type;

  /// Create a copy of ChunkingStrategyRequestParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AutoChunkingStrategyRequestParamCopyWith<AutoChunkingStrategyRequestParam>
      get copyWith => _$AutoChunkingStrategyRequestParamCopyWithImpl<
          AutoChunkingStrategyRequestParam>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AutoChunkingStrategyRequestParamToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AutoChunkingStrategyRequestParam &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ChunkingStrategyRequestParam.auto(type: $type)';
  }
}

/// @nodoc
abstract mixin class $AutoChunkingStrategyRequestParamCopyWith<$Res>
    implements $ChunkingStrategyRequestParamCopyWith<$Res> {
  factory $AutoChunkingStrategyRequestParamCopyWith(
          AutoChunkingStrategyRequestParam value,
          $Res Function(AutoChunkingStrategyRequestParam) _then) =
      _$AutoChunkingStrategyRequestParamCopyWithImpl;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$AutoChunkingStrategyRequestParamCopyWithImpl<$Res>
    implements $AutoChunkingStrategyRequestParamCopyWith<$Res> {
  _$AutoChunkingStrategyRequestParamCopyWithImpl(this._self, this._then);

  final AutoChunkingStrategyRequestParam _self;
  final $Res Function(AutoChunkingStrategyRequestParam) _then;

  /// Create a copy of ChunkingStrategyRequestParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
  }) {
    return _then(AutoChunkingStrategyRequestParam(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class StaticChunkingStrategyRequestParam extends ChunkingStrategyRequestParam {
  const StaticChunkingStrategyRequestParam(
      {required this.type, required this.static})
      : super._();
  factory StaticChunkingStrategyRequestParam.fromJson(
          Map<String, dynamic> json) =>
      _$StaticChunkingStrategyRequestParamFromJson(json);

  /// Always `static`.
  @override
  final String type;

  /// Static chunking strategy
  final StaticChunkingStrategy static;

  /// Create a copy of ChunkingStrategyRequestParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StaticChunkingStrategyRequestParamCopyWith<
          StaticChunkingStrategyRequestParam>
      get copyWith => _$StaticChunkingStrategyRequestParamCopyWithImpl<
          StaticChunkingStrategyRequestParam>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StaticChunkingStrategyRequestParamToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StaticChunkingStrategyRequestParam &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.static, static) || other.static == static));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, static);

  @override
  String toString() {
    return 'ChunkingStrategyRequestParam.static(type: $type, static: $static)';
  }
}

/// @nodoc
abstract mixin class $StaticChunkingStrategyRequestParamCopyWith<$Res>
    implements $ChunkingStrategyRequestParamCopyWith<$Res> {
  factory $StaticChunkingStrategyRequestParamCopyWith(
          StaticChunkingStrategyRequestParam value,
          $Res Function(StaticChunkingStrategyRequestParam) _then) =
      _$StaticChunkingStrategyRequestParamCopyWithImpl;
  @override
  @useResult
  $Res call({String type, StaticChunkingStrategy static});

  $StaticChunkingStrategyCopyWith<$Res> get static;
}

/// @nodoc
class _$StaticChunkingStrategyRequestParamCopyWithImpl<$Res>
    implements $StaticChunkingStrategyRequestParamCopyWith<$Res> {
  _$StaticChunkingStrategyRequestParamCopyWithImpl(this._self, this._then);

  final StaticChunkingStrategyRequestParam _self;
  final $Res Function(StaticChunkingStrategyRequestParam) _then;

  /// Create a copy of ChunkingStrategyRequestParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? static = null,
  }) {
    return _then(StaticChunkingStrategyRequestParam(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      static: null == static
          ? _self.static
          : static // ignore: cast_nullable_to_non_nullable
              as StaticChunkingStrategy,
    ));
  }

  /// Create a copy of ChunkingStrategyRequestParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StaticChunkingStrategyCopyWith<$Res> get static {
    return $StaticChunkingStrategyCopyWith<$Res>(_self.static, (value) {
      return _then(_self.copyWith(static: value));
    });
  }
}

ChunkingStrategyResponseParam _$ChunkingStrategyResponseParamFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'static':
      return StaticChunkingStrategyResponseParam.fromJson(json);
    case 'other':
      return OtherChunkingStrategyResponseParam.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChunkingStrategyResponseParam',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChunkingStrategyResponseParam {
  /// Always `static`.
  String get type;

  /// Create a copy of ChunkingStrategyResponseParam
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ChunkingStrategyResponseParamCopyWith<ChunkingStrategyResponseParam>
      get copyWith => _$ChunkingStrategyResponseParamCopyWithImpl<
              ChunkingStrategyResponseParam>(
          this as ChunkingStrategyResponseParam, _$identity);

  /// Serializes this ChunkingStrategyResponseParam to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChunkingStrategyResponseParam &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ChunkingStrategyResponseParam(type: $type)';
  }
}

/// @nodoc
abstract mixin class $ChunkingStrategyResponseParamCopyWith<$Res> {
  factory $ChunkingStrategyResponseParamCopyWith(
          ChunkingStrategyResponseParam value,
          $Res Function(ChunkingStrategyResponseParam) _then) =
      _$ChunkingStrategyResponseParamCopyWithImpl;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$ChunkingStrategyResponseParamCopyWithImpl<$Res>
    implements $ChunkingStrategyResponseParamCopyWith<$Res> {
  _$ChunkingStrategyResponseParamCopyWithImpl(this._self, this._then);

  final ChunkingStrategyResponseParam _self;
  final $Res Function(ChunkingStrategyResponseParam) _then;

  /// Create a copy of ChunkingStrategyResponseParam
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_self.copyWith(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// Adds pattern-matching-related methods to [ChunkingStrategyResponseParam].
extension ChunkingStrategyResponseParamPatterns
    on ChunkingStrategyResponseParam {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StaticChunkingStrategyResponseParam value)? static,
    TResult Function(OtherChunkingStrategyResponseParam value)? other,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case StaticChunkingStrategyResponseParam() when static != null:
        return static(_that);
      case OtherChunkingStrategyResponseParam() when other != null:
        return other(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StaticChunkingStrategyResponseParam value) static,
    required TResult Function(OtherChunkingStrategyResponseParam value) other,
  }) {
    final _that = this;
    switch (_that) {
      case StaticChunkingStrategyResponseParam():
        return static(_that);
      case OtherChunkingStrategyResponseParam():
        return other(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StaticChunkingStrategyResponseParam value)? static,
    TResult? Function(OtherChunkingStrategyResponseParam value)? other,
  }) {
    final _that = this;
    switch (_that) {
      case StaticChunkingStrategyResponseParam() when static != null:
        return static(_that);
      case OtherChunkingStrategyResponseParam() when other != null:
        return other(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, StaticChunkingStrategy static)? static,
    TResult Function(String type)? other,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case StaticChunkingStrategyResponseParam() when static != null:
        return static(_that.type, _that.static);
      case OtherChunkingStrategyResponseParam() when other != null:
        return other(_that.type);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
    required TResult Function(String type) other,
  }) {
    final _that = this;
    switch (_that) {
      case StaticChunkingStrategyResponseParam():
        return static(_that.type, _that.static);
      case OtherChunkingStrategyResponseParam():
        return other(_that.type);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, StaticChunkingStrategy static)? static,
    TResult? Function(String type)? other,
  }) {
    final _that = this;
    switch (_that) {
      case StaticChunkingStrategyResponseParam() when static != null:
        return static(_that.type, _that.static);
      case OtherChunkingStrategyResponseParam() when other != null:
        return other(_that.type);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class StaticChunkingStrategyResponseParam
    extends ChunkingStrategyResponseParam {
  const StaticChunkingStrategyResponseParam(
      {required this.type, required this.static})
      : super._();
  factory StaticChunkingStrategyResponseParam.fromJson(
          Map<String, dynamic> json) =>
      _$StaticChunkingStrategyResponseParamFromJson(json);

  /// Always `static`.
  @override
  final String type;

  /// Static chunking strategy
  final StaticChunkingStrategy static;

  /// Create a copy of ChunkingStrategyResponseParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $StaticChunkingStrategyResponseParamCopyWith<
          StaticChunkingStrategyResponseParam>
      get copyWith => _$StaticChunkingStrategyResponseParamCopyWithImpl<
          StaticChunkingStrategyResponseParam>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$StaticChunkingStrategyResponseParamToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is StaticChunkingStrategyResponseParam &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.static, static) || other.static == static));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, static);

  @override
  String toString() {
    return 'ChunkingStrategyResponseParam.static(type: $type, static: $static)';
  }
}

/// @nodoc
abstract mixin class $StaticChunkingStrategyResponseParamCopyWith<$Res>
    implements $ChunkingStrategyResponseParamCopyWith<$Res> {
  factory $StaticChunkingStrategyResponseParamCopyWith(
          StaticChunkingStrategyResponseParam value,
          $Res Function(StaticChunkingStrategyResponseParam) _then) =
      _$StaticChunkingStrategyResponseParamCopyWithImpl;
  @override
  @useResult
  $Res call({String type, StaticChunkingStrategy static});

  $StaticChunkingStrategyCopyWith<$Res> get static;
}

/// @nodoc
class _$StaticChunkingStrategyResponseParamCopyWithImpl<$Res>
    implements $StaticChunkingStrategyResponseParamCopyWith<$Res> {
  _$StaticChunkingStrategyResponseParamCopyWithImpl(this._self, this._then);

  final StaticChunkingStrategyResponseParam _self;
  final $Res Function(StaticChunkingStrategyResponseParam) _then;

  /// Create a copy of ChunkingStrategyResponseParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
    Object? static = null,
  }) {
    return _then(StaticChunkingStrategyResponseParam(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      static: null == static
          ? _self.static
          : static // ignore: cast_nullable_to_non_nullable
              as StaticChunkingStrategy,
    ));
  }

  /// Create a copy of ChunkingStrategyResponseParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StaticChunkingStrategyCopyWith<$Res> get static {
    return $StaticChunkingStrategyCopyWith<$Res>(_self.static, (value) {
      return _then(_self.copyWith(static: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class OtherChunkingStrategyResponseParam extends ChunkingStrategyResponseParam {
  const OtherChunkingStrategyResponseParam({required this.type}) : super._();
  factory OtherChunkingStrategyResponseParam.fromJson(
          Map<String, dynamic> json) =>
      _$OtherChunkingStrategyResponseParamFromJson(json);

  /// Always `other`.
  @override
  final String type;

  /// Create a copy of ChunkingStrategyResponseParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $OtherChunkingStrategyResponseParamCopyWith<
          OtherChunkingStrategyResponseParam>
      get copyWith => _$OtherChunkingStrategyResponseParamCopyWithImpl<
          OtherChunkingStrategyResponseParam>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$OtherChunkingStrategyResponseParamToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OtherChunkingStrategyResponseParam &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @override
  String toString() {
    return 'ChunkingStrategyResponseParam.other(type: $type)';
  }
}

/// @nodoc
abstract mixin class $OtherChunkingStrategyResponseParamCopyWith<$Res>
    implements $ChunkingStrategyResponseParamCopyWith<$Res> {
  factory $OtherChunkingStrategyResponseParamCopyWith(
          OtherChunkingStrategyResponseParam value,
          $Res Function(OtherChunkingStrategyResponseParam) _then) =
      _$OtherChunkingStrategyResponseParamCopyWithImpl;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$OtherChunkingStrategyResponseParamCopyWithImpl<$Res>
    implements $OtherChunkingStrategyResponseParamCopyWith<$Res> {
  _$OtherChunkingStrategyResponseParamCopyWithImpl(this._self, this._then);

  final OtherChunkingStrategyResponseParam _self;
  final $Res Function(OtherChunkingStrategyResponseParam) _then;

  /// Create a copy of ChunkingStrategyResponseParam
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? type = null,
  }) {
    return _then(OtherChunkingStrategyResponseParam(
      type: null == type
          ? _self.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

AssistantStreamEvent _$AssistantStreamEventFromJson(Map<String, dynamic> json) {
  switch (json['event']) {
    case 'thread_stream_event':
      return ThreadStreamEvent.fromJson(json);
    case 'run_stream_event':
      return RunStreamEvent.fromJson(json);
    case 'run_step_stream_event':
      return RunStepStreamEvent.fromJson(json);
    case 'run_step_stream_delta_event':
      return RunStepStreamDeltaEvent.fromJson(json);
    case 'message_stream_event':
      return MessageStreamEvent.fromJson(json);
    case 'message_stream_delta_event':
      return MessageStreamDeltaEvent.fromJson(json);
    case 'error_event':
      return ErrorEvent.fromJson(json);
    case 'done_event':
      return DoneEvent.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'event', 'AssistantStreamEvent',
          'Invalid union type "${json['event']}"!');
  }
}

/// @nodoc
mixin _$AssistantStreamEvent {
  /// The type of the event.
  EventType get event;

  /// Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages).
  Object get data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AssistantStreamEventCopyWith<AssistantStreamEvent> get copyWith =>
      _$AssistantStreamEventCopyWithImpl<AssistantStreamEvent>(
          this as AssistantStreamEvent, _$identity);

  /// Serializes this AssistantStreamEvent to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AssistantStreamEvent &&
            (identical(other.event, event) || other.event == event) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, event, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'AssistantStreamEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $AssistantStreamEventCopyWith<$Res> {
  factory $AssistantStreamEventCopyWith(AssistantStreamEvent value,
          $Res Function(AssistantStreamEvent) _then) =
      _$AssistantStreamEventCopyWithImpl;
  @useResult
  $Res call({EventType event});
}

/// @nodoc
class _$AssistantStreamEventCopyWithImpl<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  _$AssistantStreamEventCopyWithImpl(this._self, this._then);

  final AssistantStreamEvent _self;
  final $Res Function(AssistantStreamEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
  }) {
    return _then(_self.copyWith(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
    ));
  }
}

/// Adds pattern-matching-related methods to [AssistantStreamEvent].
extension AssistantStreamEventPatterns on AssistantStreamEvent {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ThreadStreamEvent() when threadStreamEvent != null:
        return threadStreamEvent(_that);
      case RunStreamEvent() when runStreamEvent != null:
        return runStreamEvent(_that);
      case RunStepStreamEvent() when runStepStreamEvent != null:
        return runStepStreamEvent(_that);
      case RunStepStreamDeltaEvent() when runStepStreamDeltaEvent != null:
        return runStepStreamDeltaEvent(_that);
      case MessageStreamEvent() when messageStreamEvent != null:
        return messageStreamEvent(_that);
      case MessageStreamDeltaEvent() when messageStreamDeltaEvent != null:
        return messageStreamDeltaEvent(_that);
      case ErrorEvent() when errorEvent != null:
        return errorEvent(_that);
      case DoneEvent() when doneEvent != null:
        return doneEvent(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadStreamEvent():
        return threadStreamEvent(_that);
      case RunStreamEvent():
        return runStreamEvent(_that);
      case RunStepStreamEvent():
        return runStepStreamEvent(_that);
      case RunStepStreamDeltaEvent():
        return runStepStreamDeltaEvent(_that);
      case MessageStreamEvent():
        return messageStreamEvent(_that);
      case MessageStreamDeltaEvent():
        return messageStreamDeltaEvent(_that);
      case ErrorEvent():
        return errorEvent(_that);
      case DoneEvent():
        return doneEvent(_that);
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadStreamEvent() when threadStreamEvent != null:
        return threadStreamEvent(_that);
      case RunStreamEvent() when runStreamEvent != null:
        return runStreamEvent(_that);
      case RunStepStreamEvent() when runStepStreamEvent != null:
        return runStepStreamEvent(_that);
      case RunStepStreamDeltaEvent() when runStepStreamDeltaEvent != null:
        return runStepStreamDeltaEvent(_that);
      case MessageStreamEvent() when messageStreamEvent != null:
        return messageStreamEvent(_that);
      case MessageStreamDeltaEvent() when messageStreamDeltaEvent != null:
        return messageStreamDeltaEvent(_that);
      case ErrorEvent() when errorEvent != null:
        return errorEvent(_that);
      case DoneEvent() when doneEvent != null:
        return doneEvent(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case ThreadStreamEvent() when threadStreamEvent != null:
        return threadStreamEvent(_that.event, _that.data);
      case RunStreamEvent() when runStreamEvent != null:
        return runStreamEvent(_that.event, _that.data);
      case RunStepStreamEvent() when runStepStreamEvent != null:
        return runStepStreamEvent(_that.event, _that.data);
      case RunStepStreamDeltaEvent() when runStepStreamDeltaEvent != null:
        return runStepStreamDeltaEvent(_that.event, _that.data);
      case MessageStreamEvent() when messageStreamEvent != null:
        return messageStreamEvent(_that.event, _that.data);
      case MessageStreamDeltaEvent() when messageStreamDeltaEvent != null:
        return messageStreamDeltaEvent(_that.event, _that.data);
      case ErrorEvent() when errorEvent != null:
        return errorEvent(_that.event, _that.data);
      case DoneEvent() when doneEvent != null:
        return doneEvent(_that.event, _that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadStreamEvent():
        return threadStreamEvent(_that.event, _that.data);
      case RunStreamEvent():
        return runStreamEvent(_that.event, _that.data);
      case RunStepStreamEvent():
        return runStepStreamEvent(_that.event, _that.data);
      case RunStepStreamDeltaEvent():
        return runStepStreamDeltaEvent(_that.event, _that.data);
      case MessageStreamEvent():
        return messageStreamEvent(_that.event, _that.data);
      case MessageStreamDeltaEvent():
        return messageStreamDeltaEvent(_that.event, _that.data);
      case ErrorEvent():
        return errorEvent(_that.event, _that.data);
      case DoneEvent():
        return doneEvent(_that.event, _that.data);
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    final _that = this;
    switch (_that) {
      case ThreadStreamEvent() when threadStreamEvent != null:
        return threadStreamEvent(_that.event, _that.data);
      case RunStreamEvent() when runStreamEvent != null:
        return runStreamEvent(_that.event, _that.data);
      case RunStepStreamEvent() when runStepStreamEvent != null:
        return runStepStreamEvent(_that.event, _that.data);
      case RunStepStreamDeltaEvent() when runStepStreamDeltaEvent != null:
        return runStepStreamDeltaEvent(_that.event, _that.data);
      case MessageStreamEvent() when messageStreamEvent != null:
        return messageStreamEvent(_that.event, _that.data);
      case MessageStreamDeltaEvent() when messageStreamDeltaEvent != null:
        return messageStreamDeltaEvent(_that.event, _that.data);
      case ErrorEvent() when errorEvent != null:
        return errorEvent(_that.event, _that.data);
      case DoneEvent() when doneEvent != null:
        return doneEvent(_that.event, _that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class ThreadStreamEvent extends AssistantStreamEvent {
  const ThreadStreamEvent({required this.event, required this.data})
      : super._();
  factory ThreadStreamEvent.fromJson(Map<String, dynamic> json) =>
      _$ThreadStreamEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages).
  @override
  final ThreadObject data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ThreadStreamEventCopyWith<ThreadStreamEvent> get copyWith =>
      _$ThreadStreamEventCopyWithImpl<ThreadStreamEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ThreadStreamEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ThreadStreamEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.threadStreamEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $ThreadStreamEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $ThreadStreamEventCopyWith(
          ThreadStreamEvent value, $Res Function(ThreadStreamEvent) _then) =
      _$ThreadStreamEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, ThreadObject data});

  $ThreadObjectCopyWith<$Res> get data;
}

/// @nodoc
class _$ThreadStreamEventCopyWithImpl<$Res>
    implements $ThreadStreamEventCopyWith<$Res> {
  _$ThreadStreamEventCopyWithImpl(this._self, this._then);

  final ThreadStreamEvent _self;
  final $Res Function(ThreadStreamEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(ThreadStreamEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as ThreadObject,
    ));
  }

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ThreadObjectCopyWith<$Res> get data {
    return $ThreadObjectCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStreamEvent extends AssistantStreamEvent {
  const RunStreamEvent({required this.event, required this.data}) : super._();
  factory RunStreamEvent.fromJson(Map<String, dynamic> json) =>
      _$RunStreamEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents an execution run on a [thread](https://platform.openai.com/docs/api-reference/threads).
  @override
  final RunObject data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStreamEventCopyWith<RunStreamEvent> get copyWith =>
      _$RunStreamEventCopyWithImpl<RunStreamEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStreamEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStreamEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.runStreamEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $RunStreamEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $RunStreamEventCopyWith(
          RunStreamEvent value, $Res Function(RunStreamEvent) _then) =
      _$RunStreamEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, RunObject data});

  $RunObjectCopyWith<$Res> get data;
}

/// @nodoc
class _$RunStreamEventCopyWithImpl<$Res>
    implements $RunStreamEventCopyWith<$Res> {
  _$RunStreamEventCopyWithImpl(this._self, this._then);

  final RunStreamEvent _self;
  final $Res Function(RunStreamEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(RunStreamEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as RunObject,
    ));
  }

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunObjectCopyWith<$Res> get data {
    return $RunObjectCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStepStreamEvent extends AssistantStreamEvent {
  const RunStepStreamEvent({required this.event, required this.data})
      : super._();
  factory RunStepStreamEvent.fromJson(Map<String, dynamic> json) =>
      _$RunStepStreamEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a step in execution of a run.
  @override
  final RunStepObject data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepStreamEventCopyWith<RunStepStreamEvent> get copyWith =>
      _$RunStepStreamEventCopyWithImpl<RunStepStreamEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepStreamEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepStreamEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.runStepStreamEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $RunStepStreamEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $RunStepStreamEventCopyWith(
          RunStepStreamEvent value, $Res Function(RunStepStreamEvent) _then) =
      _$RunStepStreamEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, RunStepObject data});

  $RunStepObjectCopyWith<$Res> get data;
}

/// @nodoc
class _$RunStepStreamEventCopyWithImpl<$Res>
    implements $RunStepStreamEventCopyWith<$Res> {
  _$RunStepStreamEventCopyWithImpl(this._self, this._then);

  final RunStepStreamEvent _self;
  final $Res Function(RunStepStreamEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(RunStepStreamEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as RunStepObject,
    ));
  }

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepObjectCopyWith<$Res> get data {
    return $RunStepObjectCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class RunStepStreamDeltaEvent extends AssistantStreamEvent {
  const RunStepStreamDeltaEvent({required this.event, required this.data})
      : super._();
  factory RunStepStreamDeltaEvent.fromJson(Map<String, dynamic> json) =>
      _$RunStepStreamDeltaEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a run step delta i.e. any changed fields on a run step during streaming.
  @override
  final RunStepDeltaObject data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $RunStepStreamDeltaEventCopyWith<RunStepStreamDeltaEvent> get copyWith =>
      _$RunStepStreamDeltaEventCopyWithImpl<RunStepStreamDeltaEvent>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$RunStepStreamDeltaEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RunStepStreamDeltaEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.runStepStreamDeltaEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $RunStepStreamDeltaEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $RunStepStreamDeltaEventCopyWith(RunStepStreamDeltaEvent value,
          $Res Function(RunStepStreamDeltaEvent) _then) =
      _$RunStepStreamDeltaEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, RunStepDeltaObject data});

  $RunStepDeltaObjectCopyWith<$Res> get data;
}

/// @nodoc
class _$RunStepStreamDeltaEventCopyWithImpl<$Res>
    implements $RunStepStreamDeltaEventCopyWith<$Res> {
  _$RunStepStreamDeltaEventCopyWithImpl(this._self, this._then);

  final RunStepStreamDeltaEvent _self;
  final $Res Function(RunStepStreamDeltaEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(RunStepStreamDeltaEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaObject,
    ));
  }

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaObjectCopyWith<$Res> get data {
    return $RunStepDeltaObjectCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageStreamEvent extends AssistantStreamEvent {
  const MessageStreamEvent({required this.event, required this.data})
      : super._();
  factory MessageStreamEvent.fromJson(Map<String, dynamic> json) =>
      _$MessageStreamEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a message within a [thread](https://platform.openai.com/docs/api-reference/threads).
  @override
  final MessageObject data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageStreamEventCopyWith<MessageStreamEvent> get copyWith =>
      _$MessageStreamEventCopyWithImpl<MessageStreamEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageStreamEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageStreamEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.messageStreamEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $MessageStreamEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $MessageStreamEventCopyWith(
          MessageStreamEvent value, $Res Function(MessageStreamEvent) _then) =
      _$MessageStreamEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, MessageObject data});

  $MessageObjectCopyWith<$Res> get data;
}

/// @nodoc
class _$MessageStreamEventCopyWithImpl<$Res>
    implements $MessageStreamEventCopyWith<$Res> {
  _$MessageStreamEventCopyWithImpl(this._self, this._then);

  final MessageStreamEvent _self;
  final $Res Function(MessageStreamEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(MessageStreamEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as MessageObject,
    ));
  }

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageObjectCopyWith<$Res> get data {
    return $MessageObjectCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class MessageStreamDeltaEvent extends AssistantStreamEvent {
  const MessageStreamDeltaEvent({required this.event, required this.data})
      : super._();
  factory MessageStreamDeltaEvent.fromJson(Map<String, dynamic> json) =>
      _$MessageStreamDeltaEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a message delta i.e. any changed fields on a message during streaming.
  @override
  final MessageDeltaObject data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MessageStreamDeltaEventCopyWith<MessageStreamDeltaEvent> get copyWith =>
      _$MessageStreamDeltaEventCopyWithImpl<MessageStreamDeltaEvent>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$MessageStreamDeltaEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MessageStreamDeltaEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.messageStreamDeltaEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $MessageStreamDeltaEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $MessageStreamDeltaEventCopyWith(MessageStreamDeltaEvent value,
          $Res Function(MessageStreamDeltaEvent) _then) =
      _$MessageStreamDeltaEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, MessageDeltaObject data});

  $MessageDeltaObjectCopyWith<$Res> get data;
}

/// @nodoc
class _$MessageStreamDeltaEventCopyWithImpl<$Res>
    implements $MessageStreamDeltaEventCopyWith<$Res> {
  _$MessageStreamDeltaEventCopyWithImpl(this._self, this._then);

  final MessageStreamDeltaEvent _self;
  final $Res Function(MessageStreamDeltaEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(MessageStreamDeltaEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as MessageDeltaObject,
    ));
  }

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaObjectCopyWith<$Res> get data {
    return $MessageDeltaObjectCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class ErrorEvent extends AssistantStreamEvent {
  const ErrorEvent({required this.event, required this.data}) : super._();
  factory ErrorEvent.fromJson(Map<String, dynamic> json) =>
      _$ErrorEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents an error that occurred during an API request.
  @override
  final Error data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $ErrorEventCopyWith<ErrorEvent> get copyWith =>
      _$ErrorEventCopyWithImpl<ErrorEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$ErrorEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.errorEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $ErrorEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $ErrorEventCopyWith(
          ErrorEvent value, $Res Function(ErrorEvent) _then) =
      _$ErrorEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, Error data});

  $ErrorCopyWith<$Res> get data;
}

/// @nodoc
class _$ErrorEventCopyWithImpl<$Res> implements $ErrorEventCopyWith<$Res> {
  _$ErrorEventCopyWithImpl(this._self, this._then);

  final ErrorEvent _self;
  final $Res Function(ErrorEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(ErrorEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as Error,
    ));
  }

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ErrorCopyWith<$Res> get data {
    return $ErrorCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class DoneEvent extends AssistantStreamEvent {
  const DoneEvent({required this.event, required this.data}) : super._();
  factory DoneEvent.fromJson(Map<String, dynamic> json) =>
      _$DoneEventFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// No Description
  @override
  final String data;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $DoneEventCopyWith<DoneEvent> get copyWith =>
      _$DoneEventCopyWithImpl<DoneEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$DoneEventToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DoneEvent &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @override
  String toString() {
    return 'AssistantStreamEvent.doneEvent(event: $event, data: $data)';
  }
}

/// @nodoc
abstract mixin class $DoneEventCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory $DoneEventCopyWith(DoneEvent value, $Res Function(DoneEvent) _then) =
      _$DoneEventCopyWithImpl;
  @override
  @useResult
  $Res call({EventType event, String data});
}

/// @nodoc
class _$DoneEventCopyWithImpl<$Res> implements $DoneEventCopyWith<$Res> {
  _$DoneEventCopyWithImpl(this._self, this._then);

  final DoneEvent _self;
  final $Res Function(DoneEvent) _then;

  /// Create a copy of AssistantStreamEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(DoneEvent(
      event: null == event
          ? _self.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

// dart format on
