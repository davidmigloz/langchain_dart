// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schema.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

CreateCompletionRequest _$CreateCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model => throw _privateConstructorUsedError;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt => throw _privateConstructorUsedError;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf => throw _privateConstructorUsedError;

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop => throw _privateConstructorUsedError;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// The suffix that comes after a completion of inserted text.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionRequestCopyWith<CreateCompletionRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionRequestCopyWith<$Res> {
  factory $CreateCompletionRequestCopyWith(CreateCompletionRequest value,
          $Res Function(CreateCompletionRequest) then) =
      _$CreateCompletionRequestCopyWithImpl<$Res, CreateCompletionRequest>;
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  $CompletionModelCopyWith<$Res> get model;
  $CompletionPromptCopyWith<$Res>? get prompt;
  $CompletionStopCopyWith<$Res>? get stop;
}

/// @nodoc
class _$CreateCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateCompletionRequest>
    implements $CreateCompletionRequestCopyWith<$Res> {
  _$CreateCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionModelCopyWith<$Res> get model {
    return $CompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionPromptCopyWith<$Res>? get prompt {
    if (_value.prompt == null) {
      return null;
    }

    return $CompletionPromptCopyWith<$Res>(_value.prompt!, (value) {
      return _then(_value.copyWith(prompt: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $CompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionRequestImplCopyWith<$Res>
    implements $CreateCompletionRequestCopyWith<$Res> {
  factory _$$CreateCompletionRequestImplCopyWith(
          _$CreateCompletionRequestImpl value,
          $Res Function(_$CreateCompletionRequestImpl) then) =
      __$$CreateCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CompletionModelCopyWith<$Res> get model;
  @override
  $CompletionPromptCopyWith<$Res>? get prompt;
  @override
  $CompletionStopCopyWith<$Res>? get stop;
}

/// @nodoc
class __$$CreateCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateCompletionRequestCopyWithImpl<$Res,
        _$CreateCompletionRequestImpl>
    implements _$$CreateCompletionRequestImplCopyWith<$Res> {
  __$$CreateCompletionRequestImplCopyWithImpl(
      _$CreateCompletionRequestImpl _value,
      $Res Function(_$CreateCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionRequestImpl extends _CreateCompletionRequest {
  const _$CreateCompletionRequestImpl(
      {@_CompletionModelConverter() required this.model,
      @_CompletionPromptConverter() required this.prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) this.bestOf,
      @JsonKey(includeIfNull: false) this.echo = false,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens = 16,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @JsonKey(includeIfNull: false) this.seed,
      @_CompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) this.user})
      : _logitBias = logitBias,
        super._();

  factory _$CreateCompletionRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @_CompletionModelConverter()
  final CompletionModel model;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @override
  @_CompletionPromptConverter()
  final CompletionPrompt? prompt;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(name: 'best_of', includeIfNull: false)
  final int? bestOf;

  /// Echo back the prompt in addition to the completion
  @override
  @JsonKey(includeIfNull: false)
  final bool? echo;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @override
  @JsonKey(includeIfNull: false)
  final int? logprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @override
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final CompletionStop? stop;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// The suffix that comes after a completion of inserted text.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateCompletionRequest(model: $model, prompt: $prompt, bestOf: $bestOf, echo: $echo, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, seed: $seed, stop: $stop, stream: $stream, suffix: $suffix, temperature: $temperature, topP: $topP, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.bestOf, bestOf) || other.bestOf == bestOf) &&
            (identical(other.echo, echo) || other.echo == echo) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      prompt,
      bestOf,
      echo,
      frequencyPenalty,
      const DeepCollectionEquality().hash(_logitBias),
      logprobs,
      maxTokens,
      n,
      presencePenalty,
      seed,
      stop,
      stream,
      suffix,
      temperature,
      topP,
      user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => __$$CreateCompletionRequestImplCopyWithImpl<
          _$CreateCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionRequest extends CreateCompletionRequest {
  const factory _CreateCompletionRequest(
      {@_CompletionModelConverter() required final CompletionModel model,
      @_CompletionPromptConverter() required final CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) final int? bestOf,
      @JsonKey(includeIfNull: false) final bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) final int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @JsonKey(includeIfNull: false) final int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final CompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(includeIfNull: false) final String? suffix,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false)
      final String? user}) = _$CreateCompletionRequestImpl;
  const _CreateCompletionRequest._() : super._();

  factory _CreateCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model;
  @override

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt;
  @override

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return â€“ `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf;
  @override

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop;
  @override

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// The suffix that comes after a completion of inserted text.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionModel _$CompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return CompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionModelCopyWith<$Res> {
  factory $CompletionModelCopyWith(
          CompletionModel value, $Res Function(CompletionModel) then) =
      _$CompletionModelCopyWithImpl<$Res, CompletionModel>;
}

/// @nodoc
class _$CompletionModelCopyWithImpl<$Res, $Val extends CompletionModel>
    implements $CompletionModelCopyWith<$Res> {
  _$CompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionModelEnumerationImplCopyWith<$Res> {
  factory _$$CompletionModelEnumerationImplCopyWith(
          _$CompletionModelEnumerationImpl value,
          $Res Function(_$CompletionModelEnumerationImpl) then) =
      __$$CompletionModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CompletionModels value});
}

/// @nodoc
class __$$CompletionModelEnumerationImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res,
        _$CompletionModelEnumerationImpl>
    implements _$$CompletionModelEnumerationImplCopyWith<$Res> {
  __$$CompletionModelEnumerationImplCopyWithImpl(
      _$CompletionModelEnumerationImpl _value,
      $Res Function(_$CompletionModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionModelEnumerationImpl extends CompletionModelEnumeration {
  const _$CompletionModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$CompletionModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionModelEnumerationImplFromJson(json);

  @override
  final CompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionModelEnumerationImplCopyWith<_$CompletionModelEnumerationImpl>
      get copyWith => __$$CompletionModelEnumerationImplCopyWithImpl<
          _$CompletionModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class CompletionModelEnumeration extends CompletionModel {
  const factory CompletionModelEnumeration(final CompletionModels value) =
      _$CompletionModelEnumerationImpl;
  const CompletionModelEnumeration._() : super._();

  factory CompletionModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$CompletionModelEnumerationImpl.fromJson;

  @override
  CompletionModels get value;
  @JsonKey(ignore: true)
  _$$CompletionModelEnumerationImplCopyWith<_$CompletionModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionModelStringImplCopyWith<$Res> {
  factory _$$CompletionModelStringImplCopyWith(
          _$CompletionModelStringImpl value,
          $Res Function(_$CompletionModelStringImpl) then) =
      __$$CompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CompletionModelStringImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res, _$CompletionModelStringImpl>
    implements _$$CompletionModelStringImplCopyWith<$Res> {
  __$$CompletionModelStringImplCopyWithImpl(_$CompletionModelStringImpl _value,
      $Res Function(_$CompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionModelStringImpl extends CompletionModelString {
  const _$CompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$CompletionModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionModelStringImplCopyWith<_$CompletionModelStringImpl>
      get copyWith => __$$CompletionModelStringImplCopyWithImpl<
          _$CompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class CompletionModelString extends CompletionModel {
  const factory CompletionModelString(final String value) =
      _$CompletionModelStringImpl;
  const CompletionModelString._() : super._();

  factory CompletionModelString.fromJson(Map<String, dynamic> json) =
      _$CompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CompletionModelStringImplCopyWith<_$CompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionPrompt _$CompletionPromptFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return CompletionPromptListListInt.fromJson(json);
    case 'tokens':
      return CompletionPromptListInt.fromJson(json);
    case 'listString':
      return CompletionPromptListString.fromJson(json);
    case 'string':
      return CompletionPromptString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionPrompt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionPrompt {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptCopyWith(
          CompletionPrompt value, $Res Function(CompletionPrompt) then) =
      _$CompletionPromptCopyWithImpl<$Res, CompletionPrompt>;
}

/// @nodoc
class _$CompletionPromptCopyWithImpl<$Res, $Val extends CompletionPrompt>
    implements $CompletionPromptCopyWith<$Res> {
  _$CompletionPromptCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionPromptListListIntImplCopyWith<$Res> {
  factory _$$CompletionPromptListListIntImplCopyWith(
          _$CompletionPromptListListIntImpl value,
          $Res Function(_$CompletionPromptListListIntImpl) then) =
      __$$CompletionPromptListListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$CompletionPromptListListIntImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$CompletionPromptListListIntImpl>
    implements _$$CompletionPromptListListIntImplCopyWith<$Res> {
  __$$CompletionPromptListListIntImplCopyWithImpl(
      _$CompletionPromptListListIntImpl _value,
      $Res Function(_$CompletionPromptListListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListListIntImpl extends CompletionPromptListListInt {
  const _$CompletionPromptListListIntImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();

  factory _$CompletionPromptListListIntImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionPromptListListIntImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.listTokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListListIntImplCopyWith<_$CompletionPromptListListIntImpl>
      get copyWith => __$$CompletionPromptListListIntImplCopyWithImpl<
          _$CompletionPromptListListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listTokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listTokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return listTokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return listTokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListListIntImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListListInt extends CompletionPrompt {
  const factory CompletionPromptListListInt(final List<List<int>> value) =
      _$CompletionPromptListListIntImpl;
  const CompletionPromptListListInt._() : super._();

  factory CompletionPromptListListInt.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListListIntImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListListIntImplCopyWith<_$CompletionPromptListListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptListIntImplCopyWith<$Res> {
  factory _$$CompletionPromptListIntImplCopyWith(
          _$CompletionPromptListIntImpl value,
          $Res Function(_$CompletionPromptListIntImpl) then) =
      __$$CompletionPromptListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$CompletionPromptListIntImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res, _$CompletionPromptListIntImpl>
    implements _$$CompletionPromptListIntImplCopyWith<$Res> {
  __$$CompletionPromptListIntImplCopyWithImpl(
      _$CompletionPromptListIntImpl _value,
      $Res Function(_$CompletionPromptListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListIntImpl extends CompletionPromptListInt {
  const _$CompletionPromptListIntImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();

  factory _$CompletionPromptListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionPromptListIntImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.tokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListIntImplCopyWith<_$CompletionPromptListIntImpl>
      get copyWith => __$$CompletionPromptListIntImplCopyWithImpl<
          _$CompletionPromptListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return tokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return tokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return tokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return tokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListIntImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListInt extends CompletionPrompt {
  const factory CompletionPromptListInt(final List<int> value) =
      _$CompletionPromptListIntImpl;
  const CompletionPromptListInt._() : super._();

  factory CompletionPromptListInt.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListIntImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListIntImplCopyWith<_$CompletionPromptListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptListStringImplCopyWith<$Res> {
  factory _$$CompletionPromptListStringImplCopyWith(
          _$CompletionPromptListStringImpl value,
          $Res Function(_$CompletionPromptListStringImpl) then) =
      __$$CompletionPromptListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$CompletionPromptListStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$CompletionPromptListStringImpl>
    implements _$$CompletionPromptListStringImplCopyWith<$Res> {
  __$$CompletionPromptListStringImplCopyWithImpl(
      _$CompletionPromptListStringImpl _value,
      $Res Function(_$CompletionPromptListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListStringImpl extends CompletionPromptListString {
  const _$CompletionPromptListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$CompletionPromptListStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionPromptListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListStringImplCopyWith<_$CompletionPromptListStringImpl>
      get copyWith => __$$CompletionPromptListStringImplCopyWithImpl<
          _$CompletionPromptListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListStringImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListString extends CompletionPrompt {
  const factory CompletionPromptListString(final List<String> value) =
      _$CompletionPromptListStringImpl;
  const CompletionPromptListString._() : super._();

  factory CompletionPromptListString.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListStringImplCopyWith<_$CompletionPromptListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptStringImplCopyWith<$Res> {
  factory _$$CompletionPromptStringImplCopyWith(
          _$CompletionPromptStringImpl value,
          $Res Function(_$CompletionPromptStringImpl) then) =
      __$$CompletionPromptStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CompletionPromptStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res, _$CompletionPromptStringImpl>
    implements _$$CompletionPromptStringImplCopyWith<$Res> {
  __$$CompletionPromptStringImplCopyWithImpl(
      _$CompletionPromptStringImpl _value,
      $Res Function(_$CompletionPromptStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptStringImpl extends CompletionPromptString {
  const _$CompletionPromptStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$CompletionPromptStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionPromptStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptStringImplCopyWith<_$CompletionPromptStringImpl>
      get copyWith => __$$CompletionPromptStringImplCopyWithImpl<
          _$CompletionPromptStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptStringImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptString extends CompletionPrompt {
  const factory CompletionPromptString(final String value) =
      _$CompletionPromptStringImpl;
  const CompletionPromptString._() : super._();

  factory CompletionPromptString.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptStringImplCopyWith<_$CompletionPromptStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionStop _$CompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return CompletionStopListString.fromJson(json);
    case 'string':
      return CompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionStop {
  Object? get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionStopCopyWith<$Res> {
  factory $CompletionStopCopyWith(
          CompletionStop value, $Res Function(CompletionStop) then) =
      _$CompletionStopCopyWithImpl<$Res, CompletionStop>;
}

/// @nodoc
class _$CompletionStopCopyWithImpl<$Res, $Val extends CompletionStop>
    implements $CompletionStopCopyWith<$Res> {
  _$CompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionStopListStringImplCopyWith<$Res> {
  factory _$$CompletionStopListStringImplCopyWith(
          _$CompletionStopListStringImpl value,
          $Res Function(_$CompletionStopListStringImpl) then) =
      __$$CompletionStopListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$CompletionStopListStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res, _$CompletionStopListStringImpl>
    implements _$$CompletionStopListStringImplCopyWith<$Res> {
  __$$CompletionStopListStringImplCopyWithImpl(
      _$CompletionStopListStringImpl _value,
      $Res Function(_$CompletionStopListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionStopListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionStopListStringImpl extends CompletionStopListString {
  const _$CompletionStopListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$CompletionStopListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionStopListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionStopListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionStopListStringImplCopyWith<_$CompletionStopListStringImpl>
      get copyWith => __$$CompletionStopListStringImplCopyWithImpl<
          _$CompletionStopListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionStopListStringImplToJson(
      this,
    );
  }
}

abstract class CompletionStopListString extends CompletionStop {
  const factory CompletionStopListString(final List<String> value) =
      _$CompletionStopListStringImpl;
  const CompletionStopListString._() : super._();

  factory CompletionStopListString.fromJson(Map<String, dynamic> json) =
      _$CompletionStopListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$CompletionStopListStringImplCopyWith<_$CompletionStopListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionStopStringImplCopyWith<$Res> {
  factory _$$CompletionStopStringImplCopyWith(_$CompletionStopStringImpl value,
          $Res Function(_$CompletionStopStringImpl) then) =
      __$$CompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class __$$CompletionStopStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res, _$CompletionStopStringImpl>
    implements _$$CompletionStopStringImplCopyWith<$Res> {
  __$$CompletionStopStringImplCopyWithImpl(_$CompletionStopStringImpl _value,
      $Res Function(_$CompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$CompletionStopStringImpl(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionStopStringImpl extends CompletionStopString {
  const _$CompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$CompletionStopStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionStopStringImplFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionStopStringImplCopyWith<_$CompletionStopStringImpl>
      get copyWith =>
          __$$CompletionStopStringImplCopyWithImpl<_$CompletionStopStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class CompletionStopString extends CompletionStop {
  const factory CompletionStopString(final String? value) =
      _$CompletionStopStringImpl;
  const CompletionStopString._() : super._();

  factory CompletionStopString.fromJson(Map<String, dynamic> json) =
      _$CompletionStopStringImpl.fromJson;

  @override
  String? get value;
  @JsonKey(ignore: true)
  _$$CompletionStopStringImplCopyWith<_$CompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateCompletionResponse _$CreateCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionResponse {
  /// A unique identifier for the completion.
  String get id => throw _privateConstructorUsedError;

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always "text_completion"
  CreateCompletionResponseObject get object =>
      throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionResponseCopyWith<CreateCompletionResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionResponseCopyWith<$Res> {
  factory $CreateCompletionResponseCopyWith(CreateCompletionResponse value,
          $Res Function(CreateCompletionResponse) then) =
      _$CreateCompletionResponseCopyWithImpl<$Res, CreateCompletionResponse>;
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateCompletionResponse>
    implements $CreateCompletionResponseCopyWith<$Res> {
  _$CreateCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionResponseImplCopyWith<$Res>
    implements $CreateCompletionResponseCopyWith<$Res> {
  factory _$$CreateCompletionResponseImplCopyWith(
          _$CreateCompletionResponseImpl value,
          $Res Function(_$CreateCompletionResponseImpl) then) =
      __$$CreateCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateCompletionResponseCopyWithImpl<$Res,
        _$CreateCompletionResponseImpl>
    implements _$$CreateCompletionResponseImplCopyWith<$Res> {
  __$$CreateCompletionResponseImplCopyWithImpl(
      _$CreateCompletionResponseImpl _value,
      $Res Function(_$CreateCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateCompletionResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionResponseImpl extends _CreateCompletionResponse {
  const _$CreateCompletionResponseImpl(
      {required this.id,
      required final List<CompletionChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateCompletionResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionResponseImplFromJson(json);

  /// A unique identifier for the completion.
  @override
  final String id;

  /// The list of completion choices the model generated for the input prompt.
  final List<CompletionChoice> _choices;

  /// The list of completion choices the model generated for the input prompt.
  @override
  List<CompletionChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the completion was created.
  @override
  final int created;

  /// The model used for completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always "text_completion"
  @override
  final CreateCompletionResponseObject object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => __$$CreateCompletionResponseImplCopyWithImpl<
          _$CreateCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionResponse extends CreateCompletionResponse {
  const factory _CreateCompletionResponse(
          {required final String id,
          required final List<CompletionChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final CreateCompletionResponseObject object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateCompletionResponseImpl;
  const _CreateCompletionResponse._() : super._();

  factory _CreateCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the completion.
  String get id;
  @override

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created;
  @override

  /// The model used for completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always "text_completion"
  CreateCompletionResponseObject get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionChoice _$CompletionChoiceFromJson(Map<String, dynamic> json) {
  return _CompletionChoice.fromJson(json);
}

/// @nodoc
mixin _$CompletionChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of generated choices.
  int get index => throw _privateConstructorUsedError;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs => throw _privateConstructorUsedError;

  /// The text of the completion.
  String get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionChoiceCopyWith<CompletionChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionChoiceCopyWith<$Res> {
  factory $CompletionChoiceCopyWith(
          CompletionChoice value, $Res Function(CompletionChoice) then) =
      _$CompletionChoiceCopyWithImpl<$Res, CompletionChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$CompletionChoiceCopyWithImpl<$Res, $Val extends CompletionChoice>
    implements $CompletionChoiceCopyWith<$Res> {
  _$CompletionChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_value.copyWith(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $CompletionLogprobsCopyWith<$Res>(_value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CompletionChoiceImplCopyWith<$Res>
    implements $CompletionChoiceCopyWith<$Res> {
  factory _$$CompletionChoiceImplCopyWith(_$CompletionChoiceImpl value,
          $Res Function(_$CompletionChoiceImpl) then) =
      __$$CompletionChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  @override
  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$CompletionChoiceImplCopyWithImpl<$Res>
    extends _$CompletionChoiceCopyWithImpl<$Res, _$CompletionChoiceImpl>
    implements _$$CompletionChoiceImplCopyWith<$Res> {
  __$$CompletionChoiceImplCopyWithImpl(_$CompletionChoiceImpl _value,
      $Res Function(_$CompletionChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_$CompletionChoiceImpl(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionChoiceImpl extends _CompletionChoice {
  const _$CompletionChoiceImpl(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index,
      required this.logprobs,
      required this.text})
      : super._();

  factory _$CompletionChoiceImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final CompletionFinishReason? finishReason;

  /// The index of the choice in the list of generated choices.
  @override
  final int index;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  @override
  final CompletionLogprobs? logprobs;

  /// The text of the completion.
  @override
  final String text;

  @override
  String toString() {
    return 'CompletionChoice(finishReason: $finishReason, index: $index, logprobs: $logprobs, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, finishReason, index, logprobs, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      __$$CompletionChoiceImplCopyWithImpl<_$CompletionChoiceImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionChoiceImplToJson(
      this,
    );
  }
}

abstract class _CompletionChoice extends CompletionChoice {
  const factory _CompletionChoice(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required final CompletionFinishReason? finishReason,
      required final int index,
      required final CompletionLogprobs? logprobs,
      required final String text}) = _$CompletionChoiceImpl;
  const _CompletionChoice._() : super._();

  factory _CompletionChoice.fromJson(Map<String, dynamic> json) =
      _$CompletionChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of generated choices.
  int get index;
  @override

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs;
  @override

  /// The text of the completion.
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CompletionLogprobs _$CompletionLogprobsFromJson(Map<String, dynamic> json) {
  return _CompletionLogprobs.fromJson(json);
}

/// @nodoc
mixin _$CompletionLogprobs {
  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset => throw _privateConstructorUsedError;

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs => throw _privateConstructorUsedError;

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens => throw _privateConstructorUsedError;

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionLogprobsCopyWith<CompletionLogprobs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionLogprobsCopyWith<$Res> {
  factory $CompletionLogprobsCopyWith(
          CompletionLogprobs value, $Res Function(CompletionLogprobs) then) =
      _$CompletionLogprobsCopyWithImpl<$Res, CompletionLogprobs>;
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class _$CompletionLogprobsCopyWithImpl<$Res, $Val extends CompletionLogprobs>
    implements $CompletionLogprobsCopyWith<$Res> {
  _$CompletionLogprobsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_value.copyWith(
      textOffset: freezed == textOffset
          ? _value.textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value.tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value.tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionLogprobsImplCopyWith<$Res>
    implements $CompletionLogprobsCopyWith<$Res> {
  factory _$$CompletionLogprobsImplCopyWith(_$CompletionLogprobsImpl value,
          $Res Function(_$CompletionLogprobsImpl) then) =
      __$$CompletionLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class __$$CompletionLogprobsImplCopyWithImpl<$Res>
    extends _$CompletionLogprobsCopyWithImpl<$Res, _$CompletionLogprobsImpl>
    implements _$$CompletionLogprobsImplCopyWith<$Res> {
  __$$CompletionLogprobsImplCopyWithImpl(_$CompletionLogprobsImpl _value,
      $Res Function(_$CompletionLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_$CompletionLogprobsImpl(
      textOffset: freezed == textOffset
          ? _value._textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value._tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value._tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionLogprobsImpl extends _CompletionLogprobs {
  const _$CompletionLogprobsImpl(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      final List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      final List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) final List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      final List<Map<String, double>?>? topLogprobs})
      : _textOffset = textOffset,
        _tokenLogprobs = tokenLogprobs,
        _tokens = tokens,
        _topLogprobs = topLogprobs,
        super._();

  factory _$CompletionLogprobsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionLogprobsImplFromJson(json);

  /// The offset of the token from the beginning of the prompt.
  final List<int>? _textOffset;

  /// The offset of the token from the beginning of the prompt.
  @override
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset {
    final value = _textOffset;
    if (value == null) return null;
    if (_textOffset is EqualUnmodifiableListView) return _textOffset;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of tokens in the completion.
  final List<double?>? _tokenLogprobs;

  /// The log probabilities of tokens in the completion.
  @override
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs {
    final value = _tokenLogprobs;
    if (value == null) return null;
    if (_tokenLogprobs is EqualUnmodifiableListView) return _tokenLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The tokens generated by the model converted back to text.
  final List<String>? _tokens;

  /// The tokens generated by the model converted back to text.
  @override
  @JsonKey(includeIfNull: false)
  List<String>? get tokens {
    final value = _tokens;
    if (value == null) return null;
    if (_tokens is EqualUnmodifiableListView) return _tokens;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of the `logprobs` most likely tokens.
  final List<Map<String, double>?>? _topLogprobs;

  /// The log probabilities of the `logprobs` most likely tokens.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs {
    final value = _topLogprobs;
    if (value == null) return null;
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CompletionLogprobs(textOffset: $textOffset, tokenLogprobs: $tokenLogprobs, tokens: $tokens, topLogprobs: $topLogprobs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionLogprobsImpl &&
            const DeepCollectionEquality()
                .equals(other._textOffset, _textOffset) &&
            const DeepCollectionEquality()
                .equals(other._tokenLogprobs, _tokenLogprobs) &&
            const DeepCollectionEquality().equals(other._tokens, _tokens) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_textOffset),
      const DeepCollectionEquality().hash(_tokenLogprobs),
      const DeepCollectionEquality().hash(_tokens),
      const DeepCollectionEquality().hash(_topLogprobs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      __$$CompletionLogprobsImplCopyWithImpl<_$CompletionLogprobsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionLogprobsImplToJson(
      this,
    );
  }
}

abstract class _CompletionLogprobs extends CompletionLogprobs {
  const factory _CompletionLogprobs(
          {@JsonKey(name: 'text_offset', includeIfNull: false)
          final List<int>? textOffset,
          @JsonKey(name: 'token_logprobs', includeIfNull: false)
          final List<double?>? tokenLogprobs,
          @JsonKey(includeIfNull: false) final List<String>? tokens,
          @JsonKey(name: 'top_logprobs', includeIfNull: false)
          final List<Map<String, double>?>? topLogprobs}) =
      _$CompletionLogprobsImpl;
  const _CompletionLogprobs._() : super._();

  factory _CompletionLogprobs.fromJson(Map<String, dynamic> json) =
      _$CompletionLogprobsImpl.fromJson;

  @override

  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset;
  @override

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs;
  @override

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens;
  @override

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs;
  @override
  @JsonKey(ignore: true)
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateChatCompletionRequest _$CreateChatCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionRequest {
  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model => throw _privateConstructorUsedError;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages =>
      throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`. This option is currently not available on the `gpt-4-vision-preview` model.
  @JsonKey(includeIfNull: false)
  bool? get logprobs => throw _privateConstructorUsedError;

  /// An integer between 0 and 5 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  int? get topLogprobs => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop => throw _privateConstructorUsedError;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools => throw _privateConstructorUsedError;

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice =>
      throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionRequestCopyWith<CreateChatCompletionRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionRequestCopyWith<$Res> {
  factory $CreateChatCompletionRequestCopyWith(
          CreateChatCompletionRequest value,
          $Res Function(CreateChatCompletionRequest) then) =
      _$CreateChatCompletionRequestCopyWithImpl<$Res,
          CreateChatCompletionRequest>;
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions});

  $ChatCompletionModelCopyWith<$Res> get model;
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  $ChatCompletionStopCopyWith<$Res>? get stop;
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$CreateChatCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateChatCompletionRequest>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  _$CreateChatCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? topLogprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as bool?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value.functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionModelCopyWith<$Res> get model {
    return $ChatCompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $ChatCompletionResponseFormatCopyWith<$Res>(_value.responseFormat!,
        (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $ChatCompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice {
    if (_value.toolChoice == null) {
      return null;
    }

    return $ChatCompletionToolChoiceOptionCopyWith<$Res>(_value.toolChoice!,
        (value) {
      return _then(_value.copyWith(toolChoice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionFunctionCallCopyWith<$Res>(_value.functionCall!,
        (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionRequestImplCopyWith<$Res>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  factory _$$CreateChatCompletionRequestImplCopyWith(
          _$CreateChatCompletionRequestImpl value,
          $Res Function(_$CreateChatCompletionRequestImpl) then) =
      __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions});

  @override
  $ChatCompletionModelCopyWith<$Res> get model;
  @override
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  @override
  $ChatCompletionStopCopyWith<$Res>? get stop;
  @override
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  @override
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionRequestCopyWithImpl<$Res,
        _$CreateChatCompletionRequestImpl>
    implements _$$CreateChatCompletionRequestImplCopyWith<$Res> {
  __$$CreateChatCompletionRequestImplCopyWithImpl(
      _$CreateChatCompletionRequestImpl _value,
      $Res Function(_$CreateChatCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? topLogprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_$CreateChatCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as bool?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value._functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionRequestImpl extends _CreateChatCompletionRequest {
  const _$CreateChatCompletionRequestImpl(
      {@_ChatCompletionModelConverter() required this.model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) this.topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.seed,
      @_ChatCompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(includeIfNull: false) this.user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      this.functionCall,
      @JsonKey(includeIfNull: false) final List<FunctionObject>? functions})
      : _messages = messages,
        _logitBias = logitBias,
        _tools = tools,
        _functions = functions,
        super._();

  factory _$CreateChatCompletionRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionRequestImplFromJson(json);

  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @override
  @_ChatCompletionModelConverter()
  final ChatCompletionModel model;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  final List<ChatCompletionMessage> _messages;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  @override
  List<ChatCompletionMessage> get messages {
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_messages);
  }

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`. This option is currently not available on the `gpt-4-vision-preview` model.
  @override
  @JsonKey(includeIfNull: false)
  final bool? logprobs;

  /// An integer between 0 and 5 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  final int? topLogprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @JsonKey(name: 'response_format', includeIfNull: false)
  final ChatCompletionResponseFormat? responseFormat;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @override
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final ChatCompletionStop? stop;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  final List<ChatCompletionTool>? _tools;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @override
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final ChatCompletionToolChoiceOption? toolChoice;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @override
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionFunctionCall? functionCall;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  final List<FunctionObject>? _functions;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions {
    final value = _functions;
    if (value == null) return null;
    if (_functions is EqualUnmodifiableListView) return _functions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CreateChatCompletionRequest(model: $model, messages: $messages, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, topLogprobs: $topLogprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, responseFormat: $responseFormat, seed: $seed, stop: $stop, stream: $stream, temperature: $temperature, topP: $topP, tools: $tools, toolChoice: $toolChoice, user: $user, functionCall: $functionCall, functions: $functions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.topLogprobs, topLogprobs) ||
                other.topLogprobs == topLogprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._functions, _functions));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        model,
        const DeepCollectionEquality().hash(_messages),
        frequencyPenalty,
        const DeepCollectionEquality().hash(_logitBias),
        logprobs,
        topLogprobs,
        maxTokens,
        n,
        presencePenalty,
        responseFormat,
        seed,
        stop,
        stream,
        temperature,
        topP,
        const DeepCollectionEquality().hash(_tools),
        toolChoice,
        user,
        functionCall,
        const DeepCollectionEquality().hash(_functions)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => __$$CreateChatCompletionRequestImplCopyWithImpl<
          _$CreateChatCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionRequest
    extends CreateChatCompletionRequest {
  const factory _CreateChatCompletionRequest(
      {@_ChatCompletionModelConverter()
      required final ChatCompletionModel model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) final bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      final int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      final ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) final int? seed,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      final ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(includeIfNull: false) final String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      final ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false)
      final List<FunctionObject>?
          functions}) = _$CreateChatCompletionRequestImpl;
  const _CreateChatCompletionRequest._() : super._();

  factory _CreateChatCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model;
  @override

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`. This option is currently not available on the `gpt-4-vision-preview` model.
  @JsonKey(includeIfNull: false)
  bool? get logprobs;
  @override

  /// An integer between 0 and 5 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  int? get topLogprobs;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat;
  @override

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop;
  @override

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools;
  @override

  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall;
  @override

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionModel _$ChatCompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ChatCompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return ChatCompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionModelCopyWith<$Res> {
  factory $ChatCompletionModelCopyWith(
          ChatCompletionModel value, $Res Function(ChatCompletionModel) then) =
      _$ChatCompletionModelCopyWithImpl<$Res, ChatCompletionModel>;
}

/// @nodoc
class _$ChatCompletionModelCopyWithImpl<$Res, $Val extends ChatCompletionModel>
    implements $ChatCompletionModelCopyWith<$Res> {
  _$ChatCompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionModelEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionModelEnumerationImplCopyWith(
          _$ChatCompletionModelEnumerationImpl value,
          $Res Function(_$ChatCompletionModelEnumerationImpl) then) =
      __$$ChatCompletionModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionModels value});
}

/// @nodoc
class __$$ChatCompletionModelEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$ChatCompletionModelEnumerationImpl>
    implements _$$ChatCompletionModelEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionModelEnumerationImplCopyWithImpl(
      _$ChatCompletionModelEnumerationImpl _value,
      $Res Function(_$ChatCompletionModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionModelEnumerationImpl
    extends ChatCompletionModelEnumeration {
  const _$ChatCompletionModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$ChatCompletionModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionModelEnumerationImplFromJson(json);

  @override
  final ChatCompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionModelEnumerationImplCopyWith<
          _$ChatCompletionModelEnumerationImpl>
      get copyWith => __$$ChatCompletionModelEnumerationImplCopyWithImpl<
          _$ChatCompletionModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionModelEnumeration extends ChatCompletionModel {
  const factory ChatCompletionModelEnumeration(
      final ChatCompletionModels value) = _$ChatCompletionModelEnumerationImpl;
  const ChatCompletionModelEnumeration._() : super._();

  factory ChatCompletionModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionModelEnumerationImpl.fromJson;

  @override
  ChatCompletionModels get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionModelEnumerationImplCopyWith<
          _$ChatCompletionModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionModelStringImplCopyWith<$Res> {
  factory _$$ChatCompletionModelStringImplCopyWith(
          _$ChatCompletionModelStringImpl value,
          $Res Function(_$ChatCompletionModelStringImpl) then) =
      __$$ChatCompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ChatCompletionModelStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$ChatCompletionModelStringImpl>
    implements _$$ChatCompletionModelStringImplCopyWith<$Res> {
  __$$ChatCompletionModelStringImplCopyWithImpl(
      _$ChatCompletionModelStringImpl _value,
      $Res Function(_$ChatCompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionModelStringImpl extends ChatCompletionModelString {
  const _$ChatCompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$ChatCompletionModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionModelStringImplCopyWith<_$ChatCompletionModelStringImpl>
      get copyWith => __$$ChatCompletionModelStringImplCopyWithImpl<
          _$ChatCompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionModelString extends ChatCompletionModel {
  const factory ChatCompletionModelString(final String value) =
      _$ChatCompletionModelStringImpl;
  const ChatCompletionModelString._() : super._();

  factory ChatCompletionModelString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionModelStringImplCopyWith<_$ChatCompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseFormat _$ChatCompletionResponseFormatFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseFormat.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseFormat {
  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseFormatCopyWith<ChatCompletionResponseFormat>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseFormatCopyWith<$Res> {
  factory $ChatCompletionResponseFormatCopyWith(
          ChatCompletionResponseFormat value,
          $Res Function(ChatCompletionResponseFormat) then) =
      _$ChatCompletionResponseFormatCopyWithImpl<$Res,
          ChatCompletionResponseFormat>;
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseFormat>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  _$ChatCompletionResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseFormatImplCopyWith<$Res>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  factory _$$ChatCompletionResponseFormatImplCopyWith(
          _$ChatCompletionResponseFormatImpl value,
          $Res Function(_$ChatCompletionResponseFormatImpl) then) =
      __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        _$ChatCompletionResponseFormatImpl>
    implements _$$ChatCompletionResponseFormatImplCopyWith<$Res> {
  __$$ChatCompletionResponseFormatImplCopyWithImpl(
      _$ChatCompletionResponseFormatImpl _value,
      $Res Function(_$ChatCompletionResponseFormatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$ChatCompletionResponseFormatImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseFormatImpl extends _ChatCompletionResponseFormat {
  const _$ChatCompletionResponseFormatImpl(
      {this.type = ChatCompletionResponseFormatType.text})
      : super._();

  factory _$ChatCompletionResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseFormatImplFromJson(json);

  /// Must be one of `text` or `json_object`.
  @override
  @JsonKey()
  final ChatCompletionResponseFormatType type;

  @override
  String toString() {
    return 'ChatCompletionResponseFormat(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseFormatImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => __$$ChatCompletionResponseFormatImplCopyWithImpl<
          _$ChatCompletionResponseFormatImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseFormatImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseFormat
    extends ChatCompletionResponseFormat {
  const factory _ChatCompletionResponseFormat(
          {final ChatCompletionResponseFormatType type}) =
      _$ChatCompletionResponseFormatImpl;
  const _ChatCompletionResponseFormat._() : super._();

  factory _ChatCompletionResponseFormat.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseFormatImpl.fromJson;

  @override

  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStop _$ChatCompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return ChatCompletionStopListString.fromJson(json);
    case 'string':
      return ChatCompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionStop {
  Object? get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStopCopyWith<$Res> {
  factory $ChatCompletionStopCopyWith(
          ChatCompletionStop value, $Res Function(ChatCompletionStop) then) =
      _$ChatCompletionStopCopyWithImpl<$Res, ChatCompletionStop>;
}

/// @nodoc
class _$ChatCompletionStopCopyWithImpl<$Res, $Val extends ChatCompletionStop>
    implements $ChatCompletionStopCopyWith<$Res> {
  _$ChatCompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionStopListStringImplCopyWith<$Res> {
  factory _$$ChatCompletionStopListStringImplCopyWith(
          _$ChatCompletionStopListStringImpl value,
          $Res Function(_$ChatCompletionStopListStringImpl) then) =
      __$$ChatCompletionStopListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$ChatCompletionStopListStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$ChatCompletionStopListStringImpl>
    implements _$$ChatCompletionStopListStringImplCopyWith<$Res> {
  __$$ChatCompletionStopListStringImplCopyWithImpl(
      _$ChatCompletionStopListStringImpl _value,
      $Res Function(_$ChatCompletionStopListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionStopListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStopListStringImpl extends ChatCompletionStopListString {
  const _$ChatCompletionStopListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$ChatCompletionStopListStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStopListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStopListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStopListStringImplCopyWith<
          _$ChatCompletionStopListStringImpl>
      get copyWith => __$$ChatCompletionStopListStringImplCopyWithImpl<
          _$ChatCompletionStopListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStopListStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionStopListString extends ChatCompletionStop {
  const factory ChatCompletionStopListString(final List<String> value) =
      _$ChatCompletionStopListStringImpl;
  const ChatCompletionStopListString._() : super._();

  factory ChatCompletionStopListString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionStopListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionStopListStringImplCopyWith<
          _$ChatCompletionStopListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionStopStringImplCopyWith<$Res> {
  factory _$$ChatCompletionStopStringImplCopyWith(
          _$ChatCompletionStopStringImpl value,
          $Res Function(_$ChatCompletionStopStringImpl) then) =
      __$$ChatCompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class __$$ChatCompletionStopStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$ChatCompletionStopStringImpl>
    implements _$$ChatCompletionStopStringImplCopyWith<$Res> {
  __$$ChatCompletionStopStringImplCopyWithImpl(
      _$ChatCompletionStopStringImpl _value,
      $Res Function(_$ChatCompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$ChatCompletionStopStringImpl(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStopStringImpl extends ChatCompletionStopString {
  const _$ChatCompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ChatCompletionStopStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionStopStringImplFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStopStringImplCopyWith<_$ChatCompletionStopStringImpl>
      get copyWith => __$$ChatCompletionStopStringImplCopyWithImpl<
          _$ChatCompletionStopStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionStopString extends ChatCompletionStop {
  const factory ChatCompletionStopString(final String? value) =
      _$ChatCompletionStopStringImpl;
  const ChatCompletionStopString._() : super._();

  factory ChatCompletionStopString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionStopStringImpl.fromJson;

  @override
  String? get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionStopStringImplCopyWith<_$ChatCompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionToolChoiceOption _$ChatCompletionToolChoiceOptionFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionToolChoiceOptionEnumeration.fromJson(json);
    case 'tool':
      return ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionToolChoiceOption',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionToolChoiceOption {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  factory $ChatCompletionToolChoiceOptionCopyWith(
          ChatCompletionToolChoiceOption value,
          $Res Function(ChatCompletionToolChoiceOption) then) =
      _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
          ChatCompletionToolChoiceOption>;
}

/// @nodoc
class _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionToolChoiceOption>
    implements $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  _$ChatCompletionToolChoiceOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith(
          _$ChatCompletionToolChoiceOptionEnumerationImpl value,
          $Res Function(_$ChatCompletionToolChoiceOptionEnumerationImpl) then) =
      __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionToolChoiceMode value});
}

/// @nodoc
class __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$ChatCompletionToolChoiceOptionEnumerationImpl>
    implements _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl(
      _$ChatCompletionToolChoiceOptionEnumerationImpl _value,
      $Res Function(_$ChatCompletionToolChoiceOptionEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionToolChoiceOptionEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolChoiceOptionEnumerationImpl
    extends ChatCompletionToolChoiceOptionEnumeration {
  const _$ChatCompletionToolChoiceOptionEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$ChatCompletionToolChoiceOptionEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionToolChoiceOptionEnumerationImplFromJson(json);

  @override
  final ChatCompletionToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolChoiceOptionEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<
          _$ChatCompletionToolChoiceOptionEnumerationImpl>
      get copyWith =>
          __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<
                  _$ChatCompletionToolChoiceOptionEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolChoiceOptionEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolChoiceOptionEnumeration
    extends ChatCompletionToolChoiceOption {
  const factory ChatCompletionToolChoiceOptionEnumeration(
          final ChatCompletionToolChoiceMode value) =
      _$ChatCompletionToolChoiceOptionEnumerationImpl;
  const ChatCompletionToolChoiceOptionEnumeration._() : super._();

  factory ChatCompletionToolChoiceOptionEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionToolChoiceOptionEnumerationImpl.fromJson;

  @override
  ChatCompletionToolChoiceMode get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<
          _$ChatCompletionToolChoiceOptionEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
    $Res> {
  factory _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith(
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl value,
          $Res Function(
                  _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
              then) =
      __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionNamedToolChoice value});

  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
    implements
        _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
            $Res> {
  __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl _value,
      $Res Function(
              _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value {
    return $ChatCompletionNamedToolChoiceCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
    extends ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice {
  const _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();

  factory _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplFromJson(
          json);

  @override
  final ChatCompletionNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.tool(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith =>
          __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
                  _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) {
    return tool(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) {
    return tool?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
    extends ChatCompletionToolChoiceOption {
  const factory ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice(
          final ChatCompletionNamedToolChoice value) =
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl;
  const ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice._()
      : super._();

  factory ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
      .fromJson;

  @override
  ChatCompletionNamedToolChoice get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCall _$ChatCompletionFunctionCallFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionFunctionCallEnumeration.fromJson(json);
    case 'function':
      return ChatCompletionFunctionCallChatCompletionFunctionCallOption
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionFunctionCall',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionFunctionCall {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallCopyWith<$Res> {
  factory $ChatCompletionFunctionCallCopyWith(ChatCompletionFunctionCall value,
          $Res Function(ChatCompletionFunctionCall) then) =
      _$ChatCompletionFunctionCallCopyWithImpl<$Res,
          ChatCompletionFunctionCall>;
}

/// @nodoc
class _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCall>
    implements $ChatCompletionFunctionCallCopyWith<$Res> {
  _$ChatCompletionFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionFunctionCallEnumerationImplCopyWith(
          _$ChatCompletionFunctionCallEnumerationImpl value,
          $Res Function(_$ChatCompletionFunctionCallEnumerationImpl) then) =
      __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallMode value});
}

/// @nodoc
class __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallEnumerationImpl>
    implements _$$ChatCompletionFunctionCallEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl(
      _$ChatCompletionFunctionCallEnumerationImpl _value,
      $Res Function(_$ChatCompletionFunctionCallEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionFunctionCallEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallEnumerationImpl
    extends ChatCompletionFunctionCallEnumeration {
  const _$ChatCompletionFunctionCallEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$ChatCompletionFunctionCallEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallEnumerationImplFromJson(json);

  @override
  final ChatCompletionFunctionCallMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionCallEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallEnumerationImplCopyWith<
          _$ChatCompletionFunctionCallEnumerationImpl>
      get copyWith => __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<
          _$ChatCompletionFunctionCallEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionCallEnumeration
    extends ChatCompletionFunctionCall {
  const factory ChatCompletionFunctionCallEnumeration(
          final ChatCompletionFunctionCallMode value) =
      _$ChatCompletionFunctionCallEnumerationImpl;
  const ChatCompletionFunctionCallEnumeration._() : super._();

  factory ChatCompletionFunctionCallEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallEnumerationImpl.fromJson;

  @override
  ChatCompletionFunctionCallMode get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallEnumerationImplCopyWith<
          _$ChatCompletionFunctionCallEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
    $Res> {
  factory _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith(
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl value,
          $Res Function(
                  _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
              then) =
      __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallOption value});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value;
}

/// @nodoc
class __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
    implements
        _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
            $Res> {
  __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl _value,
      $Res Function(
              _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl
    extends ChatCompletionFunctionCallChatCompletionFunctionCallOption {
  const _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'function',
        super._();

  factory _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplFromJson(
          json);

  @override
  final ChatCompletionFunctionCallOption value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.function(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith =>
          __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
                  _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) {
    return function(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) {
    return function?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionCallChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCall {
  const factory ChatCompletionFunctionCallChatCompletionFunctionCallOption(
          final ChatCompletionFunctionCallOption value) =
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl;
  const ChatCompletionFunctionCallChatCompletionFunctionCallOption._()
      : super._();

  factory ChatCompletionFunctionCallChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl.fromJson;

  @override
  ChatCompletionFunctionCallOption get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageFunctionCall _$ChatCompletionMessageFunctionCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageFunctionCall {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageFunctionCallCopyWith<ChatCompletionMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionMessageFunctionCallCopyWith(
          ChatCompletionMessageFunctionCall value,
          $Res Function(ChatCompletionMessageFunctionCall) then) =
      _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionMessageFunctionCall>;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageFunctionCall>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionMessageFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageFunctionCallImplCopyWith(
          _$ChatCompletionMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionMessageFunctionCallImpl) then) =
      __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionMessageFunctionCallImpl>
    implements _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_$ChatCompletionMessageFunctionCallImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageFunctionCallImpl
    extends _ChatCompletionMessageFunctionCall {
  const _$ChatCompletionMessageFunctionCallImpl(
      {required this.name, required this.arguments})
      : super._();

  factory _$ChatCompletionMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  final String arguments;

  @override
  String toString() {
    return 'ChatCompletionMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<
          _$ChatCompletionMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageFunctionCall
    extends ChatCompletionMessageFunctionCall {
  const factory _ChatCompletionMessageFunctionCall(
          {required final String name, required final String arguments}) =
      _$ChatCompletionMessageFunctionCallImpl;
  const _ChatCompletionMessageFunctionCall._() : super._();

  factory _ChatCompletionMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCallOption _$ChatCompletionFunctionCallOptionFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionFunctionCallOption.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionFunctionCallOption {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionFunctionCallOptionCopyWith<ChatCompletionFunctionCallOption>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory $ChatCompletionFunctionCallOptionCopyWith(
          ChatCompletionFunctionCallOption value,
          $Res Function(ChatCompletionFunctionCallOption) then) =
      _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
          ChatCompletionFunctionCallOption>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCallOption>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  _$ChatCompletionFunctionCallOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory _$$ChatCompletionFunctionCallOptionImplCopyWith(
          _$ChatCompletionFunctionCallOptionImpl value,
          $Res Function(_$ChatCompletionFunctionCallOptionImpl) then) =
      __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallOptionImpl>
    implements _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res> {
  __$$ChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$ChatCompletionFunctionCallOptionImpl _value,
      $Res Function(_$ChatCompletionFunctionCallOptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$ChatCompletionFunctionCallOptionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallOptionImpl
    extends _ChatCompletionFunctionCallOption {
  const _$ChatCompletionFunctionCallOptionImpl({required this.name})
      : super._();

  factory _$ChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallOptionImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'ChatCompletionFunctionCallOption(name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionCallOptionImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<
          _$ChatCompletionFunctionCallOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCallOption {
  const factory _ChatCompletionFunctionCallOption(
      {required final String name}) = _$ChatCompletionFunctionCallOptionImpl;
  const _ChatCompletionFunctionCallOption._() : super._();

  factory _ChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallOptionImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FunctionObject _$FunctionObjectFromJson(Map<String, dynamic> json) {
  return _FunctionObject.fromJson(json);
}

/// @nodoc
mixin _$FunctionObject {
  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name => throw _privateConstructorUsedError;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get parameters => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FunctionObjectCopyWith<FunctionObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FunctionObjectCopyWith<$Res> {
  factory $FunctionObjectCopyWith(
          FunctionObject value, $Res Function(FunctionObject) then) =
      _$FunctionObjectCopyWithImpl<$Res, FunctionObject>;
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? parameters});
}

/// @nodoc
class _$FunctionObjectCopyWithImpl<$Res, $Val extends FunctionObject>
    implements $FunctionObjectCopyWith<$Res> {
  _$FunctionObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FunctionObjectImplCopyWith<$Res>
    implements $FunctionObjectCopyWith<$Res> {
  factory _$$FunctionObjectImplCopyWith(_$FunctionObjectImpl value,
          $Res Function(_$FunctionObjectImpl) then) =
      __$$FunctionObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? parameters});
}

/// @nodoc
class __$$FunctionObjectImplCopyWithImpl<$Res>
    extends _$FunctionObjectCopyWithImpl<$Res, _$FunctionObjectImpl>
    implements _$$FunctionObjectImplCopyWith<$Res> {
  __$$FunctionObjectImplCopyWithImpl(
      _$FunctionObjectImpl _value, $Res Function(_$FunctionObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_$FunctionObjectImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FunctionObjectImpl extends _FunctionObject {
  const _$FunctionObjectImpl(
      {required this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? parameters})
      : _parameters = parameters,
        super._();

  factory _$FunctionObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$FunctionObjectImplFromJson(json);

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  @override
  final String name;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  final Map<String, dynamic>? _parameters;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'FunctionObject(name: $name, description: $description, parameters: $parameters)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FunctionObjectImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(_parameters));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FunctionObjectImplCopyWith<_$FunctionObjectImpl> get copyWith =>
      __$$FunctionObjectImplCopyWithImpl<_$FunctionObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FunctionObjectImplToJson(
      this,
    );
  }
}

abstract class _FunctionObject extends FunctionObject {
  const factory _FunctionObject(
      {required final String name,
      @JsonKey(includeIfNull: false) final String? description,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? parameters}) = _$FunctionObjectImpl;
  const _FunctionObject._() : super._();

  factory _FunctionObject.fromJson(Map<String, dynamic> json) =
      _$FunctionObjectImpl.fromJson;

  @override

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name;
  @override

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get parameters;
  @override
  @JsonKey(ignore: true)
  _$$FunctionObjectImplCopyWith<_$FunctionObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionTool _$ChatCompletionToolFromJson(Map<String, dynamic> json) {
  return _ChatCompletionTool.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTool {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type => throw _privateConstructorUsedError;

  /// A function that the model may call.
  FunctionObject get function => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionToolCopyWith<ChatCompletionTool> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolCopyWith<$Res> {
  factory $ChatCompletionToolCopyWith(
          ChatCompletionTool value, $Res Function(ChatCompletionTool) then) =
      _$ChatCompletionToolCopyWithImpl<$Res, ChatCompletionTool>;
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionToolCopyWithImpl<$Res, $Val extends ChatCompletionTool>
    implements $ChatCompletionToolCopyWith<$Res> {
  _$ChatCompletionToolCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionToolImplCopyWith<$Res>
    implements $ChatCompletionToolCopyWith<$Res> {
  factory _$$ChatCompletionToolImplCopyWith(_$ChatCompletionToolImpl value,
          $Res Function(_$ChatCompletionToolImpl) then) =
      __$$ChatCompletionToolImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  @override
  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionToolImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolCopyWithImpl<$Res, _$ChatCompletionToolImpl>
    implements _$$ChatCompletionToolImplCopyWith<$Res> {
  __$$ChatCompletionToolImplCopyWithImpl(_$ChatCompletionToolImpl _value,
      $Res Function(_$ChatCompletionToolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionToolImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolImpl extends _ChatCompletionTool {
  const _$ChatCompletionToolImpl({required this.type, required this.function})
      : super._();

  factory _$ChatCompletionToolImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionToolImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionToolType type;

  /// A function that the model may call.
  @override
  final FunctionObject function;

  @override
  String toString() {
    return 'ChatCompletionTool(type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      __$$ChatCompletionToolImplCopyWithImpl<_$ChatCompletionToolImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTool extends ChatCompletionTool {
  const factory _ChatCompletionTool(
      {required final ChatCompletionToolType type,
      required final FunctionObject function}) = _$ChatCompletionToolImpl;
  const _ChatCompletionTool._() : super._();

  factory _ChatCompletionTool.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionToolImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type;
  @override

  /// A function that the model may call.
  FunctionObject get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionNamedToolChoice _$ChatCompletionNamedToolChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionNamedToolChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionNamedToolChoice {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionNamedToolChoiceType get type =>
      throw _privateConstructorUsedError;

  /// Forces the model to call the specified function.
  ChatCompletionFunctionCallOption get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionNamedToolChoiceCopyWith<ChatCompletionNamedToolChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory $ChatCompletionNamedToolChoiceCopyWith(
          ChatCompletionNamedToolChoice value,
          $Res Function(ChatCompletionNamedToolChoice) then) =
      _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
          ChatCompletionNamedToolChoice>;
  @useResult
  $Res call(
      {ChatCompletionNamedToolChoiceType type,
      ChatCompletionFunctionCallOption function});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionNamedToolChoice>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  _$ChatCompletionNamedToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory _$$ChatCompletionNamedToolChoiceImplCopyWith(
          _$ChatCompletionNamedToolChoiceImpl value,
          $Res Function(_$ChatCompletionNamedToolChoiceImpl) then) =
      __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionNamedToolChoiceType type,
      ChatCompletionFunctionCallOption function});

  @override
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        _$ChatCompletionNamedToolChoiceImpl>
    implements _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res> {
  __$$ChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$ChatCompletionNamedToolChoiceImpl _value,
      $Res Function(_$ChatCompletionNamedToolChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionNamedToolChoiceImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionNamedToolChoiceImpl
    extends _ChatCompletionNamedToolChoice {
  const _$ChatCompletionNamedToolChoiceImpl(
      {required this.type, required this.function})
      : super._();

  factory _$ChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionNamedToolChoiceImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionNamedToolChoiceType type;

  /// Forces the model to call the specified function.
  @override
  final ChatCompletionFunctionCallOption function;

  @override
  String toString() {
    return 'ChatCompletionNamedToolChoice(type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionNamedToolChoiceImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<
          _$ChatCompletionNamedToolChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionNamedToolChoice
    extends ChatCompletionNamedToolChoice {
  const factory _ChatCompletionNamedToolChoice(
          {required final ChatCompletionNamedToolChoiceType type,
          required final ChatCompletionFunctionCallOption function}) =
      _$ChatCompletionNamedToolChoiceImpl;
  const _ChatCompletionNamedToolChoice._() : super._();

  factory _ChatCompletionNamedToolChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionNamedToolChoiceImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionNamedToolChoiceType get type;
  @override

  /// Forces the model to call the specified function.
  ChatCompletionFunctionCallOption get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageToolCall _$ChatCompletionMessageToolCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageToolCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageToolCall {
  /// The ID of the tool call.
  String get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageToolCallCopyWith<ChatCompletionMessageToolCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory $ChatCompletionMessageToolCallCopyWith(
          ChatCompletionMessageToolCall value,
          $Res Function(ChatCompletionMessageToolCall) then) =
      _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
          ChatCompletionMessageToolCall>;
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageToolCall>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  _$ChatCompletionMessageToolCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function {
    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageToolCallImplCopyWith<$Res>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageToolCallImplCopyWith(
          _$ChatCompletionMessageToolCallImpl value,
          $Res Function(_$ChatCompletionMessageToolCallImpl) then) =
      __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  @override
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        _$ChatCompletionMessageToolCallImpl>
    implements _$$ChatCompletionMessageToolCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageToolCallImplCopyWithImpl(
      _$ChatCompletionMessageToolCallImpl _value,
      $Res Function(_$ChatCompletionMessageToolCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionMessageToolCallImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageToolCallImpl
    extends _ChatCompletionMessageToolCall {
  const _$ChatCompletionMessageToolCallImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$ChatCompletionMessageToolCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageToolCallImplFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionMessageToolCallType type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  final ChatCompletionMessageFunctionCall function;

  @override
  String toString() {
    return 'ChatCompletionMessageToolCall(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageToolCallImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => __$$ChatCompletionMessageToolCallImplCopyWithImpl<
          _$ChatCompletionMessageToolCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageToolCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageToolCall
    extends ChatCompletionMessageToolCall {
  const factory _ChatCompletionMessageToolCall(
          {required final String id,
          required final ChatCompletionMessageToolCallType type,
          required final ChatCompletionMessageFunctionCall function}) =
      _$ChatCompletionMessageToolCallImpl;
  const _ChatCompletionMessageToolCall._() : super._();

  factory _ChatCompletionMessageToolCall.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageToolCallImpl.fromJson;

  @override

  /// The ID of the tool call.
  String get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionResponse _$CreateChatCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionResponse {
  /// A unique identifier for the chat completion.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for the chat completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion`.
  String get object => throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionResponseCopyWith<CreateChatCompletionResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionResponseCopyWith<$Res> {
  factory $CreateChatCompletionResponseCopyWith(
          CreateChatCompletionResponse value,
          $Res Function(CreateChatCompletionResponse) then) =
      _$CreateChatCompletionResponseCopyWithImpl<$Res,
          CreateChatCompletionResponse>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateChatCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionResponse>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  _$CreateChatCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionResponseImplCopyWith<$Res>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionResponseImplCopyWith(
          _$CreateChatCompletionResponseImpl value,
          $Res Function(_$CreateChatCompletionResponseImpl) then) =
      __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionResponseCopyWithImpl<$Res,
        _$CreateChatCompletionResponseImpl>
    implements _$$CreateChatCompletionResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionResponseImplCopyWithImpl(
      _$CreateChatCompletionResponseImpl _value,
      $Res Function(_$CreateChatCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateChatCompletionResponseImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionResponseImpl extends _CreateChatCompletionResponse {
  const _$CreateChatCompletionResponseImpl(
      {@JsonKey(includeIfNull: false) this.id,
      required final List<ChatCompletionResponseChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionResponseImplFromJson(json);

  /// A unique identifier for the chat completion.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  @override
  final int created;

  /// The model used for the chat completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion`.
  @override
  final String object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateChatCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => __$$CreateChatCompletionResponseImplCopyWithImpl<
          _$CreateChatCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionResponse
    extends CreateChatCompletionResponse {
  const factory _CreateChatCompletionResponse(
          {@JsonKey(includeIfNull: false) final String? id,
          required final List<ChatCompletionResponseChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final String object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateChatCompletionResponseImpl;
  const _CreateChatCompletionResponse._() : super._();

  factory _CreateChatCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created;
  @override

  /// The model used for the chat completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion`.
  String get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseChoice _$ChatCompletionResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index => throw _privateConstructorUsedError;

  /// An assistant message in a chat conversation.
  ChatCompletionAssistantMessage get message =>
      throw _privateConstructorUsedError;

  /// Log probability information for the choice.
  ChatCompletionLogprobs? get logprobs => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseChoiceCopyWith<ChatCompletionResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionResponseChoiceCopyWith(
          ChatCompletionResponseChoice value,
          $Res Function(ChatCompletionResponseChoice) then) =
      _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
          ChatCompletionResponseChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index,
      ChatCompletionAssistantMessage message,
      ChatCompletionLogprobs? logprobs});

  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseChoice>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  _$ChatCompletionResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = freezed,
    Object? message = freezed,
    Object? logprobs = freezed,
  }) {
    return _then(_value.copyWith(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionLogprobs?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $ChatCompletionLogprobsCopyWith<$Res>(_value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionResponseChoiceImplCopyWith(
          _$ChatCompletionResponseChoiceImpl value,
          $Res Function(_$ChatCompletionResponseChoiceImpl) then) =
      __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index,
      ChatCompletionAssistantMessage message,
      ChatCompletionLogprobs? logprobs});

  @override
  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionResponseChoiceImpl>
    implements _$$ChatCompletionResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionResponseChoiceImplCopyWithImpl(
      _$ChatCompletionResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = freezed,
    Object? message = freezed,
    Object? logprobs = freezed,
  }) {
    return _then(_$ChatCompletionResponseChoiceImpl(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionLogprobs?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseChoiceImpl extends _ChatCompletionResponseChoice {
  const _$ChatCompletionResponseChoiceImpl(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      @JsonKey(includeIfNull: false) this.index,
      required this.message,
      required this.logprobs})
      : super._();

  factory _$ChatCompletionResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  /// An assistant message in a chat conversation.
  @override
  final ChatCompletionAssistantMessage message;

  /// Log probability information for the choice.
  @override
  final ChatCompletionLogprobs? logprobs;

  @override
  String toString() {
    return 'ChatCompletionResponseChoice(finishReason: $finishReason, index: $index, message: $message, logprobs: $logprobs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            const DeepCollectionEquality().equals(other.message, message) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, finishReason, index,
      const DeepCollectionEquality().hash(message), logprobs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => __$$ChatCompletionResponseChoiceImplCopyWithImpl<
          _$ChatCompletionResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseChoice
    extends ChatCompletionResponseChoice {
  const factory _ChatCompletionResponseChoice(
          {@JsonKey(
              name: 'finish_reason',
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          required final ChatCompletionFinishReason? finishReason,
          @JsonKey(includeIfNull: false) final int? index,
          required final ChatCompletionAssistantMessage message,
          required final ChatCompletionLogprobs? logprobs}) =
      _$ChatCompletionResponseChoiceImpl;
  const _ChatCompletionResponseChoice._() : super._();

  factory _ChatCompletionResponseChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index;
  @override

  /// An assistant message in a chat conversation.
  ChatCompletionAssistantMessage get message;
  @override

  /// Log probability information for the choice.
  ChatCompletionLogprobs? get logprobs;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionLogprobs _$ChatCompletionLogprobsFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionLogprobs.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionLogprobs {
  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionLogprobsCopyWith<ChatCompletionLogprobs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionLogprobsCopyWith<$Res> {
  factory $ChatCompletionLogprobsCopyWith(ChatCompletionLogprobs value,
          $Res Function(ChatCompletionLogprobs) then) =
      _$ChatCompletionLogprobsCopyWithImpl<$Res, ChatCompletionLogprobs>;
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class _$ChatCompletionLogprobsCopyWithImpl<$Res,
        $Val extends ChatCompletionLogprobs>
    implements $ChatCompletionLogprobsCopyWith<$Res> {
  _$ChatCompletionLogprobsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionLogprobsImplCopyWith<$Res>
    implements $ChatCompletionLogprobsCopyWith<$Res> {
  factory _$$ChatCompletionLogprobsImplCopyWith(
          _$ChatCompletionLogprobsImpl value,
          $Res Function(_$ChatCompletionLogprobsImpl) then) =
      __$$ChatCompletionLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class __$$ChatCompletionLogprobsImplCopyWithImpl<$Res>
    extends _$ChatCompletionLogprobsCopyWithImpl<$Res,
        _$ChatCompletionLogprobsImpl>
    implements _$$ChatCompletionLogprobsImplCopyWith<$Res> {
  __$$ChatCompletionLogprobsImplCopyWithImpl(
      _$ChatCompletionLogprobsImpl _value,
      $Res Function(_$ChatCompletionLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_$ChatCompletionLogprobsImpl(
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionLogprobsImpl extends _ChatCompletionLogprobs {
  const _$ChatCompletionLogprobsImpl(
      {required final List<ChatCompletionTokenLogprob>? content})
      : _content = content,
        super._();

  factory _$ChatCompletionLogprobsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionLogprobsImplFromJson(json);

  /// A list of message content tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _content;

  /// A list of message content tokens with log probability information.
  @override
  List<ChatCompletionTokenLogprob>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChatCompletionLogprobs(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionLogprobsImpl &&
            const DeepCollectionEquality().equals(other._content, _content));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_content));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionLogprobsImplCopyWith<_$ChatCompletionLogprobsImpl>
      get copyWith => __$$ChatCompletionLogprobsImplCopyWithImpl<
          _$ChatCompletionLogprobsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionLogprobsImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionLogprobs extends ChatCompletionLogprobs {
  const factory _ChatCompletionLogprobs(
          {required final List<ChatCompletionTokenLogprob>? content}) =
      _$ChatCompletionLogprobsImpl;
  const _ChatCompletionLogprobs._() : super._();

  factory _ChatCompletionLogprobs.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionLogprobsImpl.fromJson;

  @override

  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionLogprobsImplCopyWith<_$ChatCompletionLogprobsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionTokenLogprob _$ChatCompletionTokenLogprobFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionTokenLogprob.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTokenLogprob {
  /// The token.
  String get token => throw _privateConstructorUsedError;

  /// The log probability of this token.
  double get logprob => throw _privateConstructorUsedError;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes => throw _privateConstructorUsedError;

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionTokenLogprobCopyWith<ChatCompletionTokenLogprob>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionTokenLogprobCopyWith<$Res> {
  factory $ChatCompletionTokenLogprobCopyWith(ChatCompletionTokenLogprob value,
          $Res Function(ChatCompletionTokenLogprob) then) =
      _$ChatCompletionTokenLogprobCopyWithImpl<$Res,
          ChatCompletionTokenLogprob>;
  @useResult
  $Res call(
      {String token,
      double logprob,
      List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      List<ChatCompletionTokenTopLogprob> topLogprobs});
}

/// @nodoc
class _$ChatCompletionTokenLogprobCopyWithImpl<$Res,
        $Val extends ChatCompletionTokenLogprob>
    implements $ChatCompletionTokenLogprobCopyWith<$Res> {
  _$ChatCompletionTokenLogprobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
    Object? topLogprobs = null,
  }) {
    return _then(_value.copyWith(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value.bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      topLogprobs: null == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenTopLogprob>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionTokenLogprobImplCopyWith<$Res>
    implements $ChatCompletionTokenLogprobCopyWith<$Res> {
  factory _$$ChatCompletionTokenLogprobImplCopyWith(
          _$ChatCompletionTokenLogprobImpl value,
          $Res Function(_$ChatCompletionTokenLogprobImpl) then) =
      __$$ChatCompletionTokenLogprobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String token,
      double logprob,
      List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      List<ChatCompletionTokenTopLogprob> topLogprobs});
}

/// @nodoc
class __$$ChatCompletionTokenLogprobImplCopyWithImpl<$Res>
    extends _$ChatCompletionTokenLogprobCopyWithImpl<$Res,
        _$ChatCompletionTokenLogprobImpl>
    implements _$$ChatCompletionTokenLogprobImplCopyWith<$Res> {
  __$$ChatCompletionTokenLogprobImplCopyWithImpl(
      _$ChatCompletionTokenLogprobImpl _value,
      $Res Function(_$ChatCompletionTokenLogprobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
    Object? topLogprobs = null,
  }) {
    return _then(_$ChatCompletionTokenLogprobImpl(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value._bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      topLogprobs: null == topLogprobs
          ? _value._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenTopLogprob>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionTokenLogprobImpl extends _ChatCompletionTokenLogprob {
  const _$ChatCompletionTokenLogprobImpl(
      {required this.token,
      required this.logprob,
      required final List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      required final List<ChatCompletionTokenTopLogprob> topLogprobs})
      : _bytes = bytes,
        _topLogprobs = topLogprobs,
        super._();

  factory _$ChatCompletionTokenLogprobImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionTokenLogprobImplFromJson(json);

  /// The token.
  @override
  final String token;

  /// The log probability of this token.
  @override
  final double logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  final List<int>? _bytes;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  @override
  List<int>? get bytes {
    final value = _bytes;
    if (value == null) return null;
    if (_bytes is EqualUnmodifiableListView) return _bytes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  final List<ChatCompletionTokenTopLogprob> _topLogprobs;

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @override
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs {
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topLogprobs);
  }

  @override
  String toString() {
    return 'ChatCompletionTokenLogprob(token: $token, logprob: $logprob, bytes: $bytes, topLogprobs: $topLogprobs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionTokenLogprobImpl &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other._bytes, _bytes) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      token,
      logprob,
      const DeepCollectionEquality().hash(_bytes),
      const DeepCollectionEquality().hash(_topLogprobs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionTokenLogprobImplCopyWith<_$ChatCompletionTokenLogprobImpl>
      get copyWith => __$$ChatCompletionTokenLogprobImplCopyWithImpl<
          _$ChatCompletionTokenLogprobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionTokenLogprobImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTokenLogprob extends ChatCompletionTokenLogprob {
  const factory _ChatCompletionTokenLogprob(
          {required final String token,
          required final double logprob,
          required final List<int>? bytes,
          @JsonKey(name: 'top_logprobs')
          required final List<ChatCompletionTokenTopLogprob> topLogprobs}) =
      _$ChatCompletionTokenLogprobImpl;
  const _ChatCompletionTokenLogprob._() : super._();

  factory _ChatCompletionTokenLogprob.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionTokenLogprobImpl.fromJson;

  @override

  /// The token.
  String get token;
  @override

  /// The log probability of this token.
  double get logprob;
  @override

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes;
  @override

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionTokenLogprobImplCopyWith<_$ChatCompletionTokenLogprobImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionTokenTopLogprob _$ChatCompletionTokenTopLogprobFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionTokenTopLogprob.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTokenTopLogprob {
  /// The token.
  String get token => throw _privateConstructorUsedError;

  /// The log probability of this token.
  double get logprob => throw _privateConstructorUsedError;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionTokenTopLogprobCopyWith<ChatCompletionTokenTopLogprob>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  factory $ChatCompletionTokenTopLogprobCopyWith(
          ChatCompletionTokenTopLogprob value,
          $Res Function(ChatCompletionTokenTopLogprob) then) =
      _$ChatCompletionTokenTopLogprobCopyWithImpl<$Res,
          ChatCompletionTokenTopLogprob>;
  @useResult
  $Res call({String token, double logprob, List<int>? bytes});
}

/// @nodoc
class _$ChatCompletionTokenTopLogprobCopyWithImpl<$Res,
        $Val extends ChatCompletionTokenTopLogprob>
    implements $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  _$ChatCompletionTokenTopLogprobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
  }) {
    return _then(_value.copyWith(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value.bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionTokenTopLogprobImplCopyWith<$Res>
    implements $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  factory _$$ChatCompletionTokenTopLogprobImplCopyWith(
          _$ChatCompletionTokenTopLogprobImpl value,
          $Res Function(_$ChatCompletionTokenTopLogprobImpl) then) =
      __$$ChatCompletionTokenTopLogprobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String token, double logprob, List<int>? bytes});
}

/// @nodoc
class __$$ChatCompletionTokenTopLogprobImplCopyWithImpl<$Res>
    extends _$ChatCompletionTokenTopLogprobCopyWithImpl<$Res,
        _$ChatCompletionTokenTopLogprobImpl>
    implements _$$ChatCompletionTokenTopLogprobImplCopyWith<$Res> {
  __$$ChatCompletionTokenTopLogprobImplCopyWithImpl(
      _$ChatCompletionTokenTopLogprobImpl _value,
      $Res Function(_$ChatCompletionTokenTopLogprobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
  }) {
    return _then(_$ChatCompletionTokenTopLogprobImpl(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value._bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionTokenTopLogprobImpl
    extends _ChatCompletionTokenTopLogprob {
  const _$ChatCompletionTokenTopLogprobImpl(
      {required this.token,
      required this.logprob,
      required final List<int>? bytes})
      : _bytes = bytes,
        super._();

  factory _$ChatCompletionTokenTopLogprobImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionTokenTopLogprobImplFromJson(json);

  /// The token.
  @override
  final String token;

  /// The log probability of this token.
  @override
  final double logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  final List<int>? _bytes;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  @override
  List<int>? get bytes {
    final value = _bytes;
    if (value == null) return null;
    if (_bytes is EqualUnmodifiableListView) return _bytes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChatCompletionTokenTopLogprob(token: $token, logprob: $logprob, bytes: $bytes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionTokenTopLogprobImpl &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other._bytes, _bytes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, token, logprob, const DeepCollectionEquality().hash(_bytes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionTokenTopLogprobImplCopyWith<
          _$ChatCompletionTokenTopLogprobImpl>
      get copyWith => __$$ChatCompletionTokenTopLogprobImplCopyWithImpl<
          _$ChatCompletionTokenTopLogprobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionTokenTopLogprobImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTokenTopLogprob
    extends ChatCompletionTokenTopLogprob {
  const factory _ChatCompletionTokenTopLogprob(
      {required final String token,
      required final double logprob,
      required final List<int>? bytes}) = _$ChatCompletionTokenTopLogprobImpl;
  const _ChatCompletionTokenTopLogprob._() : super._();

  factory _ChatCompletionTokenTopLogprob.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionTokenTopLogprobImpl.fromJson;

  @override

  /// The token.
  String get token;
  @override

  /// The log probability of this token.
  double get logprob;
  @override

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionTokenTopLogprobImplCopyWith<
          _$ChatCompletionTokenTopLogprobImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionStreamResponse _$CreateChatCompletionStreamResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionStreamResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionStreamResponse {
  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionStreamResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  int get created => throw _privateConstructorUsedError;

  /// The model to generate the completion.
  @JsonKey(includeIfNull: false)
  String? get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion.chunk`.
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionStreamResponseCopyWith<
          CreateChatCompletionStreamResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory $CreateChatCompletionStreamResponseCopyWith(
          CreateChatCompletionStreamResponse value,
          $Res Function(CreateChatCompletionStreamResponse) then) =
      _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
          CreateChatCompletionStreamResponse>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionStreamResponseChoice> choices,
      int created,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object});
}

/// @nodoc
class _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionStreamResponse>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  _$CreateChatCompletionStreamResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = freezed,
    Object? systemFingerprint = freezed,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionStreamResponseImplCopyWith<$Res>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionStreamResponseImplCopyWith(
          _$CreateChatCompletionStreamResponseImpl value,
          $Res Function(_$CreateChatCompletionStreamResponseImpl) then) =
      __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionStreamResponseChoice> choices,
      int created,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object});
}

/// @nodoc
class __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        _$CreateChatCompletionStreamResponseImpl>
    implements _$$CreateChatCompletionStreamResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionStreamResponseImplCopyWithImpl(
      _$CreateChatCompletionStreamResponseImpl _value,
      $Res Function(_$CreateChatCompletionStreamResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = freezed,
    Object? systemFingerprint = freezed,
    Object? object = null,
  }) {
    return _then(_$CreateChatCompletionStreamResponseImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionStreamResponseImpl
    extends _CreateChatCompletionStreamResponse {
  const _$CreateChatCompletionStreamResponseImpl(
      {@JsonKey(includeIfNull: false) this.id,
      required final List<ChatCompletionStreamResponseChoice> choices,
      required this.created,
      @JsonKey(includeIfNull: false) this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionStreamResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionStreamResponseImplFromJson(json);

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionStreamResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionStreamResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @override
  final int created;

  /// The model to generate the completion.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion.chunk`.
  @override
  final String object;

  @override
  String toString() {
    return 'CreateChatCompletionStreamResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionStreamResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => __$$CreateChatCompletionStreamResponseImplCopyWithImpl<
          _$CreateChatCompletionStreamResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionStreamResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionStreamResponse
    extends CreateChatCompletionStreamResponse {
  const factory _CreateChatCompletionStreamResponse(
      {@JsonKey(includeIfNull: false) final String? id,
      required final List<ChatCompletionStreamResponseChoice> choices,
      required final int created,
      @JsonKey(includeIfNull: false) final String? model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      final String? systemFingerprint,
      required final String object}) = _$CreateChatCompletionStreamResponseImpl;
  const _CreateChatCompletionStreamResponse._() : super._();

  factory _CreateChatCompletionStreamResponse.fromJson(
          Map<String, dynamic> json) =
      _$CreateChatCompletionStreamResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionStreamResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  int get created;
  @override

  /// The model to generate the completion.
  @JsonKey(includeIfNull: false)
  String? get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion.chunk`.
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseChoice _$ChatCompletionStreamResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoice {
  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta =>
      throw _privateConstructorUsedError;

  /// Log probability information for the choice.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamResponseChoiceLogprobs? get logprobs =>
      throw _privateConstructorUsedError;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseChoiceCopyWith<
          ChatCompletionStreamResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceCopyWith(
          ChatCompletionStreamResponseChoice value,
          $Res Function(ChatCompletionStreamResponseChoice) then) =
      _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
          ChatCompletionStreamResponseChoice>;
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseChoiceLogprobs? logprobs,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index});

  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseChoice>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? logprobs = freezed,
    Object? finishReason = freezed,
    Object? index = freezed,
  }) {
    return _then(_value.copyWith(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseChoiceLogprobs?,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta {
    return $ChatCompletionStreamResponseDeltaCopyWith<$Res>(_value.delta,
        (value) {
      return _then(_value.copyWith(delta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>(
        _value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseChoiceImplCopyWith(
          _$ChatCompletionStreamResponseChoiceImpl value,
          $Res Function(_$ChatCompletionStreamResponseChoiceImpl) then) =
      __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseChoiceLogprobs? logprobs,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index});

  @override
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
  @override
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseChoiceImpl>
    implements _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl(
      _$ChatCompletionStreamResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionStreamResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? logprobs = freezed,
    Object? finishReason = freezed,
    Object? index = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseChoiceImpl(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseChoiceLogprobs?,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseChoiceImpl
    extends _ChatCompletionStreamResponseChoice {
  const _$ChatCompletionStreamResponseChoiceImpl(
      {required this.delta,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      @JsonKey(includeIfNull: false) this.index})
      : super._();

  factory _$ChatCompletionStreamResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseChoiceImplFromJson(json);

  /// A chat completion delta generated by streamed model responses.
  @override
  final ChatCompletionStreamResponseDelta delta;

  /// Log probability information for the choice.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamResponseChoiceLogprobs? logprobs;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoice(delta: $delta, logprobs: $logprobs, finishReason: $finishReason, index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseChoiceImpl &&
            (identical(other.delta, delta) || other.delta == delta) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, delta, logprobs, finishReason, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<
          _$ChatCompletionStreamResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseChoice
    extends ChatCompletionStreamResponseChoice {
  const factory _ChatCompletionStreamResponseChoice(
          {required final ChatCompletionStreamResponseDelta delta,
          @JsonKey(includeIfNull: false)
          final ChatCompletionStreamResponseChoiceLogprobs? logprobs,
          @JsonKey(
              name: 'finish_reason',
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          required final ChatCompletionFinishReason? finishReason,
          @JsonKey(includeIfNull: false) final int? index}) =
      _$ChatCompletionStreamResponseChoiceImpl;
  const _ChatCompletionStreamResponseChoice._() : super._();

  factory _ChatCompletionStreamResponseChoice.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseChoiceImpl.fromJson;

  @override

  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta;
  @override

  /// Log probability information for the choice.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamResponseChoiceLogprobs? get logprobs;
  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseChoiceLogprobs
    _$ChatCompletionStreamResponseChoiceLogprobsFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseChoiceLogprobs.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoiceLogprobs {
  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<
          ChatCompletionStreamResponseChoiceLogprobs>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceLogprobsCopyWith(
          ChatCompletionStreamResponseChoiceLogprobs value,
          $Res Function(ChatCompletionStreamResponseChoiceLogprobs) then) =
      _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res,
          ChatCompletionStreamResponseChoiceLogprobs>;
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseChoiceLogprobs>
    implements $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith(
          _$ChatCompletionStreamResponseChoiceLogprobsImpl value,
          $Res Function(_$ChatCompletionStreamResponseChoiceLogprobsImpl)
              then) =
      __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseChoiceLogprobsImpl>
    implements _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl(
      _$ChatCompletionStreamResponseChoiceLogprobsImpl _value,
      $Res Function(_$ChatCompletionStreamResponseChoiceLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseChoiceLogprobsImpl(
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseChoiceLogprobsImpl
    extends _ChatCompletionStreamResponseChoiceLogprobs {
  const _$ChatCompletionStreamResponseChoiceLogprobsImpl(
      {required final List<ChatCompletionTokenLogprob>? content})
      : _content = content,
        super._();

  factory _$ChatCompletionStreamResponseChoiceLogprobsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseChoiceLogprobsImplFromJson(json);

  /// A list of message content tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _content;

  /// A list of message content tokens with log probability information.
  @override
  List<ChatCompletionTokenLogprob>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoiceLogprobs(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseChoiceLogprobsImpl &&
            const DeepCollectionEquality().equals(other._content, _content));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_content));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<
          _$ChatCompletionStreamResponseChoiceLogprobsImpl>
      get copyWith =>
          __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl<
                  _$ChatCompletionStreamResponseChoiceLogprobsImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseChoiceLogprobsImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseChoiceLogprobs
    extends ChatCompletionStreamResponseChoiceLogprobs {
  const factory _ChatCompletionStreamResponseChoiceLogprobs(
          {required final List<ChatCompletionTokenLogprob>? content}) =
      _$ChatCompletionStreamResponseChoiceLogprobsImpl;
  const _ChatCompletionStreamResponseChoiceLogprobs._() : super._();

  factory _ChatCompletionStreamResponseChoiceLogprobs.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseChoiceLogprobsImpl.fromJson;

  @override

  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<
          _$ChatCompletionStreamResponseChoiceLogprobsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseDelta _$ChatCompletionStreamResponseDeltaFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseDelta.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseDelta {
  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content => throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls =>
      throw _privateConstructorUsedError;

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseDeltaCopyWith<ChatCompletionStreamResponseDelta>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory $ChatCompletionStreamResponseDeltaCopyWith(
          ChatCompletionStreamResponseDelta value,
          $Res Function(ChatCompletionStreamResponseDelta) then) =
      _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
          ChatCompletionStreamResponseDelta>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseDelta>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  _$ChatCompletionStreamResponseDeltaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseDeltaImplCopyWith(
          _$ChatCompletionStreamResponseDeltaImpl value,
          $Res Function(_$ChatCompletionStreamResponseDeltaImpl) then) =
      __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseDeltaImpl>
    implements _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl(
      _$ChatCompletionStreamResponseDeltaImpl _value,
      $Res Function(_$ChatCompletionStreamResponseDeltaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseDeltaImpl(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseDeltaImpl
    extends _ChatCompletionStreamResponseDelta {
  const _$ChatCompletionStreamResponseDeltaImpl(
      {@JsonKey(includeIfNull: false) this.content,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.role})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionStreamResponseDeltaImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseDeltaImplFromJson(json);

  /// The contents of the chunk message.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? functionCall;

  /// No Description
  final List<ChatCompletionStreamMessageToolCallChunk>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionMessageRole? role;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDelta(content: $content, functionCall: $functionCall, toolCalls: $toolCalls, role: $role)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseDeltaImpl &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.role, role) || other.role == role));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, content, functionCall,
      const DeepCollectionEquality().hash(_toolCalls), role);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<
          _$ChatCompletionStreamResponseDeltaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseDeltaImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseDelta
    extends ChatCompletionStreamResponseDelta {
  const factory _ChatCompletionStreamResponseDelta(
          {@JsonKey(includeIfNull: false) final String? content,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? functionCall,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionMessageRole? role}) =
      _$ChatCompletionStreamResponseDeltaImpl;
  const _ChatCompletionStreamResponseDelta._() : super._();

  factory _ChatCompletionStreamResponseDelta.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseDeltaImpl.fromJson;

  @override

  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall;
  @override

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls;
  @override

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageFunctionCall
    _$ChatCompletionStreamMessageFunctionCallFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageFunctionCall {
  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageFunctionCallCopyWith<
          ChatCompletionStreamMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionStreamMessageFunctionCallCopyWith(
          ChatCompletionStreamMessageFunctionCall value,
          $Res Function(ChatCompletionStreamMessageFunctionCall) then) =
      _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionStreamMessageFunctionCall>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageFunctionCall>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionStreamMessageFunctionCallCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageFunctionCallImplCopyWith(
          _$ChatCompletionStreamMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) then) =
      __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageFunctionCallImpl>
    implements _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionStreamMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageFunctionCallImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageFunctionCallImpl
    extends _ChatCompletionStreamMessageFunctionCall {
  const _$ChatCompletionStreamMessageFunctionCallImpl(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.arguments})
      : super._();

  factory _$ChatCompletionStreamMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  @JsonKey(includeIfNull: false)
  final String? arguments;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<
              _$ChatCompletionStreamMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageFunctionCall
    extends ChatCompletionStreamMessageFunctionCall {
  const factory _ChatCompletionStreamMessageFunctionCall(
          {@JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? arguments}) =
      _$ChatCompletionStreamMessageFunctionCallImpl;
  const _ChatCompletionStreamMessageFunctionCall._() : super._();

  factory _ChatCompletionStreamMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageToolCallChunk
    _$ChatCompletionStreamMessageToolCallChunkFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageToolCallChunk.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageToolCallChunk {
  /// No Description
  int get index => throw _privateConstructorUsedError;

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageToolCallChunkCopyWith<
          ChatCompletionStreamMessageToolCallChunk>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory $ChatCompletionStreamMessageToolCallChunkCopyWith(
          ChatCompletionStreamMessageToolCallChunk value,
          $Res Function(ChatCompletionStreamMessageToolCallChunk) then) =
      _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
          ChatCompletionStreamMessageToolCallChunk>;
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageToolCallChunk>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.function!, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith(
          _$ChatCompletionStreamMessageToolCallChunkImpl value,
          $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) then) =
      __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageToolCallChunkImpl>
    implements _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl(
      _$ChatCompletionStreamMessageToolCallChunkImpl _value,
      $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageToolCallChunkImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageToolCallChunkImpl
    extends _ChatCompletionStreamMessageToolCallChunk {
  const _$ChatCompletionStreamMessageToolCallChunkImpl(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageToolCallChunkImplFromJson(json);

  /// No Description
  @override
  final int index;

  /// The ID of the tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionStreamMessageToolCallChunkType? type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? function;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageToolCallChunk(index: $index, id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageToolCallChunkImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<
              _$ChatCompletionStreamMessageToolCallChunkImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageToolCallChunkImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageToolCallChunk
    extends ChatCompletionStreamMessageToolCallChunk {
  const factory _ChatCompletionStreamMessageToolCallChunk(
          {required final int index,
          @JsonKey(includeIfNull: false) final String? id,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionStreamMessageToolCallChunkType? type,
          @JsonKey(includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? function}) =
      _$ChatCompletionStreamMessageToolCallChunkImpl;
  const _ChatCompletionStreamMessageToolCallChunk._() : super._();

  factory _ChatCompletionStreamMessageToolCallChunk.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson;

  @override

  /// No Description
  int get index;
  @override

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionUsage _$CompletionUsageFromJson(Map<String, dynamic> json) {
  return _CompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$CompletionUsage {
  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens => throw _privateConstructorUsedError;

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionUsageCopyWith<CompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionUsageCopyWith<$Res> {
  factory $CompletionUsageCopyWith(
          CompletionUsage value, $Res Function(CompletionUsage) then) =
      _$CompletionUsageCopyWithImpl<$Res, CompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$CompletionUsageCopyWithImpl<$Res, $Val extends CompletionUsage>
    implements $CompletionUsageCopyWith<$Res> {
  _$CompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionUsageImplCopyWith<$Res>
    implements $CompletionUsageCopyWith<$Res> {
  factory _$$CompletionUsageImplCopyWith(_$CompletionUsageImpl value,
          $Res Function(_$CompletionUsageImpl) then) =
      __$$CompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$CompletionUsageImplCopyWithImpl<$Res>
    extends _$CompletionUsageCopyWithImpl<$Res, _$CompletionUsageImpl>
    implements _$$CompletionUsageImplCopyWith<$Res> {
  __$$CompletionUsageImplCopyWithImpl(
      _$CompletionUsageImpl _value, $Res Function(_$CompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$CompletionUsageImpl(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionUsageImpl extends _CompletionUsage {
  const _$CompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$CompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionUsageImplFromJson(json);

  /// Number of tokens in the generated completion.
  @override
  @JsonKey(name: 'completion_tokens')
  final int? completionTokens;

  /// Number of tokens in the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used in the request (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'CompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      __$$CompletionUsageImplCopyWithImpl<_$CompletionUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _CompletionUsage extends CompletionUsage {
  const factory _CompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int? completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$CompletionUsageImpl;
  const _CompletionUsage._() : super._();

  factory _CompletionUsage.fromJson(Map<String, dynamic> json) =
      _$CompletionUsageImpl.fromJson;

  @override

  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens;
  @override

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateEmbeddingRequest _$CreateEmbeddingRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model => throw _privateConstructorUsedError;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input => throw _privateConstructorUsedError;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat =>
      throw _privateConstructorUsedError;

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @JsonKey(includeIfNull: false)
  int? get dimensions => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingRequestCopyWith<CreateEmbeddingRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingRequestCopyWith<$Res> {
  factory $CreateEmbeddingRequestCopyWith(CreateEmbeddingRequest value,
          $Res Function(CreateEmbeddingRequest) then) =
      _$CreateEmbeddingRequestCopyWithImpl<$Res, CreateEmbeddingRequest>;
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) int? dimensions,
      @JsonKey(includeIfNull: false) String? user});

  $EmbeddingModelCopyWith<$Res> get model;
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateEmbeddingRequestCopyWithImpl<$Res,
        $Val extends CreateEmbeddingRequest>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  _$CreateEmbeddingRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? dimensions = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      dimensions: freezed == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as int?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingModelCopyWith<$Res> get model {
    return $EmbeddingModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingInputCopyWith<$Res> get input {
    return $EmbeddingInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingRequestImplCopyWith<$Res>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  factory _$$CreateEmbeddingRequestImplCopyWith(
          _$CreateEmbeddingRequestImpl value,
          $Res Function(_$CreateEmbeddingRequestImpl) then) =
      __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) int? dimensions,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $EmbeddingModelCopyWith<$Res> get model;
  @override
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingRequestCopyWithImpl<$Res,
        _$CreateEmbeddingRequestImpl>
    implements _$$CreateEmbeddingRequestImplCopyWith<$Res> {
  __$$CreateEmbeddingRequestImplCopyWithImpl(
      _$CreateEmbeddingRequestImpl _value,
      $Res Function(_$CreateEmbeddingRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? dimensions = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateEmbeddingRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      dimensions: freezed == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as int?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingRequestImpl extends _CreateEmbeddingRequest {
  const _$CreateEmbeddingRequestImpl(
      {@_EmbeddingModelConverter() required this.model,
      @_EmbeddingInputConverter() required this.input,
      @JsonKey(name: 'encoding_format')
      this.encodingFormat = EmbeddingEncodingFormat.float,
      @JsonKey(includeIfNull: false) this.dimensions,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateEmbeddingRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @_EmbeddingModelConverter()
  final EmbeddingModel model;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @_EmbeddingInputConverter()
  final EmbeddingInput input;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @override
  @JsonKey(name: 'encoding_format')
  final EmbeddingEncodingFormat encodingFormat;

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @override
  @JsonKey(includeIfNull: false)
  final int? dimensions;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateEmbeddingRequest(model: $model, input: $input, encodingFormat: $encodingFormat, dimensions: $dimensions, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.encodingFormat, encodingFormat) ||
                other.encodingFormat == encodingFormat) &&
            (identical(other.dimensions, dimensions) ||
                other.dimensions == dimensions) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, model, input, encodingFormat, dimensions, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => __$$CreateEmbeddingRequestImplCopyWithImpl<
          _$CreateEmbeddingRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingRequest extends CreateEmbeddingRequest {
  const factory _CreateEmbeddingRequest(
          {@_EmbeddingModelConverter() required final EmbeddingModel model,
          @_EmbeddingInputConverter() required final EmbeddingInput input,
          @JsonKey(name: 'encoding_format')
          final EmbeddingEncodingFormat encodingFormat,
          @JsonKey(includeIfNull: false) final int? dimensions,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateEmbeddingRequestImpl;
  const _CreateEmbeddingRequest._() : super._();

  factory _CreateEmbeddingRequest.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model;
  @override

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input;
  @override

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat;
  @override

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @JsonKey(includeIfNull: false)
  int? get dimensions;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingModel _$EmbeddingModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return EmbeddingModelEnumeration.fromJson(json);
    case 'modelId':
      return EmbeddingModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingModelCopyWith<$Res> {
  factory $EmbeddingModelCopyWith(
          EmbeddingModel value, $Res Function(EmbeddingModel) then) =
      _$EmbeddingModelCopyWithImpl<$Res, EmbeddingModel>;
}

/// @nodoc
class _$EmbeddingModelCopyWithImpl<$Res, $Val extends EmbeddingModel>
    implements $EmbeddingModelCopyWith<$Res> {
  _$EmbeddingModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingModelEnumerationImplCopyWith<$Res> {
  factory _$$EmbeddingModelEnumerationImplCopyWith(
          _$EmbeddingModelEnumerationImpl value,
          $Res Function(_$EmbeddingModelEnumerationImpl) then) =
      __$$EmbeddingModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({EmbeddingModels value});
}

/// @nodoc
class __$$EmbeddingModelEnumerationImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$EmbeddingModelEnumerationImpl>
    implements _$$EmbeddingModelEnumerationImplCopyWith<$Res> {
  __$$EmbeddingModelEnumerationImplCopyWithImpl(
      _$EmbeddingModelEnumerationImpl _value,
      $Res Function(_$EmbeddingModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as EmbeddingModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingModelEnumerationImpl extends EmbeddingModelEnumeration {
  const _$EmbeddingModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$EmbeddingModelEnumerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingModelEnumerationImplFromJson(json);

  @override
  final EmbeddingModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingModelEnumerationImplCopyWith<_$EmbeddingModelEnumerationImpl>
      get copyWith => __$$EmbeddingModelEnumerationImplCopyWithImpl<
          _$EmbeddingModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class EmbeddingModelEnumeration extends EmbeddingModel {
  const factory EmbeddingModelEnumeration(final EmbeddingModels value) =
      _$EmbeddingModelEnumerationImpl;
  const EmbeddingModelEnumeration._() : super._();

  factory EmbeddingModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$EmbeddingModelEnumerationImpl.fromJson;

  @override
  EmbeddingModels get value;
  @JsonKey(ignore: true)
  _$$EmbeddingModelEnumerationImplCopyWith<_$EmbeddingModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingModelStringImplCopyWith<$Res> {
  factory _$$EmbeddingModelStringImplCopyWith(_$EmbeddingModelStringImpl value,
          $Res Function(_$EmbeddingModelStringImpl) then) =
      __$$EmbeddingModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingModelStringImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$EmbeddingModelStringImpl>
    implements _$$EmbeddingModelStringImplCopyWith<$Res> {
  __$$EmbeddingModelStringImplCopyWithImpl(_$EmbeddingModelStringImpl _value,
      $Res Function(_$EmbeddingModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingModelStringImpl extends EmbeddingModelString {
  const _$EmbeddingModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$EmbeddingModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingModelStringImplCopyWith<_$EmbeddingModelStringImpl>
      get copyWith =>
          __$$EmbeddingModelStringImplCopyWithImpl<_$EmbeddingModelStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingModelStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingModelString extends EmbeddingModel {
  const factory EmbeddingModelString(final String value) =
      _$EmbeddingModelStringImpl;
  const EmbeddingModelString._() : super._();

  factory EmbeddingModelString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingModelStringImplCopyWith<_$EmbeddingModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingInput _$EmbeddingInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return EmbeddingInputListListInt.fromJson(json);
    case 'tokens':
      return EmbeddingInputListInt.fromJson(json);
    case 'listString':
      return EmbeddingInputListString.fromJson(json);
    case 'string':
      return EmbeddingInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputCopyWith(
          EmbeddingInput value, $Res Function(EmbeddingInput) then) =
      _$EmbeddingInputCopyWithImpl<$Res, EmbeddingInput>;
}

/// @nodoc
class _$EmbeddingInputCopyWithImpl<$Res, $Val extends EmbeddingInput>
    implements $EmbeddingInputCopyWith<$Res> {
  _$EmbeddingInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingInputListListIntImplCopyWith<$Res> {
  factory _$$EmbeddingInputListListIntImplCopyWith(
          _$EmbeddingInputListListIntImpl value,
          $Res Function(_$EmbeddingInputListListIntImpl) then) =
      __$$EmbeddingInputListListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$EmbeddingInputListListIntImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListListIntImpl>
    implements _$$EmbeddingInputListListIntImplCopyWith<$Res> {
  __$$EmbeddingInputListListIntImplCopyWithImpl(
      _$EmbeddingInputListListIntImpl _value,
      $Res Function(_$EmbeddingInputListListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListListIntImpl extends EmbeddingInputListListInt {
  const _$EmbeddingInputListListIntImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();

  factory _$EmbeddingInputListListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListListIntImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.listTokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListListIntImplCopyWith<_$EmbeddingInputListListIntImpl>
      get copyWith => __$$EmbeddingInputListListIntImplCopyWithImpl<
          _$EmbeddingInputListListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listTokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listTokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return listTokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return listTokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListListIntImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListListInt extends EmbeddingInput {
  const factory EmbeddingInputListListInt(final List<List<int>> value) =
      _$EmbeddingInputListListIntImpl;
  const EmbeddingInputListListInt._() : super._();

  factory EmbeddingInputListListInt.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListListIntImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListListIntImplCopyWith<_$EmbeddingInputListListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputListIntImplCopyWith<$Res> {
  factory _$$EmbeddingInputListIntImplCopyWith(
          _$EmbeddingInputListIntImpl value,
          $Res Function(_$EmbeddingInputListIntImpl) then) =
      __$$EmbeddingInputListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$EmbeddingInputListIntImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListIntImpl>
    implements _$$EmbeddingInputListIntImplCopyWith<$Res> {
  __$$EmbeddingInputListIntImplCopyWithImpl(_$EmbeddingInputListIntImpl _value,
      $Res Function(_$EmbeddingInputListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListIntImpl extends EmbeddingInputListInt {
  const _$EmbeddingInputListIntImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();

  factory _$EmbeddingInputListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListIntImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.tokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListIntImplCopyWith<_$EmbeddingInputListIntImpl>
      get copyWith => __$$EmbeddingInputListIntImplCopyWithImpl<
          _$EmbeddingInputListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return tokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return tokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return tokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return tokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListIntImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListInt extends EmbeddingInput {
  const factory EmbeddingInputListInt(final List<int> value) =
      _$EmbeddingInputListIntImpl;
  const EmbeddingInputListInt._() : super._();

  factory EmbeddingInputListInt.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListIntImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListIntImplCopyWith<_$EmbeddingInputListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputListStringImplCopyWith<$Res> {
  factory _$$EmbeddingInputListStringImplCopyWith(
          _$EmbeddingInputListStringImpl value,
          $Res Function(_$EmbeddingInputListStringImpl) then) =
      __$$EmbeddingInputListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$EmbeddingInputListStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListStringImpl>
    implements _$$EmbeddingInputListStringImplCopyWith<$Res> {
  __$$EmbeddingInputListStringImplCopyWithImpl(
      _$EmbeddingInputListStringImpl _value,
      $Res Function(_$EmbeddingInputListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListStringImpl extends EmbeddingInputListString {
  const _$EmbeddingInputListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$EmbeddingInputListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListStringImplCopyWith<_$EmbeddingInputListStringImpl>
      get copyWith => __$$EmbeddingInputListStringImplCopyWithImpl<
          _$EmbeddingInputListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListString extends EmbeddingInput {
  const factory EmbeddingInputListString(final List<String> value) =
      _$EmbeddingInputListStringImpl;
  const EmbeddingInputListString._() : super._();

  factory EmbeddingInputListString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListStringImplCopyWith<_$EmbeddingInputListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputStringImplCopyWith<$Res> {
  factory _$$EmbeddingInputStringImplCopyWith(_$EmbeddingInputStringImpl value,
          $Res Function(_$EmbeddingInputStringImpl) then) =
      __$$EmbeddingInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingInputStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputStringImpl>
    implements _$$EmbeddingInputStringImplCopyWith<$Res> {
  __$$EmbeddingInputStringImplCopyWithImpl(_$EmbeddingInputStringImpl _value,
      $Res Function(_$EmbeddingInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputStringImpl extends EmbeddingInputString {
  const _$EmbeddingInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$EmbeddingInputStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputStringImplCopyWith<_$EmbeddingInputStringImpl>
      get copyWith =>
          __$$EmbeddingInputStringImplCopyWithImpl<_$EmbeddingInputStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputString extends EmbeddingInput {
  const factory EmbeddingInputString(final String value) =
      _$EmbeddingInputStringImpl;
  const EmbeddingInputString._() : super._();

  factory EmbeddingInputString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputStringImplCopyWith<_$EmbeddingInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateEmbeddingResponse _$CreateEmbeddingResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingResponse {
  /// The list of embeddings generated by the model.
  List<Embedding> get data => throw _privateConstructorUsedError;

  /// The name of the model used to generate the embedding.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  CreateEmbeddingResponseObject get object =>
      throw _privateConstructorUsedError;

  /// The usage information for the request.
  @JsonKey(includeIfNull: false)
  EmbeddingUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingResponseCopyWith<CreateEmbeddingResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingResponseCopyWith<$Res> {
  factory $CreateEmbeddingResponseCopyWith(CreateEmbeddingResponse value,
          $Res Function(CreateEmbeddingResponse) then) =
      _$CreateEmbeddingResponseCopyWithImpl<$Res, CreateEmbeddingResponse>;
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      @JsonKey(includeIfNull: false) EmbeddingUsage? usage});

  $EmbeddingUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateEmbeddingResponseCopyWithImpl<$Res,
        $Val extends CreateEmbeddingResponse>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  _$CreateEmbeddingResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $EmbeddingUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingResponseImplCopyWith<$Res>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  factory _$$CreateEmbeddingResponseImplCopyWith(
          _$CreateEmbeddingResponseImpl value,
          $Res Function(_$CreateEmbeddingResponseImpl) then) =
      __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      @JsonKey(includeIfNull: false) EmbeddingUsage? usage});

  @override
  $EmbeddingUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingResponseCopyWithImpl<$Res,
        _$CreateEmbeddingResponseImpl>
    implements _$$CreateEmbeddingResponseImplCopyWith<$Res> {
  __$$CreateEmbeddingResponseImplCopyWithImpl(
      _$CreateEmbeddingResponseImpl _value,
      $Res Function(_$CreateEmbeddingResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateEmbeddingResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingResponseImpl extends _CreateEmbeddingResponse {
  const _$CreateEmbeddingResponseImpl(
      {required final List<Embedding> data,
      required this.model,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _data = data,
        super._();

  factory _$CreateEmbeddingResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingResponseImplFromJson(json);

  /// The list of embeddings generated by the model.
  final List<Embedding> _data;

  /// The list of embeddings generated by the model.
  @override
  List<Embedding> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The name of the model used to generate the embedding.
  @override
  final String model;

  /// The object type, which is always "list".
  @override
  final CreateEmbeddingResponseObject object;

  /// The usage information for the request.
  @override
  @JsonKey(includeIfNull: false)
  final EmbeddingUsage? usage;

  @override
  String toString() {
    return 'CreateEmbeddingResponse(data: $data, model: $model, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_data), model, object, usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => __$$CreateEmbeddingResponseImplCopyWithImpl<
          _$CreateEmbeddingResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingResponse extends CreateEmbeddingResponse {
  const factory _CreateEmbeddingResponse(
          {required final List<Embedding> data,
          required final String model,
          required final CreateEmbeddingResponseObject object,
          @JsonKey(includeIfNull: false) final EmbeddingUsage? usage}) =
      _$CreateEmbeddingResponseImpl;
  const _CreateEmbeddingResponse._() : super._();

  factory _CreateEmbeddingResponse.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingResponseImpl.fromJson;

  @override

  /// The list of embeddings generated by the model.
  List<Embedding> get data;
  @override

  /// The name of the model used to generate the embedding.
  String get model;
  @override

  /// The object type, which is always "list".
  CreateEmbeddingResponseObject get object;
  @override

  /// The usage information for the request.
  @JsonKey(includeIfNull: false)
  EmbeddingUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Embedding _$EmbeddingFromJson(Map<String, dynamic> json) {
  return _Embedding.fromJson(json);
}

/// @nodoc
mixin _$Embedding {
  /// The index of the embedding in the list of embeddings.
  int get index => throw _privateConstructorUsedError;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding => throw _privateConstructorUsedError;

  /// The object type, which is always "embedding".
  EmbeddingObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingCopyWith<Embedding> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingCopyWith<$Res> {
  factory $EmbeddingCopyWith(Embedding value, $Res Function(Embedding) then) =
      _$EmbeddingCopyWithImpl<$Res, Embedding>;
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class _$EmbeddingCopyWithImpl<$Res, $Val extends Embedding>
    implements $EmbeddingCopyWith<$Res> {
  _$EmbeddingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingVectorCopyWith<$Res> get embedding {
    return $EmbeddingVectorCopyWith<$Res>(_value.embedding, (value) {
      return _then(_value.copyWith(embedding: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EmbeddingImplCopyWith<$Res>
    implements $EmbeddingCopyWith<$Res> {
  factory _$$EmbeddingImplCopyWith(
          _$EmbeddingImpl value, $Res Function(_$EmbeddingImpl) then) =
      __$$EmbeddingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  @override
  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class __$$EmbeddingImplCopyWithImpl<$Res>
    extends _$EmbeddingCopyWithImpl<$Res, _$EmbeddingImpl>
    implements _$$EmbeddingImplCopyWith<$Res> {
  __$$EmbeddingImplCopyWithImpl(
      _$EmbeddingImpl _value, $Res Function(_$EmbeddingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_$EmbeddingImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingImpl extends _Embedding {
  const _$EmbeddingImpl(
      {required this.index,
      @_EmbeddingVectorConverter() required this.embedding,
      required this.object})
      : super._();

  factory _$EmbeddingImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingImplFromJson(json);

  /// The index of the embedding in the list of embeddings.
  @override
  final int index;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @override
  @_EmbeddingVectorConverter()
  final EmbeddingVector embedding;

  /// The object type, which is always "embedding".
  @override
  final EmbeddingObject object;

  @override
  String toString() {
    return 'Embedding(index: $index, embedding: $embedding, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.embedding, embedding) ||
                other.embedding == embedding) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, embedding, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      __$$EmbeddingImplCopyWithImpl<_$EmbeddingImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingImplToJson(
      this,
    );
  }
}

abstract class _Embedding extends Embedding {
  const factory _Embedding(
      {required final int index,
      @_EmbeddingVectorConverter() required final EmbeddingVector embedding,
      required final EmbeddingObject object}) = _$EmbeddingImpl;
  const _Embedding._() : super._();

  factory _Embedding.fromJson(Map<String, dynamic> json) =
      _$EmbeddingImpl.fromJson;

  @override

  /// The index of the embedding in the list of embeddings.
  int get index;
  @override

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding;
  @override

  /// The object type, which is always "embedding".
  EmbeddingObject get object;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EmbeddingVector _$EmbeddingVectorFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'vector':
      return EmbeddingVectorListDouble.fromJson(json);
    case 'vectorBase64':
      return EmbeddingVectorString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingVector',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingVector {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingVectorCopyWith<$Res> {
  factory $EmbeddingVectorCopyWith(
          EmbeddingVector value, $Res Function(EmbeddingVector) then) =
      _$EmbeddingVectorCopyWithImpl<$Res, EmbeddingVector>;
}

/// @nodoc
class _$EmbeddingVectorCopyWithImpl<$Res, $Val extends EmbeddingVector>
    implements $EmbeddingVectorCopyWith<$Res> {
  _$EmbeddingVectorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingVectorListDoubleImplCopyWith<$Res> {
  factory _$$EmbeddingVectorListDoubleImplCopyWith(
          _$EmbeddingVectorListDoubleImpl value,
          $Res Function(_$EmbeddingVectorListDoubleImpl) then) =
      __$$EmbeddingVectorListDoubleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<double> value});
}

/// @nodoc
class __$$EmbeddingVectorListDoubleImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res, _$EmbeddingVectorListDoubleImpl>
    implements _$$EmbeddingVectorListDoubleImplCopyWith<$Res> {
  __$$EmbeddingVectorListDoubleImplCopyWithImpl(
      _$EmbeddingVectorListDoubleImpl _value,
      $Res Function(_$EmbeddingVectorListDoubleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingVectorListDoubleImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<double>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingVectorListDoubleImpl extends EmbeddingVectorListDouble {
  const _$EmbeddingVectorListDoubleImpl(final List<double> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'vector',
        super._();

  factory _$EmbeddingVectorListDoubleImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingVectorListDoubleImplFromJson(json);

  final List<double> _value;
  @override
  List<double> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.vector(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingVectorListDoubleImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingVectorListDoubleImplCopyWith<_$EmbeddingVectorListDoubleImpl>
      get copyWith => __$$EmbeddingVectorListDoubleImplCopyWithImpl<
          _$EmbeddingVectorListDoubleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) {
    return vector(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) {
    return vector?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vector != null) {
      return vector(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) {
    return vector(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) {
    return vector?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vector != null) {
      return vector(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingVectorListDoubleImplToJson(
      this,
    );
  }
}

abstract class EmbeddingVectorListDouble extends EmbeddingVector {
  const factory EmbeddingVectorListDouble(final List<double> value) =
      _$EmbeddingVectorListDoubleImpl;
  const EmbeddingVectorListDouble._() : super._();

  factory EmbeddingVectorListDouble.fromJson(Map<String, dynamic> json) =
      _$EmbeddingVectorListDoubleImpl.fromJson;

  @override
  List<double> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingVectorListDoubleImplCopyWith<_$EmbeddingVectorListDoubleImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingVectorStringImplCopyWith<$Res> {
  factory _$$EmbeddingVectorStringImplCopyWith(
          _$EmbeddingVectorStringImpl value,
          $Res Function(_$EmbeddingVectorStringImpl) then) =
      __$$EmbeddingVectorStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingVectorStringImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res, _$EmbeddingVectorStringImpl>
    implements _$$EmbeddingVectorStringImplCopyWith<$Res> {
  __$$EmbeddingVectorStringImplCopyWithImpl(_$EmbeddingVectorStringImpl _value,
      $Res Function(_$EmbeddingVectorStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingVectorStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingVectorStringImpl extends EmbeddingVectorString {
  const _$EmbeddingVectorStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'vectorBase64',
        super._();

  factory _$EmbeddingVectorStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingVectorStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.vectorBase64(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingVectorStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingVectorStringImplCopyWith<_$EmbeddingVectorStringImpl>
      get copyWith => __$$EmbeddingVectorStringImplCopyWithImpl<
          _$EmbeddingVectorStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) {
    return vectorBase64(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) {
    return vectorBase64?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vectorBase64 != null) {
      return vectorBase64(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) {
    return vectorBase64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) {
    return vectorBase64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vectorBase64 != null) {
      return vectorBase64(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingVectorStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingVectorString extends EmbeddingVector {
  const factory EmbeddingVectorString(final String value) =
      _$EmbeddingVectorStringImpl;
  const EmbeddingVectorString._() : super._();

  factory EmbeddingVectorString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingVectorStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingVectorStringImplCopyWith<_$EmbeddingVectorStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingUsage _$EmbeddingUsageFromJson(Map<String, dynamic> json) {
  return _EmbeddingUsage.fromJson(json);
}

/// @nodoc
mixin _$EmbeddingUsage {
  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingUsageCopyWith<EmbeddingUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingUsageCopyWith<$Res> {
  factory $EmbeddingUsageCopyWith(
          EmbeddingUsage value, $Res Function(EmbeddingUsage) then) =
      _$EmbeddingUsageCopyWithImpl<$Res, EmbeddingUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$EmbeddingUsageCopyWithImpl<$Res, $Val extends EmbeddingUsage>
    implements $EmbeddingUsageCopyWith<$Res> {
  _$EmbeddingUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EmbeddingUsageImplCopyWith<$Res>
    implements $EmbeddingUsageCopyWith<$Res> {
  factory _$$EmbeddingUsageImplCopyWith(_$EmbeddingUsageImpl value,
          $Res Function(_$EmbeddingUsageImpl) then) =
      __$$EmbeddingUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$EmbeddingUsageImplCopyWithImpl<$Res>
    extends _$EmbeddingUsageCopyWithImpl<$Res, _$EmbeddingUsageImpl>
    implements _$$EmbeddingUsageImplCopyWith<$Res> {
  __$$EmbeddingUsageImplCopyWithImpl(
      _$EmbeddingUsageImpl _value, $Res Function(_$EmbeddingUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$EmbeddingUsageImpl(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingUsageImpl extends _EmbeddingUsage {
  const _$EmbeddingUsageImpl(
      {@JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$EmbeddingUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingUsageImplFromJson(json);

  /// The number of tokens used by the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// The total number of tokens used by the request.
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'EmbeddingUsage(promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingUsageImpl &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      __$$EmbeddingUsageImplCopyWithImpl<_$EmbeddingUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingUsageImplToJson(
      this,
    );
  }
}

abstract class _EmbeddingUsage extends EmbeddingUsage {
  const factory _EmbeddingUsage(
          {@JsonKey(name: 'prompt_tokens') required final int promptTokens,
          @JsonKey(name: 'total_tokens') required final int totalTokens}) =
      _$EmbeddingUsageImpl;
  const _EmbeddingUsage._() : super._();

  factory _EmbeddingUsage.fromJson(Map<String, dynamic> json) =
      _$EmbeddingUsageImpl.fromJson;

  @override

  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateFineTuningJobRequest _$CreateFineTuningJobRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateFineTuningJobRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateFineTuningJobRequest {
  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters =>
      throw _privateConstructorUsedError;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateFineTuningJobRequestCopyWith<CreateFineTuningJobRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateFineTuningJobRequestCopyWith<$Res> {
  factory $CreateFineTuningJobRequestCopyWith(CreateFineTuningJobRequest value,
          $Res Function(CreateFineTuningJobRequest) then) =
      _$CreateFineTuningJobRequestCopyWithImpl<$Res,
          CreateFineTuningJobRequest>;
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile});

  $FineTuningModelCopyWith<$Res> get model;
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        $Val extends CreateFineTuningJobRequest>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  _$CreateFineTuningJobRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningModelCopyWith<$Res> get model {
    return $FineTuningModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters {
    if (_value.hyperparameters == null) {
      return null;
    }

    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters!,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateFineTuningJobRequestImplCopyWith<$Res>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  factory _$$CreateFineTuningJobRequestImplCopyWith(
          _$CreateFineTuningJobRequestImpl value,
          $Res Function(_$CreateFineTuningJobRequestImpl) then) =
      __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile});

  @override
  $FineTuningModelCopyWith<$Res> get model;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>
    extends _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        _$CreateFineTuningJobRequestImpl>
    implements _$$CreateFineTuningJobRequestImplCopyWith<$Res> {
  __$$CreateFineTuningJobRequestImplCopyWithImpl(
      _$CreateFineTuningJobRequestImpl _value,
      $Res Function(_$CreateFineTuningJobRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
  }) {
    return _then(_$CreateFineTuningJobRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateFineTuningJobRequestImpl extends _CreateFineTuningJobRequest {
  const _$CreateFineTuningJobRequestImpl(
      {@_FineTuningModelConverter() required this.model,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(includeIfNull: false) this.hyperparameters,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      this.validationFile})
      : super._();

  factory _$CreateFineTuningJobRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateFineTuningJobRequestImplFromJson(json);

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @override
  @_FineTuningModelConverter()
  final FineTuningModel model;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(includeIfNull: false)
  final FineTuningJobHyperparameters? hyperparameters;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'validation_file', includeIfNull: false)
  final String? validationFile;

  @override
  String toString() {
    return 'CreateFineTuningJobRequest(model: $model, trainingFile: $trainingFile, hyperparameters: $hyperparameters, suffix: $suffix, validationFile: $validationFile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateFineTuningJobRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, model, trainingFile,
      hyperparameters, suffix, validationFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => __$$CreateFineTuningJobRequestImplCopyWithImpl<
          _$CreateFineTuningJobRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateFineTuningJobRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateFineTuningJobRequest extends CreateFineTuningJobRequest {
  const factory _CreateFineTuningJobRequest(
      {@_FineTuningModelConverter() required final FineTuningModel model,
      @JsonKey(name: 'training_file') required final String trainingFile,
      @JsonKey(includeIfNull: false)
      final FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) final String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      final String? validationFile}) = _$CreateFineTuningJobRequestImpl;
  const _CreateFineTuningJobRequest._() : super._();

  factory _CreateFineTuningJobRequest.fromJson(Map<String, dynamic> json) =
      _$CreateFineTuningJobRequestImpl.fromJson;

  @override

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model;
  @override

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/upload) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters;
  @override

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile;
  @override
  @JsonKey(ignore: true)
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningModel _$FineTuningModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return FineTuningModelEnumeration.fromJson(json);
    case 'modelId':
      return FineTuningModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningModelCopyWith<$Res> {
  factory $FineTuningModelCopyWith(
          FineTuningModel value, $Res Function(FineTuningModel) then) =
      _$FineTuningModelCopyWithImpl<$Res, FineTuningModel>;
}

/// @nodoc
class _$FineTuningModelCopyWithImpl<$Res, $Val extends FineTuningModel>
    implements $FineTuningModelCopyWith<$Res> {
  _$FineTuningModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FineTuningModelEnumerationImplCopyWith<$Res> {
  factory _$$FineTuningModelEnumerationImplCopyWith(
          _$FineTuningModelEnumerationImpl value,
          $Res Function(_$FineTuningModelEnumerationImpl) then) =
      __$$FineTuningModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningModels value});
}

/// @nodoc
class __$$FineTuningModelEnumerationImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res,
        _$FineTuningModelEnumerationImpl>
    implements _$$FineTuningModelEnumerationImplCopyWith<$Res> {
  __$$FineTuningModelEnumerationImplCopyWithImpl(
      _$FineTuningModelEnumerationImpl _value,
      $Res Function(_$FineTuningModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningModelEnumerationImpl extends FineTuningModelEnumeration {
  const _$FineTuningModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$FineTuningModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningModelEnumerationImplFromJson(json);

  @override
  final FineTuningModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningModelEnumerationImplCopyWith<_$FineTuningModelEnumerationImpl>
      get copyWith => __$$FineTuningModelEnumerationImplCopyWithImpl<
          _$FineTuningModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class FineTuningModelEnumeration extends FineTuningModel {
  const factory FineTuningModelEnumeration(final FineTuningModels value) =
      _$FineTuningModelEnumerationImpl;
  const FineTuningModelEnumeration._() : super._();

  factory FineTuningModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$FineTuningModelEnumerationImpl.fromJson;

  @override
  FineTuningModels get value;
  @JsonKey(ignore: true)
  _$$FineTuningModelEnumerationImplCopyWith<_$FineTuningModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FineTuningModelStringImplCopyWith<$Res> {
  factory _$$FineTuningModelStringImplCopyWith(
          _$FineTuningModelStringImpl value,
          $Res Function(_$FineTuningModelStringImpl) then) =
      __$$FineTuningModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$FineTuningModelStringImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res, _$FineTuningModelStringImpl>
    implements _$$FineTuningModelStringImplCopyWith<$Res> {
  __$$FineTuningModelStringImplCopyWithImpl(_$FineTuningModelStringImpl _value,
      $Res Function(_$FineTuningModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningModelStringImpl extends FineTuningModelString {
  const _$FineTuningModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$FineTuningModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningModelStringImplCopyWith<_$FineTuningModelStringImpl>
      get copyWith => __$$FineTuningModelStringImplCopyWithImpl<
          _$FineTuningModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningModelStringImplToJson(
      this,
    );
  }
}

abstract class FineTuningModelString extends FineTuningModel {
  const factory FineTuningModelString(final String value) =
      _$FineTuningModelStringImpl;
  const FineTuningModelString._() : super._();

  factory FineTuningModelString.fromJson(Map<String, dynamic> json) =
      _$FineTuningModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$FineTuningModelStringImplCopyWith<_$FineTuningModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJob _$FineTuningJobFromJson(Map<String, dynamic> json) {
  return _FineTuningJob.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJob {
  /// The object identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error => throw _privateConstructorUsedError;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters =>
      throw _privateConstructorUsedError;

  /// The base model that is being fine-tuned.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job".
  FineTuningJobObject get object => throw _privateConstructorUsedError;

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId => throw _privateConstructorUsedError;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles => throw _privateConstructorUsedError;

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status => throw _privateConstructorUsedError;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens => throw _privateConstructorUsedError;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobCopyWith<FineTuningJob> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobCopyWith<$Res> {
  factory $FineTuningJobCopyWith(
          FineTuningJob value, $Res Function(FineTuningJob) then) =
      _$FineTuningJobCopyWithImpl<$Res, FineTuningJob>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile});

  $FineTuningJobErrorCopyWith<$Res>? get error;
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class _$FineTuningJobCopyWithImpl<$Res, $Val extends FineTuningJob>
    implements $FineTuningJobCopyWith<$Res> {
  _$FineTuningJobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value.resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobErrorCopyWith<$Res>? get error {
    if (_value.error == null) {
      return null;
    }

    return $FineTuningJobErrorCopyWith<$Res>(_value.error!, (value) {
      return _then(_value.copyWith(error: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters {
    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobImplCopyWith<$Res>
    implements $FineTuningJobCopyWith<$Res> {
  factory _$$FineTuningJobImplCopyWith(
          _$FineTuningJobImpl value, $Res Function(_$FineTuningJobImpl) then) =
      __$$FineTuningJobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile});

  @override
  $FineTuningJobErrorCopyWith<$Res>? get error;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class __$$FineTuningJobImplCopyWithImpl<$Res>
    extends _$FineTuningJobCopyWithImpl<$Res, _$FineTuningJobImpl>
    implements _$$FineTuningJobImplCopyWith<$Res> {
  __$$FineTuningJobImplCopyWithImpl(
      _$FineTuningJobImpl _value, $Res Function(_$FineTuningJobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
  }) {
    return _then(_$FineTuningJobImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value._resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobImpl extends _FineTuningJob {
  const _$FineTuningJobImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.error,
      @JsonKey(name: 'fine_tuned_model') required this.fineTunedModel,
      @JsonKey(name: 'finished_at') required this.finishedAt,
      required this.hyperparameters,
      required this.model,
      required this.object,
      @JsonKey(name: 'organization_id') required this.organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required this.status,
      @JsonKey(name: 'trained_tokens') required this.trainedTokens,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(name: 'validation_file') required this.validationFile})
      : _resultFiles = resultFiles,
        super._();

  factory _$FineTuningJobImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobImplFromJson(json);

  /// The object identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  @override
  final FineTuningJobError? error;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'fine_tuned_model')
  final String? fineTunedModel;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'finished_at')
  final int? finishedAt;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  final FineTuningJobHyperparameters hyperparameters;

  /// The base model that is being fine-tuned.
  @override
  final String model;

  /// The object type, which is always "fine_tuning.job".
  @override
  final FineTuningJobObject object;

  /// The organization that owns the fine-tuning job.
  @override
  @JsonKey(name: 'organization_id')
  final String organizationId;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  final List<String> _resultFiles;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'result_files')
  List<String> get resultFiles {
    if (_resultFiles is EqualUnmodifiableListView) return _resultFiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_resultFiles);
  }

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  @override
  final FineTuningJobStatus status;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'trained_tokens')
  final int? trainedTokens;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'validation_file')
  final String? validationFile;

  @override
  String toString() {
    return 'FineTuningJob(id: $id, createdAt: $createdAt, error: $error, fineTunedModel: $fineTunedModel, finishedAt: $finishedAt, hyperparameters: $hyperparameters, model: $model, object: $object, organizationId: $organizationId, resultFiles: $resultFiles, status: $status, trainedTokens: $trainedTokens, trainingFile: $trainingFile, validationFile: $validationFile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.fineTunedModel, fineTunedModel) ||
                other.fineTunedModel == fineTunedModel) &&
            (identical(other.finishedAt, finishedAt) ||
                other.finishedAt == finishedAt) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.organizationId, organizationId) ||
                other.organizationId == organizationId) &&
            const DeepCollectionEquality()
                .equals(other._resultFiles, _resultFiles) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.trainedTokens, trainedTokens) ||
                other.trainedTokens == trainedTokens) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      createdAt,
      error,
      fineTunedModel,
      finishedAt,
      hyperparameters,
      model,
      object,
      organizationId,
      const DeepCollectionEquality().hash(_resultFiles),
      status,
      trainedTokens,
      trainingFile,
      validationFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      __$$FineTuningJobImplCopyWithImpl<_$FineTuningJobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJob extends FineTuningJob {
  const factory _FineTuningJob(
      {required final String id,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') required final String? fineTunedModel,
      @JsonKey(name: 'finished_at') required final int? finishedAt,
      required final FineTuningJobHyperparameters hyperparameters,
      required final String model,
      required final FineTuningJobObject object,
      @JsonKey(name: 'organization_id') required final String organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required final FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') required final int? trainedTokens,
      @JsonKey(name: 'training_file') required final String trainingFile,
      @JsonKey(name: 'validation_file')
      required final String? validationFile}) = _$FineTuningJobImpl;
  const _FineTuningJob._() : super._();

  factory _FineTuningJob.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobImpl.fromJson;

  @override

  /// The object identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error;
  @override

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters;
  @override

  /// The base model that is being fine-tuned.
  String get model;
  @override

  /// The object type, which is always "fine_tuning.job".
  FineTuningJobObject get object;
  @override

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId;
  @override

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles;
  @override

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status;
  @override

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens;
  @override

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobError _$FineTuningJobErrorFromJson(Map<String, dynamic> json) {
  return _FineTuningJobError.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobError {
  /// A machine-readable error code.
  String get code => throw _privateConstructorUsedError;

  /// A human-readable error message.
  String get message => throw _privateConstructorUsedError;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobErrorCopyWith<FineTuningJobError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobErrorCopyWith<$Res> {
  factory $FineTuningJobErrorCopyWith(
          FineTuningJobError value, $Res Function(FineTuningJobError) then) =
      _$FineTuningJobErrorCopyWithImpl<$Res, FineTuningJobError>;
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class _$FineTuningJobErrorCopyWithImpl<$Res, $Val extends FineTuningJobError>
    implements $FineTuningJobErrorCopyWith<$Res> {
  _$FineTuningJobErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobErrorImplCopyWith<$Res>
    implements $FineTuningJobErrorCopyWith<$Res> {
  factory _$$FineTuningJobErrorImplCopyWith(_$FineTuningJobErrorImpl value,
          $Res Function(_$FineTuningJobErrorImpl) then) =
      __$$FineTuningJobErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class __$$FineTuningJobErrorImplCopyWithImpl<$Res>
    extends _$FineTuningJobErrorCopyWithImpl<$Res, _$FineTuningJobErrorImpl>
    implements _$$FineTuningJobErrorImplCopyWith<$Res> {
  __$$FineTuningJobErrorImplCopyWithImpl(_$FineTuningJobErrorImpl _value,
      $Res Function(_$FineTuningJobErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_$FineTuningJobErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobErrorImpl extends _FineTuningJobError {
  const _$FineTuningJobErrorImpl(
      {required this.code, required this.message, required this.param})
      : super._();

  factory _$FineTuningJobErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobErrorImplFromJson(json);

  /// A machine-readable error code.
  @override
  final String code;

  /// A human-readable error message.
  @override
  final String message;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  @override
  final String? param;

  @override
  String toString() {
    return 'FineTuningJobError(code: $code, message: $message, param: $param)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      __$$FineTuningJobErrorImplCopyWithImpl<_$FineTuningJobErrorImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobErrorImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobError extends FineTuningJobError {
  const factory _FineTuningJobError(
      {required final String code,
      required final String message,
      required final String? param}) = _$FineTuningJobErrorImpl;
  const _FineTuningJobError._() : super._();

  factory _FineTuningJobError.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobErrorImpl.fromJson;

  @override

  /// A machine-readable error code.
  String get code;
  @override

  /// A human-readable error message.
  String get message;
  @override

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobHyperparameters _$FineTuningJobHyperparametersFromJson(
    Map<String, dynamic> json) {
  return _FineTuningJobHyperparameters.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobHyperparameters {
  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobHyperparametersCopyWith<FineTuningJobHyperparameters>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobHyperparametersCopyWith<$Res> {
  factory $FineTuningJobHyperparametersCopyWith(
          FineTuningJobHyperparameters value,
          $Res Function(FineTuningJobHyperparameters) then) =
      _$FineTuningJobHyperparametersCopyWithImpl<$Res,
          FineTuningJobHyperparameters>;
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        $Val extends FineTuningJobHyperparameters>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  _$FineTuningJobHyperparametersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_value.copyWith(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsCopyWith<$Res> get nEpochs {
    return $FineTuningNEpochsCopyWith<$Res>(_value.nEpochs, (value) {
      return _then(_value.copyWith(nEpochs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobHyperparametersImplCopyWith<$Res>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  factory _$$FineTuningJobHyperparametersImplCopyWith(
          _$FineTuningJobHyperparametersImpl value,
          $Res Function(_$FineTuningJobHyperparametersImpl) then) =
      __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  @override
  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>
    extends _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        _$FineTuningJobHyperparametersImpl>
    implements _$$FineTuningJobHyperparametersImplCopyWith<$Res> {
  __$$FineTuningJobHyperparametersImplCopyWithImpl(
      _$FineTuningJobHyperparametersImpl _value,
      $Res Function(_$FineTuningJobHyperparametersImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_$FineTuningJobHyperparametersImpl(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobHyperparametersImpl extends _FineTuningJobHyperparameters {
  const _$FineTuningJobHyperparametersImpl(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      required this.nEpochs})
      : super._();

  factory _$FineTuningJobHyperparametersImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningJobHyperparametersImplFromJson(json);

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @override
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  final FineTuningNEpochs nEpochs;

  @override
  String toString() {
    return 'FineTuningJobHyperparameters(nEpochs: $nEpochs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobHyperparametersImpl &&
            (identical(other.nEpochs, nEpochs) || other.nEpochs == nEpochs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, nEpochs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => __$$FineTuningJobHyperparametersImplCopyWithImpl<
          _$FineTuningJobHyperparametersImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobHyperparametersImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobHyperparameters
    extends FineTuningJobHyperparameters {
  const factory _FineTuningJobHyperparameters(
          {@_FineTuningNEpochsConverter()
          @JsonKey(name: 'n_epochs')
          required final FineTuningNEpochs nEpochs}) =
      _$FineTuningJobHyperparametersImpl;
  const _FineTuningJobHyperparameters._() : super._();

  factory _FineTuningJobHyperparameters.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobHyperparametersImpl.fromJson;

  @override

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningNEpochs _$FineTuningNEpochsFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return FineTuningNEpochsEnumeration.fromJson(json);
    case 'number':
      return FineTuningNEpochsInt.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningNEpochs',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningNEpochs {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningNEpochsCopyWith<$Res> {
  factory $FineTuningNEpochsCopyWith(
          FineTuningNEpochs value, $Res Function(FineTuningNEpochs) then) =
      _$FineTuningNEpochsCopyWithImpl<$Res, FineTuningNEpochs>;
}

/// @nodoc
class _$FineTuningNEpochsCopyWithImpl<$Res, $Val extends FineTuningNEpochs>
    implements $FineTuningNEpochsCopyWith<$Res> {
  _$FineTuningNEpochsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FineTuningNEpochsEnumerationImplCopyWith<$Res> {
  factory _$$FineTuningNEpochsEnumerationImplCopyWith(
          _$FineTuningNEpochsEnumerationImpl value,
          $Res Function(_$FineTuningNEpochsEnumerationImpl) then) =
      __$$FineTuningNEpochsEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningNEpochsOptions value});
}

/// @nodoc
class __$$FineTuningNEpochsEnumerationImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res,
        _$FineTuningNEpochsEnumerationImpl>
    implements _$$FineTuningNEpochsEnumerationImplCopyWith<$Res> {
  __$$FineTuningNEpochsEnumerationImplCopyWithImpl(
      _$FineTuningNEpochsEnumerationImpl _value,
      $Res Function(_$FineTuningNEpochsEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningNEpochsEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochsOptions,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningNEpochsEnumerationImpl extends FineTuningNEpochsEnumeration {
  const _$FineTuningNEpochsEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$FineTuningNEpochsEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningNEpochsEnumerationImplFromJson(json);

  @override
  final FineTuningNEpochsOptions value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningNEpochsEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningNEpochsEnumerationImplCopyWith<
          _$FineTuningNEpochsEnumerationImpl>
      get copyWith => __$$FineTuningNEpochsEnumerationImplCopyWithImpl<
          _$FineTuningNEpochsEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningNEpochsEnumerationImplToJson(
      this,
    );
  }
}

abstract class FineTuningNEpochsEnumeration extends FineTuningNEpochs {
  const factory FineTuningNEpochsEnumeration(
          final FineTuningNEpochsOptions value) =
      _$FineTuningNEpochsEnumerationImpl;
  const FineTuningNEpochsEnumeration._() : super._();

  factory FineTuningNEpochsEnumeration.fromJson(Map<String, dynamic> json) =
      _$FineTuningNEpochsEnumerationImpl.fromJson;

  @override
  FineTuningNEpochsOptions get value;
  @JsonKey(ignore: true)
  _$$FineTuningNEpochsEnumerationImplCopyWith<
          _$FineTuningNEpochsEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FineTuningNEpochsIntImplCopyWith<$Res> {
  factory _$$FineTuningNEpochsIntImplCopyWith(_$FineTuningNEpochsIntImpl value,
          $Res Function(_$FineTuningNEpochsIntImpl) then) =
      __$$FineTuningNEpochsIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$FineTuningNEpochsIntImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res, _$FineTuningNEpochsIntImpl>
    implements _$$FineTuningNEpochsIntImplCopyWith<$Res> {
  __$$FineTuningNEpochsIntImplCopyWithImpl(_$FineTuningNEpochsIntImpl _value,
      $Res Function(_$FineTuningNEpochsIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningNEpochsIntImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningNEpochsIntImpl extends FineTuningNEpochsInt {
  const _$FineTuningNEpochsIntImpl(this.value, {final String? $type})
      : $type = $type ?? 'number',
        super._();

  factory _$FineTuningNEpochsIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningNEpochsIntImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.number(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningNEpochsIntImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningNEpochsIntImplCopyWith<_$FineTuningNEpochsIntImpl>
      get copyWith =>
          __$$FineTuningNEpochsIntImplCopyWithImpl<_$FineTuningNEpochsIntImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) {
    return number(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) {
    return number?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) {
    return number(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) {
    return number?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningNEpochsIntImplToJson(
      this,
    );
  }
}

abstract class FineTuningNEpochsInt extends FineTuningNEpochs {
  const factory FineTuningNEpochsInt(final int value) =
      _$FineTuningNEpochsIntImpl;
  const FineTuningNEpochsInt._() : super._();

  factory FineTuningNEpochsInt.fromJson(Map<String, dynamic> json) =
      _$FineTuningNEpochsIntImpl.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$FineTuningNEpochsIntImplCopyWith<_$FineTuningNEpochsIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListPaginatedFineTuningJobsResponse
    _$ListPaginatedFineTuningJobsResponseFromJson(Map<String, dynamic> json) {
  return _ListPaginatedFineTuningJobsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListPaginatedFineTuningJobsResponse {
  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data => throw _privateConstructorUsedError;

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  ListPaginatedFineTuningJobsResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListPaginatedFineTuningJobsResponseCopyWith<
          ListPaginatedFineTuningJobsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory $ListPaginatedFineTuningJobsResponseCopyWith(
          ListPaginatedFineTuningJobsResponse value,
          $Res Function(ListPaginatedFineTuningJobsResponse) then) =
      _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
          ListPaginatedFineTuningJobsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        $Val extends ListPaginatedFineTuningJobsResponse>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  _$ListPaginatedFineTuningJobsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory _$$ListPaginatedFineTuningJobsResponseImplCopyWith(
          _$ListPaginatedFineTuningJobsResponseImpl value,
          $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) then) =
      __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>
    extends _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        _$ListPaginatedFineTuningJobsResponseImpl>
    implements _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res> {
  __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl(
      _$ListPaginatedFineTuningJobsResponseImpl _value,
      $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_$ListPaginatedFineTuningJobsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListPaginatedFineTuningJobsResponseImpl
    extends _ListPaginatedFineTuningJobsResponse {
  const _$ListPaginatedFineTuningJobsResponseImpl(
      {required final List<FineTuningJob> data,
      @JsonKey(name: 'has_more') required this.hasMore,
      required this.object})
      : _data = data,
        super._();

  factory _$ListPaginatedFineTuningJobsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListPaginatedFineTuningJobsResponseImplFromJson(json);

  /// The list of fine-tuning jobs.
  final List<FineTuningJob> _data;

  /// The list of fine-tuning jobs.
  @override
  List<FineTuningJob> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// Whether there are more fine-tuning jobs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// The object type, which is always "list".
  @override
  final ListPaginatedFineTuningJobsResponseObject object;

  @override
  String toString() {
    return 'ListPaginatedFineTuningJobsResponse(data: $data, hasMore: $hasMore, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListPaginatedFineTuningJobsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), hasMore, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<
          _$ListPaginatedFineTuningJobsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListPaginatedFineTuningJobsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListPaginatedFineTuningJobsResponse
    extends ListPaginatedFineTuningJobsResponse {
  const factory _ListPaginatedFineTuningJobsResponse(
          {required final List<FineTuningJob> data,
          @JsonKey(name: 'has_more') required final bool hasMore,
          required final ListPaginatedFineTuningJobsResponseObject object}) =
      _$ListPaginatedFineTuningJobsResponseImpl;
  const _ListPaginatedFineTuningJobsResponse._() : super._();

  factory _ListPaginatedFineTuningJobsResponse.fromJson(
          Map<String, dynamic> json) =
      _$ListPaginatedFineTuningJobsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data;
  @override

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override

  /// The object type, which is always "list".
  ListPaginatedFineTuningJobsResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListFineTuningJobEventsResponse _$ListFineTuningJobEventsResponseFromJson(
    Map<String, dynamic> json) {
  return _ListFineTuningJobEventsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListFineTuningJobEventsResponse {
  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  ListFineTuningJobEventsResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListFineTuningJobEventsResponseCopyWith<ListFineTuningJobEventsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory $ListFineTuningJobEventsResponseCopyWith(
          ListFineTuningJobEventsResponse value,
          $Res Function(ListFineTuningJobEventsResponse) then) =
      _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
          ListFineTuningJobEventsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        $Val extends ListFineTuningJobEventsResponse>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  _$ListFineTuningJobEventsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListFineTuningJobEventsResponseImplCopyWith<$Res>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory _$$ListFineTuningJobEventsResponseImplCopyWith(
          _$ListFineTuningJobEventsResponseImpl value,
          $Res Function(_$ListFineTuningJobEventsResponseImpl) then) =
      __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>
    extends _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        _$ListFineTuningJobEventsResponseImpl>
    implements _$$ListFineTuningJobEventsResponseImplCopyWith<$Res> {
  __$$ListFineTuningJobEventsResponseImplCopyWithImpl(
      _$ListFineTuningJobEventsResponseImpl _value,
      $Res Function(_$ListFineTuningJobEventsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_$ListFineTuningJobEventsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListFineTuningJobEventsResponseImpl
    extends _ListFineTuningJobEventsResponse {
  const _$ListFineTuningJobEventsResponseImpl(
      {required final List<FineTuningJobEvent> data, required this.object})
      : _data = data,
        super._();

  factory _$ListFineTuningJobEventsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListFineTuningJobEventsResponseImplFromJson(json);

  /// The list of fine-tuning job events.
  final List<FineTuningJobEvent> _data;

  /// The list of fine-tuning job events.
  @override
  List<FineTuningJobEvent> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The object type, which is always "list".
  @override
  final ListFineTuningJobEventsResponseObject object;

  @override
  String toString() {
    return 'ListFineTuningJobEventsResponse(data: $data, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListFineTuningJobEventsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => __$$ListFineTuningJobEventsResponseImplCopyWithImpl<
          _$ListFineTuningJobEventsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListFineTuningJobEventsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListFineTuningJobEventsResponse
    extends ListFineTuningJobEventsResponse {
  const factory _ListFineTuningJobEventsResponse(
          {required final List<FineTuningJobEvent> data,
          required final ListFineTuningJobEventsResponseObject object}) =
      _$ListFineTuningJobEventsResponseImpl;
  const _ListFineTuningJobEventsResponse._() : super._();

  factory _ListFineTuningJobEventsResponse.fromJson(Map<String, dynamic> json) =
      _$ListFineTuningJobEventsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data;
  @override

  /// The object type, which is always "list".
  ListFineTuningJobEventsResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJobEvent _$FineTuningJobEventFromJson(Map<String, dynamic> json) {
  return _FineTuningJobEvent.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobEvent {
  /// The event identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The log level of the event.
  FineTuningJobEventLevel get level => throw _privateConstructorUsedError;

  /// The message of the event.
  String get message => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job.event".
  FineTuningJobEventObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobEventCopyWith<FineTuningJobEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobEventCopyWith<$Res> {
  factory $FineTuningJobEventCopyWith(
          FineTuningJobEvent value, $Res Function(FineTuningJobEvent) then) =
      _$FineTuningJobEventCopyWithImpl<$Res, FineTuningJobEvent>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class _$FineTuningJobEventCopyWithImpl<$Res, $Val extends FineTuningJobEvent>
    implements $FineTuningJobEventCopyWith<$Res> {
  _$FineTuningJobEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobEventImplCopyWith<$Res>
    implements $FineTuningJobEventCopyWith<$Res> {
  factory _$$FineTuningJobEventImplCopyWith(_$FineTuningJobEventImpl value,
          $Res Function(_$FineTuningJobEventImpl) then) =
      __$$FineTuningJobEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class __$$FineTuningJobEventImplCopyWithImpl<$Res>
    extends _$FineTuningJobEventCopyWithImpl<$Res, _$FineTuningJobEventImpl>
    implements _$$FineTuningJobEventImplCopyWith<$Res> {
  __$$FineTuningJobEventImplCopyWithImpl(_$FineTuningJobEventImpl _value,
      $Res Function(_$FineTuningJobEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_$FineTuningJobEventImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobEventImpl extends _FineTuningJobEvent {
  const _$FineTuningJobEventImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.level,
      required this.message,
      required this.object})
      : super._();

  factory _$FineTuningJobEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobEventImplFromJson(json);

  /// The event identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the event was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The log level of the event.
  @override
  final FineTuningJobEventLevel level;

  /// The message of the event.
  @override
  final String message;

  /// The object type, which is always "fine_tuning.job.event".
  @override
  final FineTuningJobEventObject object;

  @override
  String toString() {
    return 'FineTuningJobEvent(id: $id, createdAt: $createdAt, level: $level, message: $message, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobEventImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, createdAt, level, message, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      __$$FineTuningJobEventImplCopyWithImpl<_$FineTuningJobEventImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobEventImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobEvent extends FineTuningJobEvent {
  const factory _FineTuningJobEvent(
          {required final String id,
          @JsonKey(name: 'created_at') required final int createdAt,
          required final FineTuningJobEventLevel level,
          required final String message,
          required final FineTuningJobEventObject object}) =
      _$FineTuningJobEventImpl;
  const _FineTuningJobEvent._() : super._();

  factory _FineTuningJobEvent.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobEventImpl.fromJson;

  @override

  /// The event identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The log level of the event.
  FineTuningJobEventLevel get level;
  @override

  /// The message of the event.
  String get message;
  @override

  /// The object type, which is always "fine_tuning.job.event".
  FineTuningJobEventObject get object;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateImageRequest _$CreateImageRequestFromJson(Map<String, dynamic> json) {
  return _CreateImageRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateImageRequest {
  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  String get prompt => throw _privateConstructorUsedError;

  /// The model to use for image generation.
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateImageRequestModel? get model => throw _privateConstructorUsedError;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  ImageQuality get quality => throw _privateConstructorUsedError;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat => throw _privateConstructorUsedError;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size => throw _privateConstructorUsedError;

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageStyle? get style => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateImageRequestCopyWith<CreateImageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateImageRequestCopyWith<$Res> {
  factory $CreateImageRequestCopyWith(
          CreateImageRequest value, $Res Function(CreateImageRequest) then) =
      _$CreateImageRequestCopyWithImpl<$Res, CreateImageRequest>;
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      ImageQuality quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class _$CreateImageRequestCopyWithImpl<$Res, $Val extends CreateImageRequest>
    implements $CreateImageRequestCopyWith<$Res> {
  _$CreateImageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = null,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateImageRequestModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $CreateImageRequestModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateImageRequestImplCopyWith<$Res>
    implements $CreateImageRequestCopyWith<$Res> {
  factory _$$CreateImageRequestImplCopyWith(_$CreateImageRequestImpl value,
          $Res Function(_$CreateImageRequestImpl) then) =
      __$$CreateImageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      ImageQuality quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class __$$CreateImageRequestImplCopyWithImpl<$Res>
    extends _$CreateImageRequestCopyWithImpl<$Res, _$CreateImageRequestImpl>
    implements _$$CreateImageRequestImplCopyWith<$Res> {
  __$$CreateImageRequestImplCopyWithImpl(_$CreateImageRequestImpl _value,
      $Res Function(_$CreateImageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = null,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateImageRequestImpl(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestImpl extends _CreateImageRequest {
  const _$CreateImageRequestImpl(
      {required this.prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const CreateImageRequestModelString('dall-e-2'),
      @JsonKey(includeIfNull: false) this.n = 1,
      this.quality = ImageQuality.standard,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.responseFormat = ImageResponseFormat.url,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.size = ImageSize.v1024x1024,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.style = ImageStyle.vivid,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateImageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateImageRequestImplFromJson(json);

  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  @override
  final String prompt;

  /// The model to use for image generation.
  @override
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  final CreateImageRequestModel? model;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  @override
  @JsonKey()
  final ImageQuality quality;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @override
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageResponseFormat? responseFormat;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageSize? size;

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageStyle? style;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateImageRequest(prompt: $prompt, model: $model, n: $n, quality: $quality, responseFormat: $responseFormat, size: $size, style: $style, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestImpl &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, prompt, model, n, quality,
      responseFormat, size, style, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      __$$CreateImageRequestImplCopyWithImpl<_$CreateImageRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateImageRequest extends CreateImageRequest {
  const factory _CreateImageRequest(
          {required final String prompt,
          @_CreateImageRequestModelConverter()
          @JsonKey(includeIfNull: false)
          final CreateImageRequestModel? model,
          @JsonKey(includeIfNull: false) final int? n,
          final ImageQuality quality,
          @JsonKey(
              name: 'response_format',
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageResponseFormat? responseFormat,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageSize? size,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageStyle? style,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateImageRequestImpl;
  const _CreateImageRequest._() : super._();

  factory _CreateImageRequest.fromJson(Map<String, dynamic> json) =
      _$CreateImageRequestImpl.fromJson;

  @override

  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  String get prompt;
  @override

  /// The model to use for image generation.
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateImageRequestModel? get model;
  @override

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  ImageQuality get quality;
  @override

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat;
  @override

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size;
  @override

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageStyle? get style;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateImageRequestModel _$CreateImageRequestModelFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CreateImageRequestModelEnumeration.fromJson(json);
    case 'modelId':
      return CreateImageRequestModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateImageRequestModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateImageRequestModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateImageRequestModelCopyWith<$Res> {
  factory $CreateImageRequestModelCopyWith(CreateImageRequestModel value,
          $Res Function(CreateImageRequestModel) then) =
      _$CreateImageRequestModelCopyWithImpl<$Res, CreateImageRequestModel>;
}

/// @nodoc
class _$CreateImageRequestModelCopyWithImpl<$Res,
        $Val extends CreateImageRequestModel>
    implements $CreateImageRequestModelCopyWith<$Res> {
  _$CreateImageRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateImageRequestModelEnumerationImplCopyWith<$Res> {
  factory _$$CreateImageRequestModelEnumerationImplCopyWith(
          _$CreateImageRequestModelEnumerationImpl value,
          $Res Function(_$CreateImageRequestModelEnumerationImpl) then) =
      __$$CreateImageRequestModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ImageModels value});
}

/// @nodoc
class __$$CreateImageRequestModelEnumerationImplCopyWithImpl<$Res>
    extends _$CreateImageRequestModelCopyWithImpl<$Res,
        _$CreateImageRequestModelEnumerationImpl>
    implements _$$CreateImageRequestModelEnumerationImplCopyWith<$Res> {
  __$$CreateImageRequestModelEnumerationImplCopyWithImpl(
      _$CreateImageRequestModelEnumerationImpl _value,
      $Res Function(_$CreateImageRequestModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateImageRequestModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ImageModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestModelEnumerationImpl
    extends CreateImageRequestModelEnumeration {
  const _$CreateImageRequestModelEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$CreateImageRequestModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateImageRequestModelEnumerationImplFromJson(json);

  @override
  final ImageModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateImageRequestModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestModelEnumerationImplCopyWith<
          _$CreateImageRequestModelEnumerationImpl>
      get copyWith => __$$CreateImageRequestModelEnumerationImplCopyWithImpl<
          _$CreateImageRequestModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateImageRequestModelEnumeration
    extends CreateImageRequestModel {
  const factory CreateImageRequestModelEnumeration(final ImageModels value) =
      _$CreateImageRequestModelEnumerationImpl;
  const CreateImageRequestModelEnumeration._() : super._();

  factory CreateImageRequestModelEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateImageRequestModelEnumerationImpl.fromJson;

  @override
  ImageModels get value;
  @JsonKey(ignore: true)
  _$$CreateImageRequestModelEnumerationImplCopyWith<
          _$CreateImageRequestModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateImageRequestModelStringImplCopyWith<$Res> {
  factory _$$CreateImageRequestModelStringImplCopyWith(
          _$CreateImageRequestModelStringImpl value,
          $Res Function(_$CreateImageRequestModelStringImpl) then) =
      __$$CreateImageRequestModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CreateImageRequestModelStringImplCopyWithImpl<$Res>
    extends _$CreateImageRequestModelCopyWithImpl<$Res,
        _$CreateImageRequestModelStringImpl>
    implements _$$CreateImageRequestModelStringImplCopyWith<$Res> {
  __$$CreateImageRequestModelStringImplCopyWithImpl(
      _$CreateImageRequestModelStringImpl _value,
      $Res Function(_$CreateImageRequestModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateImageRequestModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestModelStringImpl
    extends CreateImageRequestModelString {
  const _$CreateImageRequestModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$CreateImageRequestModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateImageRequestModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateImageRequestModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestModelStringImplCopyWith<
          _$CreateImageRequestModelStringImpl>
      get copyWith => __$$CreateImageRequestModelStringImplCopyWithImpl<
          _$CreateImageRequestModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestModelStringImplToJson(
      this,
    );
  }
}

abstract class CreateImageRequestModelString extends CreateImageRequestModel {
  const factory CreateImageRequestModelString(final String value) =
      _$CreateImageRequestModelStringImpl;
  const CreateImageRequestModelString._() : super._();

  factory CreateImageRequestModelString.fromJson(Map<String, dynamic> json) =
      _$CreateImageRequestModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CreateImageRequestModelStringImplCopyWith<
          _$CreateImageRequestModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ImagesResponse _$ImagesResponseFromJson(Map<String, dynamic> json) {
  return _ImagesResponse.fromJson(json);
}

/// @nodoc
mixin _$ImagesResponse {
  /// The Unix timestamp (in seconds) when the image was created.
  int get created => throw _privateConstructorUsedError;

  /// The list of images generated by the model.
  List<Image> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImagesResponseCopyWith<ImagesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImagesResponseCopyWith<$Res> {
  factory $ImagesResponseCopyWith(
          ImagesResponse value, $Res Function(ImagesResponse) then) =
      _$ImagesResponseCopyWithImpl<$Res, ImagesResponse>;
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class _$ImagesResponseCopyWithImpl<$Res, $Val extends ImagesResponse>
    implements $ImagesResponseCopyWith<$Res> {
  _$ImagesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImagesResponseImplCopyWith<$Res>
    implements $ImagesResponseCopyWith<$Res> {
  factory _$$ImagesResponseImplCopyWith(_$ImagesResponseImpl value,
          $Res Function(_$ImagesResponseImpl) then) =
      __$$ImagesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class __$$ImagesResponseImplCopyWithImpl<$Res>
    extends _$ImagesResponseCopyWithImpl<$Res, _$ImagesResponseImpl>
    implements _$$ImagesResponseImplCopyWith<$Res> {
  __$$ImagesResponseImplCopyWithImpl(
      _$ImagesResponseImpl _value, $Res Function(_$ImagesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_$ImagesResponseImpl(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImagesResponseImpl extends _ImagesResponse {
  const _$ImagesResponseImpl(
      {required this.created, required final List<Image> data})
      : _data = data,
        super._();

  factory _$ImagesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImagesResponseImplFromJson(json);

  /// The Unix timestamp (in seconds) when the image was created.
  @override
  final int created;

  /// The list of images generated by the model.
  final List<Image> _data;

  /// The list of images generated by the model.
  @override
  List<Image> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ImagesResponse(created: $created, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImagesResponseImpl &&
            (identical(other.created, created) || other.created == created) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, created, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      __$$ImagesResponseImplCopyWithImpl<_$ImagesResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImagesResponseImplToJson(
      this,
    );
  }
}

abstract class _ImagesResponse extends ImagesResponse {
  const factory _ImagesResponse(
      {required final int created,
      required final List<Image> data}) = _$ImagesResponseImpl;
  const _ImagesResponse._() : super._();

  factory _ImagesResponse.fromJson(Map<String, dynamic> json) =
      _$ImagesResponseImpl.fromJson;

  @override

  /// The Unix timestamp (in seconds) when the image was created.
  int get created;
  @override

  /// The list of images generated by the model.
  List<Image> get data;
  @override
  @JsonKey(ignore: true)
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Image _$ImageFromJson(Map<String, dynamic> json) {
  return _Image.fromJson(json);
}

/// @nodoc
mixin _$Image {
  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json => throw _privateConstructorUsedError;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url => throw _privateConstructorUsedError;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  String? get revisedPrompt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageCopyWith<Image> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageCopyWith<$Res> {
  factory $ImageCopyWith(Image value, $Res Function(Image) then) =
      _$ImageCopyWithImpl<$Res, Image>;
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class _$ImageCopyWithImpl<$Res, $Val extends Image>
    implements $ImageCopyWith<$Res> {
  _$ImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_value.copyWith(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _value.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageImplCopyWith<$Res> implements $ImageCopyWith<$Res> {
  factory _$$ImageImplCopyWith(
          _$ImageImpl value, $Res Function(_$ImageImpl) then) =
      __$$ImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class __$$ImageImplCopyWithImpl<$Res>
    extends _$ImageCopyWithImpl<$Res, _$ImageImpl>
    implements _$$ImageImplCopyWith<$Res> {
  __$$ImageImplCopyWithImpl(
      _$ImageImpl _value, $Res Function(_$ImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_$ImageImpl(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _value.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageImpl extends _Image {
  const _$ImageImpl(
      {@JsonKey(name: 'b64_json', includeIfNull: false) this.b64Json,
      @JsonKey(includeIfNull: false) this.url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      this.revisedPrompt})
      : super._();

  factory _$ImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImageImplFromJson(json);

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @override
  @JsonKey(name: 'b64_json', includeIfNull: false)
  final String? b64Json;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @override
  @JsonKey(includeIfNull: false)
  final String? url;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @override
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  final String? revisedPrompt;

  @override
  String toString() {
    return 'Image(b64Json: $b64Json, url: $url, revisedPrompt: $revisedPrompt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageImpl &&
            (identical(other.b64Json, b64Json) || other.b64Json == b64Json) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.revisedPrompt, revisedPrompt) ||
                other.revisedPrompt == revisedPrompt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, b64Json, url, revisedPrompt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      __$$ImageImplCopyWithImpl<_$ImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageImplToJson(
      this,
    );
  }
}

abstract class _Image extends Image {
  const factory _Image(
      {@JsonKey(name: 'b64_json', includeIfNull: false) final String? b64Json,
      @JsonKey(includeIfNull: false) final String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      final String? revisedPrompt}) = _$ImageImpl;
  const _Image._() : super._();

  factory _Image.fromJson(Map<String, dynamic> json) = _$ImageImpl.fromJson;

  @override

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json;
  @override

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url;
  @override

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  String? get revisedPrompt;
  @override
  @JsonKey(ignore: true)
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Model _$ModelFromJson(Map<String, dynamic> json) {
  return _Model.fromJson(json);
}

/// @nodoc
mixin _$Model {
  /// The model identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) when the model was created.
  int get created => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  ModelObject get object => throw _privateConstructorUsedError;

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModelCopyWith<Model> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) then) =
      _$ModelCopyWithImpl<$Res, Model>;
  @useResult
  $Res call(
      {String id,
      int created,
      ModelObject object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class _$ModelCopyWithImpl<$Res, $Val extends Model>
    implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModelImplCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$$ModelImplCopyWith(
          _$ModelImpl value, $Res Function(_$ModelImpl) then) =
      __$$ModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      int created,
      ModelObject object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class __$$ModelImplCopyWithImpl<$Res>
    extends _$ModelCopyWithImpl<$Res, _$ModelImpl>
    implements _$$ModelImplCopyWith<$Res> {
  __$$ModelImplCopyWithImpl(
      _$ModelImpl _value, $Res Function(_$ModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_$ModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModelImpl extends _Model {
  const _$ModelImpl(
      {required this.id,
      required this.created,
      required this.object,
      @JsonKey(name: 'owned_by') required this.ownedBy})
      : super._();

  factory _$ModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModelImplFromJson(json);

  /// The model identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) when the model was created.
  @override
  final int created;

  /// The object type, which is always "model".
  @override
  final ModelObject object;

  /// The organization that owns the model.
  @override
  @JsonKey(name: 'owned_by')
  final String ownedBy;

  @override
  String toString() {
    return 'Model(id: $id, created: $created, object: $object, ownedBy: $ownedBy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.ownedBy, ownedBy) || other.ownedBy == ownedBy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, created, object, ownedBy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      __$$ModelImplCopyWithImpl<_$ModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModelImplToJson(
      this,
    );
  }
}

abstract class _Model extends Model {
  const factory _Model(
      {required final String id,
      required final int created,
      required final ModelObject object,
      @JsonKey(name: 'owned_by') required final String ownedBy}) = _$ModelImpl;
  const _Model._() : super._();

  factory _Model.fromJson(Map<String, dynamic> json) = _$ModelImpl.fromJson;

  @override

  /// The model identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) when the model was created.
  int get created;
  @override

  /// The object type, which is always "model".
  ModelObject get object;
  @override

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy;
  @override
  @JsonKey(ignore: true)
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListModelsResponse _$ListModelsResponseFromJson(Map<String, dynamic> json) {
  return _ListModelsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListModelsResponse {
  /// The object type, which is always "list".
  ListModelsResponseObject get object => throw _privateConstructorUsedError;

  /// The list of models.
  List<Model> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListModelsResponseCopyWith<ListModelsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListModelsResponseCopyWith<$Res> {
  factory $ListModelsResponseCopyWith(
          ListModelsResponse value, $Res Function(ListModelsResponse) then) =
      _$ListModelsResponseCopyWithImpl<$Res, ListModelsResponse>;
  @useResult
  $Res call({ListModelsResponseObject object, List<Model> data});
}

/// @nodoc
class _$ListModelsResponseCopyWithImpl<$Res, $Val extends ListModelsResponse>
    implements $ListModelsResponseCopyWith<$Res> {
  _$ListModelsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListModelsResponseImplCopyWith<$Res>
    implements $ListModelsResponseCopyWith<$Res> {
  factory _$$ListModelsResponseImplCopyWith(_$ListModelsResponseImpl value,
          $Res Function(_$ListModelsResponseImpl) then) =
      __$$ListModelsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ListModelsResponseObject object, List<Model> data});
}

/// @nodoc
class __$$ListModelsResponseImplCopyWithImpl<$Res>
    extends _$ListModelsResponseCopyWithImpl<$Res, _$ListModelsResponseImpl>
    implements _$$ListModelsResponseImplCopyWith<$Res> {
  __$$ListModelsResponseImplCopyWithImpl(_$ListModelsResponseImpl _value,
      $Res Function(_$ListModelsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_$ListModelsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListModelsResponseImpl extends _ListModelsResponse {
  const _$ListModelsResponseImpl(
      {required this.object, required final List<Model> data})
      : _data = data,
        super._();

  factory _$ListModelsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListModelsResponseImplFromJson(json);

  /// The object type, which is always "list".
  @override
  final ListModelsResponseObject object;

  /// The list of models.
  final List<Model> _data;

  /// The list of models.
  @override
  List<Model> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ListModelsResponse(object: $object, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListModelsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      __$$ListModelsResponseImplCopyWithImpl<_$ListModelsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListModelsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListModelsResponse extends ListModelsResponse {
  const factory _ListModelsResponse(
      {required final ListModelsResponseObject object,
      required final List<Model> data}) = _$ListModelsResponseImpl;
  const _ListModelsResponse._() : super._();

  factory _ListModelsResponse.fromJson(Map<String, dynamic> json) =
      _$ListModelsResponseImpl.fromJson;

  @override

  /// The object type, which is always "list".
  ListModelsResponseObject get object;
  @override

  /// The list of models.
  List<Model> get data;
  @override
  @JsonKey(ignore: true)
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeleteModelResponse _$DeleteModelResponseFromJson(Map<String, dynamic> json) {
  return _DeleteModelResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteModelResponse {
  /// The model identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the model was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteModelResponseCopyWith<DeleteModelResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteModelResponseCopyWith<$Res> {
  factory $DeleteModelResponseCopyWith(
          DeleteModelResponse value, $Res Function(DeleteModelResponse) then) =
      _$DeleteModelResponseCopyWithImpl<$Res, DeleteModelResponse>;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteModelResponseCopyWithImpl<$Res, $Val extends DeleteModelResponse>
    implements $DeleteModelResponseCopyWith<$Res> {
  _$DeleteModelResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteModelResponseImplCopyWith<$Res>
    implements $DeleteModelResponseCopyWith<$Res> {
  factory _$$DeleteModelResponseImplCopyWith(_$DeleteModelResponseImpl value,
          $Res Function(_$DeleteModelResponseImpl) then) =
      __$$DeleteModelResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$$DeleteModelResponseImplCopyWithImpl<$Res>
    extends _$DeleteModelResponseCopyWithImpl<$Res, _$DeleteModelResponseImpl>
    implements _$$DeleteModelResponseImplCopyWith<$Res> {
  __$$DeleteModelResponseImplCopyWithImpl(_$DeleteModelResponseImpl _value,
      $Res Function(_$DeleteModelResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteModelResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteModelResponseImpl extends _DeleteModelResponse {
  const _$DeleteModelResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteModelResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteModelResponseImplFromJson(json);

  /// The model identifier.
  @override
  final String id;

  /// Whether the model was deleted.
  @override
  final bool deleted;

  /// The object type, which is always "model".
  @override
  final String object;

  @override
  String toString() {
    return 'DeleteModelResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteModelResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      __$$DeleteModelResponseImplCopyWithImpl<_$DeleteModelResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteModelResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteModelResponse extends DeleteModelResponse {
  const factory _DeleteModelResponse(
      {required final String id,
      required final bool deleted,
      required final String object}) = _$DeleteModelResponseImpl;
  const _DeleteModelResponse._() : super._();

  factory _DeleteModelResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteModelResponseImpl.fromJson;

  @override

  /// The model identifier.
  String get id;
  @override

  /// Whether the model was deleted.
  bool get deleted;
  @override

  /// The object type, which is always "model".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateModerationRequest _$CreateModerationRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationRequest {
  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model => throw _privateConstructorUsedError;

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationRequestCopyWith<CreateModerationRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationRequestCopyWith<$Res> {
  factory $CreateModerationRequestCopyWith(CreateModerationRequest value,
          $Res Function(CreateModerationRequest) then) =
      _$CreateModerationRequestCopyWithImpl<$Res, CreateModerationRequest>;
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  $ModerationModelCopyWith<$Res>? get model;
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateModerationRequestCopyWithImpl<$Res,
        $Val extends CreateModerationRequest>
    implements $CreateModerationRequestCopyWith<$Res> {
  _$CreateModerationRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_value.copyWith(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $ModerationModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationInputCopyWith<$Res> get input {
    return $ModerationInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateModerationRequestImplCopyWith<$Res>
    implements $CreateModerationRequestCopyWith<$Res> {
  factory _$$CreateModerationRequestImplCopyWith(
          _$CreateModerationRequestImpl value,
          $Res Function(_$CreateModerationRequestImpl) then) =
      __$$CreateModerationRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  @override
  $ModerationModelCopyWith<$Res>? get model;
  @override
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateModerationRequestImplCopyWithImpl<$Res>
    extends _$CreateModerationRequestCopyWithImpl<$Res,
        _$CreateModerationRequestImpl>
    implements _$$CreateModerationRequestImplCopyWith<$Res> {
  __$$CreateModerationRequestImplCopyWithImpl(
      _$CreateModerationRequestImpl _value,
      $Res Function(_$CreateModerationRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_$CreateModerationRequestImpl(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationRequestImpl extends _CreateModerationRequest {
  const _$CreateModerationRequestImpl(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const ModerationModelString('text-moderation-latest'),
      @_ModerationInputConverter() required this.input})
      : super._();

  factory _$CreateModerationRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationRequestImplFromJson(json);

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @override
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  final ModerationModel? model;

  /// The input text to classify
  @override
  @_ModerationInputConverter()
  final ModerationInput input;

  @override
  String toString() {
    return 'CreateModerationRequest(model: $model, input: $input)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, model, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => __$$CreateModerationRequestImplCopyWithImpl<
          _$CreateModerationRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationRequest extends CreateModerationRequest {
  const factory _CreateModerationRequest(
          {@_ModerationModelConverter()
          @JsonKey(includeIfNull: false)
          final ModerationModel? model,
          @_ModerationInputConverter() required final ModerationInput input}) =
      _$CreateModerationRequestImpl;
  const _CreateModerationRequest._() : super._();

  factory _CreateModerationRequest.fromJson(Map<String, dynamic> json) =
      _$CreateModerationRequestImpl.fromJson;

  @override

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model;
  @override

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationModel _$ModerationModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ModerationModelEnumeration.fromJson(json);
    case 'modelId':
      return ModerationModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationModelCopyWith<$Res> {
  factory $ModerationModelCopyWith(
          ModerationModel value, $Res Function(ModerationModel) then) =
      _$ModerationModelCopyWithImpl<$Res, ModerationModel>;
}

/// @nodoc
class _$ModerationModelCopyWithImpl<$Res, $Val extends ModerationModel>
    implements $ModerationModelCopyWith<$Res> {
  _$ModerationModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ModerationModelEnumerationImplCopyWith<$Res> {
  factory _$$ModerationModelEnumerationImplCopyWith(
          _$ModerationModelEnumerationImpl value,
          $Res Function(_$ModerationModelEnumerationImpl) then) =
      __$$ModerationModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ModerationModels value});
}

/// @nodoc
class __$$ModerationModelEnumerationImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res,
        _$ModerationModelEnumerationImpl>
    implements _$$ModerationModelEnumerationImplCopyWith<$Res> {
  __$$ModerationModelEnumerationImplCopyWithImpl(
      _$ModerationModelEnumerationImpl _value,
      $Res Function(_$ModerationModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ModerationModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationModelEnumerationImpl extends ModerationModelEnumeration {
  const _$ModerationModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$ModerationModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModerationModelEnumerationImplFromJson(json);

  @override
  final ModerationModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationModelEnumerationImplCopyWith<_$ModerationModelEnumerationImpl>
      get copyWith => __$$ModerationModelEnumerationImplCopyWithImpl<
          _$ModerationModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class ModerationModelEnumeration extends ModerationModel {
  const factory ModerationModelEnumeration(final ModerationModels value) =
      _$ModerationModelEnumerationImpl;
  const ModerationModelEnumeration._() : super._();

  factory ModerationModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$ModerationModelEnumerationImpl.fromJson;

  @override
  ModerationModels get value;
  @JsonKey(ignore: true)
  _$$ModerationModelEnumerationImplCopyWith<_$ModerationModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModerationModelStringImplCopyWith<$Res> {
  factory _$$ModerationModelStringImplCopyWith(
          _$ModerationModelStringImpl value,
          $Res Function(_$ModerationModelStringImpl) then) =
      __$$ModerationModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ModerationModelStringImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res, _$ModerationModelStringImpl>
    implements _$$ModerationModelStringImplCopyWith<$Res> {
  __$$ModerationModelStringImplCopyWithImpl(_$ModerationModelStringImpl _value,
      $Res Function(_$ModerationModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationModelStringImpl extends ModerationModelString {
  const _$ModerationModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$ModerationModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationModelStringImplCopyWith<_$ModerationModelStringImpl>
      get copyWith => __$$ModerationModelStringImplCopyWithImpl<
          _$ModerationModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationModelStringImplToJson(
      this,
    );
  }
}

abstract class ModerationModelString extends ModerationModel {
  const factory ModerationModelString(final String value) =
      _$ModerationModelStringImpl;
  const ModerationModelString._() : super._();

  factory ModerationModelString.fromJson(Map<String, dynamic> json) =
      _$ModerationModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ModerationModelStringImplCopyWith<_$ModerationModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationInput _$ModerationInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return ModerationInputListString.fromJson(json);
    case 'string':
      return ModerationInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationInputCopyWith<$Res> {
  factory $ModerationInputCopyWith(
          ModerationInput value, $Res Function(ModerationInput) then) =
      _$ModerationInputCopyWithImpl<$Res, ModerationInput>;
}

/// @nodoc
class _$ModerationInputCopyWithImpl<$Res, $Val extends ModerationInput>
    implements $ModerationInputCopyWith<$Res> {
  _$ModerationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ModerationInputListStringImplCopyWith<$Res> {
  factory _$$ModerationInputListStringImplCopyWith(
          _$ModerationInputListStringImpl value,
          $Res Function(_$ModerationInputListStringImpl) then) =
      __$$ModerationInputListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$ModerationInputListStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res, _$ModerationInputListStringImpl>
    implements _$$ModerationInputListStringImplCopyWith<$Res> {
  __$$ModerationInputListStringImplCopyWithImpl(
      _$ModerationInputListStringImpl _value,
      $Res Function(_$ModerationInputListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationInputListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationInputListStringImpl extends ModerationInputListString {
  const _$ModerationInputListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$ModerationInputListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationInputListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationInputListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationInputListStringImplCopyWith<_$ModerationInputListStringImpl>
      get copyWith => __$$ModerationInputListStringImplCopyWithImpl<
          _$ModerationInputListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationInputListStringImplToJson(
      this,
    );
  }
}

abstract class ModerationInputListString extends ModerationInput {
  const factory ModerationInputListString(final List<String> value) =
      _$ModerationInputListStringImpl;
  const ModerationInputListString._() : super._();

  factory ModerationInputListString.fromJson(Map<String, dynamic> json) =
      _$ModerationInputListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$ModerationInputListStringImplCopyWith<_$ModerationInputListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModerationInputStringImplCopyWith<$Res> {
  factory _$$ModerationInputStringImplCopyWith(
          _$ModerationInputStringImpl value,
          $Res Function(_$ModerationInputStringImpl) then) =
      __$$ModerationInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ModerationInputStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res, _$ModerationInputStringImpl>
    implements _$$ModerationInputStringImplCopyWith<$Res> {
  __$$ModerationInputStringImplCopyWithImpl(_$ModerationInputStringImpl _value,
      $Res Function(_$ModerationInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationInputStringImpl extends ModerationInputString {
  const _$ModerationInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ModerationInputStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationInputStringImplCopyWith<_$ModerationInputStringImpl>
      get copyWith => __$$ModerationInputStringImplCopyWithImpl<
          _$ModerationInputStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationInputStringImplToJson(
      this,
    );
  }
}

abstract class ModerationInputString extends ModerationInput {
  const factory ModerationInputString(final String value) =
      _$ModerationInputStringImpl;
  const ModerationInputString._() : super._();

  factory ModerationInputString.fromJson(Map<String, dynamic> json) =
      _$ModerationInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ModerationInputStringImplCopyWith<_$ModerationInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateModerationResponse _$CreateModerationResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationResponse {
  /// The unique identifier for the moderation request.
  String get id => throw _privateConstructorUsedError;

  /// The model used to generate the moderation results.
  String get model => throw _privateConstructorUsedError;

  /// A list of moderation objects.
  List<Moderation> get results => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationResponseCopyWith<CreateModerationResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationResponseCopyWith<$Res> {
  factory $CreateModerationResponseCopyWith(CreateModerationResponse value,
          $Res Function(CreateModerationResponse) then) =
      _$CreateModerationResponseCopyWithImpl<$Res, CreateModerationResponse>;
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class _$CreateModerationResponseCopyWithImpl<$Res,
        $Val extends CreateModerationResponse>
    implements $CreateModerationResponseCopyWith<$Res> {
  _$CreateModerationResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateModerationResponseImplCopyWith<$Res>
    implements $CreateModerationResponseCopyWith<$Res> {
  factory _$$CreateModerationResponseImplCopyWith(
          _$CreateModerationResponseImpl value,
          $Res Function(_$CreateModerationResponseImpl) then) =
      __$$CreateModerationResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class __$$CreateModerationResponseImplCopyWithImpl<$Res>
    extends _$CreateModerationResponseCopyWithImpl<$Res,
        _$CreateModerationResponseImpl>
    implements _$$CreateModerationResponseImplCopyWith<$Res> {
  __$$CreateModerationResponseImplCopyWithImpl(
      _$CreateModerationResponseImpl _value,
      $Res Function(_$CreateModerationResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_$CreateModerationResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationResponseImpl extends _CreateModerationResponse {
  const _$CreateModerationResponseImpl(
      {required this.id,
      required this.model,
      required final List<Moderation> results})
      : _results = results,
        super._();

  factory _$CreateModerationResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationResponseImplFromJson(json);

  /// The unique identifier for the moderation request.
  @override
  final String id;

  /// The model used to generate the moderation results.
  @override
  final String model;

  /// A list of moderation objects.
  final List<Moderation> _results;

  /// A list of moderation objects.
  @override
  List<Moderation> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  @override
  String toString() {
    return 'CreateModerationResponse(id: $id, model: $model, results: $results)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._results, _results));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, model, const DeepCollectionEquality().hash(_results));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => __$$CreateModerationResponseImplCopyWithImpl<
          _$CreateModerationResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationResponse extends CreateModerationResponse {
  const factory _CreateModerationResponse(
          {required final String id,
          required final String model,
          required final List<Moderation> results}) =
      _$CreateModerationResponseImpl;
  const _CreateModerationResponse._() : super._();

  factory _CreateModerationResponse.fromJson(Map<String, dynamic> json) =
      _$CreateModerationResponseImpl.fromJson;

  @override

  /// The unique identifier for the moderation request.
  String get id;
  @override

  /// The model used to generate the moderation results.
  String get model;
  @override

  /// A list of moderation objects.
  List<Moderation> get results;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Moderation _$ModerationFromJson(Map<String, dynamic> json) {
  return _Moderation.fromJson(json);
}

/// @nodoc
mixin _$Moderation {
  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  bool get flagged => throw _privateConstructorUsedError;

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories => throw _privateConstructorUsedError;

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCopyWith<Moderation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCopyWith<$Res> {
  factory $ModerationCopyWith(
          Moderation value, $Res Function(Moderation) then) =
      _$ModerationCopyWithImpl<$Res, Moderation>;
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  $ModerationCategoriesCopyWith<$Res> get categories;
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class _$ModerationCopyWithImpl<$Res, $Val extends Moderation>
    implements $ModerationCopyWith<$Res> {
  _$ModerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_value.copyWith(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesCopyWith<$Res> get categories {
    return $ModerationCategoriesCopyWith<$Res>(_value.categories, (value) {
      return _then(_value.copyWith(categories: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores {
    return $ModerationCategoriesScoresCopyWith<$Res>(_value.categoryScores,
        (value) {
      return _then(_value.copyWith(categoryScores: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModerationImplCopyWith<$Res>
    implements $ModerationCopyWith<$Res> {
  factory _$$ModerationImplCopyWith(
          _$ModerationImpl value, $Res Function(_$ModerationImpl) then) =
      __$$ModerationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  @override
  $ModerationCategoriesCopyWith<$Res> get categories;
  @override
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class __$$ModerationImplCopyWithImpl<$Res>
    extends _$ModerationCopyWithImpl<$Res, _$ModerationImpl>
    implements _$$ModerationImplCopyWith<$Res> {
  __$$ModerationImplCopyWithImpl(
      _$ModerationImpl _value, $Res Function(_$ModerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_$ModerationImpl(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationImpl extends _Moderation {
  const _$ModerationImpl(
      {required this.flagged,
      required this.categories,
      @JsonKey(name: 'category_scores') required this.categoryScores})
      : super._();

  factory _$ModerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationImplFromJson(json);

  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  @override
  final bool flagged;

  /// A list of the categories, and whether they are flagged or not.
  @override
  final ModerationCategories categories;

  /// A list of the categories along with their scores as predicted by model.
  @override
  @JsonKey(name: 'category_scores')
  final ModerationCategoriesScores categoryScores;

  @override
  String toString() {
    return 'Moderation(flagged: $flagged, categories: $categories, categoryScores: $categoryScores)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationImpl &&
            (identical(other.flagged, flagged) || other.flagged == flagged) &&
            (identical(other.categories, categories) ||
                other.categories == categories) &&
            (identical(other.categoryScores, categoryScores) ||
                other.categoryScores == categoryScores));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, flagged, categories, categoryScores);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      __$$ModerationImplCopyWithImpl<_$ModerationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationImplToJson(
      this,
    );
  }
}

abstract class _Moderation extends Moderation {
  const factory _Moderation(
          {required final bool flagged,
          required final ModerationCategories categories,
          @JsonKey(name: 'category_scores')
          required final ModerationCategoriesScores categoryScores}) =
      _$ModerationImpl;
  const _Moderation._() : super._();

  factory _Moderation.fromJson(Map<String, dynamic> json) =
      _$ModerationImpl.fromJson;

  @override

  /// Whether the content violates [OpenAI's usage policies](https://platform.openai.com/policies/usage-policies).
  bool get flagged;
  @override

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories;
  @override

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores;
  @override
  @JsonKey(ignore: true)
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModerationCategories _$ModerationCategoriesFromJson(Map<String, dynamic> json) {
  return _ModerationCategories.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategories {
  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  bool get hate => throw _privateConstructorUsedError;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening => throw _privateConstructorUsedError;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment => throw _privateConstructorUsedError;

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening => throw _privateConstructorUsedError;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm => throw _privateConstructorUsedError;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent => throw _privateConstructorUsedError;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions => throw _privateConstructorUsedError;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual => throw _privateConstructorUsedError;

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury.
  bool get violence => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesCopyWith<ModerationCategories> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesCopyWith<$Res> {
  factory $ModerationCategoriesCopyWith(ModerationCategories value,
          $Res Function(ModerationCategories) then) =
      _$ModerationCategoriesCopyWithImpl<$Res, ModerationCategories>;
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesCopyWithImpl<$Res,
        $Val extends ModerationCategories>
    implements $ModerationCategoriesCopyWith<$Res> {
  _$ModerationCategoriesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesImplCopyWith<$Res>
    implements $ModerationCategoriesCopyWith<$Res> {
  factory _$$ModerationCategoriesImplCopyWith(_$ModerationCategoriesImpl value,
          $Res Function(_$ModerationCategoriesImpl) then) =
      __$$ModerationCategoriesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesCopyWithImpl<$Res, _$ModerationCategoriesImpl>
    implements _$$ModerationCategoriesImplCopyWith<$Res> {
  __$$ModerationCategoriesImplCopyWithImpl(_$ModerationCategoriesImpl _value,
      $Res Function(_$ModerationCategoriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesImpl extends _ModerationCategories {
  const _$ModerationCategoriesImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationCategoriesImplFromJson(json);

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  @override
  final bool hate;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @override
  @JsonKey(name: 'hate/threatening')
  final bool hateThreatening;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  @override
  final bool harassment;

  /// Harassment content that also includes violence or serious harm towards any target.
  @override
  @JsonKey(name: 'harassment/threatening')
  final bool harassmentThreatening;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm')
  final bool selfHarm;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm/intent')
  final bool selfHarmIntent;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final bool selfHarmInstructions;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  @override
  final bool sexual;

  /// Sexual content that includes an individual who is under 18 years old.
  @override
  @JsonKey(name: 'sexual/minors')
  final bool sexualMinors;

  /// Content that depicts death, violence, or physical injury.
  @override
  final bool violence;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @override
  @JsonKey(name: 'violence/graphic')
  final bool violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategories(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith =>
          __$$ModerationCategoriesImplCopyWithImpl<_$ModerationCategoriesImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategories extends ModerationCategories {
  const factory _ModerationCategories(
      {required final bool hate,
      @JsonKey(name: 'hate/threatening') required final bool hateThreatening,
      required final bool harassment,
      @JsonKey(name: 'harassment/threatening')
      required final bool harassmentThreatening,
      @JsonKey(name: 'self-harm') required final bool selfHarm,
      @JsonKey(name: 'self-harm/intent') required final bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final bool selfHarmInstructions,
      required final bool sexual,
      @JsonKey(name: 'sexual/minors') required final bool sexualMinors,
      required final bool violence,
      @JsonKey(name: 'violence/graphic')
      required final bool violenceGraphic}) = _$ModerationCategoriesImpl;
  const _ModerationCategories._() : super._();

  factory _ModerationCategories.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesImpl.fromJson;

  @override

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  bool get hate;
  @override

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening;
  @override

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment;
  @override

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening;
  @override

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm;
  @override

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent;
  @override

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions;
  @override

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual;
  @override

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors;
  @override

  /// Content that depicts death, violence, or physical injury.
  bool get violence;
  @override

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationCategoriesScores _$ModerationCategoriesScoresFromJson(
    Map<String, dynamic> json) {
  return _ModerationCategoriesScores.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategoriesScores {
  /// The score for the category 'hate'.
  double get hate => throw _privateConstructorUsedError;

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'harassment'.
  double get harassment => throw _privateConstructorUsedError;

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions => throw _privateConstructorUsedError;

  /// The score for the category 'sexual'.
  double get sexual => throw _privateConstructorUsedError;

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors => throw _privateConstructorUsedError;

  /// The score for the category 'violence'.
  double get violence => throw _privateConstructorUsedError;

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesScoresCopyWith<ModerationCategoriesScores>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesScoresCopyWith<$Res> {
  factory $ModerationCategoriesScoresCopyWith(ModerationCategoriesScores value,
          $Res Function(ModerationCategoriesScores) then) =
      _$ModerationCategoriesScoresCopyWithImpl<$Res,
          ModerationCategoriesScores>;
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesScoresCopyWithImpl<$Res,
        $Val extends ModerationCategoriesScores>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  _$ModerationCategoriesScoresCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesScoresImplCopyWith<$Res>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  factory _$$ModerationCategoriesScoresImplCopyWith(
          _$ModerationCategoriesScoresImpl value,
          $Res Function(_$ModerationCategoriesScoresImpl) then) =
      __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesScoresCopyWithImpl<$Res,
        _$ModerationCategoriesScoresImpl>
    implements _$$ModerationCategoriesScoresImplCopyWith<$Res> {
  __$$ModerationCategoriesScoresImplCopyWithImpl(
      _$ModerationCategoriesScoresImpl _value,
      $Res Function(_$ModerationCategoriesScoresImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesScoresImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesScoresImpl extends _ModerationCategoriesScores {
  const _$ModerationCategoriesScoresImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesScoresImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModerationCategoriesScoresImplFromJson(json);

  /// The score for the category 'hate'.
  @override
  final double hate;

  /// The score for the category 'hate/threatening'.
  @override
  @JsonKey(name: 'hate/threatening')
  final double hateThreatening;

  /// The score for the category 'harassment'.
  @override
  final double harassment;

  /// The score for the category 'harassment/threatening'.
  @override
  @JsonKey(name: 'harassment/threatening')
  final double harassmentThreatening;

  /// The score for the category 'self-harm'.
  @override
  @JsonKey(name: 'self-harm')
  final double selfHarm;

  /// The score for the category 'self-harm/intent'.
  @override
  @JsonKey(name: 'self-harm/intent')
  final double selfHarmIntent;

  /// The score for the category 'self-harm/instructions'.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final double selfHarmInstructions;

  /// The score for the category 'sexual'.
  @override
  final double sexual;

  /// The score for the category 'sexual/minors'.
  @override
  @JsonKey(name: 'sexual/minors')
  final double sexualMinors;

  /// The score for the category 'violence'.
  @override
  final double violence;

  /// The score for the category 'violence/graphic'.
  @override
  @JsonKey(name: 'violence/graphic')
  final double violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategoriesScores(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesScoresImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => __$$ModerationCategoriesScoresImplCopyWithImpl<
          _$ModerationCategoriesScoresImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesScoresImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategoriesScores extends ModerationCategoriesScores {
  const factory _ModerationCategoriesScores(
      {required final double hate,
      @JsonKey(name: 'hate/threatening') required final double hateThreatening,
      required final double harassment,
      @JsonKey(name: 'harassment/threatening')
      required final double harassmentThreatening,
      @JsonKey(name: 'self-harm') required final double selfHarm,
      @JsonKey(name: 'self-harm/intent') required final double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final double selfHarmInstructions,
      required final double sexual,
      @JsonKey(name: 'sexual/minors') required final double sexualMinors,
      required final double violence,
      @JsonKey(name: 'violence/graphic')
      required final double
          violenceGraphic}) = _$ModerationCategoriesScoresImpl;
  const _ModerationCategoriesScores._() : super._();

  factory _ModerationCategoriesScores.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesScoresImpl.fromJson;

  @override

  /// The score for the category 'hate'.
  double get hate;
  @override

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening;
  @override

  /// The score for the category 'harassment'.
  double get harassment;
  @override

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening;
  @override

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm;
  @override

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent;
  @override

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions;
  @override

  /// The score for the category 'sexual'.
  double get sexual;
  @override

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors;
  @override

  /// The score for the category 'violence'.
  double get violence;
  @override

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantObject _$AssistantObjectFromJson(Map<String, dynamic> json) {
  return _AssistantObject.fromJson(json);
}

/// @nodoc
mixin _$AssistantObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `assistant`.
  AssistantObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The name of the assistant. The maximum length is 256 characters.
  String? get name => throw _privateConstructorUsedError;

  /// The description of the assistant. The maximum length is 512 characters.
  String? get description => throw _privateConstructorUsedError;

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  String get model => throw _privateConstructorUsedError;

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  String? get instructions => throw _privateConstructorUsedError;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantObjectCopyWith<AssistantObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantObjectCopyWith<$Res> {
  factory $AssistantObjectCopyWith(
          AssistantObject value, $Res Function(AssistantObject) then) =
      _$AssistantObjectCopyWithImpl<$Res, AssistantObject>;
  @useResult
  $Res call(
      {String id,
      AssistantObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      String? description,
      String model,
      String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$AssistantObjectCopyWithImpl<$Res, $Val extends AssistantObject>
    implements $AssistantObjectCopyWith<$Res> {
  _$AssistantObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? model = null,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssistantObjectImplCopyWith<$Res>
    implements $AssistantObjectCopyWith<$Res> {
  factory _$$AssistantObjectImplCopyWith(_$AssistantObjectImpl value,
          $Res Function(_$AssistantObjectImpl) then) =
      __$$AssistantObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      AssistantObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      String? description,
      String model,
      String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$AssistantObjectImplCopyWithImpl<$Res>
    extends _$AssistantObjectCopyWithImpl<$Res, _$AssistantObjectImpl>
    implements _$$AssistantObjectImplCopyWith<$Res> {
  __$$AssistantObjectImplCopyWithImpl(
      _$AssistantObjectImpl _value, $Res Function(_$AssistantObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? model = null,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_$AssistantObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantObjectImpl extends _AssistantObject {
  const _$AssistantObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.name,
      required this.description,
      required this.model,
      required this.instructions,
      required final List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') required final List<String> fileIds,
      required final Map<String, dynamic>? metadata})
      : _tools = tools,
        _fileIds = fileIds,
        _metadata = metadata,
        super._();

  factory _$AssistantObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `assistant`.
  @override
  final AssistantObjectObject object;

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  final String? description;

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  final String model;

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  @override
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  @override
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  final List<String> _fileIds;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'AssistantObject(id: $id, object: $object, createdAt: $createdAt, name: $name, description: $description, model: $model, instructions: $instructions, tools: $tools, fileIds: $fileIds, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      name,
      description,
      model,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_fileIds),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantObjectImplCopyWith<_$AssistantObjectImpl> get copyWith =>
      __$$AssistantObjectImplCopyWithImpl<_$AssistantObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantObjectImplToJson(
      this,
    );
  }
}

abstract class _AssistantObject extends AssistantObject {
  const factory _AssistantObject(
      {required final String id,
      required final AssistantObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final String? name,
      required final String? description,
      required final String model,
      required final String? instructions,
      required final List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') required final List<String> fileIds,
      required final Map<String, dynamic>? metadata}) = _$AssistantObjectImpl;
  const _AssistantObject._() : super._();

  factory _AssistantObject.fromJson(Map<String, dynamic> json) =
      _$AssistantObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `assistant`.
  AssistantObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The name of the assistant. The maximum length is 256 characters.
  String? get name;
  @override

  /// The description of the assistant. The maximum length is 512 characters.
  String? get description;
  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  String get model;
  @override

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  String? get instructions;
  @override

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  List<AssistantTools> get tools;
  @override

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$AssistantObjectImplCopyWith<_$AssistantObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateAssistantRequest _$CreateAssistantRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateAssistantRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateAssistantRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_CreateAssistantRequestModelConverter()
  CreateAssistantRequestModel get model => throw _privateConstructorUsedError;

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateAssistantRequestCopyWith<CreateAssistantRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateAssistantRequestCopyWith<$Res> {
  factory $CreateAssistantRequestCopyWith(CreateAssistantRequest value,
          $Res Function(CreateAssistantRequest) then) =
      _$CreateAssistantRequestCopyWithImpl<$Res, CreateAssistantRequest>;
  @useResult
  $Res call(
      {@_CreateAssistantRequestModelConverter()
      CreateAssistantRequestModel model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $CreateAssistantRequestModelCopyWith<$Res> get model;
}

/// @nodoc
class _$CreateAssistantRequestCopyWithImpl<$Res,
        $Val extends CreateAssistantRequest>
    implements $CreateAssistantRequestCopyWith<$Res> {
  _$CreateAssistantRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateAssistantRequestModel,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateAssistantRequestModelCopyWith<$Res> get model {
    return $CreateAssistantRequestModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateAssistantRequestImplCopyWith<$Res>
    implements $CreateAssistantRequestCopyWith<$Res> {
  factory _$$CreateAssistantRequestImplCopyWith(
          _$CreateAssistantRequestImpl value,
          $Res Function(_$CreateAssistantRequestImpl) then) =
      __$$CreateAssistantRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_CreateAssistantRequestModelConverter()
      CreateAssistantRequestModel model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $CreateAssistantRequestModelCopyWith<$Res> get model;
}

/// @nodoc
class __$$CreateAssistantRequestImplCopyWithImpl<$Res>
    extends _$CreateAssistantRequestCopyWithImpl<$Res,
        _$CreateAssistantRequestImpl>
    implements _$$CreateAssistantRequestImplCopyWith<$Res> {
  __$$CreateAssistantRequestImplCopyWithImpl(
      _$CreateAssistantRequestImpl _value,
      $Res Function(_$CreateAssistantRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateAssistantRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateAssistantRequestModel,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateAssistantRequestImpl extends _CreateAssistantRequest {
  const _$CreateAssistantRequestImpl(
      {@_CreateAssistantRequestModelConverter() required this.model,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) this.instructions,
      final List<AssistantTools> tools = const [],
      @JsonKey(name: 'file_ids') final List<String> fileIds = const [],
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _tools = tools,
        _fileIds = fileIds,
        _metadata = metadata,
        super._();

  factory _$CreateAssistantRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateAssistantRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @_CreateAssistantRequestModelConverter()
  final CreateAssistantRequestModel model;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  @override
  @JsonKey()
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  final List<String> _fileIds;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, fileIds: $fileIds, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateAssistantRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_fileIds),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateAssistantRequestImplCopyWith<_$CreateAssistantRequestImpl>
      get copyWith => __$$CreateAssistantRequestImplCopyWithImpl<
          _$CreateAssistantRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateAssistantRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateAssistantRequest extends CreateAssistantRequest {
  const factory _CreateAssistantRequest(
      {@_CreateAssistantRequestModelConverter()
      required final CreateAssistantRequestModel model,
      @JsonKey(includeIfNull: false) final String? name,
      @JsonKey(includeIfNull: false) final String? description,
      @JsonKey(includeIfNull: false) final String? instructions,
      final List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') final List<String> fileIds,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$CreateAssistantRequestImpl;
  const _CreateAssistantRequest._() : super._();

  factory _CreateAssistantRequest.fromJson(Map<String, dynamic> json) =
      _$CreateAssistantRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_CreateAssistantRequestModelConverter()
  CreateAssistantRequestModel get model;
  @override

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  List<AssistantTools> get tools;
  @override

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateAssistantRequestImplCopyWith<_$CreateAssistantRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateAssistantRequestModel _$CreateAssistantRequestModelFromJson(
    Map<String, dynamic> json) {
  return CreateAssistantRequestModelString.fromJson(json);
}

/// @nodoc
mixin _$CreateAssistantRequestModel {
  String get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateAssistantRequestModelString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantRequestModelString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateAssistantRequestModelString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateAssistantRequestModelCopyWith<CreateAssistantRequestModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateAssistantRequestModelCopyWith<$Res> {
  factory $CreateAssistantRequestModelCopyWith(
          CreateAssistantRequestModel value,
          $Res Function(CreateAssistantRequestModel) then) =
      _$CreateAssistantRequestModelCopyWithImpl<$Res,
          CreateAssistantRequestModel>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$CreateAssistantRequestModelCopyWithImpl<$Res,
        $Val extends CreateAssistantRequestModel>
    implements $CreateAssistantRequestModelCopyWith<$Res> {
  _$CreateAssistantRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateAssistantRequestModelStringImplCopyWith<$Res>
    implements $CreateAssistantRequestModelCopyWith<$Res> {
  factory _$$CreateAssistantRequestModelStringImplCopyWith(
          _$CreateAssistantRequestModelStringImpl value,
          $Res Function(_$CreateAssistantRequestModelStringImpl) then) =
      __$$CreateAssistantRequestModelStringImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CreateAssistantRequestModelStringImplCopyWithImpl<$Res>
    extends _$CreateAssistantRequestModelCopyWithImpl<$Res,
        _$CreateAssistantRequestModelStringImpl>
    implements _$$CreateAssistantRequestModelStringImplCopyWith<$Res> {
  __$$CreateAssistantRequestModelStringImplCopyWithImpl(
      _$CreateAssistantRequestModelStringImpl _value,
      $Res Function(_$CreateAssistantRequestModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateAssistantRequestModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateAssistantRequestModelStringImpl
    extends CreateAssistantRequestModelString {
  const _$CreateAssistantRequestModelStringImpl(this.value) : super._();

  factory _$CreateAssistantRequestModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateAssistantRequestModelStringImplFromJson(json);

  @override
  final String value;

  @override
  String toString() {
    return 'CreateAssistantRequestModel.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateAssistantRequestModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateAssistantRequestModelStringImplCopyWith<
          _$CreateAssistantRequestModelStringImpl>
      get copyWith => __$$CreateAssistantRequestModelStringImplCopyWithImpl<
          _$CreateAssistantRequestModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateAssistantRequestModelString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantRequestModelString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateAssistantRequestModelString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateAssistantRequestModelStringImplToJson(
      this,
    );
  }
}

abstract class CreateAssistantRequestModelString
    extends CreateAssistantRequestModel {
  const factory CreateAssistantRequestModelString(final String value) =
      _$CreateAssistantRequestModelStringImpl;
  const CreateAssistantRequestModelString._() : super._();

  factory CreateAssistantRequestModelString.fromJson(
          Map<String, dynamic> json) =
      _$CreateAssistantRequestModelStringImpl.fromJson;

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$CreateAssistantRequestModelStringImplCopyWith<
          _$CreateAssistantRequestModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModifyAssistantRequest _$ModifyAssistantRequestFromJson(
    Map<String, dynamic> json) {
  return _ModifyAssistantRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyAssistantRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @JsonKey(includeIfNull: false)
  String? get model => throw _privateConstructorUsedError;

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyAssistantRequestCopyWith<ModifyAssistantRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyAssistantRequestCopyWith<$Res> {
  factory $ModifyAssistantRequestCopyWith(ModifyAssistantRequest value,
          $Res Function(ModifyAssistantRequest) then) =
      _$ModifyAssistantRequestCopyWithImpl<$Res, ModifyAssistantRequest>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyAssistantRequestCopyWithImpl<$Res,
        $Val extends ModifyAssistantRequest>
    implements $ModifyAssistantRequestCopyWith<$Res> {
  _$ModifyAssistantRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModifyAssistantRequestImplCopyWith<$Res>
    implements $ModifyAssistantRequestCopyWith<$Res> {
  factory _$$ModifyAssistantRequestImplCopyWith(
          _$ModifyAssistantRequestImpl value,
          $Res Function(_$ModifyAssistantRequestImpl) then) =
      __$$ModifyAssistantRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ModifyAssistantRequestImplCopyWithImpl<$Res>
    extends _$ModifyAssistantRequestCopyWithImpl<$Res,
        _$ModifyAssistantRequestImpl>
    implements _$$ModifyAssistantRequestImplCopyWith<$Res> {
  __$$ModifyAssistantRequestImplCopyWithImpl(
      _$ModifyAssistantRequestImpl _value,
      $Res Function(_$ModifyAssistantRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_$ModifyAssistantRequestImpl(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyAssistantRequestImpl extends _ModifyAssistantRequest {
  const _$ModifyAssistantRequestImpl(
      {@JsonKey(includeIfNull: false) this.model,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) this.instructions,
      final List<AssistantTools> tools = const [],
      @JsonKey(name: 'file_ids') final List<String> fileIds = const [],
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _tools = tools,
        _fileIds = fileIds,
        _metadata = metadata,
        super._();

  factory _$ModifyAssistantRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyAssistantRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  @override
  @JsonKey()
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  final List<String> _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ModifyAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, fileIds: $fileIds, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyAssistantRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_fileIds),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyAssistantRequestImplCopyWith<_$ModifyAssistantRequestImpl>
      get copyWith => __$$ModifyAssistantRequestImplCopyWithImpl<
          _$ModifyAssistantRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyAssistantRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyAssistantRequest extends ModifyAssistantRequest {
  const factory _ModifyAssistantRequest(
      {@JsonKey(includeIfNull: false) final String? model,
      @JsonKey(includeIfNull: false) final String? name,
      @JsonKey(includeIfNull: false) final String? description,
      @JsonKey(includeIfNull: false) final String? instructions,
      final List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') final List<String> fileIds,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$ModifyAssistantRequestImpl;
  const _ModifyAssistantRequest._() : super._();

  factory _ModifyAssistantRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyAssistantRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @JsonKey(includeIfNull: false)
  String? get model;
  @override

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The system instructions that the assistant uses. The maximum length is 32768 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`.
  List<AssistantTools> get tools;
  @override

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ModifyAssistantRequestImplCopyWith<_$ModifyAssistantRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteAssistantResponse _$DeleteAssistantResponseFromJson(
    Map<String, dynamic> json) {
  return _DeleteAssistantResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteAssistantResponse {
  /// The assistant identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the assistant was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `assistant.deleted`.
  DeleteAssistantResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteAssistantResponseCopyWith<DeleteAssistantResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteAssistantResponseCopyWith<$Res> {
  factory $DeleteAssistantResponseCopyWith(DeleteAssistantResponse value,
          $Res Function(DeleteAssistantResponse) then) =
      _$DeleteAssistantResponseCopyWithImpl<$Res, DeleteAssistantResponse>;
  @useResult
  $Res call({String id, bool deleted, DeleteAssistantResponseObject object});
}

/// @nodoc
class _$DeleteAssistantResponseCopyWithImpl<$Res,
        $Val extends DeleteAssistantResponse>
    implements $DeleteAssistantResponseCopyWith<$Res> {
  _$DeleteAssistantResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteAssistantResponseImplCopyWith<$Res>
    implements $DeleteAssistantResponseCopyWith<$Res> {
  factory _$$DeleteAssistantResponseImplCopyWith(
          _$DeleteAssistantResponseImpl value,
          $Res Function(_$DeleteAssistantResponseImpl) then) =
      __$$DeleteAssistantResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteAssistantResponseObject object});
}

/// @nodoc
class __$$DeleteAssistantResponseImplCopyWithImpl<$Res>
    extends _$DeleteAssistantResponseCopyWithImpl<$Res,
        _$DeleteAssistantResponseImpl>
    implements _$$DeleteAssistantResponseImplCopyWith<$Res> {
  __$$DeleteAssistantResponseImplCopyWithImpl(
      _$DeleteAssistantResponseImpl _value,
      $Res Function(_$DeleteAssistantResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteAssistantResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteAssistantResponseImpl extends _DeleteAssistantResponse {
  const _$DeleteAssistantResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteAssistantResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteAssistantResponseImplFromJson(json);

  /// The assistant identifier.
  @override
  final String id;

  /// Whether the assistant was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `assistant.deleted`.
  @override
  final DeleteAssistantResponseObject object;

  @override
  String toString() {
    return 'DeleteAssistantResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteAssistantResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteAssistantResponseImplCopyWith<_$DeleteAssistantResponseImpl>
      get copyWith => __$$DeleteAssistantResponseImplCopyWithImpl<
          _$DeleteAssistantResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteAssistantResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteAssistantResponse extends DeleteAssistantResponse {
  const factory _DeleteAssistantResponse(
          {required final String id,
          required final bool deleted,
          required final DeleteAssistantResponseObject object}) =
      _$DeleteAssistantResponseImpl;
  const _DeleteAssistantResponse._() : super._();

  factory _DeleteAssistantResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteAssistantResponseImpl.fromJson;

  @override

  /// The assistant identifier.
  String get id;
  @override

  /// Whether the assistant was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `assistant.deleted`.
  DeleteAssistantResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteAssistantResponseImplCopyWith<_$DeleteAssistantResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListAssistantsResponse _$ListAssistantsResponseFromJson(
    Map<String, dynamic> json) {
  return _ListAssistantsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListAssistantsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of assistants.
  List<AssistantObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first assistant in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last assistant in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more assistants to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListAssistantsResponseCopyWith<ListAssistantsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListAssistantsResponseCopyWith<$Res> {
  factory $ListAssistantsResponseCopyWith(ListAssistantsResponse value,
          $Res Function(ListAssistantsResponse) then) =
      _$ListAssistantsResponseCopyWithImpl<$Res, ListAssistantsResponse>;
  @useResult
  $Res call(
      {String object,
      List<AssistantObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListAssistantsResponseCopyWithImpl<$Res,
        $Val extends ListAssistantsResponse>
    implements $ListAssistantsResponseCopyWith<$Res> {
  _$ListAssistantsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListAssistantsResponseImplCopyWith<$Res>
    implements $ListAssistantsResponseCopyWith<$Res> {
  factory _$$ListAssistantsResponseImplCopyWith(
          _$ListAssistantsResponseImpl value,
          $Res Function(_$ListAssistantsResponseImpl) then) =
      __$$ListAssistantsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<AssistantObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListAssistantsResponseImplCopyWithImpl<$Res>
    extends _$ListAssistantsResponseCopyWithImpl<$Res,
        _$ListAssistantsResponseImpl>
    implements _$$ListAssistantsResponseImplCopyWith<$Res> {
  __$$ListAssistantsResponseImplCopyWithImpl(
      _$ListAssistantsResponseImpl _value,
      $Res Function(_$ListAssistantsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListAssistantsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListAssistantsResponseImpl extends _ListAssistantsResponse {
  const _$ListAssistantsResponseImpl(
      {required this.object,
      required final List<AssistantObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListAssistantsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListAssistantsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of assistants.
  final List<AssistantObject> _data;

  /// The list of assistants.
  @override
  List<AssistantObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first assistant in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last assistant in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more assistants to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListAssistantsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListAssistantsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListAssistantsResponseImplCopyWith<_$ListAssistantsResponseImpl>
      get copyWith => __$$ListAssistantsResponseImplCopyWithImpl<
          _$ListAssistantsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListAssistantsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListAssistantsResponse extends ListAssistantsResponse {
  const factory _ListAssistantsResponse(
          {required final String object,
          required final List<AssistantObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListAssistantsResponseImpl;
  const _ListAssistantsResponse._() : super._();

  factory _ListAssistantsResponse.fromJson(Map<String, dynamic> json) =
      _$ListAssistantsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of assistants.
  List<AssistantObject> get data;
  @override

  /// The ID of the first assistant in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last assistant in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more assistants to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListAssistantsResponseImplCopyWith<_$ListAssistantsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunObject _$RunObjectFromJson(Map<String, dynamic> json) {
  return _RunObject.fromJson(json);
}

/// @nodoc
mixin _$RunObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.run`.
  RunObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @JsonKey(name: 'thread_id')
  String get threadId => throw _privateConstructorUsedError;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, or `expired`.
  RunStatus get status => throw _privateConstructorUsedError;

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @JsonKey(name: 'required_action')
  RunRequiredAction? get requiredAction => throw _privateConstructorUsedError;

  /// The last error associated with this run. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunLastError? get lastError => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run will expire.
  @JsonKey(name: 'expires_at')
  int? get expiresAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was started.
  @JsonKey(name: 'started_at')
  int? get startedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt => throw _privateConstructorUsedError;

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get model => throw _privateConstructorUsedError;

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get instructions => throw _privateConstructorUsedError;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// The list of [File](https://platform.openai.com/docs/api-reference/files) IDs the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  RunCompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunObjectCopyWith<RunObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunObjectCopyWith<$Res> {
  factory $RunObjectCopyWith(RunObject value, $Res Function(RunObject) then) =
      _$RunObjectCopyWithImpl<$Res, RunObject>;
  @useResult
  $Res call(
      {String id,
      RunObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'assistant_id') String assistantId,
      RunStatus status,
      @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') RunLastError? lastError,
      @JsonKey(name: 'expires_at') int? expiresAt,
      @JsonKey(name: 'started_at') int? startedAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      String model,
      String instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      Map<String, dynamic>? metadata,
      RunCompletionUsage? usage});

  $RunRequiredActionCopyWith<$Res>? get requiredAction;
  $RunLastErrorCopyWith<$Res>? get lastError;
  $RunCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$RunObjectCopyWithImpl<$Res, $Val extends RunObject>
    implements $RunObjectCopyWith<$Res> {
  _$RunObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? assistantId = null,
    Object? status = null,
    Object? requiredAction = freezed,
    Object? lastError = freezed,
    Object? expiresAt = freezed,
    Object? startedAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? model = null,
    Object? instructions = null,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStatus,
      requiredAction: freezed == requiredAction
          ? _value.requiredAction
          : requiredAction // ignore: cast_nullable_to_non_nullable
              as RunRequiredAction?,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunLastError?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      startedAt: freezed == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: null == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunCompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunRequiredActionCopyWith<$Res>? get requiredAction {
    if (_value.requiredAction == null) {
      return null;
    }

    return $RunRequiredActionCopyWith<$Res>(_value.requiredAction!, (value) {
      return _then(_value.copyWith(requiredAction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunLastErrorCopyWith<$Res>? get lastError {
    if (_value.lastError == null) {
      return null;
    }

    return $RunLastErrorCopyWith<$Res>(_value.lastError!, (value) {
      return _then(_value.copyWith(lastError: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunCompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $RunCompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunObjectImplCopyWith<$Res>
    implements $RunObjectCopyWith<$Res> {
  factory _$$RunObjectImplCopyWith(
          _$RunObjectImpl value, $Res Function(_$RunObjectImpl) then) =
      __$$RunObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      RunObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'assistant_id') String assistantId,
      RunStatus status,
      @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') RunLastError? lastError,
      @JsonKey(name: 'expires_at') int? expiresAt,
      @JsonKey(name: 'started_at') int? startedAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      String model,
      String instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      Map<String, dynamic>? metadata,
      RunCompletionUsage? usage});

  @override
  $RunRequiredActionCopyWith<$Res>? get requiredAction;
  @override
  $RunLastErrorCopyWith<$Res>? get lastError;
  @override
  $RunCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$RunObjectImplCopyWithImpl<$Res>
    extends _$RunObjectCopyWithImpl<$Res, _$RunObjectImpl>
    implements _$$RunObjectImplCopyWith<$Res> {
  __$$RunObjectImplCopyWithImpl(
      _$RunObjectImpl _value, $Res Function(_$RunObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? assistantId = null,
    Object? status = null,
    Object? requiredAction = freezed,
    Object? lastError = freezed,
    Object? expiresAt = freezed,
    Object? startedAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? model = null,
    Object? instructions = null,
    Object? tools = null,
    Object? fileIds = null,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_$RunObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStatus,
      requiredAction: freezed == requiredAction
          ? _value.requiredAction
          : requiredAction // ignore: cast_nullable_to_non_nullable
              as RunRequiredAction?,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunLastError?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      startedAt: freezed == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: null == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunCompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunObjectImpl extends _RunObject {
  const _$RunObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      required this.status,
      @JsonKey(name: 'required_action') required this.requiredAction,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'expires_at') required this.expiresAt,
      @JsonKey(name: 'started_at') required this.startedAt,
      @JsonKey(name: 'cancelled_at') required this.cancelledAt,
      @JsonKey(name: 'failed_at') required this.failedAt,
      @JsonKey(name: 'completed_at') required this.completedAt,
      required this.model,
      required this.instructions,
      required final List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') required final List<String> fileIds,
      required final Map<String, dynamic>? metadata,
      required this.usage})
      : _tools = tools,
        _fileIds = fileIds,
        _metadata = metadata,
        super._();

  factory _$RunObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run`.
  @override
  final RunObjectObject object;

  /// The Unix timestamp (in seconds) for when the run was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, or `expired`.
  @override
  final RunStatus status;

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @override
  @JsonKey(name: 'required_action')
  final RunRequiredAction? requiredAction;

  /// The last error associated with this run. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final RunLastError? lastError;

  /// The Unix timestamp (in seconds) for when the run will expire.
  @override
  @JsonKey(name: 'expires_at')
  final int? expiresAt;

  /// The Unix timestamp (in seconds) for when the run was started.
  @override
  @JsonKey(name: 'started_at')
  final int? startedAt;

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @override
  @JsonKey(name: 'cancelled_at')
  final int? cancelledAt;

  /// The Unix timestamp (in seconds) for when the run failed.
  @override
  @JsonKey(name: 'failed_at')
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the run was completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  final String model;

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  final String instructions;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  final List<AssistantTools> _tools;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// The list of [File](https://platform.openai.com/docs/api-reference/files) IDs the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  final List<String> _fileIds;

  /// The list of [File](https://platform.openai.com/docs/api-reference/files) IDs the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  @override
  final RunCompletionUsage? usage;

  @override
  String toString() {
    return 'RunObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, assistantId: $assistantId, status: $status, requiredAction: $requiredAction, lastError: $lastError, expiresAt: $expiresAt, startedAt: $startedAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, model: $model, instructions: $instructions, tools: $tools, fileIds: $fileIds, metadata: $metadata, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.requiredAction, requiredAction) ||
                other.requiredAction == requiredAction) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.startedAt, startedAt) ||
                other.startedAt == startedAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        createdAt,
        threadId,
        assistantId,
        status,
        requiredAction,
        lastError,
        expiresAt,
        startedAt,
        cancelledAt,
        failedAt,
        completedAt,
        model,
        instructions,
        const DeepCollectionEquality().hash(_tools),
        const DeepCollectionEquality().hash(_fileIds),
        const DeepCollectionEquality().hash(_metadata),
        usage
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunObjectImplCopyWith<_$RunObjectImpl> get copyWith =>
      __$$RunObjectImplCopyWithImpl<_$RunObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunObjectImplToJson(
      this,
    );
  }
}

abstract class _RunObject extends RunObject {
  const factory _RunObject(
      {required final String id,
      required final RunObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'thread_id') required final String threadId,
      @JsonKey(name: 'assistant_id') required final String assistantId,
      required final RunStatus status,
      @JsonKey(name: 'required_action')
      required final RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') required final RunLastError? lastError,
      @JsonKey(name: 'expires_at') required final int? expiresAt,
      @JsonKey(name: 'started_at') required final int? startedAt,
      @JsonKey(name: 'cancelled_at') required final int? cancelledAt,
      @JsonKey(name: 'failed_at') required final int? failedAt,
      @JsonKey(name: 'completed_at') required final int? completedAt,
      required final String model,
      required final String instructions,
      required final List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') required final List<String> fileIds,
      required final Map<String, dynamic>? metadata,
      required final RunCompletionUsage? usage}) = _$RunObjectImpl;
  const _RunObject._() : super._();

  factory _RunObject.fromJson(Map<String, dynamic> json) =
      _$RunObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.run`.
  RunObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the run was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @JsonKey(name: 'thread_id')
  String get threadId;
  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, or `expired`.
  RunStatus get status;
  @override

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @JsonKey(name: 'required_action')
  RunRequiredAction? get requiredAction;
  @override

  /// The last error associated with this run. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunLastError? get lastError;
  @override

  /// The Unix timestamp (in seconds) for when the run will expire.
  @JsonKey(name: 'expires_at')
  int? get expiresAt;
  @override

  /// The Unix timestamp (in seconds) for when the run was started.
  @JsonKey(name: 'started_at')
  int? get startedAt;
  @override

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt;
  @override

  /// The Unix timestamp (in seconds) for when the run failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt;
  @override

  /// The Unix timestamp (in seconds) for when the run was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;
  @override

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get model;
  @override

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get instructions;
  @override

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  List<AssistantTools> get tools;
  @override

  /// The list of [File](https://platform.openai.com/docs/api-reference/files) IDs the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  RunCompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$RunObjectImplCopyWith<_$RunObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunRequiredAction _$RunRequiredActionFromJson(Map<String, dynamic> json) {
  return _RunRequiredAction.fromJson(json);
}

/// @nodoc
mixin _$RunRequiredAction {
  /// For now, this is always `submit_tool_outputs`.
  RunRequiredActionType get type => throw _privateConstructorUsedError;

  /// Details on the tool outputs needed for this run to continue.
  @JsonKey(name: 'submit_tool_outputs')
  RunSubmitToolOutputs get submitToolOutputs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunRequiredActionCopyWith<RunRequiredAction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunRequiredActionCopyWith<$Res> {
  factory $RunRequiredActionCopyWith(
          RunRequiredAction value, $Res Function(RunRequiredAction) then) =
      _$RunRequiredActionCopyWithImpl<$Res, RunRequiredAction>;
  @useResult
  $Res call(
      {RunRequiredActionType type,
      @JsonKey(name: 'submit_tool_outputs')
      RunSubmitToolOutputs submitToolOutputs});

  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs;
}

/// @nodoc
class _$RunRequiredActionCopyWithImpl<$Res, $Val extends RunRequiredAction>
    implements $RunRequiredActionCopyWith<$Res> {
  _$RunRequiredActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? submitToolOutputs = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunRequiredActionType,
      submitToolOutputs: null == submitToolOutputs
          ? _value.submitToolOutputs
          : submitToolOutputs // ignore: cast_nullable_to_non_nullable
              as RunSubmitToolOutputs,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs {
    return $RunSubmitToolOutputsCopyWith<$Res>(_value.submitToolOutputs,
        (value) {
      return _then(_value.copyWith(submitToolOutputs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunRequiredActionImplCopyWith<$Res>
    implements $RunRequiredActionCopyWith<$Res> {
  factory _$$RunRequiredActionImplCopyWith(_$RunRequiredActionImpl value,
          $Res Function(_$RunRequiredActionImpl) then) =
      __$$RunRequiredActionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RunRequiredActionType type,
      @JsonKey(name: 'submit_tool_outputs')
      RunSubmitToolOutputs submitToolOutputs});

  @override
  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs;
}

/// @nodoc
class __$$RunRequiredActionImplCopyWithImpl<$Res>
    extends _$RunRequiredActionCopyWithImpl<$Res, _$RunRequiredActionImpl>
    implements _$$RunRequiredActionImplCopyWith<$Res> {
  __$$RunRequiredActionImplCopyWithImpl(_$RunRequiredActionImpl _value,
      $Res Function(_$RunRequiredActionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? submitToolOutputs = null,
  }) {
    return _then(_$RunRequiredActionImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunRequiredActionType,
      submitToolOutputs: null == submitToolOutputs
          ? _value.submitToolOutputs
          : submitToolOutputs // ignore: cast_nullable_to_non_nullable
              as RunSubmitToolOutputs,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunRequiredActionImpl extends _RunRequiredAction {
  const _$RunRequiredActionImpl(
      {required this.type,
      @JsonKey(name: 'submit_tool_outputs') required this.submitToolOutputs})
      : super._();

  factory _$RunRequiredActionImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunRequiredActionImplFromJson(json);

  /// For now, this is always `submit_tool_outputs`.
  @override
  final RunRequiredActionType type;

  /// Details on the tool outputs needed for this run to continue.
  @override
  @JsonKey(name: 'submit_tool_outputs')
  final RunSubmitToolOutputs submitToolOutputs;

  @override
  String toString() {
    return 'RunRequiredAction(type: $type, submitToolOutputs: $submitToolOutputs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunRequiredActionImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.submitToolOutputs, submitToolOutputs) ||
                other.submitToolOutputs == submitToolOutputs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, submitToolOutputs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunRequiredActionImplCopyWith<_$RunRequiredActionImpl> get copyWith =>
      __$$RunRequiredActionImplCopyWithImpl<_$RunRequiredActionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunRequiredActionImplToJson(
      this,
    );
  }
}

abstract class _RunRequiredAction extends RunRequiredAction {
  const factory _RunRequiredAction(
          {required final RunRequiredActionType type,
          @JsonKey(name: 'submit_tool_outputs')
          required final RunSubmitToolOutputs submitToolOutputs}) =
      _$RunRequiredActionImpl;
  const _RunRequiredAction._() : super._();

  factory _RunRequiredAction.fromJson(Map<String, dynamic> json) =
      _$RunRequiredActionImpl.fromJson;

  @override

  /// For now, this is always `submit_tool_outputs`.
  RunRequiredActionType get type;
  @override

  /// Details on the tool outputs needed for this run to continue.
  @JsonKey(name: 'submit_tool_outputs')
  RunSubmitToolOutputs get submitToolOutputs;
  @override
  @JsonKey(ignore: true)
  _$$RunRequiredActionImplCopyWith<_$RunRequiredActionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunLastError _$RunLastErrorFromJson(Map<String, dynamic> json) {
  return _RunLastError.fromJson(json);
}

/// @nodoc
mixin _$RunLastError {
  /// One of `server_error` or `rate_limit_exceeded`.
  RunLastErrorCode get code => throw _privateConstructorUsedError;

  /// A human-readable description of the error.
  String get message => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunLastErrorCopyWith<RunLastError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunLastErrorCopyWith<$Res> {
  factory $RunLastErrorCopyWith(
          RunLastError value, $Res Function(RunLastError) then) =
      _$RunLastErrorCopyWithImpl<$Res, RunLastError>;
  @useResult
  $Res call({RunLastErrorCode code, String message});
}

/// @nodoc
class _$RunLastErrorCopyWithImpl<$Res, $Val extends RunLastError>
    implements $RunLastErrorCopyWith<$Res> {
  _$RunLastErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunLastErrorImplCopyWith<$Res>
    implements $RunLastErrorCopyWith<$Res> {
  factory _$$RunLastErrorImplCopyWith(
          _$RunLastErrorImpl value, $Res Function(_$RunLastErrorImpl) then) =
      __$$RunLastErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({RunLastErrorCode code, String message});
}

/// @nodoc
class __$$RunLastErrorImplCopyWithImpl<$Res>
    extends _$RunLastErrorCopyWithImpl<$Res, _$RunLastErrorImpl>
    implements _$$RunLastErrorImplCopyWith<$Res> {
  __$$RunLastErrorImplCopyWithImpl(
      _$RunLastErrorImpl _value, $Res Function(_$RunLastErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_$RunLastErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunLastErrorImpl extends _RunLastError {
  const _$RunLastErrorImpl({required this.code, required this.message})
      : super._();

  factory _$RunLastErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunLastErrorImplFromJson(json);

  /// One of `server_error` or `rate_limit_exceeded`.
  @override
  final RunLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  @override
  String toString() {
    return 'RunLastError(code: $code, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunLastErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunLastErrorImplCopyWith<_$RunLastErrorImpl> get copyWith =>
      __$$RunLastErrorImplCopyWithImpl<_$RunLastErrorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunLastErrorImplToJson(
      this,
    );
  }
}

abstract class _RunLastError extends RunLastError {
  const factory _RunLastError(
      {required final RunLastErrorCode code,
      required final String message}) = _$RunLastErrorImpl;
  const _RunLastError._() : super._();

  factory _RunLastError.fromJson(Map<String, dynamic> json) =
      _$RunLastErrorImpl.fromJson;

  @override

  /// One of `server_error` or `rate_limit_exceeded`.
  RunLastErrorCode get code;
  @override

  /// A human-readable description of the error.
  String get message;
  @override
  @JsonKey(ignore: true)
  _$$RunLastErrorImplCopyWith<_$RunLastErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunSubmitToolOutputs _$RunSubmitToolOutputsFromJson(Map<String, dynamic> json) {
  return _RunSubmitToolOutputs.fromJson(json);
}

/// @nodoc
mixin _$RunSubmitToolOutputs {
  /// A list of the relevant tool calls.
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunSubmitToolOutputsCopyWith<RunSubmitToolOutputs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunSubmitToolOutputsCopyWith<$Res> {
  factory $RunSubmitToolOutputsCopyWith(RunSubmitToolOutputs value,
          $Res Function(RunSubmitToolOutputs) then) =
      _$RunSubmitToolOutputsCopyWithImpl<$Res, RunSubmitToolOutputs>;
  @useResult
  $Res call({@JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls});
}

/// @nodoc
class _$RunSubmitToolOutputsCopyWithImpl<$Res,
        $Val extends RunSubmitToolOutputs>
    implements $RunSubmitToolOutputsCopyWith<$Res> {
  _$RunSubmitToolOutputsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCalls = null,
  }) {
    return _then(_value.copyWith(
      toolCalls: null == toolCalls
          ? _value.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunToolCallObject>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunSubmitToolOutputsImplCopyWith<$Res>
    implements $RunSubmitToolOutputsCopyWith<$Res> {
  factory _$$RunSubmitToolOutputsImplCopyWith(_$RunSubmitToolOutputsImpl value,
          $Res Function(_$RunSubmitToolOutputsImpl) then) =
      __$$RunSubmitToolOutputsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls});
}

/// @nodoc
class __$$RunSubmitToolOutputsImplCopyWithImpl<$Res>
    extends _$RunSubmitToolOutputsCopyWithImpl<$Res, _$RunSubmitToolOutputsImpl>
    implements _$$RunSubmitToolOutputsImplCopyWith<$Res> {
  __$$RunSubmitToolOutputsImplCopyWithImpl(_$RunSubmitToolOutputsImpl _value,
      $Res Function(_$RunSubmitToolOutputsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCalls = null,
  }) {
    return _then(_$RunSubmitToolOutputsImpl(
      toolCalls: null == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunToolCallObject>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunSubmitToolOutputsImpl extends _RunSubmitToolOutputs {
  const _$RunSubmitToolOutputsImpl(
      {@JsonKey(name: 'tool_calls')
      required final List<RunToolCallObject> toolCalls})
      : _toolCalls = toolCalls,
        super._();

  factory _$RunSubmitToolOutputsImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunSubmitToolOutputsImplFromJson(json);

  /// A list of the relevant tool calls.
  final List<RunToolCallObject> _toolCalls;

  /// A list of the relevant tool calls.
  @override
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls {
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolCalls);
  }

  @override
  String toString() {
    return 'RunSubmitToolOutputs(toolCalls: $toolCalls)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunSubmitToolOutputsImpl &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_toolCalls));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunSubmitToolOutputsImplCopyWith<_$RunSubmitToolOutputsImpl>
      get copyWith =>
          __$$RunSubmitToolOutputsImplCopyWithImpl<_$RunSubmitToolOutputsImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunSubmitToolOutputsImplToJson(
      this,
    );
  }
}

abstract class _RunSubmitToolOutputs extends RunSubmitToolOutputs {
  const factory _RunSubmitToolOutputs(
          {@JsonKey(name: 'tool_calls')
          required final List<RunToolCallObject> toolCalls}) =
      _$RunSubmitToolOutputsImpl;
  const _RunSubmitToolOutputs._() : super._();

  factory _RunSubmitToolOutputs.fromJson(Map<String, dynamic> json) =
      _$RunSubmitToolOutputsImpl.fromJson;

  @override

  /// A list of the relevant tool calls.
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls;
  @override
  @JsonKey(ignore: true)
  _$$RunSubmitToolOutputsImplCopyWith<_$RunSubmitToolOutputsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunCompletionUsage _$RunCompletionUsageFromJson(Map<String, dynamic> json) {
  return _RunCompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$RunCompletionUsage {
  /// Number of completion tokens used over the course of the run.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens => throw _privateConstructorUsedError;

  /// Number of prompt tokens used over the course of the run.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunCompletionUsageCopyWith<RunCompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunCompletionUsageCopyWith<$Res> {
  factory $RunCompletionUsageCopyWith(
          RunCompletionUsage value, $Res Function(RunCompletionUsage) then) =
      _$RunCompletionUsageCopyWithImpl<$Res, RunCompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$RunCompletionUsageCopyWithImpl<$Res, $Val extends RunCompletionUsage>
    implements $RunCompletionUsageCopyWith<$Res> {
  _$RunCompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunCompletionUsageImplCopyWith<$Res>
    implements $RunCompletionUsageCopyWith<$Res> {
  factory _$$RunCompletionUsageImplCopyWith(_$RunCompletionUsageImpl value,
          $Res Function(_$RunCompletionUsageImpl) then) =
      __$$RunCompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$RunCompletionUsageImplCopyWithImpl<$Res>
    extends _$RunCompletionUsageCopyWithImpl<$Res, _$RunCompletionUsageImpl>
    implements _$$RunCompletionUsageImplCopyWith<$Res> {
  __$$RunCompletionUsageImplCopyWithImpl(_$RunCompletionUsageImpl _value,
      $Res Function(_$RunCompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$RunCompletionUsageImpl(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunCompletionUsageImpl extends _RunCompletionUsage {
  const _$RunCompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$RunCompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunCompletionUsageImplFromJson(json);

  /// Number of completion tokens used over the course of the run.
  @override
  @JsonKey(name: 'completion_tokens')
  final int completionTokens;

  /// Number of prompt tokens used over the course of the run.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'RunCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunCompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunCompletionUsageImplCopyWith<_$RunCompletionUsageImpl> get copyWith =>
      __$$RunCompletionUsageImplCopyWithImpl<_$RunCompletionUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunCompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _RunCompletionUsage extends RunCompletionUsage {
  const factory _RunCompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$RunCompletionUsageImpl;
  const _RunCompletionUsage._() : super._();

  factory _RunCompletionUsage.fromJson(Map<String, dynamic> json) =
      _$RunCompletionUsageImpl.fromJson;

  @override

  /// Number of completion tokens used over the course of the run.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens;
  @override

  /// Number of prompt tokens used over the course of the run.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$RunCompletionUsageImplCopyWith<_$RunCompletionUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateRunRequest _$CreateRunRequestFromJson(Map<String, dynamic> json) {
  return _CreateRunRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateRunRequest {
  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @JsonKey(includeIfNull: false)
  String? get model => throw _privateConstructorUsedError;

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  String? get additionalInstructions => throw _privateConstructorUsedError;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateRunRequestCopyWith<CreateRunRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateRunRequestCopyWith<$Res> {
  factory $CreateRunRequestCopyWith(
          CreateRunRequest value, $Res Function(CreateRunRequest) then) =
      _$CreateRunRequestCopyWithImpl<$Res, CreateRunRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      String? additionalInstructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$CreateRunRequestCopyWithImpl<$Res, $Val extends CreateRunRequest>
    implements $CreateRunRequestCopyWith<$Res> {
  _$CreateRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? additionalInstructions = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInstructions: freezed == additionalInstructions
          ? _value.additionalInstructions
          : additionalInstructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateRunRequestImplCopyWith<$Res>
    implements $CreateRunRequestCopyWith<$Res> {
  factory _$$CreateRunRequestImplCopyWith(_$CreateRunRequestImpl value,
          $Res Function(_$CreateRunRequestImpl) then) =
      __$$CreateRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      String? additionalInstructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$CreateRunRequestImplCopyWithImpl<$Res>
    extends _$CreateRunRequestCopyWithImpl<$Res, _$CreateRunRequestImpl>
    implements _$$CreateRunRequestImplCopyWith<$Res> {
  __$$CreateRunRequestImplCopyWithImpl(_$CreateRunRequestImpl _value,
      $Res Function(_$CreateRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? additionalInstructions = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateRunRequestImpl(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInstructions: freezed == additionalInstructions
          ? _value.additionalInstructions
          : additionalInstructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestImpl extends _CreateRunRequest {
  const _$CreateRunRequestImpl(
      {@JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(includeIfNull: false) this.model,
      @JsonKey(includeIfNull: false) this.instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      this.additionalInstructions,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _tools = tools,
        _metadata = metadata,
        super._();

  factory _$CreateRunRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateRunRequestImplFromJson(json);

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @override
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  final String? additionalInstructions;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  final List<AssistantTools>? _tools;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateRunRequest(assistantId: $assistantId, model: $model, instructions: $instructions, additionalInstructions: $additionalInstructions, tools: $tools, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateRunRequestImpl &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            (identical(other.additionalInstructions, additionalInstructions) ||
                other.additionalInstructions == additionalInstructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      model,
      instructions,
      additionalInstructions,
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestImplCopyWith<_$CreateRunRequestImpl> get copyWith =>
      __$$CreateRunRequestImplCopyWithImpl<_$CreateRunRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateRunRequest extends CreateRunRequest {
  const factory _CreateRunRequest(
      {@JsonKey(name: 'assistant_id') required final String assistantId,
      @JsonKey(includeIfNull: false) final String? model,
      @JsonKey(includeIfNull: false) final String? instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      final String? additionalInstructions,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$CreateRunRequestImpl;
  const _CreateRunRequest._() : super._();

  factory _CreateRunRequest.fromJson(Map<String, dynamic> json) =
      _$CreateRunRequestImpl.fromJson;

  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @JsonKey(includeIfNull: false)
  String? get model;
  @override

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  String? get additionalInstructions;
  @override

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateRunRequestImplCopyWith<_$CreateRunRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListRunsResponse _$ListRunsResponseFromJson(Map<String, dynamic> json) {
  return _ListRunsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListRunsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of runs.
  List<RunObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first run in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last run in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more runs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListRunsResponseCopyWith<ListRunsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListRunsResponseCopyWith<$Res> {
  factory $ListRunsResponseCopyWith(
          ListRunsResponse value, $Res Function(ListRunsResponse) then) =
      _$ListRunsResponseCopyWithImpl<$Res, ListRunsResponse>;
  @useResult
  $Res call(
      {String object,
      List<RunObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListRunsResponseCopyWithImpl<$Res, $Val extends ListRunsResponse>
    implements $ListRunsResponseCopyWith<$Res> {
  _$ListRunsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListRunsResponseImplCopyWith<$Res>
    implements $ListRunsResponseCopyWith<$Res> {
  factory _$$ListRunsResponseImplCopyWith(_$ListRunsResponseImpl value,
          $Res Function(_$ListRunsResponseImpl) then) =
      __$$ListRunsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<RunObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListRunsResponseImplCopyWithImpl<$Res>
    extends _$ListRunsResponseCopyWithImpl<$Res, _$ListRunsResponseImpl>
    implements _$$ListRunsResponseImplCopyWith<$Res> {
  __$$ListRunsResponseImplCopyWithImpl(_$ListRunsResponseImpl _value,
      $Res Function(_$ListRunsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListRunsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListRunsResponseImpl extends _ListRunsResponse {
  const _$ListRunsResponseImpl(
      {required this.object,
      required final List<RunObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListRunsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListRunsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of runs.
  final List<RunObject> _data;

  /// The list of runs.
  @override
  List<RunObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first run in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last run in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more runs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListRunsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListRunsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListRunsResponseImplCopyWith<_$ListRunsResponseImpl> get copyWith =>
      __$$ListRunsResponseImplCopyWithImpl<_$ListRunsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListRunsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListRunsResponse extends ListRunsResponse {
  const factory _ListRunsResponse(
          {required final String object,
          required final List<RunObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListRunsResponseImpl;
  const _ListRunsResponse._() : super._();

  factory _ListRunsResponse.fromJson(Map<String, dynamic> json) =
      _$ListRunsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of runs.
  List<RunObject> get data;
  @override

  /// The ID of the first run in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last run in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more runs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListRunsResponseImplCopyWith<_$ListRunsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModifyRunRequest _$ModifyRunRequestFromJson(Map<String, dynamic> json) {
  return _ModifyRunRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyRunRequest {
  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyRunRequestCopyWith<ModifyRunRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyRunRequestCopyWith<$Res> {
  factory $ModifyRunRequestCopyWith(
          ModifyRunRequest value, $Res Function(ModifyRunRequest) then) =
      _$ModifyRunRequestCopyWithImpl<$Res, ModifyRunRequest>;
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyRunRequestCopyWithImpl<$Res, $Val extends ModifyRunRequest>
    implements $ModifyRunRequestCopyWith<$Res> {
  _$ModifyRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModifyRunRequestImplCopyWith<$Res>
    implements $ModifyRunRequestCopyWith<$Res> {
  factory _$$ModifyRunRequestImplCopyWith(_$ModifyRunRequestImpl value,
          $Res Function(_$ModifyRunRequestImpl) then) =
      __$$ModifyRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ModifyRunRequestImplCopyWithImpl<$Res>
    extends _$ModifyRunRequestCopyWithImpl<$Res, _$ModifyRunRequestImpl>
    implements _$$ModifyRunRequestImplCopyWith<$Res> {
  __$$ModifyRunRequestImplCopyWithImpl(_$ModifyRunRequestImpl _value,
      $Res Function(_$ModifyRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_$ModifyRunRequestImpl(
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyRunRequestImpl extends _ModifyRunRequest {
  const _$ModifyRunRequestImpl(
      {@JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ModifyRunRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyRunRequestImplFromJson(json);

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ModifyRunRequest(metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyRunRequestImpl &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyRunRequestImplCopyWith<_$ModifyRunRequestImpl> get copyWith =>
      __$$ModifyRunRequestImplCopyWithImpl<_$ModifyRunRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyRunRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyRunRequest extends ModifyRunRequest {
  const factory _ModifyRunRequest(
      {@JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$ModifyRunRequestImpl;
  const _ModifyRunRequest._() : super._();

  factory _ModifyRunRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyRunRequestImpl.fromJson;

  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ModifyRunRequestImplCopyWith<_$ModifyRunRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SubmitToolOutputsRunRequest _$SubmitToolOutputsRunRequestFromJson(
    Map<String, dynamic> json) {
  return _SubmitToolOutputsRunRequest.fromJson(json);
}

/// @nodoc
mixin _$SubmitToolOutputsRunRequest {
  /// A list of tools for which the outputs are being submitted.
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubmitToolOutputsRunRequestCopyWith<SubmitToolOutputsRunRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubmitToolOutputsRunRequestCopyWith<$Res> {
  factory $SubmitToolOutputsRunRequestCopyWith(
          SubmitToolOutputsRunRequest value,
          $Res Function(SubmitToolOutputsRunRequest) then) =
      _$SubmitToolOutputsRunRequestCopyWithImpl<$Res,
          SubmitToolOutputsRunRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_outputs') List<RunSubmitToolOutput> toolOutputs});
}

/// @nodoc
class _$SubmitToolOutputsRunRequestCopyWithImpl<$Res,
        $Val extends SubmitToolOutputsRunRequest>
    implements $SubmitToolOutputsRunRequestCopyWith<$Res> {
  _$SubmitToolOutputsRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolOutputs = null,
  }) {
    return _then(_value.copyWith(
      toolOutputs: null == toolOutputs
          ? _value.toolOutputs
          : toolOutputs // ignore: cast_nullable_to_non_nullable
              as List<RunSubmitToolOutput>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubmitToolOutputsRunRequestImplCopyWith<$Res>
    implements $SubmitToolOutputsRunRequestCopyWith<$Res> {
  factory _$$SubmitToolOutputsRunRequestImplCopyWith(
          _$SubmitToolOutputsRunRequestImpl value,
          $Res Function(_$SubmitToolOutputsRunRequestImpl) then) =
      __$$SubmitToolOutputsRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_outputs') List<RunSubmitToolOutput> toolOutputs});
}

/// @nodoc
class __$$SubmitToolOutputsRunRequestImplCopyWithImpl<$Res>
    extends _$SubmitToolOutputsRunRequestCopyWithImpl<$Res,
        _$SubmitToolOutputsRunRequestImpl>
    implements _$$SubmitToolOutputsRunRequestImplCopyWith<$Res> {
  __$$SubmitToolOutputsRunRequestImplCopyWithImpl(
      _$SubmitToolOutputsRunRequestImpl _value,
      $Res Function(_$SubmitToolOutputsRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolOutputs = null,
  }) {
    return _then(_$SubmitToolOutputsRunRequestImpl(
      toolOutputs: null == toolOutputs
          ? _value._toolOutputs
          : toolOutputs // ignore: cast_nullable_to_non_nullable
              as List<RunSubmitToolOutput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubmitToolOutputsRunRequestImpl extends _SubmitToolOutputsRunRequest {
  const _$SubmitToolOutputsRunRequestImpl(
      {@JsonKey(name: 'tool_outputs')
      required final List<RunSubmitToolOutput> toolOutputs})
      : _toolOutputs = toolOutputs,
        super._();

  factory _$SubmitToolOutputsRunRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$SubmitToolOutputsRunRequestImplFromJson(json);

  /// A list of tools for which the outputs are being submitted.
  final List<RunSubmitToolOutput> _toolOutputs;

  /// A list of tools for which the outputs are being submitted.
  @override
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs {
    if (_toolOutputs is EqualUnmodifiableListView) return _toolOutputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolOutputs);
  }

  @override
  String toString() {
    return 'SubmitToolOutputsRunRequest(toolOutputs: $toolOutputs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubmitToolOutputsRunRequestImpl &&
            const DeepCollectionEquality()
                .equals(other._toolOutputs, _toolOutputs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_toolOutputs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SubmitToolOutputsRunRequestImplCopyWith<_$SubmitToolOutputsRunRequestImpl>
      get copyWith => __$$SubmitToolOutputsRunRequestImplCopyWithImpl<
          _$SubmitToolOutputsRunRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SubmitToolOutputsRunRequestImplToJson(
      this,
    );
  }
}

abstract class _SubmitToolOutputsRunRequest
    extends SubmitToolOutputsRunRequest {
  const factory _SubmitToolOutputsRunRequest(
          {@JsonKey(name: 'tool_outputs')
          required final List<RunSubmitToolOutput> toolOutputs}) =
      _$SubmitToolOutputsRunRequestImpl;
  const _SubmitToolOutputsRunRequest._() : super._();

  factory _SubmitToolOutputsRunRequest.fromJson(Map<String, dynamic> json) =
      _$SubmitToolOutputsRunRequestImpl.fromJson;

  @override

  /// A list of tools for which the outputs are being submitted.
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs;
  @override
  @JsonKey(ignore: true)
  _$$SubmitToolOutputsRunRequestImplCopyWith<_$SubmitToolOutputsRunRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunSubmitToolOutput _$RunSubmitToolOutputFromJson(Map<String, dynamic> json) {
  return _RunSubmitToolOutput.fromJson(json);
}

/// @nodoc
mixin _$RunSubmitToolOutput {
  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  String? get toolCallId => throw _privateConstructorUsedError;

  /// The output of the tool call to be submitted to continue the run.
  @JsonKey(includeIfNull: false)
  String? get output => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunSubmitToolOutputCopyWith<RunSubmitToolOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunSubmitToolOutputCopyWith<$Res> {
  factory $RunSubmitToolOutputCopyWith(
          RunSubmitToolOutput value, $Res Function(RunSubmitToolOutput) then) =
      _$RunSubmitToolOutputCopyWithImpl<$Res, RunSubmitToolOutput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class _$RunSubmitToolOutputCopyWithImpl<$Res, $Val extends RunSubmitToolOutput>
    implements $RunSubmitToolOutputCopyWith<$Res> {
  _$RunSubmitToolOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCallId = freezed,
    Object? output = freezed,
  }) {
    return _then(_value.copyWith(
      toolCallId: freezed == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunSubmitToolOutputImplCopyWith<$Res>
    implements $RunSubmitToolOutputCopyWith<$Res> {
  factory _$$RunSubmitToolOutputImplCopyWith(_$RunSubmitToolOutputImpl value,
          $Res Function(_$RunSubmitToolOutputImpl) then) =
      __$$RunSubmitToolOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class __$$RunSubmitToolOutputImplCopyWithImpl<$Res>
    extends _$RunSubmitToolOutputCopyWithImpl<$Res, _$RunSubmitToolOutputImpl>
    implements _$$RunSubmitToolOutputImplCopyWith<$Res> {
  __$$RunSubmitToolOutputImplCopyWithImpl(_$RunSubmitToolOutputImpl _value,
      $Res Function(_$RunSubmitToolOutputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCallId = freezed,
    Object? output = freezed,
  }) {
    return _then(_$RunSubmitToolOutputImpl(
      toolCallId: freezed == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunSubmitToolOutputImpl extends _RunSubmitToolOutput {
  const _$RunSubmitToolOutputImpl(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) this.toolCallId,
      @JsonKey(includeIfNull: false) this.output})
      : super._();

  factory _$RunSubmitToolOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunSubmitToolOutputImplFromJson(json);

  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @override
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  final String? toolCallId;

  /// The output of the tool call to be submitted to continue the run.
  @override
  @JsonKey(includeIfNull: false)
  final String? output;

  @override
  String toString() {
    return 'RunSubmitToolOutput(toolCallId: $toolCallId, output: $output)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunSubmitToolOutputImpl &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, toolCallId, output);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunSubmitToolOutputImplCopyWith<_$RunSubmitToolOutputImpl> get copyWith =>
      __$$RunSubmitToolOutputImplCopyWithImpl<_$RunSubmitToolOutputImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunSubmitToolOutputImplToJson(
      this,
    );
  }
}

abstract class _RunSubmitToolOutput extends RunSubmitToolOutput {
  const factory _RunSubmitToolOutput(
          {@JsonKey(name: 'tool_call_id', includeIfNull: false)
          final String? toolCallId,
          @JsonKey(includeIfNull: false) final String? output}) =
      _$RunSubmitToolOutputImpl;
  const _RunSubmitToolOutput._() : super._();

  factory _RunSubmitToolOutput.fromJson(Map<String, dynamic> json) =
      _$RunSubmitToolOutputImpl.fromJson;

  @override

  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  String? get toolCallId;
  @override

  /// The output of the tool call to be submitted to continue the run.
  @JsonKey(includeIfNull: false)
  String? get output;
  @override
  @JsonKey(ignore: true)
  _$$RunSubmitToolOutputImplCopyWith<_$RunSubmitToolOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunToolCallObject _$RunToolCallObjectFromJson(Map<String, dynamic> json) {
  return _RunToolCallObject.fromJson(json);
}

/// @nodoc
mixin _$RunToolCallObject {
  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  String get id => throw _privateConstructorUsedError;

  /// The type of tool call the output is required for. For now, this is always `function`.
  RunToolCallObjectType get type => throw _privateConstructorUsedError;

  /// The function definition.
  RunToolCallFunction get function => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunToolCallObjectCopyWith<RunToolCallObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunToolCallObjectCopyWith<$Res> {
  factory $RunToolCallObjectCopyWith(
          RunToolCallObject value, $Res Function(RunToolCallObject) then) =
      _$RunToolCallObjectCopyWithImpl<$Res, RunToolCallObject>;
  @useResult
  $Res call(
      {String id, RunToolCallObjectType type, RunToolCallFunction function});

  $RunToolCallFunctionCopyWith<$Res> get function;
}

/// @nodoc
class _$RunToolCallObjectCopyWithImpl<$Res, $Val extends RunToolCallObject>
    implements $RunToolCallObjectCopyWith<$Res> {
  _$RunToolCallObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunToolCallObjectType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunToolCallFunction,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunToolCallFunctionCopyWith<$Res> get function {
    return $RunToolCallFunctionCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunToolCallObjectImplCopyWith<$Res>
    implements $RunToolCallObjectCopyWith<$Res> {
  factory _$$RunToolCallObjectImplCopyWith(_$RunToolCallObjectImpl value,
          $Res Function(_$RunToolCallObjectImpl) then) =
      __$$RunToolCallObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id, RunToolCallObjectType type, RunToolCallFunction function});

  @override
  $RunToolCallFunctionCopyWith<$Res> get function;
}

/// @nodoc
class __$$RunToolCallObjectImplCopyWithImpl<$Res>
    extends _$RunToolCallObjectCopyWithImpl<$Res, _$RunToolCallObjectImpl>
    implements _$$RunToolCallObjectImplCopyWith<$Res> {
  __$$RunToolCallObjectImplCopyWithImpl(_$RunToolCallObjectImpl _value,
      $Res Function(_$RunToolCallObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$RunToolCallObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunToolCallObjectType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunToolCallFunction,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunToolCallObjectImpl extends _RunToolCallObject {
  const _$RunToolCallObjectImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$RunToolCallObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunToolCallObjectImplFromJson(json);

  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  @override
  final String id;

  /// The type of tool call the output is required for. For now, this is always `function`.
  @override
  final RunToolCallObjectType type;

  /// The function definition.
  @override
  final RunToolCallFunction function;

  @override
  String toString() {
    return 'RunToolCallObject(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunToolCallObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunToolCallObjectImplCopyWith<_$RunToolCallObjectImpl> get copyWith =>
      __$$RunToolCallObjectImplCopyWithImpl<_$RunToolCallObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunToolCallObjectImplToJson(
      this,
    );
  }
}

abstract class _RunToolCallObject extends RunToolCallObject {
  const factory _RunToolCallObject(
      {required final String id,
      required final RunToolCallObjectType type,
      required final RunToolCallFunction function}) = _$RunToolCallObjectImpl;
  const _RunToolCallObject._() : super._();

  factory _RunToolCallObject.fromJson(Map<String, dynamic> json) =
      _$RunToolCallObjectImpl.fromJson;

  @override

  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  String get id;
  @override

  /// The type of tool call the output is required for. For now, this is always `function`.
  RunToolCallObjectType get type;
  @override

  /// The function definition.
  RunToolCallFunction get function;
  @override
  @JsonKey(ignore: true)
  _$$RunToolCallObjectImplCopyWith<_$RunToolCallObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunToolCallFunction _$RunToolCallFunctionFromJson(Map<String, dynamic> json) {
  return _RunToolCallFunction.fromJson(json);
}

/// @nodoc
mixin _$RunToolCallFunction {
  /// The name of the function.
  String get name => throw _privateConstructorUsedError;

  /// The arguments that the model expects you to pass to the function.
  String get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunToolCallFunctionCopyWith<RunToolCallFunction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunToolCallFunctionCopyWith<$Res> {
  factory $RunToolCallFunctionCopyWith(
          RunToolCallFunction value, $Res Function(RunToolCallFunction) then) =
      _$RunToolCallFunctionCopyWithImpl<$Res, RunToolCallFunction>;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$RunToolCallFunctionCopyWithImpl<$Res, $Val extends RunToolCallFunction>
    implements $RunToolCallFunctionCopyWith<$Res> {
  _$RunToolCallFunctionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunToolCallFunctionImplCopyWith<$Res>
    implements $RunToolCallFunctionCopyWith<$Res> {
  factory _$$RunToolCallFunctionImplCopyWith(_$RunToolCallFunctionImpl value,
          $Res Function(_$RunToolCallFunctionImpl) then) =
      __$$RunToolCallFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$$RunToolCallFunctionImplCopyWithImpl<$Res>
    extends _$RunToolCallFunctionCopyWithImpl<$Res, _$RunToolCallFunctionImpl>
    implements _$$RunToolCallFunctionImplCopyWith<$Res> {
  __$$RunToolCallFunctionImplCopyWithImpl(_$RunToolCallFunctionImpl _value,
      $Res Function(_$RunToolCallFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_$RunToolCallFunctionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunToolCallFunctionImpl extends _RunToolCallFunction {
  const _$RunToolCallFunctionImpl({required this.name, required this.arguments})
      : super._();

  factory _$RunToolCallFunctionImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunToolCallFunctionImplFromJson(json);

  /// The name of the function.
  @override
  final String name;

  /// The arguments that the model expects you to pass to the function.
  @override
  final String arguments;

  @override
  String toString() {
    return 'RunToolCallFunction(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunToolCallFunctionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunToolCallFunctionImplCopyWith<_$RunToolCallFunctionImpl> get copyWith =>
      __$$RunToolCallFunctionImplCopyWithImpl<_$RunToolCallFunctionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunToolCallFunctionImplToJson(
      this,
    );
  }
}

abstract class _RunToolCallFunction extends RunToolCallFunction {
  const factory _RunToolCallFunction(
      {required final String name,
      required final String arguments}) = _$RunToolCallFunctionImpl;
  const _RunToolCallFunction._() : super._();

  factory _RunToolCallFunction.fromJson(Map<String, dynamic> json) =
      _$RunToolCallFunctionImpl.fromJson;

  @override

  /// The name of the function.
  String get name;
  @override

  /// The arguments that the model expects you to pass to the function.
  String get arguments;
  @override
  @JsonKey(ignore: true)
  _$$RunToolCallFunctionImplCopyWith<_$RunToolCallFunctionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateThreadAndRunRequest _$CreateThreadAndRunRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateThreadAndRunRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateThreadAndRunRequest {
  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// If no thread is provided, an empty thread will be created.
  @JsonKey(includeIfNull: false)
  CreateThreadRequest? get thread => throw _privateConstructorUsedError;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @JsonKey(includeIfNull: false)
  String? get model => throw _privateConstructorUsedError;

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateThreadAndRunRequestCopyWith<CreateThreadAndRunRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateThreadAndRunRequestCopyWith<$Res> {
  factory $CreateThreadAndRunRequestCopyWith(CreateThreadAndRunRequest value,
          $Res Function(CreateThreadAndRunRequest) then) =
      _$CreateThreadAndRunRequestCopyWithImpl<$Res, CreateThreadAndRunRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $CreateThreadRequestCopyWith<$Res>? get thread;
}

/// @nodoc
class _$CreateThreadAndRunRequestCopyWithImpl<$Res,
        $Val extends CreateThreadAndRunRequest>
    implements $CreateThreadAndRunRequestCopyWith<$Res> {
  _$CreateThreadAndRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? thread = freezed,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      thread: freezed == thread
          ? _value.thread
          : thread // ignore: cast_nullable_to_non_nullable
              as CreateThreadRequest?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateThreadRequestCopyWith<$Res>? get thread {
    if (_value.thread == null) {
      return null;
    }

    return $CreateThreadRequestCopyWith<$Res>(_value.thread!, (value) {
      return _then(_value.copyWith(thread: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateThreadAndRunRequestImplCopyWith<$Res>
    implements $CreateThreadAndRunRequestCopyWith<$Res> {
  factory _$$CreateThreadAndRunRequestImplCopyWith(
          _$CreateThreadAndRunRequestImpl value,
          $Res Function(_$CreateThreadAndRunRequestImpl) then) =
      __$$CreateThreadAndRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $CreateThreadRequestCopyWith<$Res>? get thread;
}

/// @nodoc
class __$$CreateThreadAndRunRequestImplCopyWithImpl<$Res>
    extends _$CreateThreadAndRunRequestCopyWithImpl<$Res,
        _$CreateThreadAndRunRequestImpl>
    implements _$$CreateThreadAndRunRequestImplCopyWith<$Res> {
  __$$CreateThreadAndRunRequestImplCopyWithImpl(
      _$CreateThreadAndRunRequestImpl _value,
      $Res Function(_$CreateThreadAndRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? thread = freezed,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateThreadAndRunRequestImpl(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      thread: freezed == thread
          ? _value.thread
          : thread // ignore: cast_nullable_to_non_nullable
              as CreateThreadRequest?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadAndRunRequestImpl extends _CreateThreadAndRunRequest {
  const _$CreateThreadAndRunRequestImpl(
      {@JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(includeIfNull: false) this.thread,
      @JsonKey(includeIfNull: false) this.model,
      @JsonKey(includeIfNull: false) this.instructions,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _tools = tools,
        _metadata = metadata,
        super._();

  factory _$CreateThreadAndRunRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateThreadAndRunRequestImplFromJson(json);

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// If no thread is provided, an empty thread will be created.
  @override
  @JsonKey(includeIfNull: false)
  final CreateThreadRequest? thread;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  final List<AssistantTools>? _tools;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateThreadAndRunRequest(assistantId: $assistantId, thread: $thread, model: $model, instructions: $instructions, tools: $tools, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateThreadAndRunRequestImpl &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.thread, thread) || other.thread == thread) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      thread,
      model,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadAndRunRequestImplCopyWith<_$CreateThreadAndRunRequestImpl>
      get copyWith => __$$CreateThreadAndRunRequestImplCopyWithImpl<
          _$CreateThreadAndRunRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadAndRunRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateThreadAndRunRequest extends CreateThreadAndRunRequest {
  const factory _CreateThreadAndRunRequest(
      {@JsonKey(name: 'assistant_id') required final String assistantId,
      @JsonKey(includeIfNull: false) final CreateThreadRequest? thread,
      @JsonKey(includeIfNull: false) final String? model,
      @JsonKey(includeIfNull: false) final String? instructions,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$CreateThreadAndRunRequestImpl;
  const _CreateThreadAndRunRequest._() : super._();

  factory _CreateThreadAndRunRequest.fromJson(Map<String, dynamic> json) =
      _$CreateThreadAndRunRequestImpl.fromJson;

  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// If no thread is provided, an empty thread will be created.
  @JsonKey(includeIfNull: false)
  CreateThreadRequest? get thread;
  @override

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @JsonKey(includeIfNull: false)
  String? get model;
  @override

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateThreadAndRunRequestImplCopyWith<_$CreateThreadAndRunRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ThreadObject _$ThreadObjectFromJson(Map<String, dynamic> json) {
  return _ThreadObject.fromJson(json);
}

/// @nodoc
mixin _$ThreadObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread`.
  ThreadObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the thread was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ThreadObjectCopyWith<ThreadObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThreadObjectCopyWith<$Res> {
  factory $ThreadObjectCopyWith(
          ThreadObject value, $Res Function(ThreadObject) then) =
      _$ThreadObjectCopyWithImpl<$Res, ThreadObject>;
  @useResult
  $Res call(
      {String id,
      ThreadObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ThreadObjectCopyWithImpl<$Res, $Val extends ThreadObject>
    implements $ThreadObjectCopyWith<$Res> {
  _$ThreadObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ThreadObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ThreadObjectImplCopyWith<$Res>
    implements $ThreadObjectCopyWith<$Res> {
  factory _$$ThreadObjectImplCopyWith(
          _$ThreadObjectImpl value, $Res Function(_$ThreadObjectImpl) then) =
      __$$ThreadObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      ThreadObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ThreadObjectImplCopyWithImpl<$Res>
    extends _$ThreadObjectCopyWithImpl<$Res, _$ThreadObjectImpl>
    implements _$$ThreadObjectImplCopyWith<$Res> {
  __$$ThreadObjectImplCopyWithImpl(
      _$ThreadObjectImpl _value, $Res Function(_$ThreadObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? metadata = freezed,
  }) {
    return _then(_$ThreadObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ThreadObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ThreadObjectImpl extends _ThreadObject {
  const _$ThreadObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      required final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ThreadObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$ThreadObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread`.
  @override
  final ThreadObjectObject object;

  /// The Unix timestamp (in seconds) for when the thread was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ThreadObject(id: $id, object: $object, createdAt: $createdAt, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThreadObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, createdAt,
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ThreadObjectImplCopyWith<_$ThreadObjectImpl> get copyWith =>
      __$$ThreadObjectImplCopyWithImpl<_$ThreadObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ThreadObjectImplToJson(
      this,
    );
  }
}

abstract class _ThreadObject extends ThreadObject {
  const factory _ThreadObject(
      {required final String id,
      required final ThreadObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final Map<String, dynamic>? metadata}) = _$ThreadObjectImpl;
  const _ThreadObject._() : super._();

  factory _ThreadObject.fromJson(Map<String, dynamic> json) =
      _$ThreadObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread`.
  ThreadObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the thread was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ThreadObjectImplCopyWith<_$ThreadObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateThreadRequest _$CreateThreadRequestFromJson(Map<String, dynamic> json) {
  return _CreateThreadRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateThreadRequest {
  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages =>
      throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateThreadRequestCopyWith<CreateThreadRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateThreadRequestCopyWith<$Res> {
  factory $CreateThreadRequestCopyWith(
          CreateThreadRequest value, $Res Function(CreateThreadRequest) then) =
      _$CreateThreadRequestCopyWithImpl<$Res, CreateThreadRequest>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$CreateThreadRequestCopyWithImpl<$Res, $Val extends CreateThreadRequest>
    implements $CreateThreadRequestCopyWith<$Res> {
  _$CreateThreadRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messages = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      messages: freezed == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateThreadRequestImplCopyWith<$Res>
    implements $CreateThreadRequestCopyWith<$Res> {
  factory _$$CreateThreadRequestImplCopyWith(_$CreateThreadRequestImpl value,
          $Res Function(_$CreateThreadRequestImpl) then) =
      __$$CreateThreadRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$CreateThreadRequestImplCopyWithImpl<$Res>
    extends _$CreateThreadRequestCopyWithImpl<$Res, _$CreateThreadRequestImpl>
    implements _$$CreateThreadRequestImplCopyWith<$Res> {
  __$$CreateThreadRequestImplCopyWithImpl(_$CreateThreadRequestImpl _value,
      $Res Function(_$CreateThreadRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messages = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateThreadRequestImpl(
      messages: freezed == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadRequestImpl extends _CreateThreadRequest {
  const _$CreateThreadRequestImpl(
      {@JsonKey(includeIfNull: false)
      final List<CreateMessageRequest>? messages,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _messages = messages,
        _metadata = metadata,
        super._();

  factory _$CreateThreadRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateThreadRequestImplFromJson(json);

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  final List<CreateMessageRequest>? _messages;

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @override
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages {
    final value = _messages;
    if (value == null) return null;
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateThreadRequest(messages: $messages, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateThreadRequestImpl &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_messages),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadRequestImplCopyWith<_$CreateThreadRequestImpl> get copyWith =>
      __$$CreateThreadRequestImplCopyWithImpl<_$CreateThreadRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateThreadRequest extends CreateThreadRequest {
  const factory _CreateThreadRequest(
      {@JsonKey(includeIfNull: false)
      final List<CreateMessageRequest>? messages,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$CreateThreadRequestImpl;
  const _CreateThreadRequest._() : super._();

  factory _CreateThreadRequest.fromJson(Map<String, dynamic> json) =
      _$CreateThreadRequestImpl.fromJson;

  @override

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateThreadRequestImplCopyWith<_$CreateThreadRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModifyThreadRequest _$ModifyThreadRequestFromJson(Map<String, dynamic> json) {
  return _ModifyThreadRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyThreadRequest {
  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyThreadRequestCopyWith<ModifyThreadRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyThreadRequestCopyWith<$Res> {
  factory $ModifyThreadRequestCopyWith(
          ModifyThreadRequest value, $Res Function(ModifyThreadRequest) then) =
      _$ModifyThreadRequestCopyWithImpl<$Res, ModifyThreadRequest>;
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyThreadRequestCopyWithImpl<$Res, $Val extends ModifyThreadRequest>
    implements $ModifyThreadRequestCopyWith<$Res> {
  _$ModifyThreadRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModifyThreadRequestImplCopyWith<$Res>
    implements $ModifyThreadRequestCopyWith<$Res> {
  factory _$$ModifyThreadRequestImplCopyWith(_$ModifyThreadRequestImpl value,
          $Res Function(_$ModifyThreadRequestImpl) then) =
      __$$ModifyThreadRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ModifyThreadRequestImplCopyWithImpl<$Res>
    extends _$ModifyThreadRequestCopyWithImpl<$Res, _$ModifyThreadRequestImpl>
    implements _$$ModifyThreadRequestImplCopyWith<$Res> {
  __$$ModifyThreadRequestImplCopyWithImpl(_$ModifyThreadRequestImpl _value,
      $Res Function(_$ModifyThreadRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_$ModifyThreadRequestImpl(
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyThreadRequestImpl extends _ModifyThreadRequest {
  const _$ModifyThreadRequestImpl(
      {@JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ModifyThreadRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyThreadRequestImplFromJson(json);

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ModifyThreadRequest(metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyThreadRequestImpl &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyThreadRequestImplCopyWith<_$ModifyThreadRequestImpl> get copyWith =>
      __$$ModifyThreadRequestImplCopyWithImpl<_$ModifyThreadRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyThreadRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyThreadRequest extends ModifyThreadRequest {
  const factory _ModifyThreadRequest(
      {@JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$ModifyThreadRequestImpl;
  const _ModifyThreadRequest._() : super._();

  factory _ModifyThreadRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyThreadRequestImpl.fromJson;

  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ModifyThreadRequestImplCopyWith<_$ModifyThreadRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeleteThreadResponse _$DeleteThreadResponseFromJson(Map<String, dynamic> json) {
  return _DeleteThreadResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteThreadResponse {
  /// The thread identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the thread was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.deleted`.
  DeleteThreadResponseObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteThreadResponseCopyWith<DeleteThreadResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteThreadResponseCopyWith<$Res> {
  factory $DeleteThreadResponseCopyWith(DeleteThreadResponse value,
          $Res Function(DeleteThreadResponse) then) =
      _$DeleteThreadResponseCopyWithImpl<$Res, DeleteThreadResponse>;
  @useResult
  $Res call({String id, bool deleted, DeleteThreadResponseObject object});
}

/// @nodoc
class _$DeleteThreadResponseCopyWithImpl<$Res,
        $Val extends DeleteThreadResponse>
    implements $DeleteThreadResponseCopyWith<$Res> {
  _$DeleteThreadResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteThreadResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteThreadResponseImplCopyWith<$Res>
    implements $DeleteThreadResponseCopyWith<$Res> {
  factory _$$DeleteThreadResponseImplCopyWith(_$DeleteThreadResponseImpl value,
          $Res Function(_$DeleteThreadResponseImpl) then) =
      __$$DeleteThreadResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteThreadResponseObject object});
}

/// @nodoc
class __$$DeleteThreadResponseImplCopyWithImpl<$Res>
    extends _$DeleteThreadResponseCopyWithImpl<$Res, _$DeleteThreadResponseImpl>
    implements _$$DeleteThreadResponseImplCopyWith<$Res> {
  __$$DeleteThreadResponseImplCopyWithImpl(_$DeleteThreadResponseImpl _value,
      $Res Function(_$DeleteThreadResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteThreadResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteThreadResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteThreadResponseImpl extends _DeleteThreadResponse {
  const _$DeleteThreadResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteThreadResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteThreadResponseImplFromJson(json);

  /// The thread identifier.
  @override
  final String id;

  /// Whether the thread was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `thread.deleted`.
  @override
  final DeleteThreadResponseObject object;

  @override
  String toString() {
    return 'DeleteThreadResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteThreadResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteThreadResponseImplCopyWith<_$DeleteThreadResponseImpl>
      get copyWith =>
          __$$DeleteThreadResponseImplCopyWithImpl<_$DeleteThreadResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteThreadResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteThreadResponse extends DeleteThreadResponse {
  const factory _DeleteThreadResponse(
          {required final String id,
          required final bool deleted,
          required final DeleteThreadResponseObject object}) =
      _$DeleteThreadResponseImpl;
  const _DeleteThreadResponse._() : super._();

  factory _DeleteThreadResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteThreadResponseImpl.fromJson;

  @override

  /// The thread identifier.
  String get id;
  @override

  /// Whether the thread was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `thread.deleted`.
  DeleteThreadResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteThreadResponseImplCopyWith<_$DeleteThreadResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListThreadsResponse _$ListThreadsResponseFromJson(Map<String, dynamic> json) {
  return _ListThreadsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListThreadsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of threads.
  List<ThreadObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first thread in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last thread in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more threads to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListThreadsResponseCopyWith<ListThreadsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListThreadsResponseCopyWith<$Res> {
  factory $ListThreadsResponseCopyWith(
          ListThreadsResponse value, $Res Function(ListThreadsResponse) then) =
      _$ListThreadsResponseCopyWithImpl<$Res, ListThreadsResponse>;
  @useResult
  $Res call(
      {String object,
      List<ThreadObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListThreadsResponseCopyWithImpl<$Res, $Val extends ListThreadsResponse>
    implements $ListThreadsResponseCopyWith<$Res> {
  _$ListThreadsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ThreadObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListThreadsResponseImplCopyWith<$Res>
    implements $ListThreadsResponseCopyWith<$Res> {
  factory _$$ListThreadsResponseImplCopyWith(_$ListThreadsResponseImpl value,
          $Res Function(_$ListThreadsResponseImpl) then) =
      __$$ListThreadsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<ThreadObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListThreadsResponseImplCopyWithImpl<$Res>
    extends _$ListThreadsResponseCopyWithImpl<$Res, _$ListThreadsResponseImpl>
    implements _$$ListThreadsResponseImplCopyWith<$Res> {
  __$$ListThreadsResponseImplCopyWithImpl(_$ListThreadsResponseImpl _value,
      $Res Function(_$ListThreadsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListThreadsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ThreadObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListThreadsResponseImpl extends _ListThreadsResponse {
  const _$ListThreadsResponseImpl(
      {required this.object,
      required final List<ThreadObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListThreadsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListThreadsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of threads.
  final List<ThreadObject> _data;

  /// The list of threads.
  @override
  List<ThreadObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first thread in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last thread in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more threads to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListThreadsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListThreadsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListThreadsResponseImplCopyWith<_$ListThreadsResponseImpl> get copyWith =>
      __$$ListThreadsResponseImplCopyWithImpl<_$ListThreadsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListThreadsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListThreadsResponse extends ListThreadsResponse {
  const factory _ListThreadsResponse(
          {required final String object,
          required final List<ThreadObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListThreadsResponseImpl;
  const _ListThreadsResponse._() : super._();

  factory _ListThreadsResponse.fromJson(Map<String, dynamic> json) =
      _$ListThreadsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of threads.
  List<ThreadObject> get data;
  @override

  /// The ID of the first thread in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last thread in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more threads to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListThreadsResponseImplCopyWith<_$ListThreadsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageObject _$MessageObjectFromJson(Map<String, dynamic> json) {
  return _MessageObject.fromJson(json);
}

/// @nodoc
mixin _$MessageObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.message`.
  MessageObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the message was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @JsonKey(name: 'thread_id')
  String get threadId => throw _privateConstructorUsedError;

  /// The entity that produced the message. One of `user` or `assistant`.
  MessageObjectRole get role => throw _privateConstructorUsedError;

  /// The content of the message in array of text and/or images.
  List<MessageContent> get content => throw _privateConstructorUsedError;

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @JsonKey(name: 'assistant_id')
  String? get assistantId => throw _privateConstructorUsedError;

  /// If applicable, the ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the authoring of this message.
  @JsonKey(name: 'run_id')
  String? get runId => throw _privateConstructorUsedError;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageObjectCopyWith<MessageObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageObjectCopyWith<$Res> {
  factory $MessageObjectCopyWith(
          MessageObject value, $Res Function(MessageObject) then) =
      _$MessageObjectCopyWithImpl<$Res, MessageObject>;
  @useResult
  $Res call(
      {String id,
      MessageObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      MessageObjectRole role,
      List<MessageContent> content,
      @JsonKey(name: 'assistant_id') String? assistantId,
      @JsonKey(name: 'run_id') String? runId,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$MessageObjectCopyWithImpl<$Res, $Val extends MessageObject>
    implements $MessageObjectCopyWith<$Res> {
  _$MessageObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? role = null,
    Object? content = null,
    Object? assistantId = freezed,
    Object? runId = freezed,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageObjectRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
      assistantId: freezed == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String?,
      runId: freezed == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageObjectImplCopyWith<$Res>
    implements $MessageObjectCopyWith<$Res> {
  factory _$$MessageObjectImplCopyWith(
          _$MessageObjectImpl value, $Res Function(_$MessageObjectImpl) then) =
      __$$MessageObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      MessageObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      MessageObjectRole role,
      List<MessageContent> content,
      @JsonKey(name: 'assistant_id') String? assistantId,
      @JsonKey(name: 'run_id') String? runId,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$MessageObjectImplCopyWithImpl<$Res>
    extends _$MessageObjectCopyWithImpl<$Res, _$MessageObjectImpl>
    implements _$$MessageObjectImplCopyWith<$Res> {
  __$$MessageObjectImplCopyWithImpl(
      _$MessageObjectImpl _value, $Res Function(_$MessageObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? role = null,
    Object? content = null,
    Object? assistantId = freezed,
    Object? runId = freezed,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_$MessageObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageObjectRole,
      content: null == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
      assistantId: freezed == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String?,
      runId: freezed == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageObjectImpl extends _MessageObject {
  const _$MessageObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'thread_id') required this.threadId,
      required this.role,
      required final List<MessageContent> content,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(name: 'run_id') required this.runId,
      @JsonKey(name: 'file_ids') required final List<String> fileIds,
      required final Map<String, dynamic>? metadata})
      : _content = content,
        _fileIds = fileIds,
        _metadata = metadata,
        super._();

  factory _$MessageObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.message`.
  @override
  final MessageObjectObject object;

  /// The Unix timestamp (in seconds) for when the message was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The entity that produced the message. One of `user` or `assistant`.
  @override
  final MessageObjectRole role;

  /// The content of the message in array of text and/or images.
  final List<MessageContent> _content;

  /// The content of the message in array of text and/or images.
  @override
  List<MessageContent> get content {
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_content);
  }

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @override
  @JsonKey(name: 'assistant_id')
  final String? assistantId;

  /// If applicable, the ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the authoring of this message.
  @override
  @JsonKey(name: 'run_id')
  final String? runId;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
  final List<String> _fileIds;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'MessageObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, role: $role, content: $content, assistantId: $assistantId, runId: $runId, fileIds: $fileIds, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      threadId,
      role,
      const DeepCollectionEquality().hash(_content),
      assistantId,
      runId,
      const DeepCollectionEquality().hash(_fileIds),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageObjectImplCopyWith<_$MessageObjectImpl> get copyWith =>
      __$$MessageObjectImplCopyWithImpl<_$MessageObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageObjectImplToJson(
      this,
    );
  }
}

abstract class _MessageObject extends MessageObject {
  const factory _MessageObject(
      {required final String id,
      required final MessageObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'thread_id') required final String threadId,
      required final MessageObjectRole role,
      required final List<MessageContent> content,
      @JsonKey(name: 'assistant_id') required final String? assistantId,
      @JsonKey(name: 'run_id') required final String? runId,
      @JsonKey(name: 'file_ids') required final List<String> fileIds,
      required final Map<String, dynamic>? metadata}) = _$MessageObjectImpl;
  const _MessageObject._() : super._();

  factory _MessageObject.fromJson(Map<String, dynamic> json) =
      _$MessageObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.message`.
  MessageObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the message was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @JsonKey(name: 'thread_id')
  String get threadId;
  @override

  /// The entity that produced the message. One of `user` or `assistant`.
  MessageObjectRole get role;
  @override

  /// The content of the message in array of text and/or images.
  List<MessageContent> get content;
  @override

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @JsonKey(name: 'assistant_id')
  String? get assistantId;
  @override

  /// If applicable, the ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the authoring of this message.
  @JsonKey(name: 'run_id')
  String? get runId;
  @override

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$MessageObjectImplCopyWith<_$MessageObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateMessageRequest _$CreateMessageRequestFromJson(Map<String, dynamic> json) {
  return _CreateMessageRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateMessageRequest {
  /// The role of the entity that is creating the message. Currently only `user` is supported.
  CreateMessageRequestRole get role => throw _privateConstructorUsedError;

  /// The content of the message.
  String get content => throw _privateConstructorUsedError;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the message should use. There can be a maximum of 10 files attached to a message. Useful for tools like `retrieval` and `code_interpreter` that can access and use files.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateMessageRequestCopyWith<CreateMessageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateMessageRequestCopyWith<$Res> {
  factory $CreateMessageRequestCopyWith(CreateMessageRequest value,
          $Res Function(CreateMessageRequest) then) =
      _$CreateMessageRequestCopyWithImpl<$Res, CreateMessageRequest>;
  @useResult
  $Res call(
      {CreateMessageRequestRole role,
      String content,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$CreateMessageRequestCopyWithImpl<$Res,
        $Val extends CreateMessageRequest>
    implements $CreateMessageRequestCopyWith<$Res> {
  _$CreateMessageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CreateMessageRequestRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateMessageRequestImplCopyWith<$Res>
    implements $CreateMessageRequestCopyWith<$Res> {
  factory _$$CreateMessageRequestImplCopyWith(_$CreateMessageRequestImpl value,
          $Res Function(_$CreateMessageRequestImpl) then) =
      __$$CreateMessageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {CreateMessageRequestRole role,
      String content,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$CreateMessageRequestImplCopyWithImpl<$Res>
    extends _$CreateMessageRequestCopyWithImpl<$Res, _$CreateMessageRequestImpl>
    implements _$$CreateMessageRequestImplCopyWith<$Res> {
  __$$CreateMessageRequestImplCopyWithImpl(_$CreateMessageRequestImpl _value,
      $Res Function(_$CreateMessageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? fileIds = null,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateMessageRequestImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CreateMessageRequestRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateMessageRequestImpl extends _CreateMessageRequest {
  const _$CreateMessageRequestImpl(
      {required this.role,
      required this.content,
      @JsonKey(name: 'file_ids') final List<String> fileIds = const [],
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _fileIds = fileIds,
        _metadata = metadata,
        super._();

  factory _$CreateMessageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateMessageRequestImplFromJson(json);

  /// The role of the entity that is creating the message. Currently only `user` is supported.
  @override
  final CreateMessageRequestRole role;

  /// The content of the message.
  @override
  final String content;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the message should use. There can be a maximum of 10 files attached to a message. Useful for tools like `retrieval` and `code_interpreter` that can access and use files.
  final List<String> _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the message should use. There can be a maximum of 10 files attached to a message. Useful for tools like `retrieval` and `code_interpreter` that can access and use files.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateMessageRequest(role: $role, content: $content, fileIds: $fileIds, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateMessageRequestImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      role,
      content,
      const DeepCollectionEquality().hash(_fileIds),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateMessageRequestImplCopyWith<_$CreateMessageRequestImpl>
      get copyWith =>
          __$$CreateMessageRequestImplCopyWithImpl<_$CreateMessageRequestImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateMessageRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateMessageRequest extends CreateMessageRequest {
  const factory _CreateMessageRequest(
      {required final CreateMessageRequestRole role,
      required final String content,
      @JsonKey(name: 'file_ids') final List<String> fileIds,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$CreateMessageRequestImpl;
  const _CreateMessageRequest._() : super._();

  factory _CreateMessageRequest.fromJson(Map<String, dynamic> json) =
      _$CreateMessageRequestImpl.fromJson;

  @override

  /// The role of the entity that is creating the message. Currently only `user` is supported.
  CreateMessageRequestRole get role;
  @override

  /// The content of the message.
  String get content;
  @override

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the message should use. There can be a maximum of 10 files attached to a message. Useful for tools like `retrieval` and `code_interpreter` that can access and use files.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateMessageRequestImplCopyWith<_$CreateMessageRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModifyMessageRequest _$ModifyMessageRequestFromJson(Map<String, dynamic> json) {
  return _ModifyMessageRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyMessageRequest {
  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyMessageRequestCopyWith<ModifyMessageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyMessageRequestCopyWith<$Res> {
  factory $ModifyMessageRequestCopyWith(ModifyMessageRequest value,
          $Res Function(ModifyMessageRequest) then) =
      _$ModifyMessageRequestCopyWithImpl<$Res, ModifyMessageRequest>;
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyMessageRequestCopyWithImpl<$Res,
        $Val extends ModifyMessageRequest>
    implements $ModifyMessageRequestCopyWith<$Res> {
  _$ModifyMessageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModifyMessageRequestImplCopyWith<$Res>
    implements $ModifyMessageRequestCopyWith<$Res> {
  factory _$$ModifyMessageRequestImplCopyWith(_$ModifyMessageRequestImpl value,
          $Res Function(_$ModifyMessageRequestImpl) then) =
      __$$ModifyMessageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ModifyMessageRequestImplCopyWithImpl<$Res>
    extends _$ModifyMessageRequestCopyWithImpl<$Res, _$ModifyMessageRequestImpl>
    implements _$$ModifyMessageRequestImplCopyWith<$Res> {
  __$$ModifyMessageRequestImplCopyWithImpl(_$ModifyMessageRequestImpl _value,
      $Res Function(_$ModifyMessageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_$ModifyMessageRequestImpl(
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyMessageRequestImpl extends _ModifyMessageRequest {
  const _$ModifyMessageRequestImpl(
      {@JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ModifyMessageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyMessageRequestImplFromJson(json);

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ModifyMessageRequest(metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyMessageRequestImpl &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyMessageRequestImplCopyWith<_$ModifyMessageRequestImpl>
      get copyWith =>
          __$$ModifyMessageRequestImplCopyWithImpl<_$ModifyMessageRequestImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyMessageRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyMessageRequest extends ModifyMessageRequest {
  const factory _ModifyMessageRequest(
      {@JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$ModifyMessageRequestImpl;
  const _ModifyMessageRequest._() : super._();

  factory _ModifyMessageRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyMessageRequestImpl.fromJson;

  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ModifyMessageRequestImplCopyWith<_$ModifyMessageRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteMessageResponse _$DeleteMessageResponseFromJson(
    Map<String, dynamic> json) {
  return _DeleteMessageResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteMessageResponse {
  /// The message identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the message was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.message.deleted`.
  DeleteMessageResponseObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteMessageResponseCopyWith<DeleteMessageResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteMessageResponseCopyWith<$Res> {
  factory $DeleteMessageResponseCopyWith(DeleteMessageResponse value,
          $Res Function(DeleteMessageResponse) then) =
      _$DeleteMessageResponseCopyWithImpl<$Res, DeleteMessageResponse>;
  @useResult
  $Res call({String id, bool deleted, DeleteMessageResponseObject object});
}

/// @nodoc
class _$DeleteMessageResponseCopyWithImpl<$Res,
        $Val extends DeleteMessageResponse>
    implements $DeleteMessageResponseCopyWith<$Res> {
  _$DeleteMessageResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteMessageResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteMessageResponseImplCopyWith<$Res>
    implements $DeleteMessageResponseCopyWith<$Res> {
  factory _$$DeleteMessageResponseImplCopyWith(
          _$DeleteMessageResponseImpl value,
          $Res Function(_$DeleteMessageResponseImpl) then) =
      __$$DeleteMessageResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteMessageResponseObject object});
}

/// @nodoc
class __$$DeleteMessageResponseImplCopyWithImpl<$Res>
    extends _$DeleteMessageResponseCopyWithImpl<$Res,
        _$DeleteMessageResponseImpl>
    implements _$$DeleteMessageResponseImplCopyWith<$Res> {
  __$$DeleteMessageResponseImplCopyWithImpl(_$DeleteMessageResponseImpl _value,
      $Res Function(_$DeleteMessageResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteMessageResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteMessageResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteMessageResponseImpl extends _DeleteMessageResponse {
  const _$DeleteMessageResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteMessageResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteMessageResponseImplFromJson(json);

  /// The message identifier.
  @override
  final String id;

  /// Whether the message was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `thread.message.deleted`.
  @override
  final DeleteMessageResponseObject object;

  @override
  String toString() {
    return 'DeleteMessageResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteMessageResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteMessageResponseImplCopyWith<_$DeleteMessageResponseImpl>
      get copyWith => __$$DeleteMessageResponseImplCopyWithImpl<
          _$DeleteMessageResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteMessageResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteMessageResponse extends DeleteMessageResponse {
  const factory _DeleteMessageResponse(
          {required final String id,
          required final bool deleted,
          required final DeleteMessageResponseObject object}) =
      _$DeleteMessageResponseImpl;
  const _DeleteMessageResponse._() : super._();

  factory _DeleteMessageResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteMessageResponseImpl.fromJson;

  @override

  /// The message identifier.
  String get id;
  @override

  /// Whether the message was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `thread.message.deleted`.
  DeleteMessageResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteMessageResponseImplCopyWith<_$DeleteMessageResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListMessagesResponse _$ListMessagesResponseFromJson(Map<String, dynamic> json) {
  return _ListMessagesResponse.fromJson(json);
}

/// @nodoc
mixin _$ListMessagesResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of messages.
  List<MessageObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first message in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last message in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more messages to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListMessagesResponseCopyWith<ListMessagesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListMessagesResponseCopyWith<$Res> {
  factory $ListMessagesResponseCopyWith(ListMessagesResponse value,
          $Res Function(ListMessagesResponse) then) =
      _$ListMessagesResponseCopyWithImpl<$Res, ListMessagesResponse>;
  @useResult
  $Res call(
      {String object,
      List<MessageObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListMessagesResponseCopyWithImpl<$Res,
        $Val extends ListMessagesResponse>
    implements $ListMessagesResponseCopyWith<$Res> {
  _$ListMessagesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListMessagesResponseImplCopyWith<$Res>
    implements $ListMessagesResponseCopyWith<$Res> {
  factory _$$ListMessagesResponseImplCopyWith(_$ListMessagesResponseImpl value,
          $Res Function(_$ListMessagesResponseImpl) then) =
      __$$ListMessagesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<MessageObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListMessagesResponseImplCopyWithImpl<$Res>
    extends _$ListMessagesResponseCopyWithImpl<$Res, _$ListMessagesResponseImpl>
    implements _$$ListMessagesResponseImplCopyWith<$Res> {
  __$$ListMessagesResponseImplCopyWithImpl(_$ListMessagesResponseImpl _value,
      $Res Function(_$ListMessagesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListMessagesResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListMessagesResponseImpl extends _ListMessagesResponse {
  const _$ListMessagesResponseImpl(
      {required this.object,
      required final List<MessageObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListMessagesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListMessagesResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of messages.
  final List<MessageObject> _data;

  /// The list of messages.
  @override
  List<MessageObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first message in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last message in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more messages to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListMessagesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListMessagesResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListMessagesResponseImplCopyWith<_$ListMessagesResponseImpl>
      get copyWith =>
          __$$ListMessagesResponseImplCopyWithImpl<_$ListMessagesResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListMessagesResponseImplToJson(
      this,
    );
  }
}

abstract class _ListMessagesResponse extends ListMessagesResponse {
  const factory _ListMessagesResponse(
          {required final String object,
          required final List<MessageObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListMessagesResponseImpl;
  const _ListMessagesResponse._() : super._();

  factory _ListMessagesResponse.fromJson(Map<String, dynamic> json) =
      _$ListMessagesResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of messages.
  List<MessageObject> get data;
  @override

  /// The ID of the first message in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last message in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more messages to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListMessagesResponseImplCopyWith<_$ListMessagesResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentImageFile _$MessageContentImageFileFromJson(
    Map<String, dynamic> json) {
  return _MessageContentImageFile.fromJson(json);
}

/// @nodoc
mixin _$MessageContentImageFile {
  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentImageFileCopyWith<MessageContentImageFile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentImageFileCopyWith<$Res> {
  factory $MessageContentImageFileCopyWith(MessageContentImageFile value,
          $Res Function(MessageContentImageFile) then) =
      _$MessageContentImageFileCopyWithImpl<$Res, MessageContentImageFile>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$MessageContentImageFileCopyWithImpl<$Res,
        $Val extends MessageContentImageFile>
    implements $MessageContentImageFileCopyWith<$Res> {
  _$MessageContentImageFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentImageFileImplCopyWith<$Res>
    implements $MessageContentImageFileCopyWith<$Res> {
  factory _$$MessageContentImageFileImplCopyWith(
          _$MessageContentImageFileImpl value,
          $Res Function(_$MessageContentImageFileImpl) then) =
      __$$MessageContentImageFileImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$$MessageContentImageFileImplCopyWithImpl<$Res>
    extends _$MessageContentImageFileCopyWithImpl<$Res,
        _$MessageContentImageFileImpl>
    implements _$$MessageContentImageFileImplCopyWith<$Res> {
  __$$MessageContentImageFileImplCopyWithImpl(
      _$MessageContentImageFileImpl _value,
      $Res Function(_$MessageContentImageFileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_$MessageContentImageFileImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentImageFileImpl extends _MessageContentImageFile {
  const _$MessageContentImageFileImpl(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();

  factory _$MessageContentImageFileImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageContentImageFileImplFromJson(json);

  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  @override
  String toString() {
    return 'MessageContentImageFile(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentImageFileImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentImageFileImplCopyWith<_$MessageContentImageFileImpl>
      get copyWith => __$$MessageContentImageFileImplCopyWithImpl<
          _$MessageContentImageFileImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentImageFileImplToJson(
      this,
    );
  }
}

abstract class _MessageContentImageFile extends MessageContentImageFile {
  const factory _MessageContentImageFile(
          {@JsonKey(name: 'file_id') required final String fileId}) =
      _$MessageContentImageFileImpl;
  const _MessageContentImageFile._() : super._();

  factory _MessageContentImageFile.fromJson(Map<String, dynamic> json) =
      _$MessageContentImageFileImpl.fromJson;

  @override

  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentImageFileImplCopyWith<_$MessageContentImageFileImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentText _$MessageContentTextFromJson(Map<String, dynamic> json) {
  return _MessageContentText.fromJson(json);
}

/// @nodoc
mixin _$MessageContentText {
  /// The data that makes up the text.
  String get value => throw _privateConstructorUsedError;

  /// A list of annotations that point to specific quotes from specific files.
  List<MessageContentTextAnnotations> get annotations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextCopyWith<MessageContentText> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextCopyWith<$Res> {
  factory $MessageContentTextCopyWith(
          MessageContentText value, $Res Function(MessageContentText) then) =
      _$MessageContentTextCopyWithImpl<$Res, MessageContentText>;
  @useResult
  $Res call({String value, List<MessageContentTextAnnotations> annotations});
}

/// @nodoc
class _$MessageContentTextCopyWithImpl<$Res, $Val extends MessageContentText>
    implements $MessageContentTextCopyWith<$Res> {
  _$MessageContentTextCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? annotations = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      annotations: null == annotations
          ? _value.annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageContentTextAnnotations>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextImplCopyWith<$Res>
    implements $MessageContentTextCopyWith<$Res> {
  factory _$$MessageContentTextImplCopyWith(_$MessageContentTextImpl value,
          $Res Function(_$MessageContentTextImpl) then) =
      __$$MessageContentTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value, List<MessageContentTextAnnotations> annotations});
}

/// @nodoc
class __$$MessageContentTextImplCopyWithImpl<$Res>
    extends _$MessageContentTextCopyWithImpl<$Res, _$MessageContentTextImpl>
    implements _$$MessageContentTextImplCopyWith<$Res> {
  __$$MessageContentTextImplCopyWithImpl(_$MessageContentTextImpl _value,
      $Res Function(_$MessageContentTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? annotations = null,
  }) {
    return _then(_$MessageContentTextImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      annotations: null == annotations
          ? _value._annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageContentTextAnnotations>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextImpl extends _MessageContentText {
  const _$MessageContentTextImpl(
      {required this.value,
      required final List<MessageContentTextAnnotations> annotations})
      : _annotations = annotations,
        super._();

  factory _$MessageContentTextImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageContentTextImplFromJson(json);

  /// The data that makes up the text.
  @override
  final String value;

  /// A list of annotations that point to specific quotes from specific files.
  final List<MessageContentTextAnnotations> _annotations;

  /// A list of annotations that point to specific quotes from specific files.
  @override
  List<MessageContentTextAnnotations> get annotations {
    if (_annotations is EqualUnmodifiableListView) return _annotations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_annotations);
  }

  @override
  String toString() {
    return 'MessageContentText(value: $value, annotations: $annotations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextImpl &&
            (identical(other.value, value) || other.value == value) &&
            const DeepCollectionEquality()
                .equals(other._annotations, _annotations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, value, const DeepCollectionEquality().hash(_annotations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextImplCopyWith<_$MessageContentTextImpl> get copyWith =>
      __$$MessageContentTextImplCopyWithImpl<_$MessageContentTextImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextImplToJson(
      this,
    );
  }
}

abstract class _MessageContentText extends MessageContentText {
  const factory _MessageContentText(
          {required final String value,
          required final List<MessageContentTextAnnotations> annotations}) =
      _$MessageContentTextImpl;
  const _MessageContentText._() : super._();

  factory _MessageContentText.fromJson(Map<String, dynamic> json) =
      _$MessageContentTextImpl.fromJson;

  @override

  /// The data that makes up the text.
  String get value;
  @override

  /// A list of annotations that point to specific quotes from specific files.
  List<MessageContentTextAnnotations> get annotations;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextImplCopyWith<_$MessageContentTextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageContentTextAnnotationsFileCitation
    _$MessageContentTextAnnotationsFileCitationFromJson(
        Map<String, dynamic> json) {
  return _MessageContentTextAnnotationsFileCitation.fromJson(json);
}

/// @nodoc
mixin _$MessageContentTextAnnotationsFileCitation {
  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  /// The specific quote in the file.
  String get quote => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextAnnotationsFileCitationCopyWith<
          MessageContentTextAnnotationsFileCitation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFileCitationCopyWith(
          MessageContentTextAnnotationsFileCitation value,
          $Res Function(MessageContentTextAnnotationsFileCitation) then) =
      _$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res,
          MessageContentTextAnnotationsFileCitation>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId, String quote});
}

/// @nodoc
class _$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res,
        $Val extends MessageContentTextAnnotationsFileCitation>
    implements $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  _$MessageContentTextAnnotationsFileCitationCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? quote = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      quote: null == quote
          ? _value.quote
          : quote // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFileCitationImplCopyWith<$Res>
    implements $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFileCitationImplCopyWith(
          _$MessageContentTextAnnotationsFileCitationImpl value,
          $Res Function(_$MessageContentTextAnnotationsFileCitationImpl) then) =
      __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId, String quote});
}

/// @nodoc
class __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFileCitationImpl>
    implements _$$MessageContentTextAnnotationsFileCitationImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl(
      _$MessageContentTextAnnotationsFileCitationImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFileCitationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? quote = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFileCitationImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      quote: null == quote
          ? _value.quote
          : quote // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFileCitationImpl
    extends _MessageContentTextAnnotationsFileCitation {
  const _$MessageContentTextAnnotationsFileCitationImpl(
      {@JsonKey(name: 'file_id') required this.fileId, required this.quote})
      : super._();

  factory _$MessageContentTextAnnotationsFileCitationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFileCitationImplFromJson(json);

  /// The ID of the specific File the citation is from.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// The specific quote in the file.
  @override
  final String quote;

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFileCitation(fileId: $fileId, quote: $quote)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFileCitationImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.quote, quote) || other.quote == quote));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, quote);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFileCitationImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationImpl>
      get copyWith =>
          __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl<
                  _$MessageContentTextAnnotationsFileCitationImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFileCitationImplToJson(
      this,
    );
  }
}

abstract class _MessageContentTextAnnotationsFileCitation
    extends MessageContentTextAnnotationsFileCitation {
  const factory _MessageContentTextAnnotationsFileCitation(
          {@JsonKey(name: 'file_id') required final String fileId,
          required final String quote}) =
      _$MessageContentTextAnnotationsFileCitationImpl;
  const _MessageContentTextAnnotationsFileCitation._() : super._();

  factory _MessageContentTextAnnotationsFileCitation.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFileCitationImpl.fromJson;

  @override

  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override

  /// The specific quote in the file.
  String get quote;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFileCitationImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepObject _$RunStepObjectFromJson(Map<String, dynamic> json) {
  return _RunStepObject.fromJson(json);
}

/// @nodoc
mixin _$RunStepObject {
  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.run.step`.
  RunStepObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @JsonKey(name: 'thread_id')
  String get threadId => throw _privateConstructorUsedError;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @JsonKey(name: 'run_id')
  String get runId => throw _privateConstructorUsedError;

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  RunStepType get type => throw _privateConstructorUsedError;

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  RunStepStatus get status => throw _privateConstructorUsedError;

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details')
  RunStepDetails get stepDetails => throw _privateConstructorUsedError;

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunStepLastError? get lastError => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @JsonKey(name: 'expired_at')
  int? get expiredAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  RunStepCompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepObjectCopyWith<RunStepObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepObjectCopyWith<$Res> {
  factory $RunStepObjectCopyWith(
          RunStepObject value, $Res Function(RunStepObject) then) =
      _$RunStepObjectCopyWithImpl<$Res, RunStepObject>;
  @useResult
  $Res call(
      {String id,
      RunStepObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'run_id') String runId,
      RunStepType type,
      RunStepStatus status,
      @JsonKey(name: 'step_details') RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') int? expiredAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      Map<String, dynamic>? metadata,
      RunStepCompletionUsage? usage});

  $RunStepDetailsCopyWith<$Res> get stepDetails;
  $RunStepLastErrorCopyWith<$Res>? get lastError;
  $RunStepCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$RunStepObjectCopyWithImpl<$Res, $Val extends RunStepObject>
    implements $RunStepObjectCopyWith<$Res> {
  _$RunStepObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
    Object? threadId = null,
    Object? runId = null,
    Object? type = null,
    Object? status = null,
    Object? stepDetails = null,
    Object? lastError = freezed,
    Object? expiredAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      runId: null == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepType,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStepStatus,
      stepDetails: null == stepDetails
          ? _value.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDetails,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunStepLastError?,
      expiredAt: freezed == expiredAt
          ? _value.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunStepCompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsCopyWith<$Res> get stepDetails {
    return $RunStepDetailsCopyWith<$Res>(_value.stepDetails, (value) {
      return _then(_value.copyWith(stepDetails: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepLastErrorCopyWith<$Res>? get lastError {
    if (_value.lastError == null) {
      return null;
    }

    return $RunStepLastErrorCopyWith<$Res>(_value.lastError!, (value) {
      return _then(_value.copyWith(lastError: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepCompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $RunStepCompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunStepObjectImplCopyWith<$Res>
    implements $RunStepObjectCopyWith<$Res> {
  factory _$$RunStepObjectImplCopyWith(
          _$RunStepObjectImpl value, $Res Function(_$RunStepObjectImpl) then) =
      __$$RunStepObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      RunStepObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'run_id') String runId,
      RunStepType type,
      RunStepStatus status,
      @JsonKey(name: 'step_details') RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') int? expiredAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      Map<String, dynamic>? metadata,
      RunStepCompletionUsage? usage});

  @override
  $RunStepDetailsCopyWith<$Res> get stepDetails;
  @override
  $RunStepLastErrorCopyWith<$Res>? get lastError;
  @override
  $RunStepCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$RunStepObjectImplCopyWithImpl<$Res>
    extends _$RunStepObjectCopyWithImpl<$Res, _$RunStepObjectImpl>
    implements _$$RunStepObjectImplCopyWith<$Res> {
  __$$RunStepObjectImplCopyWithImpl(
      _$RunStepObjectImpl _value, $Res Function(_$RunStepObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
    Object? threadId = null,
    Object? runId = null,
    Object? type = null,
    Object? status = null,
    Object? stepDetails = null,
    Object? lastError = freezed,
    Object? expiredAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_$RunStepObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      runId: null == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepType,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStepStatus,
      stepDetails: null == stepDetails
          ? _value.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDetails,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunStepLastError?,
      expiredAt: freezed == expiredAt
          ? _value.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunStepCompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepObjectImpl extends _RunStepObject {
  const _$RunStepObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(name: 'run_id') required this.runId,
      required this.type,
      required this.status,
      @JsonKey(name: 'step_details') required this.stepDetails,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'expired_at') required this.expiredAt,
      @JsonKey(name: 'cancelled_at') required this.cancelledAt,
      @JsonKey(name: 'failed_at') required this.failedAt,
      @JsonKey(name: 'completed_at') required this.completedAt,
      required final Map<String, dynamic>? metadata,
      required this.usage})
      : _metadata = metadata,
        super._();

  factory _$RunStepObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepObjectImplFromJson(json);

  /// The identifier of the run step, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run.step`.
  @override
  final RunStepObjectObject object;

  /// The Unix timestamp (in seconds) for when the run step was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @override
  @JsonKey(name: 'run_id')
  final String runId;

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  @override
  final RunStepType type;

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  @override
  final RunStepStatus status;

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @override
  @JsonKey(name: 'step_details')
  final RunStepDetails stepDetails;

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final RunStepLastError? lastError;

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @override
  @JsonKey(name: 'expired_at')
  final int? expiredAt;

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @override
  @JsonKey(name: 'cancelled_at')
  final int? cancelledAt;

  /// The Unix timestamp (in seconds) for when the run step failed.
  @override
  @JsonKey(name: 'failed_at')
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the run step completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  @override
  final RunStepCompletionUsage? usage;

  @override
  String toString() {
    return 'RunStepObject(id: $id, object: $object, createdAt: $createdAt, assistantId: $assistantId, threadId: $threadId, runId: $runId, type: $type, status: $status, stepDetails: $stepDetails, lastError: $lastError, expiredAt: $expiredAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, metadata: $metadata, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.stepDetails, stepDetails) ||
                other.stepDetails == stepDetails) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiredAt, expiredAt) ||
                other.expiredAt == expiredAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      assistantId,
      threadId,
      runId,
      type,
      status,
      stepDetails,
      lastError,
      expiredAt,
      cancelledAt,
      failedAt,
      completedAt,
      const DeepCollectionEquality().hash(_metadata),
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepObjectImplCopyWith<_$RunStepObjectImpl> get copyWith =>
      __$$RunStepObjectImplCopyWithImpl<_$RunStepObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepObjectImplToJson(
      this,
    );
  }
}

abstract class _RunStepObject extends RunStepObject {
  const factory _RunStepObject(
      {required final String id,
      required final RunStepObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'assistant_id') required final String assistantId,
      @JsonKey(name: 'thread_id') required final String threadId,
      @JsonKey(name: 'run_id') required final String runId,
      required final RunStepType type,
      required final RunStepStatus status,
      @JsonKey(name: 'step_details') required final RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') required final RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') required final int? expiredAt,
      @JsonKey(name: 'cancelled_at') required final int? cancelledAt,
      @JsonKey(name: 'failed_at') required final int? failedAt,
      @JsonKey(name: 'completed_at') required final int? completedAt,
      required final Map<String, dynamic>? metadata,
      required final RunStepCompletionUsage? usage}) = _$RunStepObjectImpl;
  const _RunStepObject._() : super._();

  factory _RunStepObject.fromJson(Map<String, dynamic> json) =
      _$RunStepObjectImpl.fromJson;

  @override

  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.run.step`.
  RunStepObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the run step was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @JsonKey(name: 'thread_id')
  String get threadId;
  @override

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @JsonKey(name: 'run_id')
  String get runId;
  @override

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  RunStepType get type;
  @override

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  RunStepStatus get status;
  @override

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details')
  RunStepDetails get stepDetails;
  @override

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunStepLastError? get lastError;
  @override

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @JsonKey(name: 'expired_at')
  int? get expiredAt;
  @override

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt;
  @override

  /// The Unix timestamp (in seconds) for when the run step failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt;
  @override

  /// The Unix timestamp (in seconds) for when the run step completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  RunStepCompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$RunStepObjectImplCopyWith<_$RunStepObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunStepLastError _$RunStepLastErrorFromJson(Map<String, dynamic> json) {
  return _RunStepLastError.fromJson(json);
}

/// @nodoc
mixin _$RunStepLastError {
  /// One of `server_error` or `rate_limit_exceeded`.
  RunStepLastErrorCode get code => throw _privateConstructorUsedError;

  /// A human-readable description of the error.
  String get message => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepLastErrorCopyWith<RunStepLastError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepLastErrorCopyWith<$Res> {
  factory $RunStepLastErrorCopyWith(
          RunStepLastError value, $Res Function(RunStepLastError) then) =
      _$RunStepLastErrorCopyWithImpl<$Res, RunStepLastError>;
  @useResult
  $Res call({RunStepLastErrorCode code, String message});
}

/// @nodoc
class _$RunStepLastErrorCopyWithImpl<$Res, $Val extends RunStepLastError>
    implements $RunStepLastErrorCopyWith<$Res> {
  _$RunStepLastErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunStepLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepLastErrorImplCopyWith<$Res>
    implements $RunStepLastErrorCopyWith<$Res> {
  factory _$$RunStepLastErrorImplCopyWith(_$RunStepLastErrorImpl value,
          $Res Function(_$RunStepLastErrorImpl) then) =
      __$$RunStepLastErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({RunStepLastErrorCode code, String message});
}

/// @nodoc
class __$$RunStepLastErrorImplCopyWithImpl<$Res>
    extends _$RunStepLastErrorCopyWithImpl<$Res, _$RunStepLastErrorImpl>
    implements _$$RunStepLastErrorImplCopyWith<$Res> {
  __$$RunStepLastErrorImplCopyWithImpl(_$RunStepLastErrorImpl _value,
      $Res Function(_$RunStepLastErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_$RunStepLastErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunStepLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepLastErrorImpl extends _RunStepLastError {
  const _$RunStepLastErrorImpl({required this.code, required this.message})
      : super._();

  factory _$RunStepLastErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepLastErrorImplFromJson(json);

  /// One of `server_error` or `rate_limit_exceeded`.
  @override
  final RunStepLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  @override
  String toString() {
    return 'RunStepLastError(code: $code, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepLastErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepLastErrorImplCopyWith<_$RunStepLastErrorImpl> get copyWith =>
      __$$RunStepLastErrorImplCopyWithImpl<_$RunStepLastErrorImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepLastErrorImplToJson(
      this,
    );
  }
}

abstract class _RunStepLastError extends RunStepLastError {
  const factory _RunStepLastError(
      {required final RunStepLastErrorCode code,
      required final String message}) = _$RunStepLastErrorImpl;
  const _RunStepLastError._() : super._();

  factory _RunStepLastError.fromJson(Map<String, dynamic> json) =
      _$RunStepLastErrorImpl.fromJson;

  @override

  /// One of `server_error` or `rate_limit_exceeded`.
  RunStepLastErrorCode get code;
  @override

  /// A human-readable description of the error.
  String get message;
  @override
  @JsonKey(ignore: true)
  _$$RunStepLastErrorImplCopyWith<_$RunStepLastErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListRunStepsResponse _$ListRunStepsResponseFromJson(Map<String, dynamic> json) {
  return _ListRunStepsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListRunStepsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of run steps.
  List<RunStepObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first run step in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last run step in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more run steps to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListRunStepsResponseCopyWith<ListRunStepsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListRunStepsResponseCopyWith<$Res> {
  factory $ListRunStepsResponseCopyWith(ListRunStepsResponse value,
          $Res Function(ListRunStepsResponse) then) =
      _$ListRunStepsResponseCopyWithImpl<$Res, ListRunStepsResponse>;
  @useResult
  $Res call(
      {String object,
      List<RunStepObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListRunStepsResponseCopyWithImpl<$Res,
        $Val extends ListRunStepsResponse>
    implements $ListRunStepsResponseCopyWith<$Res> {
  _$ListRunStepsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunStepObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListRunStepsResponseImplCopyWith<$Res>
    implements $ListRunStepsResponseCopyWith<$Res> {
  factory _$$ListRunStepsResponseImplCopyWith(_$ListRunStepsResponseImpl value,
          $Res Function(_$ListRunStepsResponseImpl) then) =
      __$$ListRunStepsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<RunStepObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListRunStepsResponseImplCopyWithImpl<$Res>
    extends _$ListRunStepsResponseCopyWithImpl<$Res, _$ListRunStepsResponseImpl>
    implements _$$ListRunStepsResponseImplCopyWith<$Res> {
  __$$ListRunStepsResponseImplCopyWithImpl(_$ListRunStepsResponseImpl _value,
      $Res Function(_$ListRunStepsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListRunStepsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunStepObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListRunStepsResponseImpl extends _ListRunStepsResponse {
  const _$ListRunStepsResponseImpl(
      {required this.object,
      required final List<RunStepObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListRunStepsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListRunStepsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of run steps.
  final List<RunStepObject> _data;

  /// The list of run steps.
  @override
  List<RunStepObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first run step in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last run step in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more run steps to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListRunStepsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListRunStepsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListRunStepsResponseImplCopyWith<_$ListRunStepsResponseImpl>
      get copyWith =>
          __$$ListRunStepsResponseImplCopyWithImpl<_$ListRunStepsResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListRunStepsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListRunStepsResponse extends ListRunStepsResponse {
  const factory _ListRunStepsResponse(
          {required final String object,
          required final List<RunStepObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListRunStepsResponseImpl;
  const _ListRunStepsResponse._() : super._();

  factory _ListRunStepsResponse.fromJson(Map<String, dynamic> json) =
      _$ListRunStepsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of run steps.
  List<RunStepObject> get data;
  @override

  /// The ID of the first run step in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last run step in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more run steps to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListRunStepsResponseImplCopyWith<_$ListRunStepsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsMessageCreation _$RunStepDetailsMessageCreationFromJson(
    Map<String, dynamic> json) {
  return _RunStepDetailsMessageCreation.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsMessageCreation {
  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id')
  String get messageId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsMessageCreationCopyWith<RunStepDetailsMessageCreation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsMessageCreationCopyWith<$Res> {
  factory $RunStepDetailsMessageCreationCopyWith(
          RunStepDetailsMessageCreation value,
          $Res Function(RunStepDetailsMessageCreation) then) =
      _$RunStepDetailsMessageCreationCopyWithImpl<$Res,
          RunStepDetailsMessageCreation>;
  @useResult
  $Res call({@JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class _$RunStepDetailsMessageCreationCopyWithImpl<$Res,
        $Val extends RunStepDetailsMessageCreation>
    implements $RunStepDetailsMessageCreationCopyWith<$Res> {
  _$RunStepDetailsMessageCreationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = null,
  }) {
    return _then(_value.copyWith(
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsMessageCreationImplCopyWith<$Res>
    implements $RunStepDetailsMessageCreationCopyWith<$Res> {
  factory _$$RunStepDetailsMessageCreationImplCopyWith(
          _$RunStepDetailsMessageCreationImpl value,
          $Res Function(_$RunStepDetailsMessageCreationImpl) then) =
      __$$RunStepDetailsMessageCreationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class __$$RunStepDetailsMessageCreationImplCopyWithImpl<$Res>
    extends _$RunStepDetailsMessageCreationCopyWithImpl<$Res,
        _$RunStepDetailsMessageCreationImpl>
    implements _$$RunStepDetailsMessageCreationImplCopyWith<$Res> {
  __$$RunStepDetailsMessageCreationImplCopyWithImpl(
      _$RunStepDetailsMessageCreationImpl _value,
      $Res Function(_$RunStepDetailsMessageCreationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = null,
  }) {
    return _then(_$RunStepDetailsMessageCreationImpl(
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsMessageCreationImpl
    extends _RunStepDetailsMessageCreation {
  const _$RunStepDetailsMessageCreationImpl(
      {@JsonKey(name: 'message_id') required this.messageId})
      : super._();

  factory _$RunStepDetailsMessageCreationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsMessageCreationImplFromJson(json);

  /// The ID of the message that was created by this run step.
  @override
  @JsonKey(name: 'message_id')
  final String messageId;

  @override
  String toString() {
    return 'RunStepDetailsMessageCreation(messageId: $messageId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsMessageCreationImpl &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, messageId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsMessageCreationImplCopyWith<
          _$RunStepDetailsMessageCreationImpl>
      get copyWith => __$$RunStepDetailsMessageCreationImplCopyWithImpl<
          _$RunStepDetailsMessageCreationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsMessageCreationImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsMessageCreation
    extends RunStepDetailsMessageCreation {
  const factory _RunStepDetailsMessageCreation(
          {@JsonKey(name: 'message_id') required final String messageId}) =
      _$RunStepDetailsMessageCreationImpl;
  const _RunStepDetailsMessageCreation._() : super._();

  factory _RunStepDetailsMessageCreation.fromJson(Map<String, dynamic> json) =
      _$RunStepDetailsMessageCreationImpl.fromJson;

  @override

  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id')
  String get messageId;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsMessageCreationImplCopyWith<
          _$RunStepDetailsMessageCreationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsCodeObjectCodeInterpreter
    _$RunStepDetailsToolCallsCodeObjectCodeInterpreterFromJson(
        Map<String, dynamic> json) {
  return _RunStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  /// The input to the Code Interpreter tool call.
  String get input => throw _privateConstructorUsedError;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  List<RunStepDetailsToolCallsCodeOutput> get outputs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
          RunStepDetailsToolCallsCodeObjectCodeInterpreter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith(
          RunStepDetailsToolCallsCodeObjectCodeInterpreter value,
          $Res Function(RunStepDetailsToolCallsCodeObjectCodeInterpreter)
              then) =
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res,
          RunStepDetailsToolCallsCodeObjectCodeInterpreter>;
  @useResult
  $Res call({String input, List<RunStepDetailsToolCallsCodeOutput> outputs});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsCodeObjectCodeInterpreter>
    implements $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? outputs = null,
  }) {
    return _then(_value.copyWith(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
      outputs: null == outputs
          ? _value.outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsCodeOutput>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
        $Res>
    implements $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith(
          _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl)
              then) =
      __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String input, List<RunStepDetailsToolCallsCodeOutput> outputs});
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
    implements
        _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? outputs = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
      outputs: null == outputs
          ? _value._outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsCodeOutput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl
    extends _RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  const _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl(
      {required this.input,
      required final List<RunStepDetailsToolCallsCodeOutput> outputs})
      : _outputs = outputs,
        super._();

  factory _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplFromJson(json);

  /// The input to the Code Interpreter tool call.
  @override
  final String input;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  final List<RunStepDetailsToolCallsCodeOutput> _outputs;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @override
  List<RunStepDetailsToolCallsCodeOutput> get outputs {
    if (_outputs is EqualUnmodifiableListView) return _outputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_outputs);
  }

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeObjectCodeInterpreter(input: $input, outputs: $outputs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other._outputs, _outputs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(_outputs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<
                  _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsToolCallsCodeObjectCodeInterpreter
    extends RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  const factory _RunStepDetailsToolCallsCodeObjectCodeInterpreter(
          {required final String input,
          required final List<RunStepDetailsToolCallsCodeOutput> outputs}) =
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl;
  const _RunStepDetailsToolCallsCodeObjectCodeInterpreter._() : super._();

  factory _RunStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl.fromJson;

  @override

  /// The input to the Code Interpreter tool call.
  String get input;
  @override

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  List<RunStepDetailsToolCallsCodeOutput> get outputs;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsCodeOutputImage
    _$RunStepDetailsToolCallsCodeOutputImageFromJson(
        Map<String, dynamic> json) {
  return _RunStepDetailsToolCallsCodeOutputImage.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeOutputImage {
  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsCodeOutputImageCopyWith<
          RunStepDetailsToolCallsCodeOutputImage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputImageCopyWith(
          RunStepDetailsToolCallsCodeOutputImage value,
          $Res Function(RunStepDetailsToolCallsCodeOutputImage) then) =
      _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
          RunStepDetailsToolCallsCodeOutputImage>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsCodeOutputImage>
    implements $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith(
          _$RunStepDetailsToolCallsCodeOutputImageImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeOutputImageImpl) then) =
      __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeOutputImageImpl>
    implements _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeOutputImageImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeOutputImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeOutputImageImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeOutputImageImpl
    extends _RunStepDetailsToolCallsCodeOutputImage {
  const _$RunStepDetailsToolCallsCodeOutputImageImpl(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();

  factory _$RunStepDetailsToolCallsCodeOutputImageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeOutputImageImplFromJson(json);

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutputImage(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeOutputImageImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<
              _$RunStepDetailsToolCallsCodeOutputImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeOutputImageImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsToolCallsCodeOutputImage
    extends RunStepDetailsToolCallsCodeOutputImage {
  const factory _RunStepDetailsToolCallsCodeOutputImage(
          {@JsonKey(name: 'file_id') required final String fileId}) =
      _$RunStepDetailsToolCallsCodeOutputImageImpl;
  const _RunStepDetailsToolCallsCodeOutputImage._() : super._();

  factory _RunStepDetailsToolCallsCodeOutputImage.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeOutputImageImpl.fromJson;

  @override

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepCompletionUsage _$RunStepCompletionUsageFromJson(
    Map<String, dynamic> json) {
  return _RunStepCompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$RunStepCompletionUsage {
  /// Number of completion tokens used over the course of the run step.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens => throw _privateConstructorUsedError;

  /// Number of prompt tokens used over the course of the run step.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepCompletionUsageCopyWith<RunStepCompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepCompletionUsageCopyWith<$Res> {
  factory $RunStepCompletionUsageCopyWith(RunStepCompletionUsage value,
          $Res Function(RunStepCompletionUsage) then) =
      _$RunStepCompletionUsageCopyWithImpl<$Res, RunStepCompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$RunStepCompletionUsageCopyWithImpl<$Res,
        $Val extends RunStepCompletionUsage>
    implements $RunStepCompletionUsageCopyWith<$Res> {
  _$RunStepCompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepCompletionUsageImplCopyWith<$Res>
    implements $RunStepCompletionUsageCopyWith<$Res> {
  factory _$$RunStepCompletionUsageImplCopyWith(
          _$RunStepCompletionUsageImpl value,
          $Res Function(_$RunStepCompletionUsageImpl) then) =
      __$$RunStepCompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$RunStepCompletionUsageImplCopyWithImpl<$Res>
    extends _$RunStepCompletionUsageCopyWithImpl<$Res,
        _$RunStepCompletionUsageImpl>
    implements _$$RunStepCompletionUsageImplCopyWith<$Res> {
  __$$RunStepCompletionUsageImplCopyWithImpl(
      _$RunStepCompletionUsageImpl _value,
      $Res Function(_$RunStepCompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$RunStepCompletionUsageImpl(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepCompletionUsageImpl extends _RunStepCompletionUsage {
  const _$RunStepCompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$RunStepCompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepCompletionUsageImplFromJson(json);

  /// Number of completion tokens used over the course of the run step.
  @override
  @JsonKey(name: 'completion_tokens')
  final int completionTokens;

  /// Number of prompt tokens used over the course of the run step.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'RunStepCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepCompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepCompletionUsageImplCopyWith<_$RunStepCompletionUsageImpl>
      get copyWith => __$$RunStepCompletionUsageImplCopyWithImpl<
          _$RunStepCompletionUsageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepCompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _RunStepCompletionUsage extends RunStepCompletionUsage {
  const factory _RunStepCompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$RunStepCompletionUsageImpl;
  const _RunStepCompletionUsage._() : super._();

  factory _RunStepCompletionUsage.fromJson(Map<String, dynamic> json) =
      _$RunStepCompletionUsageImpl.fromJson;

  @override

  /// Number of completion tokens used over the course of the run step.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens;
  @override

  /// Number of prompt tokens used over the course of the run step.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$RunStepCompletionUsageImplCopyWith<_$RunStepCompletionUsageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantFileObject _$AssistantFileObjectFromJson(Map<String, dynamic> json) {
  return _AssistantFileObject.fromJson(json);
}

/// @nodoc
mixin _$AssistantFileObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `assistant.file`.
  AssistantFileObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the assistant file was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The assistant ID that the file is attached to.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantFileObjectCopyWith<AssistantFileObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantFileObjectCopyWith<$Res> {
  factory $AssistantFileObjectCopyWith(
          AssistantFileObject value, $Res Function(AssistantFileObject) then) =
      _$AssistantFileObjectCopyWithImpl<$Res, AssistantFileObject>;
  @useResult
  $Res call(
      {String id,
      AssistantFileObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId});
}

/// @nodoc
class _$AssistantFileObjectCopyWithImpl<$Res, $Val extends AssistantFileObject>
    implements $AssistantFileObjectCopyWith<$Res> {
  _$AssistantFileObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantFileObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssistantFileObjectImplCopyWith<$Res>
    implements $AssistantFileObjectCopyWith<$Res> {
  factory _$$AssistantFileObjectImplCopyWith(_$AssistantFileObjectImpl value,
          $Res Function(_$AssistantFileObjectImpl) then) =
      __$$AssistantFileObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      AssistantFileObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId});
}

/// @nodoc
class __$$AssistantFileObjectImplCopyWithImpl<$Res>
    extends _$AssistantFileObjectCopyWithImpl<$Res, _$AssistantFileObjectImpl>
    implements _$$AssistantFileObjectImplCopyWith<$Res> {
  __$$AssistantFileObjectImplCopyWithImpl(_$AssistantFileObjectImpl _value,
      $Res Function(_$AssistantFileObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
  }) {
    return _then(_$AssistantFileObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantFileObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantFileObjectImpl extends _AssistantFileObject {
  const _$AssistantFileObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'assistant_id') required this.assistantId})
      : super._();

  factory _$AssistantFileObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantFileObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `assistant.file`.
  @override
  final AssistantFileObjectObject object;

  /// The Unix timestamp (in seconds) for when the assistant file was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The assistant ID that the file is attached to.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  @override
  String toString() {
    return 'AssistantFileObject(id: $id, object: $object, createdAt: $createdAt, assistantId: $assistantId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantFileObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, object, createdAt, assistantId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantFileObjectImplCopyWith<_$AssistantFileObjectImpl> get copyWith =>
      __$$AssistantFileObjectImplCopyWithImpl<_$AssistantFileObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantFileObjectImplToJson(
      this,
    );
  }
}

abstract class _AssistantFileObject extends AssistantFileObject {
  const factory _AssistantFileObject(
          {required final String id,
          required final AssistantFileObjectObject object,
          @JsonKey(name: 'created_at') required final int createdAt,
          @JsonKey(name: 'assistant_id') required final String assistantId}) =
      _$AssistantFileObjectImpl;
  const _AssistantFileObject._() : super._();

  factory _AssistantFileObject.fromJson(Map<String, dynamic> json) =
      _$AssistantFileObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `assistant.file`.
  AssistantFileObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the assistant file was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The assistant ID that the file is attached to.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override
  @JsonKey(ignore: true)
  _$$AssistantFileObjectImplCopyWith<_$AssistantFileObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateAssistantFileRequest _$CreateAssistantFileRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateAssistantFileRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateAssistantFileRequest {
  /// A [File](https://platform.openai.com/docs/api-reference/files) ID (with `purpose="assistants"`) that the assistant should use. Useful for tools like `retrieval` and `code_interpreter` that can access files.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateAssistantFileRequestCopyWith<CreateAssistantFileRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateAssistantFileRequestCopyWith<$Res> {
  factory $CreateAssistantFileRequestCopyWith(CreateAssistantFileRequest value,
          $Res Function(CreateAssistantFileRequest) then) =
      _$CreateAssistantFileRequestCopyWithImpl<$Res,
          CreateAssistantFileRequest>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$CreateAssistantFileRequestCopyWithImpl<$Res,
        $Val extends CreateAssistantFileRequest>
    implements $CreateAssistantFileRequestCopyWith<$Res> {
  _$CreateAssistantFileRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateAssistantFileRequestImplCopyWith<$Res>
    implements $CreateAssistantFileRequestCopyWith<$Res> {
  factory _$$CreateAssistantFileRequestImplCopyWith(
          _$CreateAssistantFileRequestImpl value,
          $Res Function(_$CreateAssistantFileRequestImpl) then) =
      __$$CreateAssistantFileRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$$CreateAssistantFileRequestImplCopyWithImpl<$Res>
    extends _$CreateAssistantFileRequestCopyWithImpl<$Res,
        _$CreateAssistantFileRequestImpl>
    implements _$$CreateAssistantFileRequestImplCopyWith<$Res> {
  __$$CreateAssistantFileRequestImplCopyWithImpl(
      _$CreateAssistantFileRequestImpl _value,
      $Res Function(_$CreateAssistantFileRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_$CreateAssistantFileRequestImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateAssistantFileRequestImpl extends _CreateAssistantFileRequest {
  const _$CreateAssistantFileRequestImpl(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();

  factory _$CreateAssistantFileRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateAssistantFileRequestImplFromJson(json);

  /// A [File](https://platform.openai.com/docs/api-reference/files) ID (with `purpose="assistants"`) that the assistant should use. Useful for tools like `retrieval` and `code_interpreter` that can access files.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  @override
  String toString() {
    return 'CreateAssistantFileRequest(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateAssistantFileRequestImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateAssistantFileRequestImplCopyWith<_$CreateAssistantFileRequestImpl>
      get copyWith => __$$CreateAssistantFileRequestImplCopyWithImpl<
          _$CreateAssistantFileRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateAssistantFileRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateAssistantFileRequest extends CreateAssistantFileRequest {
  const factory _CreateAssistantFileRequest(
          {@JsonKey(name: 'file_id') required final String fileId}) =
      _$CreateAssistantFileRequestImpl;
  const _CreateAssistantFileRequest._() : super._();

  factory _CreateAssistantFileRequest.fromJson(Map<String, dynamic> json) =
      _$CreateAssistantFileRequestImpl.fromJson;

  @override

  /// A [File](https://platform.openai.com/docs/api-reference/files) ID (with `purpose="assistants"`) that the assistant should use. Useful for tools like `retrieval` and `code_interpreter` that can access files.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override
  @JsonKey(ignore: true)
  _$$CreateAssistantFileRequestImplCopyWith<_$CreateAssistantFileRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteAssistantFileResponse _$DeleteAssistantFileResponseFromJson(
    Map<String, dynamic> json) {
  return _DeleteAssistantFileResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteAssistantFileResponse {
  /// The ID of the assistant file.
  String get id => throw _privateConstructorUsedError;

  /// Whether the assistant file was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `assistant.file.deleted`.
  DeleteAssistantFileResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteAssistantFileResponseCopyWith<DeleteAssistantFileResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteAssistantFileResponseCopyWith<$Res> {
  factory $DeleteAssistantFileResponseCopyWith(
          DeleteAssistantFileResponse value,
          $Res Function(DeleteAssistantFileResponse) then) =
      _$DeleteAssistantFileResponseCopyWithImpl<$Res,
          DeleteAssistantFileResponse>;
  @useResult
  $Res call(
      {String id, bool deleted, DeleteAssistantFileResponseObject object});
}

/// @nodoc
class _$DeleteAssistantFileResponseCopyWithImpl<$Res,
        $Val extends DeleteAssistantFileResponse>
    implements $DeleteAssistantFileResponseCopyWith<$Res> {
  _$DeleteAssistantFileResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantFileResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteAssistantFileResponseImplCopyWith<$Res>
    implements $DeleteAssistantFileResponseCopyWith<$Res> {
  factory _$$DeleteAssistantFileResponseImplCopyWith(
          _$DeleteAssistantFileResponseImpl value,
          $Res Function(_$DeleteAssistantFileResponseImpl) then) =
      __$$DeleteAssistantFileResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id, bool deleted, DeleteAssistantFileResponseObject object});
}

/// @nodoc
class __$$DeleteAssistantFileResponseImplCopyWithImpl<$Res>
    extends _$DeleteAssistantFileResponseCopyWithImpl<$Res,
        _$DeleteAssistantFileResponseImpl>
    implements _$$DeleteAssistantFileResponseImplCopyWith<$Res> {
  __$$DeleteAssistantFileResponseImplCopyWithImpl(
      _$DeleteAssistantFileResponseImpl _value,
      $Res Function(_$DeleteAssistantFileResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteAssistantFileResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantFileResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteAssistantFileResponseImpl extends _DeleteAssistantFileResponse {
  const _$DeleteAssistantFileResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteAssistantFileResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$DeleteAssistantFileResponseImplFromJson(json);

  /// The ID of the assistant file.
  @override
  final String id;

  /// Whether the assistant file was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `assistant.file.deleted`.
  @override
  final DeleteAssistantFileResponseObject object;

  @override
  String toString() {
    return 'DeleteAssistantFileResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteAssistantFileResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteAssistantFileResponseImplCopyWith<_$DeleteAssistantFileResponseImpl>
      get copyWith => __$$DeleteAssistantFileResponseImplCopyWithImpl<
          _$DeleteAssistantFileResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteAssistantFileResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteAssistantFileResponse
    extends DeleteAssistantFileResponse {
  const factory _DeleteAssistantFileResponse(
          {required final String id,
          required final bool deleted,
          required final DeleteAssistantFileResponseObject object}) =
      _$DeleteAssistantFileResponseImpl;
  const _DeleteAssistantFileResponse._() : super._();

  factory _DeleteAssistantFileResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteAssistantFileResponseImpl.fromJson;

  @override

  /// The ID of the assistant file.
  String get id;
  @override

  /// Whether the assistant file was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `assistant.file.deleted`.
  DeleteAssistantFileResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteAssistantFileResponseImplCopyWith<_$DeleteAssistantFileResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListAssistantFilesResponse _$ListAssistantFilesResponseFromJson(
    Map<String, dynamic> json) {
  return _ListAssistantFilesResponse.fromJson(json);
}

/// @nodoc
mixin _$ListAssistantFilesResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// A list of assistant files.
  List<AssistantFileObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first assistant file in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last assistant file in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more assistant files available.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListAssistantFilesResponseCopyWith<ListAssistantFilesResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListAssistantFilesResponseCopyWith<$Res> {
  factory $ListAssistantFilesResponseCopyWith(ListAssistantFilesResponse value,
          $Res Function(ListAssistantFilesResponse) then) =
      _$ListAssistantFilesResponseCopyWithImpl<$Res,
          ListAssistantFilesResponse>;
  @useResult
  $Res call(
      {String object,
      List<AssistantFileObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListAssistantFilesResponseCopyWithImpl<$Res,
        $Val extends ListAssistantFilesResponse>
    implements $ListAssistantFilesResponseCopyWith<$Res> {
  _$ListAssistantFilesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantFileObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListAssistantFilesResponseImplCopyWith<$Res>
    implements $ListAssistantFilesResponseCopyWith<$Res> {
  factory _$$ListAssistantFilesResponseImplCopyWith(
          _$ListAssistantFilesResponseImpl value,
          $Res Function(_$ListAssistantFilesResponseImpl) then) =
      __$$ListAssistantFilesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<AssistantFileObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListAssistantFilesResponseImplCopyWithImpl<$Res>
    extends _$ListAssistantFilesResponseCopyWithImpl<$Res,
        _$ListAssistantFilesResponseImpl>
    implements _$$ListAssistantFilesResponseImplCopyWith<$Res> {
  __$$ListAssistantFilesResponseImplCopyWithImpl(
      _$ListAssistantFilesResponseImpl _value,
      $Res Function(_$ListAssistantFilesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListAssistantFilesResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantFileObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListAssistantFilesResponseImpl extends _ListAssistantFilesResponse {
  const _$ListAssistantFilesResponseImpl(
      {required this.object,
      required final List<AssistantFileObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListAssistantFilesResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListAssistantFilesResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// A list of assistant files.
  final List<AssistantFileObject> _data;

  /// A list of assistant files.
  @override
  List<AssistantFileObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first assistant file in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last assistant file in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more assistant files available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListAssistantFilesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListAssistantFilesResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListAssistantFilesResponseImplCopyWith<_$ListAssistantFilesResponseImpl>
      get copyWith => __$$ListAssistantFilesResponseImplCopyWithImpl<
          _$ListAssistantFilesResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListAssistantFilesResponseImplToJson(
      this,
    );
  }
}

abstract class _ListAssistantFilesResponse extends ListAssistantFilesResponse {
  const factory _ListAssistantFilesResponse(
          {required final String object,
          required final List<AssistantFileObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListAssistantFilesResponseImpl;
  const _ListAssistantFilesResponse._() : super._();

  factory _ListAssistantFilesResponse.fromJson(Map<String, dynamic> json) =
      _$ListAssistantFilesResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// A list of assistant files.
  List<AssistantFileObject> get data;
  @override

  /// The ID of the first assistant file in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last assistant file in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more assistant files available.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListAssistantFilesResponseImplCopyWith<_$ListAssistantFilesResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageFileObject _$MessageFileObjectFromJson(Map<String, dynamic> json) {
  return _MessageFileObject.fromJson(json);
}

/// @nodoc
mixin _$MessageFileObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.message.file`.
  MessageFileObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the message file was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The ID of the [message](https://platform.openai.com/docs/api-reference/messages) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'message_id')
  String get messageId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageFileObjectCopyWith<MessageFileObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageFileObjectCopyWith<$Res> {
  factory $MessageFileObjectCopyWith(
          MessageFileObject value, $Res Function(MessageFileObject) then) =
      _$MessageFileObjectCopyWithImpl<$Res, MessageFileObject>;
  @useResult
  $Res call(
      {String id,
      MessageFileObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class _$MessageFileObjectCopyWithImpl<$Res, $Val extends MessageFileObject>
    implements $MessageFileObjectCopyWith<$Res> {
  _$MessageFileObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? messageId = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageFileObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageFileObjectImplCopyWith<$Res>
    implements $MessageFileObjectCopyWith<$Res> {
  factory _$$MessageFileObjectImplCopyWith(_$MessageFileObjectImpl value,
          $Res Function(_$MessageFileObjectImpl) then) =
      __$$MessageFileObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      MessageFileObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class __$$MessageFileObjectImplCopyWithImpl<$Res>
    extends _$MessageFileObjectCopyWithImpl<$Res, _$MessageFileObjectImpl>
    implements _$$MessageFileObjectImplCopyWith<$Res> {
  __$$MessageFileObjectImplCopyWithImpl(_$MessageFileObjectImpl _value,
      $Res Function(_$MessageFileObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? messageId = null,
  }) {
    return _then(_$MessageFileObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageFileObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageFileObjectImpl extends _MessageFileObject {
  const _$MessageFileObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'message_id') required this.messageId})
      : super._();

  factory _$MessageFileObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageFileObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.message.file`.
  @override
  final MessageFileObjectObject object;

  /// The Unix timestamp (in seconds) for when the message file was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [message](https://platform.openai.com/docs/api-reference/messages) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @override
  @JsonKey(name: 'message_id')
  final String messageId;

  @override
  String toString() {
    return 'MessageFileObject(id: $id, object: $object, createdAt: $createdAt, messageId: $messageId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageFileObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, object, createdAt, messageId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageFileObjectImplCopyWith<_$MessageFileObjectImpl> get copyWith =>
      __$$MessageFileObjectImplCopyWithImpl<_$MessageFileObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageFileObjectImplToJson(
      this,
    );
  }
}

abstract class _MessageFileObject extends MessageFileObject {
  const factory _MessageFileObject(
          {required final String id,
          required final MessageFileObjectObject object,
          @JsonKey(name: 'created_at') required final int createdAt,
          @JsonKey(name: 'message_id') required final String messageId}) =
      _$MessageFileObjectImpl;
  const _MessageFileObject._() : super._();

  factory _MessageFileObject.fromJson(Map<String, dynamic> json) =
      _$MessageFileObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.message.file`.
  MessageFileObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the message file was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The ID of the [message](https://platform.openai.com/docs/api-reference/messages) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'message_id')
  String get messageId;
  @override
  @JsonKey(ignore: true)
  _$$MessageFileObjectImplCopyWith<_$MessageFileObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListMessageFilesResponse _$ListMessageFilesResponseFromJson(
    Map<String, dynamic> json) {
  return _ListMessageFilesResponse.fromJson(json);
}

/// @nodoc
mixin _$ListMessageFilesResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// A list of message files.
  List<MessageFileObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first message file in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last message file in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more message files available.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListMessageFilesResponseCopyWith<ListMessageFilesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListMessageFilesResponseCopyWith<$Res> {
  factory $ListMessageFilesResponseCopyWith(ListMessageFilesResponse value,
          $Res Function(ListMessageFilesResponse) then) =
      _$ListMessageFilesResponseCopyWithImpl<$Res, ListMessageFilesResponse>;
  @useResult
  $Res call(
      {String object,
      List<MessageFileObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListMessageFilesResponseCopyWithImpl<$Res,
        $Val extends ListMessageFilesResponse>
    implements $ListMessageFilesResponseCopyWith<$Res> {
  _$ListMessageFilesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageFileObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListMessageFilesResponseImplCopyWith<$Res>
    implements $ListMessageFilesResponseCopyWith<$Res> {
  factory _$$ListMessageFilesResponseImplCopyWith(
          _$ListMessageFilesResponseImpl value,
          $Res Function(_$ListMessageFilesResponseImpl) then) =
      __$$ListMessageFilesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<MessageFileObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListMessageFilesResponseImplCopyWithImpl<$Res>
    extends _$ListMessageFilesResponseCopyWithImpl<$Res,
        _$ListMessageFilesResponseImpl>
    implements _$$ListMessageFilesResponseImplCopyWith<$Res> {
  __$$ListMessageFilesResponseImplCopyWithImpl(
      _$ListMessageFilesResponseImpl _value,
      $Res Function(_$ListMessageFilesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListMessageFilesResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageFileObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListMessageFilesResponseImpl extends _ListMessageFilesResponse {
  const _$ListMessageFilesResponseImpl(
      {required this.object,
      required final List<MessageFileObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListMessageFilesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListMessageFilesResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// A list of message files.
  final List<MessageFileObject> _data;

  /// A list of message files.
  @override
  List<MessageFileObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first message file in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last message file in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more message files available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListMessageFilesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListMessageFilesResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListMessageFilesResponseImplCopyWith<_$ListMessageFilesResponseImpl>
      get copyWith => __$$ListMessageFilesResponseImplCopyWithImpl<
          _$ListMessageFilesResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListMessageFilesResponseImplToJson(
      this,
    );
  }
}

abstract class _ListMessageFilesResponse extends ListMessageFilesResponse {
  const factory _ListMessageFilesResponse(
          {required final String object,
          required final List<MessageFileObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListMessageFilesResponseImpl;
  const _ListMessageFilesResponse._() : super._();

  factory _ListMessageFilesResponse.fromJson(Map<String, dynamic> json) =
      _$ListMessageFilesResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// A list of message files.
  List<MessageFileObject> get data;
  @override

  /// The ID of the first message file in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last message file in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more message files available.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListMessageFilesResponseImplCopyWith<_$ListMessageFilesResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessage _$ChatCompletionMessageFromJson(
    Map<String, dynamic> json) {
  switch (json['role']) {
    case 'system':
      return ChatCompletionSystemMessage.fromJson(json);
    case 'user':
      return ChatCompletionUserMessage.fromJson(json);
    case 'assistant':
      return ChatCompletionAssistantMessage.fromJson(json);
    case 'tool':
      return ChatCompletionToolMessage.fromJson(json);
    case 'function':
      return ChatCompletionFunctionMessage.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'role', 'ChatCompletionMessage',
          'Invalid union type "${json['role']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessage {
  /// The role of the messages author, in this case `system`.
  ChatCompletionMessageRole get role => throw _privateConstructorUsedError;

  /// The contents of the system message.
  Object? get content => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageCopyWith<ChatCompletionMessage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionMessageCopyWith(ChatCompletionMessage value,
          $Res Function(ChatCompletionMessage) then) =
      _$ChatCompletionMessageCopyWithImpl<$Res, ChatCompletionMessage>;
  @useResult
  $Res call({ChatCompletionMessageRole role});
}

/// @nodoc
class _$ChatCompletionMessageCopyWithImpl<$Res,
        $Val extends ChatCompletionMessage>
    implements $ChatCompletionMessageCopyWith<$Res> {
  _$ChatCompletionMessageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
  }) {
    return _then(_value.copyWith(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionSystemMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionSystemMessageImplCopyWith(
          _$ChatCompletionSystemMessageImpl value,
          $Res Function(_$ChatCompletionSystemMessageImpl) then) =
      __$$ChatCompletionSystemMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String content,
      @JsonKey(includeIfNull: false) String? name});
}

/// @nodoc
class __$$ChatCompletionSystemMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionSystemMessageImpl>
    implements _$$ChatCompletionSystemMessageImplCopyWith<$Res> {
  __$$ChatCompletionSystemMessageImplCopyWithImpl(
      _$ChatCompletionSystemMessageImpl _value,
      $Res Function(_$ChatCompletionSystemMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? name = freezed,
  }) {
    return _then(_$ChatCompletionSystemMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionSystemMessageImpl extends ChatCompletionSystemMessage {
  const _$ChatCompletionSystemMessageImpl(
      {this.role = ChatCompletionMessageRole.system,
      required this.content,
      @JsonKey(includeIfNull: false) this.name})
      : super._();

  factory _$ChatCompletionSystemMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionSystemMessageImplFromJson(json);

  /// The role of the messages author, in this case `system`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the system message.
  @override
  final String content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  @override
  String toString() {
    return 'ChatCompletionMessage.system(role: $role, content: $content, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionSystemMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionSystemMessageImplCopyWith<_$ChatCompletionSystemMessageImpl>
      get copyWith => __$$ChatCompletionSystemMessageImplCopyWithImpl<
          _$ChatCompletionSystemMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return system(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return system?.call(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (system != null) {
      return system(role, content, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return system(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return system?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (system != null) {
      return system(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionSystemMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionSystemMessage extends ChatCompletionMessage {
  const factory ChatCompletionSystemMessage(
          {final ChatCompletionMessageRole role,
          required final String content,
          @JsonKey(includeIfNull: false) final String? name}) =
      _$ChatCompletionSystemMessageImpl;
  const ChatCompletionSystemMessage._() : super._();

  factory ChatCompletionSystemMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionSystemMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `system`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the system message.
  String get content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionSystemMessageImplCopyWith<_$ChatCompletionSystemMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionUserMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionUserMessageImplCopyWith(
          _$ChatCompletionUserMessageImpl value,
          $Res Function(_$ChatCompletionUserMessageImpl) then) =
      __$$ChatCompletionUserMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @_ChatCompletionUserMessageContentConverter()
      ChatCompletionUserMessageContent content,
      @JsonKey(includeIfNull: false) String? name});

  $ChatCompletionUserMessageContentCopyWith<$Res> get content;
}

/// @nodoc
class __$$ChatCompletionUserMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionUserMessageImpl>
    implements _$$ChatCompletionUserMessageImplCopyWith<$Res> {
  __$$ChatCompletionUserMessageImplCopyWithImpl(
      _$ChatCompletionUserMessageImpl _value,
      $Res Function(_$ChatCompletionUserMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? name = freezed,
  }) {
    return _then(_$ChatCompletionUserMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as ChatCompletionUserMessageContent,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionUserMessageContentCopyWith<$Res> get content {
    return $ChatCompletionUserMessageContentCopyWith<$Res>(_value.content,
        (value) {
      return _then(_value.copyWith(content: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionUserMessageImpl extends ChatCompletionUserMessage {
  const _$ChatCompletionUserMessageImpl(
      {this.role = ChatCompletionMessageRole.user,
      @_ChatCompletionUserMessageContentConverter() required this.content,
      @JsonKey(includeIfNull: false) this.name})
      : super._();

  factory _$ChatCompletionUserMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionUserMessageImplFromJson(json);

  /// The role of the messages author, in this case `user`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the user message.
  @override
  @_ChatCompletionUserMessageContentConverter()
  final ChatCompletionUserMessageContent content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  @override
  String toString() {
    return 'ChatCompletionMessage.user(role: $role, content: $content, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionUserMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionUserMessageImplCopyWith<_$ChatCompletionUserMessageImpl>
      get copyWith => __$$ChatCompletionUserMessageImplCopyWithImpl<
          _$ChatCompletionUserMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return user(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return user?.call(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(role, content, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return user(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return user?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionUserMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionUserMessage extends ChatCompletionMessage {
  const factory ChatCompletionUserMessage(
          {final ChatCompletionMessageRole role,
          @_ChatCompletionUserMessageContentConverter()
          required final ChatCompletionUserMessageContent content,
          @JsonKey(includeIfNull: false) final String? name}) =
      _$ChatCompletionUserMessageImpl;
  const ChatCompletionUserMessage._() : super._();

  factory ChatCompletionUserMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionUserMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `user`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the user message.
  @_ChatCompletionUserMessageContentConverter()
  ChatCompletionUserMessageContent get content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionUserMessageImplCopyWith<_$ChatCompletionUserMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionAssistantMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionAssistantMessageImplCopyWith(
          _$ChatCompletionAssistantMessageImpl value,
          $Res Function(_$ChatCompletionAssistantMessageImpl) then) =
      __$$ChatCompletionAssistantMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @JsonKey(includeIfNull: false) String? content,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionMessageFunctionCall? functionCall});

  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionAssistantMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionAssistantMessageImpl>
    implements _$$ChatCompletionAssistantMessageImplCopyWith<$Res> {
  __$$ChatCompletionAssistantMessageImplCopyWithImpl(
      _$ChatCompletionAssistantMessageImpl _value,
      $Res Function(_$ChatCompletionAssistantMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? name = freezed,
    Object? toolCalls = freezed,
    Object? functionCall = freezed,
  }) {
    return _then(_$ChatCompletionAssistantMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageToolCall>?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionAssistantMessageImpl
    extends ChatCompletionAssistantMessage {
  const _$ChatCompletionAssistantMessageImpl(
      {this.role = ChatCompletionMessageRole.assistant,
      @JsonKey(includeIfNull: false) this.content,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionAssistantMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionAssistantMessageImplFromJson(json);

  /// The role of the messages author, in this case `assistant`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// No Description
  final List<ChatCompletionMessageToolCall>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionMessageFunctionCall? functionCall;

  @override
  String toString() {
    return 'ChatCompletionMessage.assistant(role: $role, content: $content, name: $name, toolCalls: $toolCalls, functionCall: $functionCall)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionAssistantMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name,
      const DeepCollectionEquality().hash(_toolCalls), functionCall);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionAssistantMessageImplCopyWith<
          _$ChatCompletionAssistantMessageImpl>
      get copyWith => __$$ChatCompletionAssistantMessageImplCopyWithImpl<
          _$ChatCompletionAssistantMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return assistant(role, content, name, toolCalls, functionCall);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return assistant?.call(role, content, name, toolCalls, functionCall);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (assistant != null) {
      return assistant(role, content, name, toolCalls, functionCall);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return assistant(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return assistant?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (assistant != null) {
      return assistant(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionAssistantMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionAssistantMessage extends ChatCompletionMessage {
  const factory ChatCompletionAssistantMessage(
          {final ChatCompletionMessageRole role,
          @JsonKey(includeIfNull: false) final String? content,
          @JsonKey(includeIfNull: false) final String? name,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionMessageToolCall>? toolCalls,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionMessageFunctionCall? functionCall}) =
      _$ChatCompletionAssistantMessageImpl;
  const ChatCompletionAssistantMessage._() : super._();

  factory ChatCompletionAssistantMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionAssistantMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `assistant`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
  @JsonKey(includeIfNull: false)
  String? get content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls;

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionMessageFunctionCall? get functionCall;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionAssistantMessageImplCopyWith<
          _$ChatCompletionAssistantMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionToolMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionToolMessageImplCopyWith(
          _$ChatCompletionToolMessageImpl value,
          $Res Function(_$ChatCompletionToolMessageImpl) then) =
      __$$ChatCompletionToolMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String content,
      @JsonKey(name: 'tool_call_id') String toolCallId});
}

/// @nodoc
class __$$ChatCompletionToolMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionToolMessageImpl>
    implements _$$ChatCompletionToolMessageImplCopyWith<$Res> {
  __$$ChatCompletionToolMessageImplCopyWithImpl(
      _$ChatCompletionToolMessageImpl _value,
      $Res Function(_$ChatCompletionToolMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? toolCallId = null,
  }) {
    return _then(_$ChatCompletionToolMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      toolCallId: null == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolMessageImpl extends ChatCompletionToolMessage {
  const _$ChatCompletionToolMessageImpl(
      {this.role = ChatCompletionMessageRole.tool,
      required this.content,
      @JsonKey(name: 'tool_call_id') required this.toolCallId})
      : super._();

  factory _$ChatCompletionToolMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionToolMessageImplFromJson(json);

  /// The role of the messages author, in this case `tool`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the tool message.
  @override
  final String content;

  /// Tool call that this message is responding to.
  @override
  @JsonKey(name: 'tool_call_id')
  final String toolCallId;

  @override
  String toString() {
    return 'ChatCompletionMessage.tool(role: $role, content: $content, toolCallId: $toolCallId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, toolCallId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolMessageImplCopyWith<_$ChatCompletionToolMessageImpl>
      get copyWith => __$$ChatCompletionToolMessageImplCopyWithImpl<
          _$ChatCompletionToolMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return tool(role, content, toolCallId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return tool?.call(role, content, toolCallId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(role, content, toolCallId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolMessage extends ChatCompletionMessage {
  const factory ChatCompletionToolMessage(
          {final ChatCompletionMessageRole role,
          required final String content,
          @JsonKey(name: 'tool_call_id') required final String toolCallId}) =
      _$ChatCompletionToolMessageImpl;
  const ChatCompletionToolMessage._() : super._();

  factory ChatCompletionToolMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionToolMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `tool`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the tool message.
  String get content;

  /// Tool call that this message is responding to.
  @JsonKey(name: 'tool_call_id')
  String get toolCallId;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionToolMessageImplCopyWith<_$ChatCompletionToolMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionFunctionMessageImplCopyWith(
          _$ChatCompletionFunctionMessageImpl value,
          $Res Function(_$ChatCompletionFunctionMessageImpl) then) =
      __$$ChatCompletionFunctionMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionMessageRole role, String? content, String name});
}

/// @nodoc
class __$$ChatCompletionFunctionMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionFunctionMessageImpl>
    implements _$$ChatCompletionFunctionMessageImplCopyWith<$Res> {
  __$$ChatCompletionFunctionMessageImplCopyWithImpl(
      _$ChatCompletionFunctionMessageImpl _value,
      $Res Function(_$ChatCompletionFunctionMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? name = null,
  }) {
    return _then(_$ChatCompletionFunctionMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionMessageImpl
    extends ChatCompletionFunctionMessage {
  const _$ChatCompletionFunctionMessageImpl(
      {this.role = ChatCompletionMessageRole.function,
      required this.content,
      required this.name})
      : super._();

  factory _$ChatCompletionFunctionMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionMessageImplFromJson(json);

  /// The role of the messages author, in this case `function`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the function message.
  @override
  final String? content;

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'ChatCompletionMessage.function(role: $role, content: $content, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionMessageImplCopyWith<
          _$ChatCompletionFunctionMessageImpl>
      get copyWith => __$$ChatCompletionFunctionMessageImplCopyWithImpl<
          _$ChatCompletionFunctionMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return function(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return function?.call(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(role, content, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionMessage extends ChatCompletionMessage {
  const factory ChatCompletionFunctionMessage(
      {final ChatCompletionMessageRole role,
      required final String? content,
      required final String name}) = _$ChatCompletionFunctionMessageImpl;
  const ChatCompletionFunctionMessage._() : super._();

  factory ChatCompletionFunctionMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionFunctionMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `function`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the function message.
  String? get content;

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionMessageImplCopyWith<
          _$ChatCompletionFunctionMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionUserMessageContent _$ChatCompletionUserMessageContentFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'parts':
      return ChatCompletionMessageContentParts.fromJson(json);
    case 'string':
      return ChatCompletionUserMessageContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionUserMessageContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionUserMessageContent {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionUserMessageContentCopyWith<$Res> {
  factory $ChatCompletionUserMessageContentCopyWith(
          ChatCompletionUserMessageContent value,
          $Res Function(ChatCompletionUserMessageContent) then) =
      _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
          ChatCompletionUserMessageContent>;
}

/// @nodoc
class _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        $Val extends ChatCompletionUserMessageContent>
    implements $ChatCompletionUserMessageContentCopyWith<$Res> {
  _$ChatCompletionUserMessageContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartsImplCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartsImplCopyWith(
          _$ChatCompletionMessageContentPartsImpl value,
          $Res Function(_$ChatCompletionMessageContentPartsImpl) then) =
      __$$ChatCompletionMessageContentPartsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ChatCompletionMessageContentPart> value});
}

/// @nodoc
class __$$ChatCompletionMessageContentPartsImplCopyWithImpl<$Res>
    extends _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartsImpl>
    implements _$$ChatCompletionMessageContentPartsImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartsImplCopyWithImpl(
      _$ChatCompletionMessageContentPartsImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartsImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageContentPart>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartsImpl
    extends ChatCompletionMessageContentParts {
  const _$ChatCompletionMessageContentPartsImpl(
      final List<ChatCompletionMessageContentPart> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'parts',
        super._();

  factory _$ChatCompletionMessageContentPartsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartsImplFromJson(json);

  final List<ChatCompletionMessageContentPart> _value;
  @override
  List<ChatCompletionMessageContentPart> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.parts(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartsImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartsImplCopyWith<
          _$ChatCompletionMessageContentPartsImpl>
      get copyWith => __$$ChatCompletionMessageContentPartsImplCopyWithImpl<
          _$ChatCompletionMessageContentPartsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) {
    return parts(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) {
    return parts?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) {
    return parts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) {
    return parts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartsImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentParts
    extends ChatCompletionUserMessageContent {
  const factory ChatCompletionMessageContentParts(
          final List<ChatCompletionMessageContentPart> value) =
      _$ChatCompletionMessageContentPartsImpl;
  const ChatCompletionMessageContentParts._() : super._();

  factory ChatCompletionMessageContentParts.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartsImpl.fromJson;

  @override
  List<ChatCompletionMessageContentPart> get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartsImplCopyWith<
          _$ChatCompletionMessageContentPartsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionUserMessageContentStringImplCopyWith<$Res> {
  factory _$$ChatCompletionUserMessageContentStringImplCopyWith(
          _$ChatCompletionUserMessageContentStringImpl value,
          $Res Function(_$ChatCompletionUserMessageContentStringImpl) then) =
      __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        _$ChatCompletionUserMessageContentStringImpl>
    implements _$$ChatCompletionUserMessageContentStringImplCopyWith<$Res> {
  __$$ChatCompletionUserMessageContentStringImplCopyWithImpl(
      _$ChatCompletionUserMessageContentStringImpl _value,
      $Res Function(_$ChatCompletionUserMessageContentStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionUserMessageContentStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionUserMessageContentStringImpl
    extends ChatCompletionUserMessageContentString {
  const _$ChatCompletionUserMessageContentStringImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ChatCompletionUserMessageContentStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionUserMessageContentStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionUserMessageContentStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionUserMessageContentStringImplCopyWith<
          _$ChatCompletionUserMessageContentStringImpl>
      get copyWith =>
          __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<
              _$ChatCompletionUserMessageContentStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionUserMessageContentStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionUserMessageContentString
    extends ChatCompletionUserMessageContent {
  const factory ChatCompletionUserMessageContentString(final String value) =
      _$ChatCompletionUserMessageContentStringImpl;
  const ChatCompletionUserMessageContentString._() : super._();

  factory ChatCompletionUserMessageContentString.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionUserMessageContentStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionUserMessageContentStringImplCopyWith<
          _$ChatCompletionUserMessageContentStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageContentPart _$ChatCompletionMessageContentPartFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'text':
      return ChatCompletionMessageContentPartText.fromJson(json);
    case 'image_url':
      return ChatCompletionMessageContentPartImage.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChatCompletionMessageContentPart',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessageContentPart {
  /// The type of the content part, in this case `text`.
  ChatCompletionMessageContentPartType get type =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageContentPartCopyWith<ChatCompletionMessageContentPart>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartCopyWith(
          ChatCompletionMessageContentPart value,
          $Res Function(ChatCompletionMessageContentPart) then) =
      _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
          ChatCompletionMessageContentPart>;
  @useResult
  $Res call({ChatCompletionMessageContentPartType type});
}

/// @nodoc
class _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageContentPart>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  _$ChatCompletionMessageContentPartCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartTextImplCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartTextImplCopyWith(
          _$ChatCompletionMessageContentPartTextImpl value,
          $Res Function(_$ChatCompletionMessageContentPartTextImpl) then) =
      __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionMessageContentPartType type, String text});
}

/// @nodoc
class __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartTextImpl>
    implements _$$ChatCompletionMessageContentPartTextImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartTextImplCopyWithImpl(
      _$ChatCompletionMessageContentPartTextImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartTextImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartTextImpl
    extends ChatCompletionMessageContentPartText {
  const _$ChatCompletionMessageContentPartTextImpl(
      {this.type = ChatCompletionMessageContentPartType.text,
      required this.text})
      : super._();

  factory _$ChatCompletionMessageContentPartTextImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartTextImplFromJson(json);

  /// The type of the content part, in this case `text`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The text content.
  @override
  final String text;

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.text(type: $type, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartTextImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartTextImplCopyWith<
          _$ChatCompletionMessageContentPartTextImpl>
      get copyWith => __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<
          _$ChatCompletionMessageContentPartTextImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) {
    return text(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) {
    return text?.call(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(type, this.text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartTextImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentPartText
    extends ChatCompletionMessageContentPart {
  const factory ChatCompletionMessageContentPartText(
      {final ChatCompletionMessageContentPartType type,
      required final String text}) = _$ChatCompletionMessageContentPartTextImpl;
  const ChatCompletionMessageContentPartText._() : super._();

  factory ChatCompletionMessageContentPartText.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartTextImpl.fromJson;

  @override

  /// The type of the content part, in this case `text`.
  ChatCompletionMessageContentPartType get type;

  /// The text content.
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartTextImplCopyWith<
          _$ChatCompletionMessageContentPartTextImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartImageImplCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartImageImplCopyWith(
          _$ChatCompletionMessageContentPartImageImpl value,
          $Res Function(_$ChatCompletionMessageContentPartImageImpl) then) =
      __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageContentPartType type,
      @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl});

  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl;
}

/// @nodoc
class __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartImageImpl>
    implements _$$ChatCompletionMessageContentPartImageImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartImageImplCopyWithImpl(
      _$ChatCompletionMessageContentPartImageImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? imageUrl = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartImageImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageUrl,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl {
    return $ChatCompletionMessageImageUrlCopyWith<$Res>(_value.imageUrl,
        (value) {
      return _then(_value.copyWith(imageUrl: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartImageImpl
    extends ChatCompletionMessageContentPartImage {
  const _$ChatCompletionMessageContentPartImageImpl(
      {this.type = ChatCompletionMessageContentPartType.imageUrl,
      @JsonKey(name: 'image_url') required this.imageUrl})
      : super._();

  factory _$ChatCompletionMessageContentPartImageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartImageImplFromJson(json);

  /// The type of the content part, in this case `image_url`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The URL of the image.
  @override
  @JsonKey(name: 'image_url')
  final ChatCompletionMessageImageUrl imageUrl;

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.image(type: $type, imageUrl: $imageUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartImageImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartImageImplCopyWith<
          _$ChatCompletionMessageContentPartImageImpl>
      get copyWith => __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<
          _$ChatCompletionMessageContentPartImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) {
    return image(type, imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) {
    return image?.call(type, imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(type, imageUrl);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartImageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentPartImage
    extends ChatCompletionMessageContentPart {
  const factory ChatCompletionMessageContentPartImage(
          {final ChatCompletionMessageContentPartType type,
          @JsonKey(name: 'image_url')
          required final ChatCompletionMessageImageUrl imageUrl}) =
      _$ChatCompletionMessageContentPartImageImpl;
  const ChatCompletionMessageContentPartImage._() : super._();

  factory ChatCompletionMessageContentPartImage.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartImageImpl.fromJson;

  @override

  /// The type of the content part, in this case `image_url`.
  ChatCompletionMessageContentPartType get type;

  /// The URL of the image.
  @JsonKey(name: 'image_url')
  ChatCompletionMessageImageUrl get imageUrl;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartImageImplCopyWith<
          _$ChatCompletionMessageContentPartImageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageImageUrl _$ChatCompletionMessageImageUrlFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageImageUrl.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageImageUrl {
  /// Either a URL of the image or the base64 encoded image data.
  String get url => throw _privateConstructorUsedError;

  /// Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
  ChatCompletionMessageImageDetail get detail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageImageUrlCopyWith<ChatCompletionMessageImageUrl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory $ChatCompletionMessageImageUrlCopyWith(
          ChatCompletionMessageImageUrl value,
          $Res Function(ChatCompletionMessageImageUrl) then) =
      _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
          ChatCompletionMessageImageUrl>;
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageImageUrl>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  _$ChatCompletionMessageImageUrlCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_value.copyWith(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageImageUrlImplCopyWith<$Res>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory _$$ChatCompletionMessageImageUrlImplCopyWith(
          _$ChatCompletionMessageImageUrlImpl value,
          $Res Function(_$ChatCompletionMessageImageUrlImpl) then) =
      __$$ChatCompletionMessageImageUrlImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class __$$ChatCompletionMessageImageUrlImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
        _$ChatCompletionMessageImageUrlImpl>
    implements _$$ChatCompletionMessageImageUrlImplCopyWith<$Res> {
  __$$ChatCompletionMessageImageUrlImplCopyWithImpl(
      _$ChatCompletionMessageImageUrlImpl _value,
      $Res Function(_$ChatCompletionMessageImageUrlImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_$ChatCompletionMessageImageUrlImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageImageUrlImpl
    extends _ChatCompletionMessageImageUrl {
  const _$ChatCompletionMessageImageUrlImpl(
      {required this.url, this.detail = ChatCompletionMessageImageDetail.auto})
      : super._();

  factory _$ChatCompletionMessageImageUrlImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageImageUrlImplFromJson(json);

  /// Either a URL of the image or the base64 encoded image data.
  @override
  final String url;

  /// Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
  @override
  @JsonKey()
  final ChatCompletionMessageImageDetail detail;

  @override
  String toString() {
    return 'ChatCompletionMessageImageUrl(url: $url, detail: $detail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageImageUrlImpl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageImageUrlImplCopyWith<
          _$ChatCompletionMessageImageUrlImpl>
      get copyWith => __$$ChatCompletionMessageImageUrlImplCopyWithImpl<
          _$ChatCompletionMessageImageUrlImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageImageUrlImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageImageUrl
    extends ChatCompletionMessageImageUrl {
  const factory _ChatCompletionMessageImageUrl(
          {required final String url,
          final ChatCompletionMessageImageDetail detail}) =
      _$ChatCompletionMessageImageUrlImpl;
  const _ChatCompletionMessageImageUrl._() : super._();

  factory _ChatCompletionMessageImageUrl.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageImageUrlImpl.fromJson;

  @override

  /// Either a URL of the image or the base64 encoded image data.
  String get url;
  @override

  /// Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
  ChatCompletionMessageImageDetail get detail;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageImageUrlImplCopyWith<
          _$ChatCompletionMessageImageUrlImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantTools _$AssistantToolsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return AssistantToolsCodeInterpreter.fromJson(json);
    case 'retrieval':
      return AssistantToolsRetrieval.fromJson(json);
    case 'function':
      return AssistantToolsFunction.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'AssistantTools',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$AssistantTools {
  /// The type of tool being defined: `code_interpreter`
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(String type) retrieval,
    required TResult Function(String type, FunctionObject function) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(String type)? retrieval,
    TResult? Function(String type, FunctionObject function)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(String type)? retrieval,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsRetrieval value) retrieval,
    required TResult Function(AssistantToolsFunction value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsRetrieval value)? retrieval,
    TResult? Function(AssistantToolsFunction value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsRetrieval value)? retrieval,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantToolsCopyWith<AssistantTools> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantToolsCopyWith<$Res> {
  factory $AssistantToolsCopyWith(
          AssistantTools value, $Res Function(AssistantTools) then) =
      _$AssistantToolsCopyWithImpl<$Res, AssistantTools>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$AssistantToolsCopyWithImpl<$Res, $Val extends AssistantTools>
    implements $AssistantToolsCopyWith<$Res> {
  _$AssistantToolsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssistantToolsCodeInterpreterImplCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory _$$AssistantToolsCodeInterpreterImplCopyWith(
          _$AssistantToolsCodeInterpreterImpl value,
          $Res Function(_$AssistantToolsCodeInterpreterImpl) then) =
      __$$AssistantToolsCodeInterpreterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class __$$AssistantToolsCodeInterpreterImplCopyWithImpl<$Res>
    extends _$AssistantToolsCopyWithImpl<$Res,
        _$AssistantToolsCodeInterpreterImpl>
    implements _$$AssistantToolsCodeInterpreterImplCopyWith<$Res> {
  __$$AssistantToolsCodeInterpreterImplCopyWithImpl(
      _$AssistantToolsCodeInterpreterImpl _value,
      $Res Function(_$AssistantToolsCodeInterpreterImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$AssistantToolsCodeInterpreterImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantToolsCodeInterpreterImpl
    extends AssistantToolsCodeInterpreter {
  const _$AssistantToolsCodeInterpreterImpl({this.type = 'code_interpreter'})
      : super._();

  factory _$AssistantToolsCodeInterpreterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$AssistantToolsCodeInterpreterImplFromJson(json);

  /// The type of tool being defined: `code_interpreter`
  @override
  @JsonKey()
  final String type;

  @override
  String toString() {
    return 'AssistantTools.codeInterpreter(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantToolsCodeInterpreterImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantToolsCodeInterpreterImplCopyWith<
          _$AssistantToolsCodeInterpreterImpl>
      get copyWith => __$$AssistantToolsCodeInterpreterImplCopyWithImpl<
          _$AssistantToolsCodeInterpreterImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(String type) retrieval,
    required TResult Function(String type, FunctionObject function) function,
  }) {
    return codeInterpreter(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(String type)? retrieval,
    TResult? Function(String type, FunctionObject function)? function,
  }) {
    return codeInterpreter?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(String type)? retrieval,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsRetrieval value) retrieval,
    required TResult Function(AssistantToolsFunction value) function,
  }) {
    return codeInterpreter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsRetrieval value)? retrieval,
    TResult? Function(AssistantToolsFunction value)? function,
  }) {
    return codeInterpreter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsRetrieval value)? retrieval,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantToolsCodeInterpreterImplToJson(
      this,
    );
  }
}

abstract class AssistantToolsCodeInterpreter extends AssistantTools {
  const factory AssistantToolsCodeInterpreter({final String type}) =
      _$AssistantToolsCodeInterpreterImpl;
  const AssistantToolsCodeInterpreter._() : super._();

  factory AssistantToolsCodeInterpreter.fromJson(Map<String, dynamic> json) =
      _$AssistantToolsCodeInterpreterImpl.fromJson;

  @override

  /// The type of tool being defined: `code_interpreter`
  String get type;
  @override
  @JsonKey(ignore: true)
  _$$AssistantToolsCodeInterpreterImplCopyWith<
          _$AssistantToolsCodeInterpreterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssistantToolsRetrievalImplCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory _$$AssistantToolsRetrievalImplCopyWith(
          _$AssistantToolsRetrievalImpl value,
          $Res Function(_$AssistantToolsRetrievalImpl) then) =
      __$$AssistantToolsRetrievalImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class __$$AssistantToolsRetrievalImplCopyWithImpl<$Res>
    extends _$AssistantToolsCopyWithImpl<$Res, _$AssistantToolsRetrievalImpl>
    implements _$$AssistantToolsRetrievalImplCopyWith<$Res> {
  __$$AssistantToolsRetrievalImplCopyWithImpl(
      _$AssistantToolsRetrievalImpl _value,
      $Res Function(_$AssistantToolsRetrievalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$AssistantToolsRetrievalImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantToolsRetrievalImpl extends AssistantToolsRetrieval {
  const _$AssistantToolsRetrievalImpl({this.type = 'retrieval'}) : super._();

  factory _$AssistantToolsRetrievalImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantToolsRetrievalImplFromJson(json);

  /// The type of tool being defined: `retrieval`
  @override
  @JsonKey()
  final String type;

  @override
  String toString() {
    return 'AssistantTools.retrieval(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantToolsRetrievalImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantToolsRetrievalImplCopyWith<_$AssistantToolsRetrievalImpl>
      get copyWith => __$$AssistantToolsRetrievalImplCopyWithImpl<
          _$AssistantToolsRetrievalImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(String type) retrieval,
    required TResult Function(String type, FunctionObject function) function,
  }) {
    return retrieval(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(String type)? retrieval,
    TResult? Function(String type, FunctionObject function)? function,
  }) {
    return retrieval?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(String type)? retrieval,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) {
    if (retrieval != null) {
      return retrieval(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsRetrieval value) retrieval,
    required TResult Function(AssistantToolsFunction value) function,
  }) {
    return retrieval(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsRetrieval value)? retrieval,
    TResult? Function(AssistantToolsFunction value)? function,
  }) {
    return retrieval?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsRetrieval value)? retrieval,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) {
    if (retrieval != null) {
      return retrieval(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantToolsRetrievalImplToJson(
      this,
    );
  }
}

abstract class AssistantToolsRetrieval extends AssistantTools {
  const factory AssistantToolsRetrieval({final String type}) =
      _$AssistantToolsRetrievalImpl;
  const AssistantToolsRetrieval._() : super._();

  factory AssistantToolsRetrieval.fromJson(Map<String, dynamic> json) =
      _$AssistantToolsRetrievalImpl.fromJson;

  @override

  /// The type of tool being defined: `retrieval`
  String get type;
  @override
  @JsonKey(ignore: true)
  _$$AssistantToolsRetrievalImplCopyWith<_$AssistantToolsRetrievalImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssistantToolsFunctionImplCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory _$$AssistantToolsFunctionImplCopyWith(
          _$AssistantToolsFunctionImpl value,
          $Res Function(_$AssistantToolsFunctionImpl) then) =
      __$$AssistantToolsFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, FunctionObject function});

  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class __$$AssistantToolsFunctionImplCopyWithImpl<$Res>
    extends _$AssistantToolsCopyWithImpl<$Res, _$AssistantToolsFunctionImpl>
    implements _$$AssistantToolsFunctionImplCopyWith<$Res> {
  __$$AssistantToolsFunctionImplCopyWithImpl(
      _$AssistantToolsFunctionImpl _value,
      $Res Function(_$AssistantToolsFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$AssistantToolsFunctionImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantToolsFunctionImpl extends AssistantToolsFunction {
  const _$AssistantToolsFunctionImpl(
      {this.type = 'function', required this.function})
      : super._();

  factory _$AssistantToolsFunctionImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantToolsFunctionImplFromJson(json);

  /// The type of tool being defined: `function`
  @override
  @JsonKey()
  final String type;

  /// A function that the model may call.
  @override
  final FunctionObject function;

  @override
  String toString() {
    return 'AssistantTools.function(type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantToolsFunctionImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantToolsFunctionImplCopyWith<_$AssistantToolsFunctionImpl>
      get copyWith => __$$AssistantToolsFunctionImplCopyWithImpl<
          _$AssistantToolsFunctionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(String type) retrieval,
    required TResult Function(String type, FunctionObject function) function,
  }) {
    return function(type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(String type)? retrieval,
    TResult? Function(String type, FunctionObject function)? function,
  }) {
    return function?.call(type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(String type)? retrieval,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(type, this.function);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsRetrieval value) retrieval,
    required TResult Function(AssistantToolsFunction value) function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsRetrieval value)? retrieval,
    TResult? Function(AssistantToolsFunction value)? function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsRetrieval value)? retrieval,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantToolsFunctionImplToJson(
      this,
    );
  }
}

abstract class AssistantToolsFunction extends AssistantTools {
  const factory AssistantToolsFunction(
      {final String type,
      required final FunctionObject function}) = _$AssistantToolsFunctionImpl;
  const AssistantToolsFunction._() : super._();

  factory AssistantToolsFunction.fromJson(Map<String, dynamic> json) =
      _$AssistantToolsFunctionImpl.fromJson;

  @override

  /// The type of tool being defined: `function`
  String get type;

  /// A function that the model may call.
  FunctionObject get function;
  @override
  @JsonKey(ignore: true)
  _$$AssistantToolsFunctionImplCopyWith<_$AssistantToolsFunctionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContent _$MessageContentFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'image_file':
      return MessageContentImageFileObject.fromJson(json);
    case 'text':
      return MessageContentTextObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'MessageContent',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageContent {
  /// Always `image_file`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type, MessageContentText text) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type, MessageContentText text)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type, MessageContentText text)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentTextObject value) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentTextObject value)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentTextObject value)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentCopyWith<MessageContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentCopyWith<$Res> {
  factory $MessageContentCopyWith(
          MessageContent value, $Res Function(MessageContent) then) =
      _$MessageContentCopyWithImpl<$Res, MessageContent>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$MessageContentCopyWithImpl<$Res, $Val extends MessageContent>
    implements $MessageContentCopyWith<$Res> {
  _$MessageContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentImageFileObjectImplCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory _$$MessageContentImageFileObjectImplCopyWith(
          _$MessageContentImageFileObjectImpl value,
          $Res Function(_$MessageContentImageFileObjectImpl) then) =
      __$$MessageContentImageFileObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'image_file') MessageContentImageFile imageFile});

  $MessageContentImageFileCopyWith<$Res> get imageFile;
}

/// @nodoc
class __$$MessageContentImageFileObjectImplCopyWithImpl<$Res>
    extends _$MessageContentCopyWithImpl<$Res,
        _$MessageContentImageFileObjectImpl>
    implements _$$MessageContentImageFileObjectImplCopyWith<$Res> {
  __$$MessageContentImageFileObjectImplCopyWithImpl(
      _$MessageContentImageFileObjectImpl _value,
      $Res Function(_$MessageContentImageFileObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? imageFile = null,
  }) {
    return _then(_$MessageContentImageFileObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageFile: null == imageFile
          ? _value.imageFile
          : imageFile // ignore: cast_nullable_to_non_nullable
              as MessageContentImageFile,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageFileCopyWith<$Res> get imageFile {
    return $MessageContentImageFileCopyWith<$Res>(_value.imageFile, (value) {
      return _then(_value.copyWith(imageFile: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentImageFileObjectImpl
    extends MessageContentImageFileObject {
  const _$MessageContentImageFileObjectImpl(
      {required this.type,
      @JsonKey(name: 'image_file') required this.imageFile})
      : super._();

  factory _$MessageContentImageFileObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentImageFileObjectImplFromJson(json);

  /// Always `image_file`.
  @override
  final String type;

  /// The image file that is part of a message.
  @override
  @JsonKey(name: 'image_file')
  final MessageContentImageFile imageFile;

  @override
  String toString() {
    return 'MessageContent.imageFile(type: $type, imageFile: $imageFile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentImageFileObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageFile, imageFile) ||
                other.imageFile == imageFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentImageFileObjectImplCopyWith<
          _$MessageContentImageFileObjectImpl>
      get copyWith => __$$MessageContentImageFileObjectImplCopyWithImpl<
          _$MessageContentImageFileObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type, MessageContentText text) text,
  }) {
    return imageFile(type, this.imageFile);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type, MessageContentText text)? text,
  }) {
    return imageFile?.call(type, this.imageFile);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type, MessageContentText text)? text,
    required TResult orElse(),
  }) {
    if (imageFile != null) {
      return imageFile(type, this.imageFile);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentTextObject value) text,
  }) {
    return imageFile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentTextObject value)? text,
  }) {
    return imageFile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentTextObject value)? text,
    required TResult orElse(),
  }) {
    if (imageFile != null) {
      return imageFile(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentImageFileObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentImageFileObject extends MessageContent {
  const factory MessageContentImageFileObject(
          {required final String type,
          @JsonKey(name: 'image_file')
          required final MessageContentImageFile imageFile}) =
      _$MessageContentImageFileObjectImpl;
  const MessageContentImageFileObject._() : super._();

  factory MessageContentImageFileObject.fromJson(Map<String, dynamic> json) =
      _$MessageContentImageFileObjectImpl.fromJson;

  @override

  /// Always `image_file`.
  String get type;

  /// The image file that is part of a message.
  @JsonKey(name: 'image_file')
  MessageContentImageFile get imageFile;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentImageFileObjectImplCopyWith<
          _$MessageContentImageFileObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageContentTextObjectImplCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory _$$MessageContentTextObjectImplCopyWith(
          _$MessageContentTextObjectImpl value,
          $Res Function(_$MessageContentTextObjectImpl) then) =
      __$$MessageContentTextObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, MessageContentText text});

  $MessageContentTextCopyWith<$Res> get text;
}

/// @nodoc
class __$$MessageContentTextObjectImplCopyWithImpl<$Res>
    extends _$MessageContentCopyWithImpl<$Res, _$MessageContentTextObjectImpl>
    implements _$$MessageContentTextObjectImplCopyWith<$Res> {
  __$$MessageContentTextObjectImplCopyWithImpl(
      _$MessageContentTextObjectImpl _value,
      $Res Function(_$MessageContentTextObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_$MessageContentTextObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as MessageContentText,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextCopyWith<$Res> get text {
    return $MessageContentTextCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextObjectImpl extends MessageContentTextObject {
  const _$MessageContentTextObjectImpl({required this.type, required this.text})
      : super._();

  factory _$MessageContentTextObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageContentTextObjectImplFromJson(json);

  /// Always `text`.
  @override
  final String type;

  /// The text content that is part of a message.
  @override
  final MessageContentText text;

  @override
  String toString() {
    return 'MessageContent.text(type: $type, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextObjectImplCopyWith<_$MessageContentTextObjectImpl>
      get copyWith => __$$MessageContentTextObjectImplCopyWithImpl<
          _$MessageContentTextObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type, MessageContentText text) text,
  }) {
    return text(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type, MessageContentText text)? text,
  }) {
    return text?.call(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type, MessageContentText text)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(type, this.text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentTextObject value) text,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentTextObject value)? text,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentTextObject value)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentTextObject extends MessageContent {
  const factory MessageContentTextObject(
      {required final String type,
      required final MessageContentText text}) = _$MessageContentTextObjectImpl;
  const MessageContentTextObject._() : super._();

  factory MessageContentTextObject.fromJson(Map<String, dynamic> json) =
      _$MessageContentTextObjectImpl.fromJson;

  @override

  /// Always `text`.
  String get type;

  /// The text content that is part of a message.
  MessageContentText get text;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextObjectImplCopyWith<_$MessageContentTextObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentTextAnnotations _$MessageContentTextAnnotationsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'file_citation':
      return MessageContentTextAnnotationsFileCitationObject.fromJson(json);
    case 'file_path':
      return MessageContentTextAnnotationsFilePathObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'MessageContentTextAnnotations',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageContentTextAnnotations {
  /// Always `file_citation`.
  Enum get type => throw _privateConstructorUsedError;

  /// The text in the message content that needs to be replaced.
  String get text => throw _privateConstructorUsedError;

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index')
  int get startIndex => throw _privateConstructorUsedError;

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index')
  int get endIndex => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        fileCitation,
    required TResult Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult? Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(MessageContentTextAnnotationsFilePathObject value)
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextAnnotationsCopyWith<MessageContentTextAnnotations>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextAnnotationsCopyWith<$Res> {
  factory $MessageContentTextAnnotationsCopyWith(
          MessageContentTextAnnotations value,
          $Res Function(MessageContentTextAnnotations) then) =
      _$MessageContentTextAnnotationsCopyWithImpl<$Res,
          MessageContentTextAnnotations>;
  @useResult
  $Res call(
      {String text,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});
}

/// @nodoc
class _$MessageContentTextAnnotationsCopyWithImpl<$Res,
        $Val extends MessageContentTextAnnotations>
    implements $MessageContentTextAnnotationsCopyWith<$Res> {
  _$MessageContentTextAnnotationsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(_value.copyWith(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      startIndex: null == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<
    $Res> implements $MessageContentTextAnnotationsCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith(
          _$MessageContentTextAnnotationsFileCitationObjectImpl value,
          $Res Function(_$MessageContentTextAnnotationsFileCitationObjectImpl)
              then) =
      __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {MessageContentTextAnnotationsFileCitationObjectType type,
      String text,
      @JsonKey(name: 'file_citation')
      MessageContentTextAnnotationsFileCitation fileCitation,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});

  $MessageContentTextAnnotationsFileCitationCopyWith<$Res> get fileCitation;
}

/// @nodoc
class __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFileCitationObjectImpl>
    implements
        _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl(
      _$MessageContentTextAnnotationsFileCitationObjectImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFileCitationObjectImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? fileCitation = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFileCitationObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFileCitationObjectType,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      fileCitation: null == fileCitation
          ? _value.fileCitation
          : fileCitation // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFileCitation,
      startIndex: null == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFileCitationCopyWith<$Res> get fileCitation {
    return $MessageContentTextAnnotationsFileCitationCopyWith<$Res>(
        _value.fileCitation, (value) {
      return _then(_value.copyWith(fileCitation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFileCitationObjectImpl
    extends MessageContentTextAnnotationsFileCitationObject {
  const _$MessageContentTextAnnotationsFileCitationObjectImpl(
      {required this.type,
      required this.text,
      @JsonKey(name: 'file_citation') required this.fileCitation,
      @JsonKey(name: 'start_index') required this.startIndex,
      @JsonKey(name: 'end_index') required this.endIndex})
      : super._();

  factory _$MessageContentTextAnnotationsFileCitationObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFileCitationObjectImplFromJson(json);

  /// Always `file_citation`.
  @override
  final MessageContentTextAnnotationsFileCitationObjectType type;

  /// The text in the message content that needs to be replaced.
  @override
  final String text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @override
  @JsonKey(name: 'file_citation')
  final MessageContentTextAnnotationsFileCitation fileCitation;

  /// The start index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'start_index')
  final int startIndex;

  /// The end index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'end_index')
  final int endIndex;

  @override
  String toString() {
    return 'MessageContentTextAnnotations.fileCitation(type: $type, text: $text, fileCitation: $fileCitation, startIndex: $startIndex, endIndex: $endIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFileCitationObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.fileCitation, fileCitation) ||
                other.fileCitation == fileCitation) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, text, fileCitation, startIndex, endIndex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationObjectImpl>
      get copyWith =>
          __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl<
                  _$MessageContentTextAnnotationsFileCitationObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        fileCitation,
    required TResult Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        filePath,
  }) {
    return fileCitation(type, text, this.fileCitation, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult? Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
  }) {
    return fileCitation?.call(
        type, text, this.fileCitation, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    if (fileCitation != null) {
      return fileCitation(type, text, this.fileCitation, startIndex, endIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(MessageContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    return fileCitation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    return fileCitation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    if (fileCitation != null) {
      return fileCitation(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFileCitationObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentTextAnnotationsFileCitationObject
    extends MessageContentTextAnnotations {
  const factory MessageContentTextAnnotationsFileCitationObject(
      {required final MessageContentTextAnnotationsFileCitationObjectType type,
      required final String text,
      @JsonKey(name: 'file_citation')
      required final MessageContentTextAnnotationsFileCitation fileCitation,
      @JsonKey(name: 'start_index') required final int startIndex,
      @JsonKey(name: 'end_index')
      required final int
          endIndex}) = _$MessageContentTextAnnotationsFileCitationObjectImpl;
  const MessageContentTextAnnotationsFileCitationObject._() : super._();

  factory MessageContentTextAnnotationsFileCitationObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFileCitationObjectImpl.fromJson;

  @override

  /// Always `file_citation`.
  MessageContentTextAnnotationsFileCitationObjectType get type;
  @override

  /// The text in the message content that needs to be replaced.
  String get text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @JsonKey(name: 'file_citation')
  MessageContentTextAnnotationsFileCitation get fileCitation;
  @override

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index')
  int get startIndex;
  @override

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index')
  int get endIndex;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<$Res>
    implements $MessageContentTextAnnotationsCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith(
          _$MessageContentTextAnnotationsFilePathObjectImpl value,
          $Res Function(_$MessageContentTextAnnotationsFilePathObjectImpl)
              then) =
      __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {MessageContentTextAnnotationsFilePathObjectType type,
      String text,
      @JsonKey(name: 'file_path')
      MessageContentTextAnnotationsFilePath filePath,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});

  $MessageContentTextAnnotationsFilePathCopyWith<$Res> get filePath;
}

/// @nodoc
class __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFilePathObjectImpl>
    implements
        _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl(
      _$MessageContentTextAnnotationsFilePathObjectImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFilePathObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? filePath = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFilePathObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFilePathObjectType,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      filePath: null == filePath
          ? _value.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFilePath,
      startIndex: null == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFilePathCopyWith<$Res> get filePath {
    return $MessageContentTextAnnotationsFilePathCopyWith<$Res>(_value.filePath,
        (value) {
      return _then(_value.copyWith(filePath: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFilePathObjectImpl
    extends MessageContentTextAnnotationsFilePathObject {
  const _$MessageContentTextAnnotationsFilePathObjectImpl(
      {required this.type,
      required this.text,
      @JsonKey(name: 'file_path') required this.filePath,
      @JsonKey(name: 'start_index') required this.startIndex,
      @JsonKey(name: 'end_index') required this.endIndex})
      : super._();

  factory _$MessageContentTextAnnotationsFilePathObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFilePathObjectImplFromJson(json);

  /// Always `file_path`.
  @override
  final MessageContentTextAnnotationsFilePathObjectType type;

  /// The text in the message content that needs to be replaced.
  @override
  final String text;

  /// No Description
  @override
  @JsonKey(name: 'file_path')
  final MessageContentTextAnnotationsFilePath filePath;

  /// No Description
  @override
  @JsonKey(name: 'start_index')
  final int startIndex;

  /// No Description
  @override
  @JsonKey(name: 'end_index')
  final int endIndex;

  @override
  String toString() {
    return 'MessageContentTextAnnotations.filePath(type: $type, text: $text, filePath: $filePath, startIndex: $startIndex, endIndex: $endIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFilePathObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.filePath, filePath) ||
                other.filePath == filePath) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, text, filePath, startIndex, endIndex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<
          _$MessageContentTextAnnotationsFilePathObjectImpl>
      get copyWith =>
          __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl<
                  _$MessageContentTextAnnotationsFilePathObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        fileCitation,
    required TResult Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        filePath,
  }) {
    return filePath(type, text, this.filePath, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult? Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
  }) {
    return filePath?.call(type, text, this.filePath, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            MessageContentTextAnnotationsFileCitationObjectType type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult Function(
            MessageContentTextAnnotationsFilePathObjectType type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(type, text, this.filePath, startIndex, endIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(MessageContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    return filePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    return filePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFilePathObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentTextAnnotationsFilePathObject
    extends MessageContentTextAnnotations {
  const factory MessageContentTextAnnotationsFilePathObject(
          {required final MessageContentTextAnnotationsFilePathObjectType type,
          required final String text,
          @JsonKey(name: 'file_path')
          required final MessageContentTextAnnotationsFilePath filePath,
          @JsonKey(name: 'start_index') required final int startIndex,
          @JsonKey(name: 'end_index') required final int endIndex}) =
      _$MessageContentTextAnnotationsFilePathObjectImpl;
  const MessageContentTextAnnotationsFilePathObject._() : super._();

  factory MessageContentTextAnnotationsFilePathObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFilePathObjectImpl.fromJson;

  @override

  /// Always `file_path`.
  MessageContentTextAnnotationsFilePathObjectType get type;
  @override

  /// The text in the message content that needs to be replaced.
  String get text;

  /// No Description
  @JsonKey(name: 'file_path')
  MessageContentTextAnnotationsFilePath get filePath;
  @override

  /// No Description
  @JsonKey(name: 'start_index')
  int get startIndex;
  @override

  /// No Description
  @JsonKey(name: 'end_index')
  int get endIndex;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<
          _$MessageContentTextAnnotationsFilePathObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentTextAnnotationsFilePath
    _$MessageContentTextAnnotationsFilePathFromJson(Map<String, dynamic> json) {
  return _MessageContentTextAnnotationsFilePath.fromJson(json);
}

/// @nodoc
mixin _$MessageContentTextAnnotationsFilePath {
  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextAnnotationsFilePathCopyWith<
          MessageContentTextAnnotationsFilePath>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFilePathCopyWith(
          MessageContentTextAnnotationsFilePath value,
          $Res Function(MessageContentTextAnnotationsFilePath) then) =
      _$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res,
          MessageContentTextAnnotationsFilePath>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res,
        $Val extends MessageContentTextAnnotationsFilePath>
    implements $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  _$MessageContentTextAnnotationsFilePathCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFilePathImplCopyWith<$Res>
    implements $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFilePathImplCopyWith(
          _$MessageContentTextAnnotationsFilePathImpl value,
          $Res Function(_$MessageContentTextAnnotationsFilePathImpl) then) =
      __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFilePathImpl>
    implements _$$MessageContentTextAnnotationsFilePathImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl(
      _$MessageContentTextAnnotationsFilePathImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFilePathImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFilePathImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFilePathImpl
    extends _MessageContentTextAnnotationsFilePath {
  const _$MessageContentTextAnnotationsFilePathImpl(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();

  factory _$MessageContentTextAnnotationsFilePathImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFilePathImplFromJson(json);

  /// The ID of the file that was generated.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFilePath(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFilePathImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFilePathImplCopyWith<
          _$MessageContentTextAnnotationsFilePathImpl>
      get copyWith => __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl<
          _$MessageContentTextAnnotationsFilePathImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFilePathImplToJson(
      this,
    );
  }
}

abstract class _MessageContentTextAnnotationsFilePath
    extends MessageContentTextAnnotationsFilePath {
  const factory _MessageContentTextAnnotationsFilePath(
          {@JsonKey(name: 'file_id') required final String fileId}) =
      _$MessageContentTextAnnotationsFilePathImpl;
  const _MessageContentTextAnnotationsFilePath._() : super._();

  factory _MessageContentTextAnnotationsFilePath.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFilePathImpl.fromJson;

  @override

  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFilePathImplCopyWith<
          _$MessageContentTextAnnotationsFilePathImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetails _$RunStepDetailsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'message_creation':
      return RunStepDetailsMessageCreationObject.fromJson(json);
    case 'tool_calls':
      return RunStepDetailsToolCallsObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDetails',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetails {
  /// Always `message_creation`.
  Enum get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)
        messageCreation,
    required TResult Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)
        toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult? Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDetailsToolCallsObject value) toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDetailsToolCallsObject value)? toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsCopyWith<$Res> {
  factory $RunStepDetailsCopyWith(
          RunStepDetails value, $Res Function(RunStepDetails) then) =
      _$RunStepDetailsCopyWithImpl<$Res, RunStepDetails>;
}

/// @nodoc
class _$RunStepDetailsCopyWithImpl<$Res, $Val extends RunStepDetails>
    implements $RunStepDetailsCopyWith<$Res> {
  _$RunStepDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RunStepDetailsMessageCreationObjectImplCopyWith<$Res> {
  factory _$$RunStepDetailsMessageCreationObjectImplCopyWith(
          _$RunStepDetailsMessageCreationObjectImpl value,
          $Res Function(_$RunStepDetailsMessageCreationObjectImpl) then) =
      __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {RunStepDetailsMessageCreationObjectType type,
      @JsonKey(name: 'message_creation')
      RunStepDetailsMessageCreation messageCreation});

  $RunStepDetailsMessageCreationCopyWith<$Res> get messageCreation;
}

/// @nodoc
class __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsCopyWithImpl<$Res,
        _$RunStepDetailsMessageCreationObjectImpl>
    implements _$$RunStepDetailsMessageCreationObjectImplCopyWith<$Res> {
  __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl(
      _$RunStepDetailsMessageCreationObjectImpl _value,
      $Res Function(_$RunStepDetailsMessageCreationObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? messageCreation = null,
  }) {
    return _then(_$RunStepDetailsMessageCreationObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsMessageCreationObjectType,
      messageCreation: null == messageCreation
          ? _value.messageCreation
          : messageCreation // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsMessageCreation,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsMessageCreationCopyWith<$Res> get messageCreation {
    return $RunStepDetailsMessageCreationCopyWith<$Res>(_value.messageCreation,
        (value) {
      return _then(_value.copyWith(messageCreation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsMessageCreationObjectImpl
    extends RunStepDetailsMessageCreationObject {
  const _$RunStepDetailsMessageCreationObjectImpl(
      {required this.type,
      @JsonKey(name: 'message_creation') required this.messageCreation})
      : super._();

  factory _$RunStepDetailsMessageCreationObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsMessageCreationObjectImplFromJson(json);

  /// Always `message_creation`.
  @override
  final RunStepDetailsMessageCreationObjectType type;

  /// Details of the message creation by the run step.
  @override
  @JsonKey(name: 'message_creation')
  final RunStepDetailsMessageCreation messageCreation;

  @override
  String toString() {
    return 'RunStepDetails.messageCreation(type: $type, messageCreation: $messageCreation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsMessageCreationObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.messageCreation, messageCreation) ||
                other.messageCreation == messageCreation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, messageCreation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsMessageCreationObjectImplCopyWith<
          _$RunStepDetailsMessageCreationObjectImpl>
      get copyWith => __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl<
          _$RunStepDetailsMessageCreationObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)
        messageCreation,
    required TResult Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)
        toolCalls,
  }) {
    return messageCreation(type, this.messageCreation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult? Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
  }) {
    return messageCreation?.call(type, this.messageCreation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    if (messageCreation != null) {
      return messageCreation(type, this.messageCreation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDetailsToolCallsObject value) toolCalls,
  }) {
    return messageCreation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDetailsToolCallsObject value)? toolCalls,
  }) {
    return messageCreation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    if (messageCreation != null) {
      return messageCreation(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsMessageCreationObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsMessageCreationObject extends RunStepDetails {
  const factory RunStepDetailsMessageCreationObject(
          {required final RunStepDetailsMessageCreationObjectType type,
          @JsonKey(name: 'message_creation')
          required final RunStepDetailsMessageCreation messageCreation}) =
      _$RunStepDetailsMessageCreationObjectImpl;
  const RunStepDetailsMessageCreationObject._() : super._();

  factory RunStepDetailsMessageCreationObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsMessageCreationObjectImpl.fromJson;

  @override

  /// Always `message_creation`.
  RunStepDetailsMessageCreationObjectType get type;

  /// Details of the message creation by the run step.
  @JsonKey(name: 'message_creation')
  RunStepDetailsMessageCreation get messageCreation;
  @JsonKey(ignore: true)
  _$$RunStepDetailsMessageCreationObjectImplCopyWith<
          _$RunStepDetailsMessageCreationObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsObjectImplCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsObjectImplCopyWith(
          _$RunStepDetailsToolCallsObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsObjectImpl) then) =
      __$$RunStepDetailsToolCallsObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {RunStepDetailsToolCallsObjectType type,
      @JsonKey(name: 'tool_calls') List<RunStepDetailsToolCalls> toolCalls});
}

/// @nodoc
class __$$RunStepDetailsToolCallsObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsObjectImpl>
    implements _$$RunStepDetailsToolCallsObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? toolCalls = null,
  }) {
    return _then(_$RunStepDetailsToolCallsObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsObjectType,
      toolCalls: null == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCalls>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsObjectImpl
    extends RunStepDetailsToolCallsObject {
  const _$RunStepDetailsToolCallsObjectImpl(
      {required this.type,
      @JsonKey(name: 'tool_calls')
      required final List<RunStepDetailsToolCalls> toolCalls})
      : _toolCalls = toolCalls,
        super._();

  factory _$RunStepDetailsToolCallsObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsObjectImplFromJson(json);

  /// Always `tool_calls`.
  @override
  final RunStepDetailsToolCallsObjectType type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`.
  final List<RunStepDetailsToolCalls> _toolCalls;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`.
  @override
  @JsonKey(name: 'tool_calls')
  List<RunStepDetailsToolCalls> get toolCalls {
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolCalls);
  }

  @override
  String toString() {
    return 'RunStepDetails.toolCalls(type: $type, toolCalls: $toolCalls)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, type, const DeepCollectionEquality().hash(_toolCalls));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsObjectImplCopyWith<
          _$RunStepDetailsToolCallsObjectImpl>
      get copyWith => __$$RunStepDetailsToolCallsObjectImplCopyWithImpl<
          _$RunStepDetailsToolCallsObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)
        messageCreation,
    required TResult Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)
        toolCalls,
  }) {
    return toolCalls(type, this.toolCalls);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult? Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
  }) {
    return toolCalls?.call(type, this.toolCalls);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RunStepDetailsMessageCreationObjectType type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult Function(
            RunStepDetailsToolCallsObjectType type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    if (toolCalls != null) {
      return toolCalls(type, this.toolCalls);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDetailsToolCallsObject value) toolCalls,
  }) {
    return toolCalls(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDetailsToolCallsObject value)? toolCalls,
  }) {
    return toolCalls?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    if (toolCalls != null) {
      return toolCalls(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsObject extends RunStepDetails {
  const factory RunStepDetailsToolCallsObject(
          {required final RunStepDetailsToolCallsObjectType type,
          @JsonKey(name: 'tool_calls')
          required final List<RunStepDetailsToolCalls> toolCalls}) =
      _$RunStepDetailsToolCallsObjectImpl;
  const RunStepDetailsToolCallsObject._() : super._();

  factory RunStepDetailsToolCallsObject.fromJson(Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsObjectImpl.fromJson;

  @override

  /// Always `tool_calls`.
  RunStepDetailsToolCallsObjectType get type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`.
  @JsonKey(name: 'tool_calls')
  List<RunStepDetailsToolCalls> get toolCalls;
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsObjectImplCopyWith<
          _$RunStepDetailsToolCallsObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCalls _$RunStepDetailsToolCallsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return RunStepDetailsToolCallsCodeObject.fromJson(json);
    case 'retrieval':
      return RunStepDetailsToolCallsRetrievalObject.fromJson(json);
    case 'function':
      return RunStepDetailsToolCallsFunctionObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDetailsToolCalls',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCalls {
  /// The ID of the tool call.
  String get id => throw _privateConstructorUsedError;

  /// The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
  Enum get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)
        retrieval,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult? Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsRetrievalObject value)
        retrieval,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsCopyWith<RunStepDetailsToolCalls> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCopyWith(RunStepDetailsToolCalls value,
          $Res Function(RunStepDetailsToolCalls) then) =
      _$RunStepDetailsToolCallsCopyWithImpl<$Res, RunStepDetailsToolCalls>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCalls>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  _$RunStepDetailsToolCallsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeObjectImplCopyWith(
          _$RunStepDetailsToolCallsCodeObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeObjectImpl) then) =
      __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      RunStepDetailsToolCallsCodeObjectType type,
      @JsonKey(name: 'code_interpreter')
      RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter});

  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>
      get codeInterpreter;
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeObjectImpl>
    implements _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? codeInterpreter = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeObjectType,
      codeInterpreter: null == codeInterpreter
          ? _value.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeObjectCodeInterpreter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>
      get codeInterpreter {
    return $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>(
        _value.codeInterpreter, (value) {
      return _then(_value.copyWith(codeInterpreter: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeObjectImpl
    extends RunStepDetailsToolCallsCodeObject {
  const _$RunStepDetailsToolCallsCodeObjectImpl(
      {required this.id,
      required this.type,
      @JsonKey(name: 'code_interpreter') required this.codeInterpreter})
      : super._();

  factory _$RunStepDetailsToolCallsCodeObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeObjectImplFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
  @override
  final RunStepDetailsToolCallsCodeObjectType type;

  /// The Code Interpreter tool call definition.
  @override
  @JsonKey(name: 'code_interpreter')
  final RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter;

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.codeInterpreter(id: $id, type: $type, codeInterpreter: $codeInterpreter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, codeInterpreter);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectImpl>
      get copyWith => __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl<
          _$RunStepDetailsToolCallsCodeObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)
        retrieval,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)
        function,
  }) {
    return codeInterpreter(id, type, this.codeInterpreter);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult? Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
  }) {
    return codeInterpreter?.call(id, type, this.codeInterpreter);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(id, type, this.codeInterpreter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsRetrievalObject value)
        retrieval,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return codeInterpreter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) {
    return codeInterpreter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsCodeObject
    extends RunStepDetailsToolCalls {
  const factory RunStepDetailsToolCallsCodeObject(
      {required final String id,
      required final RunStepDetailsToolCallsCodeObjectType type,
      @JsonKey(name: 'code_interpreter')
      required final RunStepDetailsToolCallsCodeObjectCodeInterpreter
          codeInterpreter}) = _$RunStepDetailsToolCallsCodeObjectImpl;
  const RunStepDetailsToolCallsCodeObject._() : super._();

  factory RunStepDetailsToolCallsCodeObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeObjectImpl.fromJson;

  @override

  /// The ID of the tool call.
  String get id;
  @override

  /// The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
  RunStepDetailsToolCallsCodeObjectType get type;

  /// The Code Interpreter tool call definition.
  @JsonKey(name: 'code_interpreter')
  RunStepDetailsToolCallsCodeObjectCodeInterpreter get codeInterpreter;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsRetrievalObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsRetrievalObjectImplCopyWith(
          _$RunStepDetailsToolCallsRetrievalObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsRetrievalObjectImpl) then) =
      __$$RunStepDetailsToolCallsRetrievalObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      RunStepDetailsToolCallsRetrievalObjectType type,
      Map<String, dynamic> retrieval});
}

/// @nodoc
class __$$RunStepDetailsToolCallsRetrievalObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsRetrievalObjectImpl>
    implements _$$RunStepDetailsToolCallsRetrievalObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsRetrievalObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsRetrievalObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsRetrievalObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? retrieval = null,
  }) {
    return _then(_$RunStepDetailsToolCallsRetrievalObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsRetrievalObjectType,
      retrieval: null == retrieval
          ? _value._retrieval
          : retrieval // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsRetrievalObjectImpl
    extends RunStepDetailsToolCallsRetrievalObject {
  const _$RunStepDetailsToolCallsRetrievalObjectImpl(
      {required this.id,
      required this.type,
      required final Map<String, dynamic> retrieval})
      : _retrieval = retrieval,
        super._();

  factory _$RunStepDetailsToolCallsRetrievalObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsRetrievalObjectImplFromJson(json);

  /// The ID of the tool call object.
  @override
  final String id;

  /// The type of tool call. This is always going to be `retrieval` for this type of tool call.
  @override
  final RunStepDetailsToolCallsRetrievalObjectType type;

  /// For now, this is always going to be an empty object.
  final Map<String, dynamic> _retrieval;

  /// For now, this is always going to be an empty object.
  @override
  Map<String, dynamic> get retrieval {
    if (_retrieval is EqualUnmodifiableMapView) return _retrieval;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_retrieval);
  }

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.retrieval(id: $id, type: $type, retrieval: $retrieval)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsRetrievalObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._retrieval, _retrieval));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, type, const DeepCollectionEquality().hash(_retrieval));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsRetrievalObjectImplCopyWith<
          _$RunStepDetailsToolCallsRetrievalObjectImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsRetrievalObjectImplCopyWithImpl<
              _$RunStepDetailsToolCallsRetrievalObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)
        retrieval,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)
        function,
  }) {
    return retrieval(id, type, this.retrieval);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult? Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
  }) {
    return retrieval?.call(id, type, this.retrieval);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) {
    if (retrieval != null) {
      return retrieval(id, type, this.retrieval);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsRetrievalObject value)
        retrieval,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return retrieval(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) {
    return retrieval?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) {
    if (retrieval != null) {
      return retrieval(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsRetrievalObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsRetrievalObject
    extends RunStepDetailsToolCalls {
  const factory RunStepDetailsToolCallsRetrievalObject(
          {required final String id,
          required final RunStepDetailsToolCallsRetrievalObjectType type,
          required final Map<String, dynamic> retrieval}) =
      _$RunStepDetailsToolCallsRetrievalObjectImpl;
  const RunStepDetailsToolCallsRetrievalObject._() : super._();

  factory RunStepDetailsToolCallsRetrievalObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsRetrievalObjectImpl.fromJson;

  @override

  /// The ID of the tool call object.
  String get id;
  @override

  /// The type of tool call. This is always going to be `retrieval` for this type of tool call.
  RunStepDetailsToolCallsRetrievalObjectType get type;

  /// For now, this is always going to be an empty object.
  Map<String, dynamic> get retrieval;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsRetrievalObjectImplCopyWith<
          _$RunStepDetailsToolCallsRetrievalObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith(
          _$RunStepDetailsToolCallsFunctionObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsFunctionObjectImpl) then) =
      __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      RunStepDetailsToolCallsFunctionObjectType type,
      RunStepDetailsToolCallsFunction function});

  $RunStepDetailsToolCallsFunctionCopyWith<$Res> get function;
}

/// @nodoc
class __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsFunctionObjectImpl>
    implements _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsFunctionObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsFunctionObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$RunStepDetailsToolCallsFunctionObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsFunctionObjectType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsFunction,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFunctionCopyWith<$Res> get function {
    return $RunStepDetailsToolCallsFunctionCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsFunctionObjectImpl
    extends RunStepDetailsToolCallsFunctionObject {
  const _$RunStepDetailsToolCallsFunctionObjectImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$RunStepDetailsToolCallsFunctionObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsFunctionObjectImplFromJson(json);

  /// The ID of the tool call object.
  @override
  final String id;

  /// The type of tool call. This is always going to be `function` for this type of tool call.
  @override
  final RunStepDetailsToolCallsFunctionObjectType type;

  /// The definition of the function that was called.
  @override
  final RunStepDetailsToolCallsFunction function;

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.function(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsFunctionObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<
          _$RunStepDetailsToolCallsFunctionObjectImpl>
      get copyWith => __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl<
          _$RunStepDetailsToolCallsFunctionObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)
        retrieval,
    required TResult Function(
            String id,
            RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)
        function,
  }) {
    return function(id, type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            String id,
            RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult? Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
  }) {
    return function?.call(id, type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            RunStepDetailsToolCallsCodeObjectType type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, RunStepDetailsToolCallsRetrievalObjectType type,
            Map<String, dynamic> retrieval)?
        retrieval,
    TResult Function(String id, RunStepDetailsToolCallsFunctionObjectType type,
            RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(id, type, this.function);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsRetrievalObject value)
        retrieval,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsRetrievalObject value)? retrieval,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsFunctionObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsFunctionObject
    extends RunStepDetailsToolCalls {
  const factory RunStepDetailsToolCallsFunctionObject(
          {required final String id,
          required final RunStepDetailsToolCallsFunctionObjectType type,
          required final RunStepDetailsToolCallsFunction function}) =
      _$RunStepDetailsToolCallsFunctionObjectImpl;
  const RunStepDetailsToolCallsFunctionObject._() : super._();

  factory RunStepDetailsToolCallsFunctionObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsFunctionObjectImpl.fromJson;

  @override

  /// The ID of the tool call object.
  String get id;
  @override

  /// The type of tool call. This is always going to be `function` for this type of tool call.
  RunStepDetailsToolCallsFunctionObjectType get type;

  /// The definition of the function that was called.
  RunStepDetailsToolCallsFunction get function;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<
          _$RunStepDetailsToolCallsFunctionObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsFunction _$RunStepDetailsToolCallsFunctionFromJson(
    Map<String, dynamic> json) {
  return _RunStepDetailsToolCallsFunction.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsToolCallsFunction {
  /// The name of the function.
  String get name => throw _privateConstructorUsedError;

  /// The arguments passed to the function.
  String get arguments => throw _privateConstructorUsedError;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  String? get output => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsFunctionCopyWith<RunStepDetailsToolCallsFunction>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory $RunStepDetailsToolCallsFunctionCopyWith(
          RunStepDetailsToolCallsFunction value,
          $Res Function(RunStepDetailsToolCallsFunction) then) =
      _$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res,
          RunStepDetailsToolCallsFunction>;
  @useResult
  $Res call({String name, String arguments, String? output});
}

/// @nodoc
class _$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsFunction>
    implements $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  _$RunStepDetailsToolCallsFunctionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
    Object? output = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsFunctionImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsFunctionImplCopyWith(
          _$RunStepDetailsToolCallsFunctionImpl value,
          $Res Function(_$RunStepDetailsToolCallsFunctionImpl) then) =
      __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments, String? output});
}

/// @nodoc
class __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsFunctionImpl>
    implements _$$RunStepDetailsToolCallsFunctionImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl(
      _$RunStepDetailsToolCallsFunctionImpl _value,
      $Res Function(_$RunStepDetailsToolCallsFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
    Object? output = freezed,
  }) {
    return _then(_$RunStepDetailsToolCallsFunctionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsFunctionImpl
    extends _RunStepDetailsToolCallsFunction {
  const _$RunStepDetailsToolCallsFunctionImpl(
      {required this.name, required this.arguments, required this.output})
      : super._();

  factory _$RunStepDetailsToolCallsFunctionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsFunctionImplFromJson(json);

  /// The name of the function.
  @override
  final String name;

  /// The arguments passed to the function.
  @override
  final String arguments;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @override
  final String? output;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFunction(name: $name, arguments: $arguments, output: $output)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsFunctionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments, output);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsFunctionImplCopyWith<
          _$RunStepDetailsToolCallsFunctionImpl>
      get copyWith => __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl<
          _$RunStepDetailsToolCallsFunctionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsFunctionImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsToolCallsFunction
    extends RunStepDetailsToolCallsFunction {
  const factory _RunStepDetailsToolCallsFunction(
      {required final String name,
      required final String arguments,
      required final String? output}) = _$RunStepDetailsToolCallsFunctionImpl;
  const _RunStepDetailsToolCallsFunction._() : super._();

  factory _RunStepDetailsToolCallsFunction.fromJson(Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsFunctionImpl.fromJson;

  @override

  /// The name of the function.
  String get name;
  @override

  /// The arguments passed to the function.
  String get arguments;
  @override

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  String? get output;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsFunctionImplCopyWith<
          _$RunStepDetailsToolCallsFunctionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsCodeOutput _$RunStepDetailsToolCallsCodeOutputFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'logs':
      return RunStepDetailsToolCallsCodeOutputLogsObject.fromJson(json);
    case 'image':
      return RunStepDetailsToolCallsCodeOutputImageObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'RunStepDetailsToolCallsCodeOutput',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeOutput {
  /// Always `logs`.
  Enum get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)?
        logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)?
        logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)?
        image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObject value)? image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputCopyWith(
          RunStepDetailsToolCallsCodeOutput value,
          $Res Function(RunStepDetailsToolCallsCodeOutput) then) =
      _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
          RunStepDetailsToolCallsCodeOutput>;
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsCodeOutput>
    implements $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
    $Res> {
  factory _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith(
          _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeOutputLogsObjectImpl)
              then) =
      __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs});
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>
    implements
        _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeOutputLogsObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? logs = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeOutputLogsObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeOutputLogsObjectType,
      logs: null == logs
          ? _value.logs
          : logs // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl
    extends RunStepDetailsToolCallsCodeOutputLogsObject {
  const _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl(
      {required this.type, required this.logs})
      : super._();

  factory _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplFromJson(json);

  /// Always `logs`.
  @override
  final RunStepDetailsToolCallsCodeOutputLogsObjectType type;

  /// The text output from the Code Interpreter tool call.
  @override
  final String logs;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutput.logs(type: $type, logs: $logs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.logs, logs) || other.logs == logs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, logs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<
                  _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)
        image,
  }) {
    return logs(type, this.logs);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)?
        logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)?
        image,
  }) {
    return logs?.call(type, this.logs);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)?
        logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)?
        image,
    required TResult orElse(),
  }) {
    if (logs != null) {
      return logs(type, this.logs);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    return logs(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    return logs?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObject value)? image,
    required TResult orElse(),
  }) {
    if (logs != null) {
      return logs(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsCodeOutputLogsObject
    extends RunStepDetailsToolCallsCodeOutput {
  const factory RunStepDetailsToolCallsCodeOutputLogsObject(
          {required final RunStepDetailsToolCallsCodeOutputLogsObjectType type,
          required final String logs}) =
      _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl;
  const RunStepDetailsToolCallsCodeOutputLogsObject._() : super._();

  factory RunStepDetailsToolCallsCodeOutputLogsObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl.fromJson;

  @override

  /// Always `logs`.
  RunStepDetailsToolCallsCodeOutputLogsObjectType get type;

  /// The text output from the Code Interpreter tool call.
  String get logs;
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
    $Res> {
  factory _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith(
          _$RunStepDetailsToolCallsCodeOutputImageObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeOutputImageObjectImpl)
              then) =
      __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {RunStepDetailsToolCallsCodeOutputImageObjectType type,
      RunStepDetailsToolCallsCodeOutputImage image});

  $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> get image;
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>
    implements
        _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeOutputImageObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeOutputImageObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? image = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeOutputImageObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeOutputImageObjectType,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeOutputImage,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> get image {
    return $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res>(_value.image,
        (value) {
      return _then(_value.copyWith(image: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeOutputImageObjectImpl
    extends RunStepDetailsToolCallsCodeOutputImageObject {
  const _$RunStepDetailsToolCallsCodeOutputImageObjectImpl(
      {required this.type, required this.image})
      : super._();

  factory _$RunStepDetailsToolCallsCodeOutputImageObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeOutputImageObjectImplFromJson(json);

  /// Always `image`.
  @override
  final RunStepDetailsToolCallsCodeOutputImageObjectType type;

  /// Code interpreter image output.
  @override
  final RunStepDetailsToolCallsCodeOutputImage image;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutput.image(type: $type, image: $image)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeOutputImageObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, image);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<
                  _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)
        image,
  }) {
    return image(type, this.image);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)?
        logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)?
        image,
  }) {
    return image?.call(type, this.image);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RunStepDetailsToolCallsCodeOutputLogsObjectType type, String logs)?
        logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObjectType type,
            RunStepDetailsToolCallsCodeOutputImage image)?
        image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(type, this.image);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObject value)? image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeOutputImageObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsCodeOutputImageObject
    extends RunStepDetailsToolCallsCodeOutput {
  const factory RunStepDetailsToolCallsCodeOutputImageObject(
          {required final RunStepDetailsToolCallsCodeOutputImageObjectType type,
          required final RunStepDetailsToolCallsCodeOutputImage image}) =
      _$RunStepDetailsToolCallsCodeOutputImageObjectImpl;
  const RunStepDetailsToolCallsCodeOutputImageObject._() : super._();

  factory RunStepDetailsToolCallsCodeOutputImageObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeOutputImageObjectImpl.fromJson;

  @override

  /// Always `image`.
  RunStepDetailsToolCallsCodeOutputImageObjectType get type;

  /// Code interpreter image output.
  RunStepDetailsToolCallsCodeOutputImage get image;
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}
