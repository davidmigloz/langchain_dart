// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schema.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CreateCompletionRequest _$CreateCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model => throw _privateConstructorUsedError;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt => throw _privateConstructorUsedError;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf => throw _privateConstructorUsedError;

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop => throw _privateConstructorUsedError;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @JsonKey(name: 'stream_options', includeIfNull: false)
  ChatCompletionStreamOptions? get streamOptions =>
      throw _privateConstructorUsedError;

  /// The suffix that comes after a completion of inserted text.
  ///
  /// This parameter is only supported for `gpt-3.5-turbo-instruct`.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionRequestCopyWith<CreateCompletionRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionRequestCopyWith<$Res> {
  factory $CreateCompletionRequestCopyWith(CreateCompletionRequest value,
          $Res Function(CreateCompletionRequest) then) =
      _$CreateCompletionRequestCopyWithImpl<$Res, CreateCompletionRequest>;
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  $CompletionModelCopyWith<$Res> get model;
  $CompletionPromptCopyWith<$Res>? get prompt;
  $CompletionStopCopyWith<$Res>? get stop;
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
}

/// @nodoc
class _$CreateCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateCompletionRequest>
    implements $CreateCompletionRequestCopyWith<$Res> {
  _$CreateCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _value.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionModelCopyWith<$Res> get model {
    return $CompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionPromptCopyWith<$Res>? get prompt {
    if (_value.prompt == null) {
      return null;
    }

    return $CompletionPromptCopyWith<$Res>(_value.prompt!, (value) {
      return _then(_value.copyWith(prompt: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $CompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions {
    if (_value.streamOptions == null) {
      return null;
    }

    return $ChatCompletionStreamOptionsCopyWith<$Res>(_value.streamOptions!,
        (value) {
      return _then(_value.copyWith(streamOptions: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionRequestImplCopyWith<$Res>
    implements $CreateCompletionRequestCopyWith<$Res> {
  factory _$$CreateCompletionRequestImplCopyWith(
          _$CreateCompletionRequestImpl value,
          $Res Function(_$CreateCompletionRequestImpl) then) =
      __$$CreateCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_CompletionModelConverter() CompletionModel model,
      @_CompletionPromptConverter() CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) int? bestOf,
      @JsonKey(includeIfNull: false) bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(includeIfNull: false) int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      CompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CompletionModelCopyWith<$Res> get model;
  @override
  $CompletionPromptCopyWith<$Res>? get prompt;
  @override
  $CompletionStopCopyWith<$Res>? get stop;
  @override
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
}

/// @nodoc
class __$$CreateCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateCompletionRequestCopyWithImpl<$Res,
        _$CreateCompletionRequestImpl>
    implements _$$CreateCompletionRequestImplCopyWith<$Res> {
  __$$CreateCompletionRequestImplCopyWithImpl(
      _$CreateCompletionRequestImpl _value,
      $Res Function(_$CreateCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? prompt = freezed,
    Object? bestOf = freezed,
    Object? echo = freezed,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? seed = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? suffix = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CompletionModel,
      prompt: freezed == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as CompletionPrompt?,
      bestOf: freezed == bestOf
          ? _value.bestOf
          : bestOf // ignore: cast_nullable_to_non_nullable
              as int?,
      echo: freezed == echo
          ? _value.echo
          : echo // ignore: cast_nullable_to_non_nullable
              as bool?,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as CompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _value.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionRequestImpl extends _CreateCompletionRequest {
  const _$CreateCompletionRequestImpl(
      {@_CompletionModelConverter() required this.model,
      @_CompletionPromptConverter() required this.prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) this.bestOf,
      @JsonKey(includeIfNull: false) this.echo = false,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens = 16,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @JsonKey(includeIfNull: false) this.seed,
      @_CompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(name: 'stream_options', includeIfNull: false) this.streamOptions,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) this.user})
      : _logitBias = logitBias,
        super._();

  factory _$CreateCompletionRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @_CompletionModelConverter()
  final CompletionModel model;

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @override
  @_CompletionPromptConverter()
  final CompletionPrompt? prompt;

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(name: 'best_of', includeIfNull: false)
  final int? bestOf;

  /// Echo back the prompt in addition to the completion
  @override
  @JsonKey(includeIfNull: false)
  final bool? echo;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @override
  @JsonKey(includeIfNull: false)
  final int? logprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @override
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final CompletionStop? stop;

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @override
  @JsonKey(name: 'stream_options', includeIfNull: false)
  final ChatCompletionStreamOptions? streamOptions;

  /// The suffix that comes after a completion of inserted text.
  ///
  /// This parameter is only supported for `gpt-3.5-turbo-instruct`.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateCompletionRequest(model: $model, prompt: $prompt, bestOf: $bestOf, echo: $echo, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, seed: $seed, stop: $stop, stream: $stream, streamOptions: $streamOptions, suffix: $suffix, temperature: $temperature, topP: $topP, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.bestOf, bestOf) || other.bestOf == bestOf) &&
            (identical(other.echo, echo) || other.echo == echo) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.streamOptions, streamOptions) ||
                other.streamOptions == streamOptions) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      prompt,
      bestOf,
      echo,
      frequencyPenalty,
      const DeepCollectionEquality().hash(_logitBias),
      logprobs,
      maxTokens,
      n,
      presencePenalty,
      seed,
      stop,
      stream,
      streamOptions,
      suffix,
      temperature,
      topP,
      user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => __$$CreateCompletionRequestImplCopyWithImpl<
          _$CreateCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionRequest extends CreateCompletionRequest {
  const factory _CreateCompletionRequest(
      {@_CompletionModelConverter() required final CompletionModel model,
      @_CompletionPromptConverter() required final CompletionPrompt? prompt,
      @JsonKey(name: 'best_of', includeIfNull: false) final int? bestOf,
      @JsonKey(includeIfNull: false) final bool? echo,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) final int? logprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @JsonKey(includeIfNull: false) final int? seed,
      @_CompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final CompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      final ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) final String? suffix,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false)
      final String? user}) = _$CreateCompletionRequestImpl;
  const _CreateCompletionRequest._() : super._();

  factory _CreateCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_CompletionModelConverter()
  CompletionModel get model;
  @override

  /// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
  ///
  /// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
  @_CompletionPromptConverter()
  CompletionPrompt? get prompt;
  @override

  /// Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
  ///
  /// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(name: 'best_of', includeIfNull: false)
  int? get bestOf;
  @override

  /// Echo back the prompt in addition to the completion
  @JsonKey(includeIfNull: false)
  bool? get echo;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  ///
  /// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  ///
  /// The maximum value for `logprobs` is 5.
  @JsonKey(includeIfNull: false)
  int? get logprobs;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.
  ///
  /// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many completions to generate for each prompt.
  ///
  /// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  ///
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
  @_CompletionStopConverter()
  @JsonKey(includeIfNull: false)
  CompletionStop? get stop;
  @override

  /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// Options for streaming response. Only set this when you set `stream: true`.
  @JsonKey(name: 'stream_options', includeIfNull: false)
  ChatCompletionStreamOptions? get streamOptions;
  @override

  /// The suffix that comes after a completion of inserted text.
  ///
  /// This parameter is only supported for `gpt-3.5-turbo-instruct`.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionRequestImplCopyWith<_$CreateCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionModel _$CompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return CompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionModelCopyWith<$Res> {
  factory $CompletionModelCopyWith(
          CompletionModel value, $Res Function(CompletionModel) then) =
      _$CompletionModelCopyWithImpl<$Res, CompletionModel>;
}

/// @nodoc
class _$CompletionModelCopyWithImpl<$Res, $Val extends CompletionModel>
    implements $CompletionModelCopyWith<$Res> {
  _$CompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionModelEnumerationImplCopyWith<$Res> {
  factory _$$CompletionModelEnumerationImplCopyWith(
          _$CompletionModelEnumerationImpl value,
          $Res Function(_$CompletionModelEnumerationImpl) then) =
      __$$CompletionModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CompletionModels value});
}

/// @nodoc
class __$$CompletionModelEnumerationImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res,
        _$CompletionModelEnumerationImpl>
    implements _$$CompletionModelEnumerationImplCopyWith<$Res> {
  __$$CompletionModelEnumerationImplCopyWithImpl(
      _$CompletionModelEnumerationImpl _value,
      $Res Function(_$CompletionModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionModelEnumerationImpl extends CompletionModelEnumeration {
  const _$CompletionModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$CompletionModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionModelEnumerationImplFromJson(json);

  @override
  final CompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionModelEnumerationImplCopyWith<_$CompletionModelEnumerationImpl>
      get copyWith => __$$CompletionModelEnumerationImplCopyWithImpl<
          _$CompletionModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class CompletionModelEnumeration extends CompletionModel {
  const factory CompletionModelEnumeration(final CompletionModels value) =
      _$CompletionModelEnumerationImpl;
  const CompletionModelEnumeration._() : super._();

  factory CompletionModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$CompletionModelEnumerationImpl.fromJson;

  @override
  CompletionModels get value;
  @JsonKey(ignore: true)
  _$$CompletionModelEnumerationImplCopyWith<_$CompletionModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionModelStringImplCopyWith<$Res> {
  factory _$$CompletionModelStringImplCopyWith(
          _$CompletionModelStringImpl value,
          $Res Function(_$CompletionModelStringImpl) then) =
      __$$CompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CompletionModelStringImplCopyWithImpl<$Res>
    extends _$CompletionModelCopyWithImpl<$Res, _$CompletionModelStringImpl>
    implements _$$CompletionModelStringImplCopyWith<$Res> {
  __$$CompletionModelStringImplCopyWithImpl(_$CompletionModelStringImpl _value,
      $Res Function(_$CompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionModelStringImpl extends CompletionModelString {
  const _$CompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$CompletionModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionModelStringImplCopyWith<_$CompletionModelStringImpl>
      get copyWith => __$$CompletionModelStringImplCopyWithImpl<
          _$CompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionModelEnumeration value) model,
    required TResult Function(CompletionModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionModelEnumeration value)? model,
    TResult? Function(CompletionModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionModelEnumeration value)? model,
    TResult Function(CompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class CompletionModelString extends CompletionModel {
  const factory CompletionModelString(final String value) =
      _$CompletionModelStringImpl;
  const CompletionModelString._() : super._();

  factory CompletionModelString.fromJson(Map<String, dynamic> json) =
      _$CompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CompletionModelStringImplCopyWith<_$CompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionPrompt _$CompletionPromptFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return CompletionPromptListListInt.fromJson(json);
    case 'tokens':
      return CompletionPromptListInt.fromJson(json);
    case 'listString':
      return CompletionPromptListString.fromJson(json);
    case 'string':
      return CompletionPromptString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionPrompt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionPrompt {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionPromptCopyWith<$Res> {
  factory $CompletionPromptCopyWith(
          CompletionPrompt value, $Res Function(CompletionPrompt) then) =
      _$CompletionPromptCopyWithImpl<$Res, CompletionPrompt>;
}

/// @nodoc
class _$CompletionPromptCopyWithImpl<$Res, $Val extends CompletionPrompt>
    implements $CompletionPromptCopyWith<$Res> {
  _$CompletionPromptCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionPromptListListIntImplCopyWith<$Res> {
  factory _$$CompletionPromptListListIntImplCopyWith(
          _$CompletionPromptListListIntImpl value,
          $Res Function(_$CompletionPromptListListIntImpl) then) =
      __$$CompletionPromptListListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$CompletionPromptListListIntImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$CompletionPromptListListIntImpl>
    implements _$$CompletionPromptListListIntImplCopyWith<$Res> {
  __$$CompletionPromptListListIntImplCopyWithImpl(
      _$CompletionPromptListListIntImpl _value,
      $Res Function(_$CompletionPromptListListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListListIntImpl extends CompletionPromptListListInt {
  const _$CompletionPromptListListIntImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();

  factory _$CompletionPromptListListIntImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionPromptListListIntImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.listTokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListListIntImplCopyWith<_$CompletionPromptListListIntImpl>
      get copyWith => __$$CompletionPromptListListIntImplCopyWithImpl<
          _$CompletionPromptListListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listTokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listTokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return listTokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return listTokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListListIntImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListListInt extends CompletionPrompt {
  const factory CompletionPromptListListInt(final List<List<int>> value) =
      _$CompletionPromptListListIntImpl;
  const CompletionPromptListListInt._() : super._();

  factory CompletionPromptListListInt.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListListIntImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListListIntImplCopyWith<_$CompletionPromptListListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptListIntImplCopyWith<$Res> {
  factory _$$CompletionPromptListIntImplCopyWith(
          _$CompletionPromptListIntImpl value,
          $Res Function(_$CompletionPromptListIntImpl) then) =
      __$$CompletionPromptListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$CompletionPromptListIntImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res, _$CompletionPromptListIntImpl>
    implements _$$CompletionPromptListIntImplCopyWith<$Res> {
  __$$CompletionPromptListIntImplCopyWithImpl(
      _$CompletionPromptListIntImpl _value,
      $Res Function(_$CompletionPromptListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListIntImpl extends CompletionPromptListInt {
  const _$CompletionPromptListIntImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();

  factory _$CompletionPromptListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionPromptListIntImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.tokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListIntImplCopyWith<_$CompletionPromptListIntImpl>
      get copyWith => __$$CompletionPromptListIntImplCopyWithImpl<
          _$CompletionPromptListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return tokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return tokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return tokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return tokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListIntImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListInt extends CompletionPrompt {
  const factory CompletionPromptListInt(final List<int> value) =
      _$CompletionPromptListIntImpl;
  const CompletionPromptListInt._() : super._();

  factory CompletionPromptListInt.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListIntImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListIntImplCopyWith<_$CompletionPromptListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptListStringImplCopyWith<$Res> {
  factory _$$CompletionPromptListStringImplCopyWith(
          _$CompletionPromptListStringImpl value,
          $Res Function(_$CompletionPromptListStringImpl) then) =
      __$$CompletionPromptListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$CompletionPromptListStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res,
        _$CompletionPromptListStringImpl>
    implements _$$CompletionPromptListStringImplCopyWith<$Res> {
  __$$CompletionPromptListStringImplCopyWithImpl(
      _$CompletionPromptListStringImpl _value,
      $Res Function(_$CompletionPromptListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptListStringImpl extends CompletionPromptListString {
  const _$CompletionPromptListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$CompletionPromptListStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CompletionPromptListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptListStringImplCopyWith<_$CompletionPromptListStringImpl>
      get copyWith => __$$CompletionPromptListStringImplCopyWithImpl<
          _$CompletionPromptListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptListStringImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptListString extends CompletionPrompt {
  const factory CompletionPromptListString(final List<String> value) =
      _$CompletionPromptListStringImpl;
  const CompletionPromptListString._() : super._();

  factory CompletionPromptListString.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptListStringImplCopyWith<_$CompletionPromptListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionPromptStringImplCopyWith<$Res> {
  factory _$$CompletionPromptStringImplCopyWith(
          _$CompletionPromptStringImpl value,
          $Res Function(_$CompletionPromptStringImpl) then) =
      __$$CompletionPromptStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CompletionPromptStringImplCopyWithImpl<$Res>
    extends _$CompletionPromptCopyWithImpl<$Res, _$CompletionPromptStringImpl>
    implements _$$CompletionPromptStringImplCopyWith<$Res> {
  __$$CompletionPromptStringImplCopyWithImpl(
      _$CompletionPromptStringImpl _value,
      $Res Function(_$CompletionPromptStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionPromptStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionPromptStringImpl extends CompletionPromptString {
  const _$CompletionPromptStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$CompletionPromptStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionPromptStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionPrompt.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionPromptStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionPromptStringImplCopyWith<_$CompletionPromptStringImpl>
      get copyWith => __$$CompletionPromptStringImplCopyWithImpl<
          _$CompletionPromptStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionPromptListListInt value) listTokens,
    required TResult Function(CompletionPromptListInt value) tokens,
    required TResult Function(CompletionPromptListString value) listString,
    required TResult Function(CompletionPromptString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionPromptListListInt value)? listTokens,
    TResult? Function(CompletionPromptListInt value)? tokens,
    TResult? Function(CompletionPromptListString value)? listString,
    TResult? Function(CompletionPromptString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionPromptListListInt value)? listTokens,
    TResult Function(CompletionPromptListInt value)? tokens,
    TResult Function(CompletionPromptListString value)? listString,
    TResult Function(CompletionPromptString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionPromptStringImplToJson(
      this,
    );
  }
}

abstract class CompletionPromptString extends CompletionPrompt {
  const factory CompletionPromptString(final String value) =
      _$CompletionPromptStringImpl;
  const CompletionPromptString._() : super._();

  factory CompletionPromptString.fromJson(Map<String, dynamic> json) =
      _$CompletionPromptStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CompletionPromptStringImplCopyWith<_$CompletionPromptStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionStop _$CompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return CompletionStopListString.fromJson(json);
    case 'string':
      return CompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CompletionStop {
  Object? get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionStopCopyWith<$Res> {
  factory $CompletionStopCopyWith(
          CompletionStop value, $Res Function(CompletionStop) then) =
      _$CompletionStopCopyWithImpl<$Res, CompletionStop>;
}

/// @nodoc
class _$CompletionStopCopyWithImpl<$Res, $Val extends CompletionStop>
    implements $CompletionStopCopyWith<$Res> {
  _$CompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompletionStopListStringImplCopyWith<$Res> {
  factory _$$CompletionStopListStringImplCopyWith(
          _$CompletionStopListStringImpl value,
          $Res Function(_$CompletionStopListStringImpl) then) =
      __$$CompletionStopListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$CompletionStopListStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res, _$CompletionStopListStringImpl>
    implements _$$CompletionStopListStringImplCopyWith<$Res> {
  __$$CompletionStopListStringImplCopyWithImpl(
      _$CompletionStopListStringImpl _value,
      $Res Function(_$CompletionStopListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompletionStopListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionStopListStringImpl extends CompletionStopListString {
  const _$CompletionStopListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$CompletionStopListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionStopListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionStopListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionStopListStringImplCopyWith<_$CompletionStopListStringImpl>
      get copyWith => __$$CompletionStopListStringImplCopyWithImpl<
          _$CompletionStopListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionStopListStringImplToJson(
      this,
    );
  }
}

abstract class CompletionStopListString extends CompletionStop {
  const factory CompletionStopListString(final List<String> value) =
      _$CompletionStopListStringImpl;
  const CompletionStopListString._() : super._();

  factory CompletionStopListString.fromJson(Map<String, dynamic> json) =
      _$CompletionStopListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$CompletionStopListStringImplCopyWith<_$CompletionStopListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompletionStopStringImplCopyWith<$Res> {
  factory _$$CompletionStopStringImplCopyWith(_$CompletionStopStringImpl value,
          $Res Function(_$CompletionStopStringImpl) then) =
      __$$CompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class __$$CompletionStopStringImplCopyWithImpl<$Res>
    extends _$CompletionStopCopyWithImpl<$Res, _$CompletionStopStringImpl>
    implements _$$CompletionStopStringImplCopyWith<$Res> {
  __$$CompletionStopStringImplCopyWithImpl(_$CompletionStopStringImpl _value,
      $Res Function(_$CompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$CompletionStopStringImpl(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionStopStringImpl extends CompletionStopString {
  const _$CompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$CompletionStopStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionStopStringImplFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionStopStringImplCopyWith<_$CompletionStopStringImpl>
      get copyWith =>
          __$$CompletionStopStringImplCopyWithImpl<_$CompletionStopStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompletionStopListString value) listString,
    required TResult Function(CompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompletionStopListString value)? listString,
    TResult? Function(CompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompletionStopListString value)? listString,
    TResult Function(CompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class CompletionStopString extends CompletionStop {
  const factory CompletionStopString(final String? value) =
      _$CompletionStopStringImpl;
  const CompletionStopString._() : super._();

  factory CompletionStopString.fromJson(Map<String, dynamic> json) =
      _$CompletionStopStringImpl.fromJson;

  @override
  String? get value;
  @JsonKey(ignore: true)
  _$$CompletionStopStringImplCopyWith<_$CompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateCompletionResponse _$CreateCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateCompletionResponse {
  /// A unique identifier for the completion.
  String get id => throw _privateConstructorUsedError;

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for completion.
  String get model => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always "text_completion"
  CreateCompletionResponseObject get object =>
      throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateCompletionResponseCopyWith<CreateCompletionResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCompletionResponseCopyWith<$Res> {
  factory $CreateCompletionResponseCopyWith(CreateCompletionResponse value,
          $Res Function(CreateCompletionResponse) then) =
      _$CreateCompletionResponseCopyWithImpl<$Res, CreateCompletionResponse>;
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateCompletionResponse>
    implements $CreateCompletionResponseCopyWith<$Res> {
  _$CreateCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateCompletionResponseImplCopyWith<$Res>
    implements $CreateCompletionResponseCopyWith<$Res> {
  factory _$$CreateCompletionResponseImplCopyWith(
          _$CreateCompletionResponseImpl value,
          $Res Function(_$CreateCompletionResponseImpl) then) =
      __$$CreateCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<CompletionChoice> choices,
      int created,
      String model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      CreateCompletionResponseObject object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateCompletionResponseCopyWithImpl<$Res,
        _$CreateCompletionResponseImpl>
    implements _$$CreateCompletionResponseImplCopyWith<$Res> {
  __$$CreateCompletionResponseImplCopyWithImpl(
      _$CreateCompletionResponseImpl _value,
      $Res Function(_$CreateCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateCompletionResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<CompletionChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateCompletionResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateCompletionResponseImpl extends _CreateCompletionResponse {
  const _$CreateCompletionResponseImpl(
      {required this.id,
      required final List<CompletionChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateCompletionResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateCompletionResponseImplFromJson(json);

  /// A unique identifier for the completion.
  @override
  final String id;

  /// The list of completion choices the model generated for the input prompt.
  final List<CompletionChoice> _choices;

  /// The list of completion choices the model generated for the input prompt.
  @override
  List<CompletionChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the completion was created.
  @override
  final int created;

  /// The model used for completion.
  @override
  final String model;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always "text_completion"
  @override
  final CreateCompletionResponseObject object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => __$$CreateCompletionResponseImplCopyWithImpl<
          _$CreateCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateCompletionResponse extends CreateCompletionResponse {
  const factory _CreateCompletionResponse(
          {required final String id,
          required final List<CompletionChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final CreateCompletionResponseObject object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateCompletionResponseImpl;
  const _CreateCompletionResponse._() : super._();

  factory _CreateCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the completion.
  String get id;
  @override

  /// The list of completion choices the model generated for the input prompt.
  List<CompletionChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the completion was created.
  int get created;
  @override

  /// The model used for completion.
  String get model;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always "text_completion"
  CreateCompletionResponseObject get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateCompletionResponseImplCopyWith<_$CreateCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionChoice _$CompletionChoiceFromJson(Map<String, dynamic> json) {
  return _CompletionChoice.fromJson(json);
}

/// @nodoc
mixin _$CompletionChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of generated choices.
  int get index => throw _privateConstructorUsedError;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs => throw _privateConstructorUsedError;

  /// The text of the completion.
  String get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionChoiceCopyWith<CompletionChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionChoiceCopyWith<$Res> {
  factory $CompletionChoiceCopyWith(
          CompletionChoice value, $Res Function(CompletionChoice) then) =
      _$CompletionChoiceCopyWithImpl<$Res, CompletionChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$CompletionChoiceCopyWithImpl<$Res, $Val extends CompletionChoice>
    implements $CompletionChoiceCopyWith<$Res> {
  _$CompletionChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_value.copyWith(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $CompletionLogprobsCopyWith<$Res>(_value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CompletionChoiceImplCopyWith<$Res>
    implements $CompletionChoiceCopyWith<$Res> {
  factory _$$CompletionChoiceImplCopyWith(_$CompletionChoiceImpl value,
          $Res Function(_$CompletionChoiceImpl) then) =
      __$$CompletionChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CompletionFinishReason? finishReason,
      int index,
      CompletionLogprobs? logprobs,
      String text});

  @override
  $CompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$CompletionChoiceImplCopyWithImpl<$Res>
    extends _$CompletionChoiceCopyWithImpl<$Res, _$CompletionChoiceImpl>
    implements _$$CompletionChoiceImplCopyWith<$Res> {
  __$$CompletionChoiceImplCopyWithImpl(_$CompletionChoiceImpl _value,
      $Res Function(_$CompletionChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = null,
    Object? logprobs = freezed,
    Object? text = null,
  }) {
    return _then(_$CompletionChoiceImpl(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as CompletionFinishReason?,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as CompletionLogprobs?,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionChoiceImpl extends _CompletionChoice {
  const _$CompletionChoiceImpl(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      required this.index,
      required this.logprobs,
      required this.text})
      : super._();

  factory _$CompletionChoiceImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final CompletionFinishReason? finishReason;

  /// The index of the choice in the list of generated choices.
  @override
  final int index;

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  @override
  final CompletionLogprobs? logprobs;

  /// The text of the completion.
  @override
  final String text;

  @override
  String toString() {
    return 'CompletionChoice(finishReason: $finishReason, index: $index, logprobs: $logprobs, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, finishReason, index, logprobs, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      __$$CompletionChoiceImplCopyWithImpl<_$CompletionChoiceImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionChoiceImplToJson(
      this,
    );
  }
}

abstract class _CompletionChoice extends CompletionChoice {
  const factory _CompletionChoice(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required final CompletionFinishReason? finishReason,
      required final int index,
      required final CompletionLogprobs? logprobs,
      required final String text}) = _$CompletionChoiceImpl;
  const _CompletionChoice._() : super._();

  factory _CompletionChoice.fromJson(Map<String, dynamic> json) =
      _$CompletionChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// or `content_filter` if content was omitted due to a flag from our content filters.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of generated choices.
  int get index;
  @override

  /// The probabilities on the `logprobs` most likely tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
  CompletionLogprobs? get logprobs;
  @override

  /// The text of the completion.
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$CompletionChoiceImplCopyWith<_$CompletionChoiceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CompletionLogprobs _$CompletionLogprobsFromJson(Map<String, dynamic> json) {
  return _CompletionLogprobs.fromJson(json);
}

/// @nodoc
mixin _$CompletionLogprobs {
  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset => throw _privateConstructorUsedError;

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs => throw _privateConstructorUsedError;

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens => throw _privateConstructorUsedError;

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionLogprobsCopyWith<CompletionLogprobs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionLogprobsCopyWith<$Res> {
  factory $CompletionLogprobsCopyWith(
          CompletionLogprobs value, $Res Function(CompletionLogprobs) then) =
      _$CompletionLogprobsCopyWithImpl<$Res, CompletionLogprobs>;
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class _$CompletionLogprobsCopyWithImpl<$Res, $Val extends CompletionLogprobs>
    implements $CompletionLogprobsCopyWith<$Res> {
  _$CompletionLogprobsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_value.copyWith(
      textOffset: freezed == textOffset
          ? _value.textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value.tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value.tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionLogprobsImplCopyWith<$Res>
    implements $CompletionLogprobsCopyWith<$Res> {
  factory _$$CompletionLogprobsImplCopyWith(_$CompletionLogprobsImpl value,
          $Res Function(_$CompletionLogprobsImpl) then) =
      __$$CompletionLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      List<Map<String, double>?>? topLogprobs});
}

/// @nodoc
class __$$CompletionLogprobsImplCopyWithImpl<$Res>
    extends _$CompletionLogprobsCopyWithImpl<$Res, _$CompletionLogprobsImpl>
    implements _$$CompletionLogprobsImplCopyWith<$Res> {
  __$$CompletionLogprobsImplCopyWithImpl(_$CompletionLogprobsImpl _value,
      $Res Function(_$CompletionLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textOffset = freezed,
    Object? tokenLogprobs = freezed,
    Object? tokens = freezed,
    Object? topLogprobs = freezed,
  }) {
    return _then(_$CompletionLogprobsImpl(
      textOffset: freezed == textOffset
          ? _value._textOffset
          : textOffset // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      tokenLogprobs: freezed == tokenLogprobs
          ? _value._tokenLogprobs
          : tokenLogprobs // ignore: cast_nullable_to_non_nullable
              as List<double?>?,
      tokens: freezed == tokens
          ? _value._tokens
          : tokens // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      topLogprobs: freezed == topLogprobs
          ? _value._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<Map<String, double>?>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionLogprobsImpl extends _CompletionLogprobs {
  const _$CompletionLogprobsImpl(
      {@JsonKey(name: 'text_offset', includeIfNull: false)
      final List<int>? textOffset,
      @JsonKey(name: 'token_logprobs', includeIfNull: false)
      final List<double?>? tokenLogprobs,
      @JsonKey(includeIfNull: false) final List<String>? tokens,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      final List<Map<String, double>?>? topLogprobs})
      : _textOffset = textOffset,
        _tokenLogprobs = tokenLogprobs,
        _tokens = tokens,
        _topLogprobs = topLogprobs,
        super._();

  factory _$CompletionLogprobsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionLogprobsImplFromJson(json);

  /// The offset of the token from the beginning of the prompt.
  final List<int>? _textOffset;

  /// The offset of the token from the beginning of the prompt.
  @override
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset {
    final value = _textOffset;
    if (value == null) return null;
    if (_textOffset is EqualUnmodifiableListView) return _textOffset;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of tokens in the completion.
  final List<double?>? _tokenLogprobs;

  /// The log probabilities of tokens in the completion.
  @override
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs {
    final value = _tokenLogprobs;
    if (value == null) return null;
    if (_tokenLogprobs is EqualUnmodifiableListView) return _tokenLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The tokens generated by the model converted back to text.
  final List<String>? _tokens;

  /// The tokens generated by the model converted back to text.
  @override
  @JsonKey(includeIfNull: false)
  List<String>? get tokens {
    final value = _tokens;
    if (value == null) return null;
    if (_tokens is EqualUnmodifiableListView) return _tokens;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The log probabilities of the `logprobs` most likely tokens.
  final List<Map<String, double>?>? _topLogprobs;

  /// The log probabilities of the `logprobs` most likely tokens.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs {
    final value = _topLogprobs;
    if (value == null) return null;
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CompletionLogprobs(textOffset: $textOffset, tokenLogprobs: $tokenLogprobs, tokens: $tokens, topLogprobs: $topLogprobs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionLogprobsImpl &&
            const DeepCollectionEquality()
                .equals(other._textOffset, _textOffset) &&
            const DeepCollectionEquality()
                .equals(other._tokenLogprobs, _tokenLogprobs) &&
            const DeepCollectionEquality().equals(other._tokens, _tokens) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_textOffset),
      const DeepCollectionEquality().hash(_tokenLogprobs),
      const DeepCollectionEquality().hash(_tokens),
      const DeepCollectionEquality().hash(_topLogprobs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      __$$CompletionLogprobsImplCopyWithImpl<_$CompletionLogprobsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionLogprobsImplToJson(
      this,
    );
  }
}

abstract class _CompletionLogprobs extends CompletionLogprobs {
  const factory _CompletionLogprobs(
          {@JsonKey(name: 'text_offset', includeIfNull: false)
          final List<int>? textOffset,
          @JsonKey(name: 'token_logprobs', includeIfNull: false)
          final List<double?>? tokenLogprobs,
          @JsonKey(includeIfNull: false) final List<String>? tokens,
          @JsonKey(name: 'top_logprobs', includeIfNull: false)
          final List<Map<String, double>?>? topLogprobs}) =
      _$CompletionLogprobsImpl;
  const _CompletionLogprobs._() : super._();

  factory _CompletionLogprobs.fromJson(Map<String, dynamic> json) =
      _$CompletionLogprobsImpl.fromJson;

  @override

  /// The offset of the token from the beginning of the prompt.
  @JsonKey(name: 'text_offset', includeIfNull: false)
  List<int>? get textOffset;
  @override

  /// The log probabilities of tokens in the completion.
  @JsonKey(name: 'token_logprobs', includeIfNull: false)
  List<double?>? get tokenLogprobs;
  @override

  /// The tokens generated by the model converted back to text.
  @JsonKey(includeIfNull: false)
  List<String>? get tokens;
  @override

  /// The log probabilities of the `logprobs` most likely tokens.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  List<Map<String, double>?>? get topLogprobs;
  @override
  @JsonKey(ignore: true)
  _$$CompletionLogprobsImplCopyWith<_$CompletionLogprobsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateChatCompletionRequest _$CreateChatCompletionRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionRequest {
  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model => throw _privateConstructorUsedError;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages =>
      throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty => throw _privateConstructorUsedError;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias => throw _privateConstructorUsedError;

  /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.
  @JsonKey(includeIfNull: false)
  bool? get logprobs => throw _privateConstructorUsedError;

  /// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  int? get topLogprobs => throw _privateConstructorUsedError;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens => throw _privateConstructorUsedError;

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty => throw _privateConstructorUsedError;

  /// An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  /// Specifies the latency tier to use for processing the request. This parameter is relevant for customers
  /// subscribed to the scale tier service:
  ///   - If set to 'auto', the system will utilize scale tier credits until they are exhausted.
  ///   - If set to 'default', the request will be processed using the default service tier with a lower
  ///     uptime SLA and no latency guarantee.
  ///
  ///   When this parameter is set, the response body will include the `service_tier` utilized.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CreateChatCompletionRequestServiceTier? get serviceTier =>
      throw _privateConstructorUsedError;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop => throw _privateConstructorUsedError;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @JsonKey(name: 'stream_options', includeIfNull: false)
  ChatCompletionStreamOptions? get streamOptions =>
      throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools => throw _privateConstructorUsedError;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tool and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools.
  /// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  ///
  /// `none` is the default when no tools are present. `auto` is the default if tools are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice =>
      throw _privateConstructorUsedError;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionRequestCopyWith<CreateChatCompletionRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionRequestCopyWith<$Res> {
  factory $CreateChatCompletionRequestCopyWith(
          CreateChatCompletionRequest value,
          $Res Function(CreateChatCompletionRequest) then) =
      _$CreateChatCompletionRequestCopyWithImpl<$Res,
          CreateChatCompletionRequest>;
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CreateChatCompletionRequestServiceTier? serviceTier,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions});

  $ChatCompletionModelCopyWith<$Res> get model;
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  $ChatCompletionStopCopyWith<$Res>? get stop;
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$CreateChatCompletionRequestCopyWithImpl<$Res,
        $Val extends CreateChatCompletionRequest>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  _$CreateChatCompletionRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? topLogprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? serviceTier = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value.logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as bool?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      serviceTier: freezed == serviceTier
          ? _value.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionRequestServiceTier?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _value.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value.functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionModelCopyWith<$Res> get model {
    return $ChatCompletionModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $ChatCompletionResponseFormatCopyWith<$Res>(_value.responseFormat!,
        (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStopCopyWith<$Res>? get stop {
    if (_value.stop == null) {
      return null;
    }

    return $ChatCompletionStopCopyWith<$Res>(_value.stop!, (value) {
      return _then(_value.copyWith(stop: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions {
    if (_value.streamOptions == null) {
      return null;
    }

    return $ChatCompletionStreamOptionsCopyWith<$Res>(_value.streamOptions!,
        (value) {
      return _then(_value.copyWith(streamOptions: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice {
    if (_value.toolChoice == null) {
      return null;
    }

    return $ChatCompletionToolChoiceOptionCopyWith<$Res>(_value.toolChoice!,
        (value) {
      return _then(_value.copyWith(toolChoice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionFunctionCallCopyWith<$Res>(_value.functionCall!,
        (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionRequestImplCopyWith<$Res>
    implements $CreateChatCompletionRequestCopyWith<$Res> {
  factory _$$CreateChatCompletionRequestImplCopyWith(
          _$CreateChatCompletionRequestImpl value,
          $Res Function(_$CreateChatCompletionRequestImpl) then) =
      __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ChatCompletionModelConverter() ChatCompletionModel model,
      List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) int? maxTokens,
      @JsonKey(includeIfNull: false) int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) int? seed,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      CreateChatCompletionRequestServiceTier? serviceTier,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(includeIfNull: false) List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @JsonKey(includeIfNull: false) String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false) List<FunctionObject>? functions});

  @override
  $ChatCompletionModelCopyWith<$Res> get model;
  @override
  $ChatCompletionResponseFormatCopyWith<$Res>? get responseFormat;
  @override
  $ChatCompletionStopCopyWith<$Res>? get stop;
  @override
  $ChatCompletionStreamOptionsCopyWith<$Res>? get streamOptions;
  @override
  $ChatCompletionToolChoiceOptionCopyWith<$Res>? get toolChoice;
  @override
  $ChatCompletionFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$CreateChatCompletionRequestImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionRequestCopyWithImpl<$Res,
        _$CreateChatCompletionRequestImpl>
    implements _$$CreateChatCompletionRequestImplCopyWith<$Res> {
  __$$CreateChatCompletionRequestImplCopyWithImpl(
      _$CreateChatCompletionRequestImpl _value,
      $Res Function(_$CreateChatCompletionRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? messages = null,
    Object? frequencyPenalty = freezed,
    Object? logitBias = freezed,
    Object? logprobs = freezed,
    Object? topLogprobs = freezed,
    Object? maxTokens = freezed,
    Object? n = freezed,
    Object? presencePenalty = freezed,
    Object? responseFormat = freezed,
    Object? seed = freezed,
    Object? serviceTier = freezed,
    Object? stop = freezed,
    Object? stream = freezed,
    Object? streamOptions = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? tools = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? user = freezed,
    Object? functionCall = freezed,
    Object? functions = freezed,
  }) {
    return _then(_$CreateChatCompletionRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModel,
      messages: null == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessage>,
      frequencyPenalty: freezed == frequencyPenalty
          ? _value.frequencyPenalty
          : frequencyPenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      logitBias: freezed == logitBias
          ? _value._logitBias
          : logitBias // ignore: cast_nullable_to_non_nullable
              as Map<String, int>?,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as bool?,
      topLogprobs: freezed == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as int?,
      maxTokens: freezed == maxTokens
          ? _value.maxTokens
          : maxTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      presencePenalty: freezed == presencePenalty
          ? _value.presencePenalty
          : presencePenalty // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormat?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
      serviceTier: freezed == serviceTier
          ? _value.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as CreateChatCompletionRequestServiceTier?,
      stop: freezed == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStop?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
      streamOptions: freezed == streamOptions
          ? _value.streamOptions
          : streamOptions // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamOptions?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTool>?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceOption?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCall?,
      functions: freezed == functions
          ? _value._functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<FunctionObject>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionRequestImpl extends _CreateChatCompletionRequest {
  const _$CreateChatCompletionRequestImpl(
      {@_ChatCompletionModelConverter() required this.model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      this.frequencyPenalty = 0.0,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false) this.topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) this.maxTokens,
      @JsonKey(includeIfNull: false) this.n = 1,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      this.presencePenalty = 0.0,
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.seed,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.serviceTier,
      @_ChatCompletionStopConverter() @JsonKey(includeIfNull: false) this.stop,
      @JsonKey(includeIfNull: false) this.stream = false,
      @JsonKey(name: 'stream_options', includeIfNull: false) this.streamOptions,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      this.parallelToolCalls = true,
      @JsonKey(includeIfNull: false) this.user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      this.functionCall,
      @JsonKey(includeIfNull: false) final List<FunctionObject>? functions})
      : _messages = messages,
        _logitBias = logitBias,
        _tools = tools,
        _functions = functions,
        super._();

  factory _$CreateChatCompletionRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionRequestImplFromJson(json);

  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @override
  @_ChatCompletionModelConverter()
  final ChatCompletionModel model;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  final List<ChatCompletionMessage> _messages;

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  @override
  List<ChatCompletionMessage> get messages {
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_messages);
  }

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  final double? frequencyPenalty;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  final Map<String, int>? _logitBias;

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @override
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias {
    final value = _logitBias;
    if (value == null) return null;
    if (_logitBias is EqualUnmodifiableMapView) return _logitBias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.
  @override
  @JsonKey(includeIfNull: false)
  final bool? logprobs;

  /// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
  @override
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  final int? topLogprobs;

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  final int? maxTokens;

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @override
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  final double? presencePenalty;

  /// An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @JsonKey(name: 'response_format', includeIfNull: false)
  final ChatCompletionResponseFormat? responseFormat;

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  /// Specifies the latency tier to use for processing the request. This parameter is relevant for customers
  /// subscribed to the scale tier service:
  ///   - If set to 'auto', the system will utilize scale tier credits until they are exhausted.
  ///   - If set to 'default', the request will be processed using the default service tier with a lower
  ///     uptime SLA and no latency guarantee.
  ///
  ///   When this parameter is set, the response body will include the `service_tier` utilized.
  @override
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final CreateChatCompletionRequestServiceTier? serviceTier;

  /// Up to 4 sequences where the API will stop generating further tokens.
  @override
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  final ChatCompletionStop? stop;

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  /// Options for streaming response. Only set this when you set `stream: true`.
  @override
  @JsonKey(name: 'stream_options', includeIfNull: false)
  final ChatCompletionStreamOptions? streamOptions;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
  final List<ChatCompletionTool>? _tools;

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
  @override
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tool and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools.
  /// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  ///
  /// `none` is the default when no tools are present. `auto` is the default if tools are present.
  @override
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final ChatCompletionToolChoiceOption? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  final bool? parallelToolCalls;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @override
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionFunctionCall? functionCall;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  final List<FunctionObject>? _functions;

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @override
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions {
    final value = _functions;
    if (value == null) return null;
    if (_functions is EqualUnmodifiableListView) return _functions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CreateChatCompletionRequest(model: $model, messages: $messages, frequencyPenalty: $frequencyPenalty, logitBias: $logitBias, logprobs: $logprobs, topLogprobs: $topLogprobs, maxTokens: $maxTokens, n: $n, presencePenalty: $presencePenalty, responseFormat: $responseFormat, seed: $seed, serviceTier: $serviceTier, stop: $stop, stream: $stream, streamOptions: $streamOptions, temperature: $temperature, topP: $topP, tools: $tools, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, user: $user, functionCall: $functionCall, functions: $functions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            (identical(other.frequencyPenalty, frequencyPenalty) ||
                other.frequencyPenalty == frequencyPenalty) &&
            const DeepCollectionEquality()
                .equals(other._logitBias, _logitBias) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.topLogprobs, topLogprobs) ||
                other.topLogprobs == topLogprobs) &&
            (identical(other.maxTokens, maxTokens) ||
                other.maxTokens == maxTokens) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.presencePenalty, presencePenalty) ||
                other.presencePenalty == presencePenalty) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.stream, stream) || other.stream == stream) &&
            (identical(other.streamOptions, streamOptions) ||
                other.streamOptions == streamOptions) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._functions, _functions));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        model,
        const DeepCollectionEquality().hash(_messages),
        frequencyPenalty,
        const DeepCollectionEquality().hash(_logitBias),
        logprobs,
        topLogprobs,
        maxTokens,
        n,
        presencePenalty,
        responseFormat,
        seed,
        serviceTier,
        stop,
        stream,
        streamOptions,
        temperature,
        topP,
        const DeepCollectionEquality().hash(_tools),
        toolChoice,
        parallelToolCalls,
        user,
        functionCall,
        const DeepCollectionEquality().hash(_functions)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => __$$CreateChatCompletionRequestImplCopyWithImpl<
          _$CreateChatCompletionRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionRequest
    extends CreateChatCompletionRequest {
  const factory _CreateChatCompletionRequest(
      {@_ChatCompletionModelConverter()
      required final ChatCompletionModel model,
      required final List<ChatCompletionMessage> messages,
      @JsonKey(name: 'frequency_penalty', includeIfNull: false)
      final double? frequencyPenalty,
      @JsonKey(name: 'logit_bias', includeIfNull: false)
      final Map<String, int>? logitBias,
      @JsonKey(includeIfNull: false) final bool? logprobs,
      @JsonKey(name: 'top_logprobs', includeIfNull: false)
      final int? topLogprobs,
      @JsonKey(name: 'max_tokens', includeIfNull: false) final int? maxTokens,
      @JsonKey(includeIfNull: false) final int? n,
      @JsonKey(name: 'presence_penalty', includeIfNull: false)
      final double? presencePenalty,
      @JsonKey(name: 'response_format', includeIfNull: false)
      final ChatCompletionResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) final int? seed,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      final CreateChatCompletionRequestServiceTier? serviceTier,
      @_ChatCompletionStopConverter()
      @JsonKey(includeIfNull: false)
      final ChatCompletionStop? stop,
      @JsonKey(includeIfNull: false) final bool? stream,
      @JsonKey(name: 'stream_options', includeIfNull: false)
      final ChatCompletionStreamOptions? streamOptions,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(includeIfNull: false) final List<ChatCompletionTool>? tools,
      @_ChatCompletionToolChoiceOptionConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      final ChatCompletionToolChoiceOption? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      final bool? parallelToolCalls,
      @JsonKey(includeIfNull: false) final String? user,
      @_ChatCompletionFunctionCallConverter()
      @JsonKey(name: 'function_call', includeIfNull: false)
      final ChatCompletionFunctionCall? functionCall,
      @JsonKey(includeIfNull: false)
      final List<FunctionObject>?
          functions}) = _$CreateChatCompletionRequestImpl;
  const _CreateChatCompletionRequest._() : super._();

  factory _CreateChatCompletionRequest.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionRequestImpl.fromJson;

  @override

  /// ID of the model to use. See the [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
  @_ChatCompletionModelConverter()
  ChatCompletionModel get model;
  @override

  /// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  List<ChatCompletionMessage> get messages;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'frequency_penalty', includeIfNull: false)
  double? get frequencyPenalty;
  @override

  /// Modify the likelihood of specified tokens appearing in the completion.
  ///
  /// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
  @JsonKey(name: 'logit_bias', includeIfNull: false)
  Map<String, int>? get logitBias;
  @override

  /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.
  @JsonKey(includeIfNull: false)
  bool? get logprobs;
  @override

  /// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
  @JsonKey(name: 'top_logprobs', includeIfNull: false)
  int? get topLogprobs;
  @override

  /// The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the chat completion.
  ///
  /// The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @JsonKey(name: 'max_tokens', includeIfNull: false)
  int? get maxTokens;
  @override

  /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  ///
  /// [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  @JsonKey(name: 'presence_penalty', includeIfNull: false)
  double? get presencePenalty;
  @override

  /// An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @JsonKey(name: 'response_format', includeIfNull: false)
  ChatCompletionResponseFormat? get responseFormat;
  @override

  /// This feature is in Beta.
  /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
  /// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override

  /// Specifies the latency tier to use for processing the request. This parameter is relevant for customers
  /// subscribed to the scale tier service:
  ///   - If set to 'auto', the system will utilize scale tier credits until they are exhausted.
  ///   - If set to 'default', the request will be processed using the default service tier with a lower
  ///     uptime SLA and no latency guarantee.
  ///
  ///   When this parameter is set, the response body will include the `service_tier` utilized.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  CreateChatCompletionRequestServiceTier? get serviceTier;
  @override

  /// Up to 4 sequences where the API will stop generating further tokens.
  @_ChatCompletionStopConverter()
  @JsonKey(includeIfNull: false)
  ChatCompletionStop? get stop;
  @override

  /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override

  /// Options for streaming response. Only set this when you set `stream: true`.
  @JsonKey(name: 'stream_options', includeIfNull: false)
  ChatCompletionStreamOptions? get streamOptions;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  ///
  /// We generally recommend altering this or `top_p` but not both.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or `temperature` but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
  @JsonKey(includeIfNull: false)
  List<ChatCompletionTool>? get tools;
  @override

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tool and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools.
  /// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  ///
  /// `none` is the default when no tools are present. `auto` is the default if tools are present.
  @_ChatCompletionToolChoiceOptionConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  ChatCompletionToolChoiceOption? get toolChoice;
  @override

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override

  /// Deprecated in favor of `tool_choice`.
  ///
  /// Controls which (if any) function is called by the model.
  /// `none` means the model will not call a function and instead generates a message.
  /// `auto` means the model can pick between generating a message or calling a function.
  /// Specifying a particular function via [ChatCompletionFunctionCallOption] forces the model to call that function.
  ///
  /// `none` is the default when no functions are present. `auto` is the default if functions are present.
  @_ChatCompletionFunctionCallConverter()
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionFunctionCall? get functionCall;
  @override

  /// Deprecated in favor of `tools`.
  ///
  /// A list of functions the model may generate JSON inputs for.
  @JsonKey(includeIfNull: false)
  List<FunctionObject>? get functions;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionRequestImplCopyWith<_$CreateChatCompletionRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionModel _$ChatCompletionModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ChatCompletionModelEnumeration.fromJson(json);
    case 'modelId':
      return ChatCompletionModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionModelCopyWith<$Res> {
  factory $ChatCompletionModelCopyWith(
          ChatCompletionModel value, $Res Function(ChatCompletionModel) then) =
      _$ChatCompletionModelCopyWithImpl<$Res, ChatCompletionModel>;
}

/// @nodoc
class _$ChatCompletionModelCopyWithImpl<$Res, $Val extends ChatCompletionModel>
    implements $ChatCompletionModelCopyWith<$Res> {
  _$ChatCompletionModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionModelEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionModelEnumerationImplCopyWith(
          _$ChatCompletionModelEnumerationImpl value,
          $Res Function(_$ChatCompletionModelEnumerationImpl) then) =
      __$$ChatCompletionModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionModels value});
}

/// @nodoc
class __$$ChatCompletionModelEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$ChatCompletionModelEnumerationImpl>
    implements _$$ChatCompletionModelEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionModelEnumerationImplCopyWithImpl(
      _$ChatCompletionModelEnumerationImpl _value,
      $Res Function(_$ChatCompletionModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionModelEnumerationImpl
    extends ChatCompletionModelEnumeration {
  const _$ChatCompletionModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$ChatCompletionModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionModelEnumerationImplFromJson(json);

  @override
  final ChatCompletionModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionModelEnumerationImplCopyWith<
          _$ChatCompletionModelEnumerationImpl>
      get copyWith => __$$ChatCompletionModelEnumerationImplCopyWithImpl<
          _$ChatCompletionModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionModelEnumeration extends ChatCompletionModel {
  const factory ChatCompletionModelEnumeration(
      final ChatCompletionModels value) = _$ChatCompletionModelEnumerationImpl;
  const ChatCompletionModelEnumeration._() : super._();

  factory ChatCompletionModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionModelEnumerationImpl.fromJson;

  @override
  ChatCompletionModels get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionModelEnumerationImplCopyWith<
          _$ChatCompletionModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionModelStringImplCopyWith<$Res> {
  factory _$$ChatCompletionModelStringImplCopyWith(
          _$ChatCompletionModelStringImpl value,
          $Res Function(_$ChatCompletionModelStringImpl) then) =
      __$$ChatCompletionModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ChatCompletionModelStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionModelCopyWithImpl<$Res,
        _$ChatCompletionModelStringImpl>
    implements _$$ChatCompletionModelStringImplCopyWith<$Res> {
  __$$ChatCompletionModelStringImplCopyWithImpl(
      _$ChatCompletionModelStringImpl _value,
      $Res Function(_$ChatCompletionModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionModelStringImpl extends ChatCompletionModelString {
  const _$ChatCompletionModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$ChatCompletionModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionModelStringImplCopyWith<_$ChatCompletionModelStringImpl>
      get copyWith => __$$ChatCompletionModelStringImplCopyWithImpl<
          _$ChatCompletionModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionModelEnumeration value) model,
    required TResult Function(ChatCompletionModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionModelEnumeration value)? model,
    TResult? Function(ChatCompletionModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionModelEnumeration value)? model,
    TResult Function(ChatCompletionModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionModelStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionModelString extends ChatCompletionModel {
  const factory ChatCompletionModelString(final String value) =
      _$ChatCompletionModelStringImpl;
  const ChatCompletionModelString._() : super._();

  factory ChatCompletionModelString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionModelStringImplCopyWith<_$ChatCompletionModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseFormat _$ChatCompletionResponseFormatFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseFormat.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseFormat {
  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseFormatCopyWith<ChatCompletionResponseFormat>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseFormatCopyWith<$Res> {
  factory $ChatCompletionResponseFormatCopyWith(
          ChatCompletionResponseFormat value,
          $Res Function(ChatCompletionResponseFormat) then) =
      _$ChatCompletionResponseFormatCopyWithImpl<$Res,
          ChatCompletionResponseFormat>;
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseFormat>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  _$ChatCompletionResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseFormatImplCopyWith<$Res>
    implements $ChatCompletionResponseFormatCopyWith<$Res> {
  factory _$$ChatCompletionResponseFormatImplCopyWith(
          _$ChatCompletionResponseFormatImpl value,
          $Res Function(_$ChatCompletionResponseFormatImpl) then) =
      __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionResponseFormatType type});
}

/// @nodoc
class __$$ChatCompletionResponseFormatImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseFormatCopyWithImpl<$Res,
        _$ChatCompletionResponseFormatImpl>
    implements _$$ChatCompletionResponseFormatImplCopyWith<$Res> {
  __$$ChatCompletionResponseFormatImplCopyWithImpl(
      _$ChatCompletionResponseFormatImpl _value,
      $Res Function(_$ChatCompletionResponseFormatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$ChatCompletionResponseFormatImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionResponseFormatType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseFormatImpl extends _ChatCompletionResponseFormat {
  const _$ChatCompletionResponseFormatImpl(
      {this.type = ChatCompletionResponseFormatType.text})
      : super._();

  factory _$ChatCompletionResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseFormatImplFromJson(json);

  /// Must be one of `text` or `json_object`.
  @override
  @JsonKey()
  final ChatCompletionResponseFormatType type;

  @override
  String toString() {
    return 'ChatCompletionResponseFormat(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseFormatImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => __$$ChatCompletionResponseFormatImplCopyWithImpl<
          _$ChatCompletionResponseFormatImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseFormatImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseFormat
    extends ChatCompletionResponseFormat {
  const factory _ChatCompletionResponseFormat(
          {final ChatCompletionResponseFormatType type}) =
      _$ChatCompletionResponseFormatImpl;
  const _ChatCompletionResponseFormat._() : super._();

  factory _ChatCompletionResponseFormat.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseFormatImpl.fromJson;

  @override

  /// Must be one of `text` or `json_object`.
  ChatCompletionResponseFormatType get type;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseFormatImplCopyWith<
          _$ChatCompletionResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStop _$ChatCompletionStopFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return ChatCompletionStopListString.fromJson(json);
    case 'string':
      return ChatCompletionStopString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ChatCompletionStop',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionStop {
  Object? get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStopCopyWith<$Res> {
  factory $ChatCompletionStopCopyWith(
          ChatCompletionStop value, $Res Function(ChatCompletionStop) then) =
      _$ChatCompletionStopCopyWithImpl<$Res, ChatCompletionStop>;
}

/// @nodoc
class _$ChatCompletionStopCopyWithImpl<$Res, $Val extends ChatCompletionStop>
    implements $ChatCompletionStopCopyWith<$Res> {
  _$ChatCompletionStopCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionStopListStringImplCopyWith<$Res> {
  factory _$$ChatCompletionStopListStringImplCopyWith(
          _$ChatCompletionStopListStringImpl value,
          $Res Function(_$ChatCompletionStopListStringImpl) then) =
      __$$ChatCompletionStopListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$ChatCompletionStopListStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$ChatCompletionStopListStringImpl>
    implements _$$ChatCompletionStopListStringImplCopyWith<$Res> {
  __$$ChatCompletionStopListStringImplCopyWithImpl(
      _$ChatCompletionStopListStringImpl _value,
      $Res Function(_$ChatCompletionStopListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionStopListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStopListStringImpl extends ChatCompletionStopListString {
  const _$ChatCompletionStopListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$ChatCompletionStopListStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStopListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStopListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStopListStringImplCopyWith<
          _$ChatCompletionStopListStringImpl>
      get copyWith => __$$ChatCompletionStopListStringImplCopyWithImpl<
          _$ChatCompletionStopListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStopListStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionStopListString extends ChatCompletionStop {
  const factory ChatCompletionStopListString(final List<String> value) =
      _$ChatCompletionStopListStringImpl;
  const ChatCompletionStopListString._() : super._();

  factory ChatCompletionStopListString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionStopListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionStopListStringImplCopyWith<
          _$ChatCompletionStopListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionStopStringImplCopyWith<$Res> {
  factory _$$ChatCompletionStopStringImplCopyWith(
          _$ChatCompletionStopStringImpl value,
          $Res Function(_$ChatCompletionStopStringImpl) then) =
      __$$ChatCompletionStopStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? value});
}

/// @nodoc
class __$$ChatCompletionStopStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionStopCopyWithImpl<$Res,
        _$ChatCompletionStopStringImpl>
    implements _$$ChatCompletionStopStringImplCopyWith<$Res> {
  __$$ChatCompletionStopStringImplCopyWithImpl(
      _$ChatCompletionStopStringImpl _value,
      $Res Function(_$ChatCompletionStopStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$ChatCompletionStopStringImpl(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStopStringImpl extends ChatCompletionStopString {
  const _$ChatCompletionStopStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ChatCompletionStopStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionStopStringImplFromJson(json);

  @override
  final String? value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionStop.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStopStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStopStringImplCopyWith<_$ChatCompletionStopStringImpl>
      get copyWith => __$$ChatCompletionStopStringImplCopyWithImpl<
          _$ChatCompletionStopStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String? value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String? value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String? value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionStopListString value) listString,
    required TResult Function(ChatCompletionStopString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionStopListString value)? listString,
    TResult? Function(ChatCompletionStopString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionStopListString value)? listString,
    TResult Function(ChatCompletionStopString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStopStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionStopString extends ChatCompletionStop {
  const factory ChatCompletionStopString(final String? value) =
      _$ChatCompletionStopStringImpl;
  const ChatCompletionStopString._() : super._();

  factory ChatCompletionStopString.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionStopStringImpl.fromJson;

  @override
  String? get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionStopStringImplCopyWith<_$ChatCompletionStopStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionToolChoiceOption _$ChatCompletionToolChoiceOptionFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionToolChoiceOptionEnumeration.fromJson(json);
    case 'tool':
      return ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionToolChoiceOption',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionToolChoiceOption {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  factory $ChatCompletionToolChoiceOptionCopyWith(
          ChatCompletionToolChoiceOption value,
          $Res Function(ChatCompletionToolChoiceOption) then) =
      _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
          ChatCompletionToolChoiceOption>;
}

/// @nodoc
class _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionToolChoiceOption>
    implements $ChatCompletionToolChoiceOptionCopyWith<$Res> {
  _$ChatCompletionToolChoiceOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith(
          _$ChatCompletionToolChoiceOptionEnumerationImpl value,
          $Res Function(_$ChatCompletionToolChoiceOptionEnumerationImpl) then) =
      __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionToolChoiceMode value});
}

/// @nodoc
class __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$ChatCompletionToolChoiceOptionEnumerationImpl>
    implements _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl(
      _$ChatCompletionToolChoiceOptionEnumerationImpl _value,
      $Res Function(_$ChatCompletionToolChoiceOptionEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionToolChoiceOptionEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolChoiceOptionEnumerationImpl
    extends ChatCompletionToolChoiceOptionEnumeration {
  const _$ChatCompletionToolChoiceOptionEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$ChatCompletionToolChoiceOptionEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionToolChoiceOptionEnumerationImplFromJson(json);

  @override
  final ChatCompletionToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolChoiceOptionEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<
          _$ChatCompletionToolChoiceOptionEnumerationImpl>
      get copyWith =>
          __$$ChatCompletionToolChoiceOptionEnumerationImplCopyWithImpl<
                  _$ChatCompletionToolChoiceOptionEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolChoiceOptionEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolChoiceOptionEnumeration
    extends ChatCompletionToolChoiceOption {
  const factory ChatCompletionToolChoiceOptionEnumeration(
          final ChatCompletionToolChoiceMode value) =
      _$ChatCompletionToolChoiceOptionEnumerationImpl;
  const ChatCompletionToolChoiceOptionEnumeration._() : super._();

  factory ChatCompletionToolChoiceOptionEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionToolChoiceOptionEnumerationImpl.fromJson;

  @override
  ChatCompletionToolChoiceMode get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionToolChoiceOptionEnumerationImplCopyWith<
          _$ChatCompletionToolChoiceOptionEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
    $Res> {
  factory _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith(
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl value,
          $Res Function(
                  _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
              then) =
      __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionNamedToolChoice value});

  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionToolChoiceOptionCopyWithImpl<$Res,
        _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
    implements
        _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
            $Res> {
  __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl _value,
      $Res Function(
              _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionNamedToolChoiceCopyWith<$Res> get value {
    return $ChatCompletionNamedToolChoiceCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
    extends ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice {
  const _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();

  factory _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplFromJson(
          json);

  @override
  final ChatCompletionNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionToolChoiceOption.tool(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith =>
          __$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWithImpl<
                  _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceMode value) mode,
    required TResult Function(ChatCompletionNamedToolChoice value) tool,
  }) {
    return tool(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceMode value)? mode,
    TResult? Function(ChatCompletionNamedToolChoice value)? tool,
  }) {
    return tool?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceMode value)? mode,
    TResult Function(ChatCompletionNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionToolChoiceOptionEnumeration value)
        mode,
    required TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)
        tool,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult? Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionToolChoiceOptionEnumeration value)? mode,
    TResult Function(
            ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice
    extends ChatCompletionToolChoiceOption {
  const factory ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice(
          final ChatCompletionNamedToolChoice value) =
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl;
  const ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice._()
      : super._();

  factory ChatCompletionToolChoiceOptionChatCompletionNamedToolChoice.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl
      .fromJson;

  @override
  ChatCompletionNamedToolChoice get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionToolChoiceOptionChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCall _$ChatCompletionFunctionCallFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ChatCompletionFunctionCallEnumeration.fromJson(json);
    case 'function':
      return ChatCompletionFunctionCallChatCompletionFunctionCallOption
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionFunctionCall',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionFunctionCall {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallCopyWith<$Res> {
  factory $ChatCompletionFunctionCallCopyWith(ChatCompletionFunctionCall value,
          $Res Function(ChatCompletionFunctionCall) then) =
      _$ChatCompletionFunctionCallCopyWithImpl<$Res,
          ChatCompletionFunctionCall>;
}

/// @nodoc
class _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCall>
    implements $ChatCompletionFunctionCallCopyWith<$Res> {
  _$ChatCompletionFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallEnumerationImplCopyWith<$Res> {
  factory _$$ChatCompletionFunctionCallEnumerationImplCopyWith(
          _$ChatCompletionFunctionCallEnumerationImpl value,
          $Res Function(_$ChatCompletionFunctionCallEnumerationImpl) then) =
      __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallMode value});
}

/// @nodoc
class __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallEnumerationImpl>
    implements _$$ChatCompletionFunctionCallEnumerationImplCopyWith<$Res> {
  __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl(
      _$ChatCompletionFunctionCallEnumerationImpl _value,
      $Res Function(_$ChatCompletionFunctionCallEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionFunctionCallEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallEnumerationImpl
    extends ChatCompletionFunctionCallEnumeration {
  const _$ChatCompletionFunctionCallEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$ChatCompletionFunctionCallEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallEnumerationImplFromJson(json);

  @override
  final ChatCompletionFunctionCallMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionCallEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallEnumerationImplCopyWith<
          _$ChatCompletionFunctionCallEnumerationImpl>
      get copyWith => __$$ChatCompletionFunctionCallEnumerationImplCopyWithImpl<
          _$ChatCompletionFunctionCallEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallEnumerationImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionCallEnumeration
    extends ChatCompletionFunctionCall {
  const factory ChatCompletionFunctionCallEnumeration(
          final ChatCompletionFunctionCallMode value) =
      _$ChatCompletionFunctionCallEnumerationImpl;
  const ChatCompletionFunctionCallEnumeration._() : super._();

  factory ChatCompletionFunctionCallEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallEnumerationImpl.fromJson;

  @override
  ChatCompletionFunctionCallMode get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallEnumerationImplCopyWith<
          _$ChatCompletionFunctionCallEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
    $Res> {
  factory _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith(
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl value,
          $Res Function(
                  _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
              then) =
      __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({ChatCompletionFunctionCallOption value});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value;
}

/// @nodoc
class __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
        $Res>
    extends _$ChatCompletionFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
    implements
        _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
            $Res> {
  __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl _value,
      $Res Function(
              _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get value {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl
    extends ChatCompletionFunctionCallChatCompletionFunctionCallOption {
  const _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'function',
        super._();

  factory _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplFromJson(
          json);

  @override
  final ChatCompletionFunctionCallOption value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionFunctionCall.function(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith =>
          __$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWithImpl<
                  _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallMode value) mode,
    required TResult Function(ChatCompletionFunctionCallOption value) function,
  }) {
    return function(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallMode value)? mode,
    TResult? Function(ChatCompletionFunctionCallOption value)? function,
  }) {
    return function?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallMode value)? mode,
    TResult Function(ChatCompletionFunctionCallOption value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionFunctionCallEnumeration value) mode,
    required TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)
        function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult? Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionFunctionCallEnumeration value)? mode,
    TResult Function(
            ChatCompletionFunctionCallChatCompletionFunctionCallOption value)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionCallChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCall {
  const factory ChatCompletionFunctionCallChatCompletionFunctionCallOption(
          final ChatCompletionFunctionCallOption value) =
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl;
  const ChatCompletionFunctionCallChatCompletionFunctionCallOption._()
      : super._();

  factory ChatCompletionFunctionCallChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl.fromJson;

  @override
  ChatCompletionFunctionCallOption get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageFunctionCall _$ChatCompletionMessageFunctionCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageFunctionCall {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageFunctionCallCopyWith<ChatCompletionMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionMessageFunctionCallCopyWith(
          ChatCompletionMessageFunctionCall value,
          $Res Function(ChatCompletionMessageFunctionCall) then) =
      _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionMessageFunctionCall>;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageFunctionCall>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionMessageFunctionCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageFunctionCallImplCopyWith(
          _$ChatCompletionMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionMessageFunctionCallImpl) then) =
      __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionMessageFunctionCallImpl>
    implements _$$ChatCompletionMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_$ChatCompletionMessageFunctionCallImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageFunctionCallImpl
    extends _ChatCompletionMessageFunctionCall {
  const _$ChatCompletionMessageFunctionCallImpl(
      {required this.name, required this.arguments})
      : super._();

  factory _$ChatCompletionMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  final String arguments;

  @override
  String toString() {
    return 'ChatCompletionMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => __$$ChatCompletionMessageFunctionCallImplCopyWithImpl<
          _$ChatCompletionMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageFunctionCall
    extends ChatCompletionMessageFunctionCall {
  const factory _ChatCompletionMessageFunctionCall(
          {required final String name, required final String arguments}) =
      _$ChatCompletionMessageFunctionCallImpl;
  const _ChatCompletionMessageFunctionCall._() : super._();

  factory _ChatCompletionMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  String get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageFunctionCallImplCopyWith<
          _$ChatCompletionMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionFunctionCallOption _$ChatCompletionFunctionCallOptionFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionFunctionCallOption.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionFunctionCallOption {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionFunctionCallOptionCopyWith<ChatCompletionFunctionCallOption>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory $ChatCompletionFunctionCallOptionCopyWith(
          ChatCompletionFunctionCallOption value,
          $Res Function(ChatCompletionFunctionCallOption) then) =
      _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
          ChatCompletionFunctionCallOption>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        $Val extends ChatCompletionFunctionCallOption>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  _$ChatCompletionFunctionCallOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res>
    implements $ChatCompletionFunctionCallOptionCopyWith<$Res> {
  factory _$$ChatCompletionFunctionCallOptionImplCopyWith(
          _$ChatCompletionFunctionCallOptionImpl value,
          $Res Function(_$ChatCompletionFunctionCallOptionImpl) then) =
      __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<$Res>
    extends _$ChatCompletionFunctionCallOptionCopyWithImpl<$Res,
        _$ChatCompletionFunctionCallOptionImpl>
    implements _$$ChatCompletionFunctionCallOptionImplCopyWith<$Res> {
  __$$ChatCompletionFunctionCallOptionImplCopyWithImpl(
      _$ChatCompletionFunctionCallOptionImpl _value,
      $Res Function(_$ChatCompletionFunctionCallOptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$ChatCompletionFunctionCallOptionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionCallOptionImpl
    extends _ChatCompletionFunctionCallOption {
  const _$ChatCompletionFunctionCallOptionImpl({required this.name})
      : super._();

  factory _$ChatCompletionFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionCallOptionImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'ChatCompletionFunctionCallOption(name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionCallOptionImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => __$$ChatCompletionFunctionCallOptionImplCopyWithImpl<
          _$ChatCompletionFunctionCallOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionFunctionCallOption
    extends ChatCompletionFunctionCallOption {
  const factory _ChatCompletionFunctionCallOption(
      {required final String name}) = _$ChatCompletionFunctionCallOptionImpl;
  const _ChatCompletionFunctionCallOption._() : super._();

  factory _ChatCompletionFunctionCallOption.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionFunctionCallOptionImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionCallOptionImplCopyWith<
          _$ChatCompletionFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FunctionObject _$FunctionObjectFromJson(Map<String, dynamic> json) {
  return _FunctionObject.fromJson(json);
}

/// @nodoc
mixin _$FunctionObject {
  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name => throw _privateConstructorUsedError;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get parameters => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FunctionObjectCopyWith<FunctionObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FunctionObjectCopyWith<$Res> {
  factory $FunctionObjectCopyWith(
          FunctionObject value, $Res Function(FunctionObject) then) =
      _$FunctionObjectCopyWithImpl<$Res, FunctionObject>;
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? parameters});
}

/// @nodoc
class _$FunctionObjectCopyWithImpl<$Res, $Val extends FunctionObject>
    implements $FunctionObjectCopyWith<$Res> {
  _$FunctionObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FunctionObjectImplCopyWith<$Res>
    implements $FunctionObjectCopyWith<$Res> {
  factory _$$FunctionObjectImplCopyWith(_$FunctionObjectImpl value,
          $Res Function(_$FunctionObjectImpl) then) =
      __$$FunctionObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? parameters});
}

/// @nodoc
class __$$FunctionObjectImplCopyWithImpl<$Res>
    extends _$FunctionObjectCopyWithImpl<$Res, _$FunctionObjectImpl>
    implements _$$FunctionObjectImplCopyWith<$Res> {
  __$$FunctionObjectImplCopyWithImpl(
      _$FunctionObjectImpl _value, $Res Function(_$FunctionObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_$FunctionObjectImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FunctionObjectImpl extends _FunctionObject {
  const _$FunctionObjectImpl(
      {required this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? parameters})
      : _parameters = parameters,
        super._();

  factory _$FunctionObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$FunctionObjectImplFromJson(json);

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  @override
  final String name;

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  final Map<String, dynamic>? _parameters;

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'FunctionObject(name: $name, description: $description, parameters: $parameters)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FunctionObjectImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description,
      const DeepCollectionEquality().hash(_parameters));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FunctionObjectImplCopyWith<_$FunctionObjectImpl> get copyWith =>
      __$$FunctionObjectImplCopyWithImpl<_$FunctionObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FunctionObjectImplToJson(
      this,
    );
  }
}

abstract class _FunctionObject extends FunctionObject {
  const factory _FunctionObject(
      {required final String name,
      @JsonKey(includeIfNull: false) final String? description,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? parameters}) = _$FunctionObjectImpl;
  const _FunctionObject._() : super._();

  factory _FunctionObject.fromJson(Map<String, dynamic> json) =
      _$FunctionObjectImpl.fromJson;

  @override

  /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  String get name;
  @override

  /// A description of what the function does, used by the model to choose when and how to call the function.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
  ///
  /// Omitting `parameters` defines a function with an empty parameter list.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get parameters;
  @override
  @JsonKey(ignore: true)
  _$$FunctionObjectImplCopyWith<_$FunctionObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionTool _$ChatCompletionToolFromJson(Map<String, dynamic> json) {
  return _ChatCompletionTool.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTool {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type => throw _privateConstructorUsedError;

  /// A function that the model may call.
  FunctionObject get function => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionToolCopyWith<ChatCompletionTool> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionToolCopyWith<$Res> {
  factory $ChatCompletionToolCopyWith(
          ChatCompletionTool value, $Res Function(ChatCompletionTool) then) =
      _$ChatCompletionToolCopyWithImpl<$Res, ChatCompletionTool>;
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionToolCopyWithImpl<$Res, $Val extends ChatCompletionTool>
    implements $ChatCompletionToolCopyWith<$Res> {
  _$ChatCompletionToolCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionToolImplCopyWith<$Res>
    implements $ChatCompletionToolCopyWith<$Res> {
  factory _$$ChatCompletionToolImplCopyWith(_$ChatCompletionToolImpl value,
          $Res Function(_$ChatCompletionToolImpl) then) =
      __$$ChatCompletionToolImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionToolType type, FunctionObject function});

  @override
  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionToolImplCopyWithImpl<$Res>
    extends _$ChatCompletionToolCopyWithImpl<$Res, _$ChatCompletionToolImpl>
    implements _$$ChatCompletionToolImplCopyWith<$Res> {
  __$$ChatCompletionToolImplCopyWithImpl(_$ChatCompletionToolImpl _value,
      $Res Function(_$ChatCompletionToolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionToolImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionToolType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolImpl extends _ChatCompletionTool {
  const _$ChatCompletionToolImpl({required this.type, required this.function})
      : super._();

  factory _$ChatCompletionToolImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionToolImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionToolType type;

  /// A function that the model may call.
  @override
  final FunctionObject function;

  @override
  String toString() {
    return 'ChatCompletionTool(type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      __$$ChatCompletionToolImplCopyWithImpl<_$ChatCompletionToolImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTool extends ChatCompletionTool {
  const factory _ChatCompletionTool(
      {required final ChatCompletionToolType type,
      required final FunctionObject function}) = _$ChatCompletionToolImpl;
  const _ChatCompletionTool._() : super._();

  factory _ChatCompletionTool.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionToolImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionToolType get type;
  @override

  /// A function that the model may call.
  FunctionObject get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionToolImplCopyWith<_$ChatCompletionToolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionNamedToolChoice _$ChatCompletionNamedToolChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionNamedToolChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionNamedToolChoice {
  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionNamedToolChoiceType get type =>
      throw _privateConstructorUsedError;

  /// Forces the model to call the specified function.
  ChatCompletionFunctionCallOption get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionNamedToolChoiceCopyWith<ChatCompletionNamedToolChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory $ChatCompletionNamedToolChoiceCopyWith(
          ChatCompletionNamedToolChoice value,
          $Res Function(ChatCompletionNamedToolChoice) then) =
      _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
          ChatCompletionNamedToolChoice>;
  @useResult
  $Res call(
      {ChatCompletionNamedToolChoiceType type,
      ChatCompletionFunctionCallOption function});

  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionNamedToolChoice>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  _$ChatCompletionNamedToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function {
    return $ChatCompletionFunctionCallOptionCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res>
    implements $ChatCompletionNamedToolChoiceCopyWith<$Res> {
  factory _$$ChatCompletionNamedToolChoiceImplCopyWith(
          _$ChatCompletionNamedToolChoiceImpl value,
          $Res Function(_$ChatCompletionNamedToolChoiceImpl) then) =
      __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionNamedToolChoiceType type,
      ChatCompletionFunctionCallOption function});

  @override
  $ChatCompletionFunctionCallOptionCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionNamedToolChoiceCopyWithImpl<$Res,
        _$ChatCompletionNamedToolChoiceImpl>
    implements _$$ChatCompletionNamedToolChoiceImplCopyWith<$Res> {
  __$$ChatCompletionNamedToolChoiceImplCopyWithImpl(
      _$ChatCompletionNamedToolChoiceImpl _value,
      $Res Function(_$ChatCompletionNamedToolChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionNamedToolChoiceImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionNamedToolChoiceType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFunctionCallOption,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionNamedToolChoiceImpl
    extends _ChatCompletionNamedToolChoice {
  const _$ChatCompletionNamedToolChoiceImpl(
      {required this.type, required this.function})
      : super._();

  factory _$ChatCompletionNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionNamedToolChoiceImplFromJson(json);

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionNamedToolChoiceType type;

  /// Forces the model to call the specified function.
  @override
  final ChatCompletionFunctionCallOption function;

  @override
  String toString() {
    return 'ChatCompletionNamedToolChoice(type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionNamedToolChoiceImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => __$$ChatCompletionNamedToolChoiceImplCopyWithImpl<
          _$ChatCompletionNamedToolChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionNamedToolChoice
    extends ChatCompletionNamedToolChoice {
  const factory _ChatCompletionNamedToolChoice(
          {required final ChatCompletionNamedToolChoiceType type,
          required final ChatCompletionFunctionCallOption function}) =
      _$ChatCompletionNamedToolChoiceImpl;
  const _ChatCompletionNamedToolChoice._() : super._();

  factory _ChatCompletionNamedToolChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionNamedToolChoiceImpl.fromJson;

  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionNamedToolChoiceType get type;
  @override

  /// Forces the model to call the specified function.
  ChatCompletionFunctionCallOption get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionNamedToolChoiceImplCopyWith<
          _$ChatCompletionNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageToolCall _$ChatCompletionMessageToolCallFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageToolCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageToolCall {
  /// The ID of the tool call.
  String get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageToolCallCopyWith<ChatCompletionMessageToolCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory $ChatCompletionMessageToolCallCopyWith(
          ChatCompletionMessageToolCall value,
          $Res Function(ChatCompletionMessageToolCall) then) =
      _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
          ChatCompletionMessageToolCall>;
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageToolCall>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  _$ChatCompletionMessageToolCallCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function {
    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageToolCallImplCopyWith<$Res>
    implements $ChatCompletionMessageToolCallCopyWith<$Res> {
  factory _$$ChatCompletionMessageToolCallImplCopyWith(
          _$ChatCompletionMessageToolCallImpl value,
          $Res Function(_$ChatCompletionMessageToolCallImpl) then) =
      __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      ChatCompletionMessageToolCallType type,
      ChatCompletionMessageFunctionCall function});

  @override
  $ChatCompletionMessageFunctionCallCopyWith<$Res> get function;
}

/// @nodoc
class __$$ChatCompletionMessageToolCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageToolCallCopyWithImpl<$Res,
        _$ChatCompletionMessageToolCallImpl>
    implements _$$ChatCompletionMessageToolCallImplCopyWith<$Res> {
  __$$ChatCompletionMessageToolCallImplCopyWithImpl(
      _$ChatCompletionMessageToolCallImpl _value,
      $Res Function(_$ChatCompletionMessageToolCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$ChatCompletionMessageToolCallImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageToolCallType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageToolCallImpl
    extends _ChatCompletionMessageToolCall {
  const _$ChatCompletionMessageToolCallImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$ChatCompletionMessageToolCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageToolCallImplFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  final ChatCompletionMessageToolCallType type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  final ChatCompletionMessageFunctionCall function;

  @override
  String toString() {
    return 'ChatCompletionMessageToolCall(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageToolCallImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => __$$ChatCompletionMessageToolCallImplCopyWithImpl<
          _$ChatCompletionMessageToolCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageToolCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageToolCall
    extends ChatCompletionMessageToolCall {
  const factory _ChatCompletionMessageToolCall(
          {required final String id,
          required final ChatCompletionMessageToolCallType type,
          required final ChatCompletionMessageFunctionCall function}) =
      _$ChatCompletionMessageToolCallImpl;
  const _ChatCompletionMessageToolCall._() : super._();

  factory _ChatCompletionMessageToolCall.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageToolCallImpl.fromJson;

  @override

  /// The ID of the tool call.
  String get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  ChatCompletionMessageToolCallType get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  ChatCompletionMessageFunctionCall get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageToolCallImplCopyWith<
          _$ChatCompletionMessageToolCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamOptions _$ChatCompletionStreamOptionsFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamOptions.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamOptions {
  /// If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
  @JsonKey(name: 'include_usage', includeIfNull: false)
  bool? get includeUsage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamOptionsCopyWith<ChatCompletionStreamOptions>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamOptionsCopyWith<$Res> {
  factory $ChatCompletionStreamOptionsCopyWith(
          ChatCompletionStreamOptions value,
          $Res Function(ChatCompletionStreamOptions) then) =
      _$ChatCompletionStreamOptionsCopyWithImpl<$Res,
          ChatCompletionStreamOptions>;
  @useResult
  $Res call(
      {@JsonKey(name: 'include_usage', includeIfNull: false)
      bool? includeUsage});
}

/// @nodoc
class _$ChatCompletionStreamOptionsCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamOptions>
    implements $ChatCompletionStreamOptionsCopyWith<$Res> {
  _$ChatCompletionStreamOptionsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? includeUsage = freezed,
  }) {
    return _then(_value.copyWith(
      includeUsage: freezed == includeUsage
          ? _value.includeUsage
          : includeUsage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamOptionsImplCopyWith<$Res>
    implements $ChatCompletionStreamOptionsCopyWith<$Res> {
  factory _$$ChatCompletionStreamOptionsImplCopyWith(
          _$ChatCompletionStreamOptionsImpl value,
          $Res Function(_$ChatCompletionStreamOptionsImpl) then) =
      __$$ChatCompletionStreamOptionsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'include_usage', includeIfNull: false)
      bool? includeUsage});
}

/// @nodoc
class __$$ChatCompletionStreamOptionsImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamOptionsCopyWithImpl<$Res,
        _$ChatCompletionStreamOptionsImpl>
    implements _$$ChatCompletionStreamOptionsImplCopyWith<$Res> {
  __$$ChatCompletionStreamOptionsImplCopyWithImpl(
      _$ChatCompletionStreamOptionsImpl _value,
      $Res Function(_$ChatCompletionStreamOptionsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? includeUsage = freezed,
  }) {
    return _then(_$ChatCompletionStreamOptionsImpl(
      includeUsage: freezed == includeUsage
          ? _value.includeUsage
          : includeUsage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamOptionsImpl extends _ChatCompletionStreamOptions {
  const _$ChatCompletionStreamOptionsImpl(
      {@JsonKey(name: 'include_usage', includeIfNull: false) this.includeUsage})
      : super._();

  factory _$ChatCompletionStreamOptionsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamOptionsImplFromJson(json);

  /// If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
  @override
  @JsonKey(name: 'include_usage', includeIfNull: false)
  final bool? includeUsage;

  @override
  String toString() {
    return 'ChatCompletionStreamOptions(includeUsage: $includeUsage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamOptionsImpl &&
            (identical(other.includeUsage, includeUsage) ||
                other.includeUsage == includeUsage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, includeUsage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamOptionsImplCopyWith<_$ChatCompletionStreamOptionsImpl>
      get copyWith => __$$ChatCompletionStreamOptionsImplCopyWithImpl<
          _$ChatCompletionStreamOptionsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamOptionsImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamOptions
    extends ChatCompletionStreamOptions {
  const factory _ChatCompletionStreamOptions(
      {@JsonKey(name: 'include_usage', includeIfNull: false)
      final bool? includeUsage}) = _$ChatCompletionStreamOptionsImpl;
  const _ChatCompletionStreamOptions._() : super._();

  factory _ChatCompletionStreamOptions.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionStreamOptionsImpl.fromJson;

  @override

  /// If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
  @JsonKey(name: 'include_usage', includeIfNull: false)
  bool? get includeUsage;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamOptionsImplCopyWith<_$ChatCompletionStreamOptionsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionResponse _$CreateChatCompletionResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionResponse {
  /// A unique identifier for the chat completion.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created => throw _privateConstructorUsedError;

  /// The model used for the chat completion.
  String get model => throw _privateConstructorUsedError;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ServiceTier? get serviceTier => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion`.
  String get object => throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionResponseCopyWith<CreateChatCompletionResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionResponseCopyWith<$Res> {
  factory $CreateChatCompletionResponseCopyWith(
          CreateChatCompletionResponse value,
          $Res Function(CreateChatCompletionResponse) then) =
      _$CreateChatCompletionResponseCopyWithImpl<$Res,
          CreateChatCompletionResponse>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateChatCompletionResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionResponse>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  _$CreateChatCompletionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      serviceTier: freezed == serviceTier
          ? _value.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionResponseImplCopyWith<$Res>
    implements $CreateChatCompletionResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionResponseImplCopyWith(
          _$CreateChatCompletionResponseImpl value,
          $Res Function(_$CreateChatCompletionResponseImpl) then) =
      __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionResponseChoice> choices,
      int created,
      String model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      String object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateChatCompletionResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionResponseCopyWithImpl<$Res,
        _$CreateChatCompletionResponseImpl>
    implements _$$CreateChatCompletionResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionResponseImplCopyWithImpl(
      _$CreateChatCompletionResponseImpl _value,
      $Res Function(_$CreateChatCompletionResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = null,
    Object? model = null,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateChatCompletionResponseImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionResponseChoice>,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      serviceTier: freezed == serviceTier
          ? _value.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionResponseImpl extends _CreateChatCompletionResponse {
  const _$CreateChatCompletionResponseImpl(
      {@JsonKey(includeIfNull: false) this.id,
      required final List<ChatCompletionResponseChoice> choices,
      required this.created,
      required this.model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionResponseImplFromJson(json);

  /// A unique identifier for the chat completion.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  final List<ChatCompletionResponseChoice> _choices;

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  @override
  List<ChatCompletionResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  @override
  final int created;

  /// The model used for the chat completion.
  @override
  final String model;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @override
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ServiceTier? serviceTier;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion`.
  @override
  final String object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateChatCompletionResponse(id: $id, choices: $choices, created: $created, model: $model, serviceTier: $serviceTier, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      serviceTier,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => __$$CreateChatCompletionResponseImplCopyWithImpl<
          _$CreateChatCompletionResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionResponse
    extends CreateChatCompletionResponse {
  const factory _CreateChatCompletionResponse(
          {@JsonKey(includeIfNull: false) final String? id,
          required final List<ChatCompletionResponseChoice> choices,
          required final int created,
          required final String model,
          @JsonKey(
              name: 'service_tier',
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ServiceTier? serviceTier,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          required final String object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateChatCompletionResponseImpl;
  const _CreateChatCompletionResponse._() : super._();

  factory _CreateChatCompletionResponse.fromJson(Map<String, dynamic> json) =
      _$CreateChatCompletionResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
  List<ChatCompletionResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created.
  int get created;
  @override

  /// The model used for the chat completion.
  String get model;
  @override

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ServiceTier? get serviceTier;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion`.
  String get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionResponseImplCopyWith<
          _$CreateChatCompletionResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionResponseChoice _$ChatCompletionResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionResponseChoice {
  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index => throw _privateConstructorUsedError;

  /// An assistant message in a chat conversation.
  ChatCompletionAssistantMessage get message =>
      throw _privateConstructorUsedError;

  /// Log probability information for the choice.
  ChatCompletionLogprobs? get logprobs => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionResponseChoiceCopyWith<ChatCompletionResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionResponseChoiceCopyWith(
          ChatCompletionResponseChoice value,
          $Res Function(ChatCompletionResponseChoice) then) =
      _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
          ChatCompletionResponseChoice>;
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index,
      ChatCompletionAssistantMessage message,
      ChatCompletionLogprobs? logprobs});

  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionResponseChoice>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  _$ChatCompletionResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = freezed,
    Object? message = freezed,
    Object? logprobs = freezed,
  }) {
    return _then(_value.copyWith(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionLogprobs?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $ChatCompletionLogprobsCopyWith<$Res>(_value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionResponseChoiceImplCopyWith(
          _$ChatCompletionResponseChoiceImpl value,
          $Res Function(_$ChatCompletionResponseChoiceImpl) then) =
      __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index,
      ChatCompletionAssistantMessage message,
      ChatCompletionLogprobs? logprobs});

  @override
  $ChatCompletionLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$ChatCompletionResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionResponseChoiceImpl>
    implements _$$ChatCompletionResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionResponseChoiceImplCopyWithImpl(
      _$ChatCompletionResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? finishReason = freezed,
    Object? index = freezed,
    Object? message = freezed,
    Object? logprobs = freezed,
  }) {
    return _then(_$ChatCompletionResponseChoiceImpl(
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as ChatCompletionAssistantMessage,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionLogprobs?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionResponseChoiceImpl extends _ChatCompletionResponseChoice {
  const _$ChatCompletionResponseChoiceImpl(
      {@JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      @JsonKey(includeIfNull: false) this.index,
      required this.message,
      required this.logprobs})
      : super._();

  factory _$ChatCompletionResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionResponseChoiceImplFromJson(json);

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  /// An assistant message in a chat conversation.
  @override
  final ChatCompletionAssistantMessage message;

  /// Log probability information for the choice.
  @override
  final ChatCompletionLogprobs? logprobs;

  @override
  String toString() {
    return 'ChatCompletionResponseChoice(finishReason: $finishReason, index: $index, message: $message, logprobs: $logprobs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionResponseChoiceImpl &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index) &&
            const DeepCollectionEquality().equals(other.message, message) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, finishReason, index,
      const DeepCollectionEquality().hash(message), logprobs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => __$$ChatCompletionResponseChoiceImplCopyWithImpl<
          _$ChatCompletionResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionResponseChoice
    extends ChatCompletionResponseChoice {
  const factory _ChatCompletionResponseChoice(
          {@JsonKey(
              name: 'finish_reason',
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          required final ChatCompletionFinishReason? finishReason,
          @JsonKey(includeIfNull: false) final int? index,
          required final ChatCompletionAssistantMessage message,
          required final ChatCompletionLogprobs? logprobs}) =
      _$ChatCompletionResponseChoiceImpl;
  const _ChatCompletionResponseChoice._() : super._();

  factory _ChatCompletionResponseChoice.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionResponseChoiceImpl.fromJson;

  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index;
  @override

  /// An assistant message in a chat conversation.
  ChatCompletionAssistantMessage get message;
  @override

  /// Log probability information for the choice.
  ChatCompletionLogprobs? get logprobs;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionResponseChoiceImplCopyWith<
          _$ChatCompletionResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionLogprobs _$ChatCompletionLogprobsFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionLogprobs.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionLogprobs {
  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionLogprobsCopyWith<ChatCompletionLogprobs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionLogprobsCopyWith<$Res> {
  factory $ChatCompletionLogprobsCopyWith(ChatCompletionLogprobs value,
          $Res Function(ChatCompletionLogprobs) then) =
      _$ChatCompletionLogprobsCopyWithImpl<$Res, ChatCompletionLogprobs>;
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class _$ChatCompletionLogprobsCopyWithImpl<$Res,
        $Val extends ChatCompletionLogprobs>
    implements $ChatCompletionLogprobsCopyWith<$Res> {
  _$ChatCompletionLogprobsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionLogprobsImplCopyWith<$Res>
    implements $ChatCompletionLogprobsCopyWith<$Res> {
  factory _$$ChatCompletionLogprobsImplCopyWith(
          _$ChatCompletionLogprobsImpl value,
          $Res Function(_$ChatCompletionLogprobsImpl) then) =
      __$$ChatCompletionLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class __$$ChatCompletionLogprobsImplCopyWithImpl<$Res>
    extends _$ChatCompletionLogprobsCopyWithImpl<$Res,
        _$ChatCompletionLogprobsImpl>
    implements _$$ChatCompletionLogprobsImplCopyWith<$Res> {
  __$$ChatCompletionLogprobsImplCopyWithImpl(
      _$ChatCompletionLogprobsImpl _value,
      $Res Function(_$ChatCompletionLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_$ChatCompletionLogprobsImpl(
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionLogprobsImpl extends _ChatCompletionLogprobs {
  const _$ChatCompletionLogprobsImpl(
      {required final List<ChatCompletionTokenLogprob>? content})
      : _content = content,
        super._();

  factory _$ChatCompletionLogprobsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionLogprobsImplFromJson(json);

  /// A list of message content tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _content;

  /// A list of message content tokens with log probability information.
  @override
  List<ChatCompletionTokenLogprob>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChatCompletionLogprobs(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionLogprobsImpl &&
            const DeepCollectionEquality().equals(other._content, _content));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_content));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionLogprobsImplCopyWith<_$ChatCompletionLogprobsImpl>
      get copyWith => __$$ChatCompletionLogprobsImplCopyWithImpl<
          _$ChatCompletionLogprobsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionLogprobsImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionLogprobs extends ChatCompletionLogprobs {
  const factory _ChatCompletionLogprobs(
          {required final List<ChatCompletionTokenLogprob>? content}) =
      _$ChatCompletionLogprobsImpl;
  const _ChatCompletionLogprobs._() : super._();

  factory _ChatCompletionLogprobs.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionLogprobsImpl.fromJson;

  @override

  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionLogprobsImplCopyWith<_$ChatCompletionLogprobsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionTokenLogprob _$ChatCompletionTokenLogprobFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionTokenLogprob.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTokenLogprob {
  /// The token.
  String get token => throw _privateConstructorUsedError;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  double get logprob => throw _privateConstructorUsedError;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes => throw _privateConstructorUsedError;

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionTokenLogprobCopyWith<ChatCompletionTokenLogprob>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionTokenLogprobCopyWith<$Res> {
  factory $ChatCompletionTokenLogprobCopyWith(ChatCompletionTokenLogprob value,
          $Res Function(ChatCompletionTokenLogprob) then) =
      _$ChatCompletionTokenLogprobCopyWithImpl<$Res,
          ChatCompletionTokenLogprob>;
  @useResult
  $Res call(
      {String token,
      double logprob,
      List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      List<ChatCompletionTokenTopLogprob> topLogprobs});
}

/// @nodoc
class _$ChatCompletionTokenLogprobCopyWithImpl<$Res,
        $Val extends ChatCompletionTokenLogprob>
    implements $ChatCompletionTokenLogprobCopyWith<$Res> {
  _$ChatCompletionTokenLogprobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
    Object? topLogprobs = null,
  }) {
    return _then(_value.copyWith(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value.bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      topLogprobs: null == topLogprobs
          ? _value.topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenTopLogprob>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionTokenLogprobImplCopyWith<$Res>
    implements $ChatCompletionTokenLogprobCopyWith<$Res> {
  factory _$$ChatCompletionTokenLogprobImplCopyWith(
          _$ChatCompletionTokenLogprobImpl value,
          $Res Function(_$ChatCompletionTokenLogprobImpl) then) =
      __$$ChatCompletionTokenLogprobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String token,
      double logprob,
      List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      List<ChatCompletionTokenTopLogprob> topLogprobs});
}

/// @nodoc
class __$$ChatCompletionTokenLogprobImplCopyWithImpl<$Res>
    extends _$ChatCompletionTokenLogprobCopyWithImpl<$Res,
        _$ChatCompletionTokenLogprobImpl>
    implements _$$ChatCompletionTokenLogprobImplCopyWith<$Res> {
  __$$ChatCompletionTokenLogprobImplCopyWithImpl(
      _$ChatCompletionTokenLogprobImpl _value,
      $Res Function(_$ChatCompletionTokenLogprobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
    Object? topLogprobs = null,
  }) {
    return _then(_$ChatCompletionTokenLogprobImpl(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value._bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      topLogprobs: null == topLogprobs
          ? _value._topLogprobs
          : topLogprobs // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenTopLogprob>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionTokenLogprobImpl extends _ChatCompletionTokenLogprob {
  const _$ChatCompletionTokenLogprobImpl(
      {required this.token,
      required this.logprob,
      required final List<int>? bytes,
      @JsonKey(name: 'top_logprobs')
      required final List<ChatCompletionTokenTopLogprob> topLogprobs})
      : _bytes = bytes,
        _topLogprobs = topLogprobs,
        super._();

  factory _$ChatCompletionTokenLogprobImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionTokenLogprobImplFromJson(json);

  /// The token.
  @override
  final String token;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  @override
  final double logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  final List<int>? _bytes;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  @override
  List<int>? get bytes {
    final value = _bytes;
    if (value == null) return null;
    if (_bytes is EqualUnmodifiableListView) return _bytes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  final List<ChatCompletionTokenTopLogprob> _topLogprobs;

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @override
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs {
    if (_topLogprobs is EqualUnmodifiableListView) return _topLogprobs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topLogprobs);
  }

  @override
  String toString() {
    return 'ChatCompletionTokenLogprob(token: $token, logprob: $logprob, bytes: $bytes, topLogprobs: $topLogprobs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionTokenLogprobImpl &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other._bytes, _bytes) &&
            const DeepCollectionEquality()
                .equals(other._topLogprobs, _topLogprobs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      token,
      logprob,
      const DeepCollectionEquality().hash(_bytes),
      const DeepCollectionEquality().hash(_topLogprobs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionTokenLogprobImplCopyWith<_$ChatCompletionTokenLogprobImpl>
      get copyWith => __$$ChatCompletionTokenLogprobImplCopyWithImpl<
          _$ChatCompletionTokenLogprobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionTokenLogprobImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTokenLogprob extends ChatCompletionTokenLogprob {
  const factory _ChatCompletionTokenLogprob(
          {required final String token,
          required final double logprob,
          required final List<int>? bytes,
          @JsonKey(name: 'top_logprobs')
          required final List<ChatCompletionTokenTopLogprob> topLogprobs}) =
      _$ChatCompletionTokenLogprobImpl;
  const _ChatCompletionTokenLogprob._() : super._();

  factory _ChatCompletionTokenLogprob.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionTokenLogprobImpl.fromJson;

  @override

  /// The token.
  String get token;
  @override

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  double get logprob;
  @override

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes;
  @override

  /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  @JsonKey(name: 'top_logprobs')
  List<ChatCompletionTokenTopLogprob> get topLogprobs;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionTokenLogprobImplCopyWith<_$ChatCompletionTokenLogprobImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionTokenTopLogprob _$ChatCompletionTokenTopLogprobFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionTokenTopLogprob.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionTokenTopLogprob {
  /// The token.
  String get token => throw _privateConstructorUsedError;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  double get logprob => throw _privateConstructorUsedError;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionTokenTopLogprobCopyWith<ChatCompletionTokenTopLogprob>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  factory $ChatCompletionTokenTopLogprobCopyWith(
          ChatCompletionTokenTopLogprob value,
          $Res Function(ChatCompletionTokenTopLogprob) then) =
      _$ChatCompletionTokenTopLogprobCopyWithImpl<$Res,
          ChatCompletionTokenTopLogprob>;
  @useResult
  $Res call({String token, double logprob, List<int>? bytes});
}

/// @nodoc
class _$ChatCompletionTokenTopLogprobCopyWithImpl<$Res,
        $Val extends ChatCompletionTokenTopLogprob>
    implements $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  _$ChatCompletionTokenTopLogprobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
  }) {
    return _then(_value.copyWith(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value.bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionTokenTopLogprobImplCopyWith<$Res>
    implements $ChatCompletionTokenTopLogprobCopyWith<$Res> {
  factory _$$ChatCompletionTokenTopLogprobImplCopyWith(
          _$ChatCompletionTokenTopLogprobImpl value,
          $Res Function(_$ChatCompletionTokenTopLogprobImpl) then) =
      __$$ChatCompletionTokenTopLogprobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String token, double logprob, List<int>? bytes});
}

/// @nodoc
class __$$ChatCompletionTokenTopLogprobImplCopyWithImpl<$Res>
    extends _$ChatCompletionTokenTopLogprobCopyWithImpl<$Res,
        _$ChatCompletionTokenTopLogprobImpl>
    implements _$$ChatCompletionTokenTopLogprobImplCopyWith<$Res> {
  __$$ChatCompletionTokenTopLogprobImplCopyWithImpl(
      _$ChatCompletionTokenTopLogprobImpl _value,
      $Res Function(_$ChatCompletionTokenTopLogprobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? logprob = null,
    Object? bytes = freezed,
  }) {
    return _then(_$ChatCompletionTokenTopLogprobImpl(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      logprob: null == logprob
          ? _value.logprob
          : logprob // ignore: cast_nullable_to_non_nullable
              as double,
      bytes: freezed == bytes
          ? _value._bytes
          : bytes // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionTokenTopLogprobImpl
    extends _ChatCompletionTokenTopLogprob {
  const _$ChatCompletionTokenTopLogprobImpl(
      {required this.token,
      required this.logprob,
      required final List<int>? bytes})
      : _bytes = bytes,
        super._();

  factory _$ChatCompletionTokenTopLogprobImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionTokenTopLogprobImplFromJson(json);

  /// The token.
  @override
  final String token;

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  @override
  final double logprob;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  final List<int>? _bytes;

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  @override
  List<int>? get bytes {
    final value = _bytes;
    if (value == null) return null;
    if (_bytes is EqualUnmodifiableListView) return _bytes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChatCompletionTokenTopLogprob(token: $token, logprob: $logprob, bytes: $bytes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionTokenTopLogprobImpl &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.logprob, logprob) || other.logprob == logprob) &&
            const DeepCollectionEquality().equals(other._bytes, _bytes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, token, logprob, const DeepCollectionEquality().hash(_bytes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionTokenTopLogprobImplCopyWith<
          _$ChatCompletionTokenTopLogprobImpl>
      get copyWith => __$$ChatCompletionTokenTopLogprobImplCopyWithImpl<
          _$ChatCompletionTokenTopLogprobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionTokenTopLogprobImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionTokenTopLogprob
    extends ChatCompletionTokenTopLogprob {
  const factory _ChatCompletionTokenTopLogprob(
      {required final String token,
      required final double logprob,
      required final List<int>? bytes}) = _$ChatCompletionTokenTopLogprobImpl;
  const _ChatCompletionTokenTopLogprob._() : super._();

  factory _ChatCompletionTokenTopLogprob.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionTokenTopLogprobImpl.fromJson;

  @override

  /// The token.
  String get token;
  @override

  /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  double get logprob;
  @override

  /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  List<int>? get bytes;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionTokenTopLogprobImplCopyWith<
          _$ChatCompletionTokenTopLogprobImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateChatCompletionStreamResponse _$CreateChatCompletionStreamResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateChatCompletionStreamResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateChatCompletionStreamResponse {
  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
  /// last chunk if you set `stream_options: {"include_usage": true}`.
  List<ChatCompletionStreamResponseChoice> get choices =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @JsonKey(includeIfNull: false)
  int? get created => throw _privateConstructorUsedError;

  /// The model to generate the completion.
  @JsonKey(includeIfNull: false)
  String? get model => throw _privateConstructorUsedError;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ServiceTier? get serviceTier => throw _privateConstructorUsedError;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint => throw _privateConstructorUsedError;

  /// The object type, which is always `chat.completion.chunk`.
  @JsonKey(includeIfNull: false)
  String? get object => throw _privateConstructorUsedError;

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateChatCompletionStreamResponseCopyWith<
          CreateChatCompletionStreamResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory $CreateChatCompletionStreamResponseCopyWith(
          CreateChatCompletionStreamResponse value,
          $Res Function(CreateChatCompletionStreamResponse) then) =
      _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
          CreateChatCompletionStreamResponse>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionStreamResponseChoice> choices,
      @JsonKey(includeIfNull: false) int? created,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      @JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        $Val extends CreateChatCompletionStreamResponse>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  _$CreateChatCompletionStreamResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = freezed,
    Object? model = freezed,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = freezed,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceTier: freezed == serviceTier
          ? _value.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: freezed == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $CompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateChatCompletionStreamResponseImplCopyWith<$Res>
    implements $CreateChatCompletionStreamResponseCopyWith<$Res> {
  factory _$$CreateChatCompletionStreamResponseImplCopyWith(
          _$CreateChatCompletionStreamResponseImpl value,
          $Res Function(_$CreateChatCompletionStreamResponseImpl) then) =
      __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? id,
      List<ChatCompletionStreamResponseChoice> choices,
      @JsonKey(includeIfNull: false) int? created,
      @JsonKey(includeIfNull: false) String? model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ServiceTier? serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      String? systemFingerprint,
      @JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) CompletionUsage? usage});

  @override
  $CompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateChatCompletionStreamResponseImplCopyWithImpl<$Res>
    extends _$CreateChatCompletionStreamResponseCopyWithImpl<$Res,
        _$CreateChatCompletionStreamResponseImpl>
    implements _$$CreateChatCompletionStreamResponseImplCopyWith<$Res> {
  __$$CreateChatCompletionStreamResponseImplCopyWithImpl(
      _$CreateChatCompletionStreamResponseImpl _value,
      $Res Function(_$CreateChatCompletionStreamResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? choices = null,
    Object? created = freezed,
    Object? model = freezed,
    Object? serviceTier = freezed,
    Object? systemFingerprint = freezed,
    Object? object = freezed,
    Object? usage = freezed,
  }) {
    return _then(_$CreateChatCompletionStreamResponseImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamResponseChoice>,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceTier: freezed == serviceTier
          ? _value.serviceTier
          : serviceTier // ignore: cast_nullable_to_non_nullable
              as ServiceTier?,
      systemFingerprint: freezed == systemFingerprint
          ? _value.systemFingerprint
          : systemFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      object: freezed == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as CompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateChatCompletionStreamResponseImpl
    extends _CreateChatCompletionStreamResponse {
  const _$CreateChatCompletionStreamResponseImpl(
      {@JsonKey(includeIfNull: false) this.id,
      required final List<ChatCompletionStreamResponseChoice> choices,
      @JsonKey(includeIfNull: false) this.created,
      @JsonKey(includeIfNull: false) this.model,
      @JsonKey(
          name: 'service_tier',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.serviceTier,
      @JsonKey(name: 'system_fingerprint', includeIfNull: false)
      this.systemFingerprint,
      @JsonKey(includeIfNull: false) this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _choices = choices,
        super._();

  factory _$CreateChatCompletionStreamResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateChatCompletionStreamResponseImplFromJson(json);

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
  /// last chunk if you set `stream_options: {"include_usage": true}`.
  final List<ChatCompletionStreamResponseChoice> _choices;

  /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
  /// last chunk if you set `stream_options: {"include_usage": true}`.
  @override
  List<ChatCompletionStreamResponseChoice> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @override
  @JsonKey(includeIfNull: false)
  final int? created;

  /// The model to generate the completion.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @override
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ServiceTier? serviceTier;

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @override
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  final String? systemFingerprint;

  /// The object type, which is always `chat.completion.chunk`.
  @override
  @JsonKey(includeIfNull: false)
  final String? object;

  /// Usage statistics for the completion request.
  @override
  @JsonKey(includeIfNull: false)
  final CompletionUsage? usage;

  @override
  String toString() {
    return 'CreateChatCompletionStreamResponse(id: $id, choices: $choices, created: $created, model: $model, serviceTier: $serviceTier, systemFingerprint: $systemFingerprint, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateChatCompletionStreamResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.serviceTier, serviceTier) ||
                other.serviceTier == serviceTier) &&
            (identical(other.systemFingerprint, systemFingerprint) ||
                other.systemFingerprint == systemFingerprint) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_choices),
      created,
      model,
      serviceTier,
      systemFingerprint,
      object,
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => __$$CreateChatCompletionStreamResponseImplCopyWithImpl<
          _$CreateChatCompletionStreamResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateChatCompletionStreamResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateChatCompletionStreamResponse
    extends CreateChatCompletionStreamResponse {
  const factory _CreateChatCompletionStreamResponse(
          {@JsonKey(includeIfNull: false) final String? id,
          required final List<ChatCompletionStreamResponseChoice> choices,
          @JsonKey(includeIfNull: false) final int? created,
          @JsonKey(includeIfNull: false) final String? model,
          @JsonKey(
              name: 'service_tier',
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ServiceTier? serviceTier,
          @JsonKey(name: 'system_fingerprint', includeIfNull: false)
          final String? systemFingerprint,
          @JsonKey(includeIfNull: false) final String? object,
          @JsonKey(includeIfNull: false) final CompletionUsage? usage}) =
      _$CreateChatCompletionStreamResponseImpl;
  const _CreateChatCompletionStreamResponse._() : super._();

  factory _CreateChatCompletionStreamResponse.fromJson(
          Map<String, dynamic> json) =
      _$CreateChatCompletionStreamResponseImpl.fromJson;

  @override

  /// A unique identifier for the chat completion. Each chunk has the same ID.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
  /// last chunk if you set `stream_options: {"include_usage": true}`.
  List<ChatCompletionStreamResponseChoice> get choices;
  @override

  /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  @JsonKey(includeIfNull: false)
  int? get created;
  @override

  /// The model to generate the completion.
  @JsonKey(includeIfNull: false)
  String? get model;
  @override

  /// The service tier used for processing the request. This field is only included if the `service_tier` parameter
  /// is specified in the request.
  @JsonKey(
      name: 'service_tier',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ServiceTier? get serviceTier;
  @override

  /// This fingerprint represents the backend configuration that the model runs with.
  ///
  /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact
  @JsonKey(name: 'system_fingerprint', includeIfNull: false)
  String? get systemFingerprint;
  @override

  /// The object type, which is always `chat.completion.chunk`.
  @JsonKey(includeIfNull: false)
  String? get object;
  @override

  /// Usage statistics for the completion request.
  @JsonKey(includeIfNull: false)
  CompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateChatCompletionStreamResponseImplCopyWith<
          _$CreateChatCompletionStreamResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseChoice _$ChatCompletionStreamResponseChoiceFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseChoice.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoice {
  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta =>
      throw _privateConstructorUsedError;

  /// Log probability information for the choice.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamResponseChoiceLogprobs? get logprobs =>
      throw _privateConstructorUsedError;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason =>
      throw _privateConstructorUsedError;

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseChoiceCopyWith<
          ChatCompletionStreamResponseChoice>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceCopyWith(
          ChatCompletionStreamResponseChoice value,
          $Res Function(ChatCompletionStreamResponseChoice) then) =
      _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
          ChatCompletionStreamResponseChoice>;
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseChoiceLogprobs? logprobs,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index});

  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseChoice>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? logprobs = freezed,
    Object? finishReason = freezed,
    Object? index = freezed,
  }) {
    return _then(_value.copyWith(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseChoiceLogprobs?,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta {
    return $ChatCompletionStreamResponseDeltaCopyWith<$Res>(_value.delta,
        (value) {
      return _then(_value.copyWith(delta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs {
    if (_value.logprobs == null) {
      return null;
    }

    return $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>(
        _value.logprobs!, (value) {
      return _then(_value.copyWith(logprobs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseChoiceImplCopyWith(
          _$ChatCompletionStreamResponseChoiceImpl value,
          $Res Function(_$ChatCompletionStreamResponseChoiceImpl) then) =
      __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionStreamResponseDelta delta,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamResponseChoiceLogprobs? logprobs,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionFinishReason? finishReason,
      @JsonKey(includeIfNull: false) int? index});

  @override
  $ChatCompletionStreamResponseDeltaCopyWith<$Res> get delta;
  @override
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res>? get logprobs;
}

/// @nodoc
class __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseChoiceCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseChoiceImpl>
    implements _$$ChatCompletionStreamResponseChoiceImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl(
      _$ChatCompletionStreamResponseChoiceImpl _value,
      $Res Function(_$ChatCompletionStreamResponseChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
    Object? logprobs = freezed,
    Object? finishReason = freezed,
    Object? index = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseChoiceImpl(
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseDelta,
      logprobs: freezed == logprobs
          ? _value.logprobs
          : logprobs // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamResponseChoiceLogprobs?,
      finishReason: freezed == finishReason
          ? _value.finishReason
          : finishReason // ignore: cast_nullable_to_non_nullable
              as ChatCompletionFinishReason?,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseChoiceImpl
    extends _ChatCompletionStreamResponseChoice {
  const _$ChatCompletionStreamResponseChoiceImpl(
      {required this.delta,
      @JsonKey(includeIfNull: false) this.logprobs,
      @JsonKey(
          name: 'finish_reason',
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.finishReason,
      @JsonKey(includeIfNull: false) this.index})
      : super._();

  factory _$ChatCompletionStreamResponseChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseChoiceImplFromJson(json);

  /// A chat completion delta generated by streamed model responses.
  @override
  final ChatCompletionStreamResponseDelta delta;

  /// Log probability information for the choice.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamResponseChoiceLogprobs? logprobs;

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @override
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionFinishReason? finishReason;

  /// The index of the choice in the list of choices.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoice(delta: $delta, logprobs: $logprobs, finishReason: $finishReason, index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseChoiceImpl &&
            (identical(other.delta, delta) || other.delta == delta) &&
            (identical(other.logprobs, logprobs) ||
                other.logprobs == logprobs) &&
            (identical(other.finishReason, finishReason) ||
                other.finishReason == finishReason) &&
            (identical(other.index, index) || other.index == index));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, delta, logprobs, finishReason, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => __$$ChatCompletionStreamResponseChoiceImplCopyWithImpl<
          _$ChatCompletionStreamResponseChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseChoiceImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseChoice
    extends ChatCompletionStreamResponseChoice {
  const factory _ChatCompletionStreamResponseChoice(
          {required final ChatCompletionStreamResponseDelta delta,
          @JsonKey(includeIfNull: false)
          final ChatCompletionStreamResponseChoiceLogprobs? logprobs,
          @JsonKey(
              name: 'finish_reason',
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          required final ChatCompletionFinishReason? finishReason,
          @JsonKey(includeIfNull: false) final int? index}) =
      _$ChatCompletionStreamResponseChoiceImpl;
  const _ChatCompletionStreamResponseChoice._() : super._();

  factory _ChatCompletionStreamResponseChoice.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseChoiceImpl.fromJson;

  @override

  /// A chat completion delta generated by streamed model responses.
  ChatCompletionStreamResponseDelta get delta;
  @override

  /// Log probability information for the choice.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamResponseChoiceLogprobs? get logprobs;
  @override

  /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
  /// `length` if the maximum number of tokens specified in the request was reached,
  /// `content_filter` if content was omitted due to a flag from our content filters,
  /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
  @JsonKey(
      name: 'finish_reason',
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionFinishReason? get finishReason;
  @override

  /// The index of the choice in the list of choices.
  @JsonKey(includeIfNull: false)
  int? get index;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseChoiceImplCopyWith<
          _$ChatCompletionStreamResponseChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseChoiceLogprobs
    _$ChatCompletionStreamResponseChoiceLogprobsFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseChoiceLogprobs.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseChoiceLogprobs {
  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseChoiceLogprobsCopyWith<
          ChatCompletionStreamResponseChoiceLogprobs>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  factory $ChatCompletionStreamResponseChoiceLogprobsCopyWith(
          ChatCompletionStreamResponseChoiceLogprobs value,
          $Res Function(ChatCompletionStreamResponseChoiceLogprobs) then) =
      _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res,
          ChatCompletionStreamResponseChoiceLogprobs>;
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseChoiceLogprobs>
    implements $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseChoiceLogprobsCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith(
          _$ChatCompletionStreamResponseChoiceLogprobsImpl value,
          $Res Function(_$ChatCompletionStreamResponseChoiceLogprobsImpl)
              then) =
      __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<ChatCompletionTokenLogprob>? content});
}

/// @nodoc
class __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseChoiceLogprobsCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseChoiceLogprobsImpl>
    implements _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl(
      _$ChatCompletionStreamResponseChoiceLogprobsImpl _value,
      $Res Function(_$ChatCompletionStreamResponseChoiceLogprobsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseChoiceLogprobsImpl(
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionTokenLogprob>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseChoiceLogprobsImpl
    extends _ChatCompletionStreamResponseChoiceLogprobs {
  const _$ChatCompletionStreamResponseChoiceLogprobsImpl(
      {required final List<ChatCompletionTokenLogprob>? content})
      : _content = content,
        super._();

  factory _$ChatCompletionStreamResponseChoiceLogprobsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseChoiceLogprobsImplFromJson(json);

  /// A list of message content tokens with log probability information.
  final List<ChatCompletionTokenLogprob>? _content;

  /// A list of message content tokens with log probability information.
  @override
  List<ChatCompletionTokenLogprob>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChatCompletionStreamResponseChoiceLogprobs(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseChoiceLogprobsImpl &&
            const DeepCollectionEquality().equals(other._content, _content));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_content));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<
          _$ChatCompletionStreamResponseChoiceLogprobsImpl>
      get copyWith =>
          __$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWithImpl<
                  _$ChatCompletionStreamResponseChoiceLogprobsImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseChoiceLogprobsImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseChoiceLogprobs
    extends ChatCompletionStreamResponseChoiceLogprobs {
  const factory _ChatCompletionStreamResponseChoiceLogprobs(
          {required final List<ChatCompletionTokenLogprob>? content}) =
      _$ChatCompletionStreamResponseChoiceLogprobsImpl;
  const _ChatCompletionStreamResponseChoiceLogprobs._() : super._();

  factory _ChatCompletionStreamResponseChoiceLogprobs.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseChoiceLogprobsImpl.fromJson;

  @override

  /// A list of message content tokens with log probability information.
  List<ChatCompletionTokenLogprob>? get content;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseChoiceLogprobsImplCopyWith<
          _$ChatCompletionStreamResponseChoiceLogprobsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamResponseDelta _$ChatCompletionStreamResponseDeltaFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionStreamResponseDelta.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamResponseDelta {
  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content => throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall =>
      throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls =>
      throw _privateConstructorUsedError;

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamResponseDeltaCopyWith<ChatCompletionStreamResponseDelta>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory $ChatCompletionStreamResponseDeltaCopyWith(
          ChatCompletionStreamResponseDelta value,
          $Res Function(ChatCompletionStreamResponseDelta) then) =
      _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
          ChatCompletionStreamResponseDelta>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamResponseDelta>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  _$ChatCompletionStreamResponseDeltaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res>
    implements $ChatCompletionStreamResponseDeltaCopyWith<$Res> {
  factory _$$ChatCompletionStreamResponseDeltaImplCopyWith(
          _$ChatCompletionStreamResponseDeltaImpl value,
          $Res Function(_$ChatCompletionStreamResponseDeltaImpl) then) =
      __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? content,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionMessageRole? role});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamResponseDeltaCopyWithImpl<$Res,
        _$ChatCompletionStreamResponseDeltaImpl>
    implements _$$ChatCompletionStreamResponseDeltaImplCopyWith<$Res> {
  __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl(
      _$ChatCompletionStreamResponseDeltaImpl _value,
      $Res Function(_$ChatCompletionStreamResponseDeltaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? functionCall = freezed,
    Object? toolCalls = freezed,
    Object? role = freezed,
  }) {
    return _then(_$ChatCompletionStreamResponseDeltaImpl(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionStreamMessageToolCallChunk>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamResponseDeltaImpl
    extends _ChatCompletionStreamResponseDelta {
  const _$ChatCompletionStreamResponseDeltaImpl(
      {@JsonKey(includeIfNull: false) this.content,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.role})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionStreamResponseDeltaImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamResponseDeltaImplFromJson(json);

  /// The contents of the chunk message.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? functionCall;

  /// No Description
  final List<ChatCompletionStreamMessageToolCallChunk>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionMessageRole? role;

  @override
  String toString() {
    return 'ChatCompletionStreamResponseDelta(content: $content, functionCall: $functionCall, toolCalls: $toolCalls, role: $role)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamResponseDeltaImpl &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.role, role) || other.role == role));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, content, functionCall,
      const DeepCollectionEquality().hash(_toolCalls), role);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => __$$ChatCompletionStreamResponseDeltaImplCopyWithImpl<
          _$ChatCompletionStreamResponseDeltaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamResponseDeltaImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamResponseDelta
    extends ChatCompletionStreamResponseDelta {
  const factory _ChatCompletionStreamResponseDelta(
          {@JsonKey(includeIfNull: false) final String? content,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? functionCall,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionStreamMessageToolCallChunk>? toolCalls,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionMessageRole? role}) =
      _$ChatCompletionStreamResponseDeltaImpl;
  const _ChatCompletionStreamResponseDelta._() : super._();

  factory _ChatCompletionStreamResponseDelta.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamResponseDeltaImpl.fromJson;

  @override

  /// The contents of the chunk message.
  @JsonKey(includeIfNull: false)
  String? get content;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get functionCall;
  @override

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionStreamMessageToolCallChunk>? get toolCalls;
  @override

  /// The role of the messages author. One of `system`, `user`, `assistant`, or `tool` (`function` is deprecated).
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionMessageRole? get role;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamResponseDeltaImplCopyWith<
          _$ChatCompletionStreamResponseDeltaImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageFunctionCall
    _$ChatCompletionStreamMessageFunctionCallFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageFunctionCall.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageFunctionCall {
  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageFunctionCallCopyWith<
          ChatCompletionStreamMessageFunctionCall>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory $ChatCompletionStreamMessageFunctionCallCopyWith(
          ChatCompletionStreamMessageFunctionCall value,
          $Res Function(ChatCompletionStreamMessageFunctionCall) then) =
      _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
          ChatCompletionStreamMessageFunctionCall>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageFunctionCall>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  _$ChatCompletionStreamMessageFunctionCallCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageFunctionCallCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageFunctionCallImplCopyWith(
          _$ChatCompletionStreamMessageFunctionCallImpl value,
          $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) then) =
      __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments});
}

/// @nodoc
class __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageFunctionCallCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageFunctionCallImpl>
    implements _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl(
      _$ChatCompletionStreamMessageFunctionCallImpl _value,
      $Res Function(_$ChatCompletionStreamMessageFunctionCallImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageFunctionCallImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageFunctionCallImpl
    extends _ChatCompletionStreamMessageFunctionCall {
  const _$ChatCompletionStreamMessageFunctionCallImpl(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.arguments})
      : super._();

  factory _$ChatCompletionStreamMessageFunctionCallImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageFunctionCallImplFromJson(json);

  /// The name of the function to call.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @override
  @JsonKey(includeIfNull: false)
  final String? arguments;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageFunctionCall(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageFunctionCallImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageFunctionCallImplCopyWithImpl<
              _$ChatCompletionStreamMessageFunctionCallImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageFunctionCallImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageFunctionCall
    extends ChatCompletionStreamMessageFunctionCall {
  const factory _ChatCompletionStreamMessageFunctionCall(
          {@JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? arguments}) =
      _$ChatCompletionStreamMessageFunctionCallImpl;
  const _ChatCompletionStreamMessageFunctionCall._() : super._();

  factory _ChatCompletionStreamMessageFunctionCall.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageFunctionCallImpl.fromJson;

  @override

  /// The name of the function to call.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  @JsonKey(includeIfNull: false)
  String? get arguments;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageFunctionCallImplCopyWith<
          _$ChatCompletionStreamMessageFunctionCallImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionStreamMessageToolCallChunk
    _$ChatCompletionStreamMessageToolCallChunkFromJson(
        Map<String, dynamic> json) {
  return _ChatCompletionStreamMessageToolCallChunk.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionStreamMessageToolCallChunk {
  /// No Description
  int get index => throw _privateConstructorUsedError;

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type =>
      throw _privateConstructorUsedError;

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionStreamMessageToolCallChunkCopyWith<
          ChatCompletionStreamMessageToolCallChunk>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory $ChatCompletionStreamMessageToolCallChunkCopyWith(
          ChatCompletionStreamMessageToolCallChunk value,
          $Res Function(ChatCompletionStreamMessageToolCallChunk) then) =
      _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
          ChatCompletionStreamMessageToolCallChunk>;
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        $Val extends ChatCompletionStreamMessageToolCallChunk>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>(
        _value.function!, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res>
    implements $ChatCompletionStreamMessageToolCallChunkCopyWith<$Res> {
  factory _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith(
          _$ChatCompletionStreamMessageToolCallChunkImpl value,
          $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) then) =
      __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ChatCompletionStreamMessageToolCallChunkType? type,
      @JsonKey(includeIfNull: false)
      ChatCompletionStreamMessageFunctionCall? function});

  @override
  $ChatCompletionStreamMessageFunctionCallCopyWith<$Res>? get function;
}

/// @nodoc
class __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<$Res>
    extends _$ChatCompletionStreamMessageToolCallChunkCopyWithImpl<$Res,
        _$ChatCompletionStreamMessageToolCallChunkImpl>
    implements _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<$Res> {
  __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl(
      _$ChatCompletionStreamMessageToolCallChunkImpl _value,
      $Res Function(_$ChatCompletionStreamMessageToolCallChunkImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = freezed,
    Object? function = freezed,
  }) {
    return _then(_$ChatCompletionStreamMessageToolCallChunkImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageToolCallChunkType?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as ChatCompletionStreamMessageFunctionCall?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionStreamMessageToolCallChunkImpl
    extends _ChatCompletionStreamMessageToolCallChunk {
  const _$ChatCompletionStreamMessageToolCallChunkImpl(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionStreamMessageToolCallChunkImplFromJson(json);

  /// No Description
  @override
  final int index;

  /// The ID of the tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The type of the tool. Currently, only `function` is supported.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ChatCompletionStreamMessageToolCallChunkType? type;

  /// The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(includeIfNull: false)
  final ChatCompletionStreamMessageFunctionCall? function;

  @override
  String toString() {
    return 'ChatCompletionStreamMessageToolCallChunk(index: $index, id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionStreamMessageToolCallChunkImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith =>
          __$$ChatCompletionStreamMessageToolCallChunkImplCopyWithImpl<
              _$ChatCompletionStreamMessageToolCallChunkImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionStreamMessageToolCallChunkImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionStreamMessageToolCallChunk
    extends ChatCompletionStreamMessageToolCallChunk {
  const factory _ChatCompletionStreamMessageToolCallChunk(
          {required final int index,
          @JsonKey(includeIfNull: false) final String? id,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ChatCompletionStreamMessageToolCallChunkType? type,
          @JsonKey(includeIfNull: false)
          final ChatCompletionStreamMessageFunctionCall? function}) =
      _$ChatCompletionStreamMessageToolCallChunkImpl;
  const _ChatCompletionStreamMessageToolCallChunk._() : super._();

  factory _ChatCompletionStreamMessageToolCallChunk.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionStreamMessageToolCallChunkImpl.fromJson;

  @override

  /// No Description
  int get index;
  @override

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// The type of the tool. Currently, only `function` is supported.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ChatCompletionStreamMessageToolCallChunkType? get type;
  @override

  /// The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(includeIfNull: false)
  ChatCompletionStreamMessageFunctionCall? get function;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionStreamMessageToolCallChunkImplCopyWith<
          _$ChatCompletionStreamMessageToolCallChunkImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CompletionUsage _$CompletionUsageFromJson(Map<String, dynamic> json) {
  return _CompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$CompletionUsage {
  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens => throw _privateConstructorUsedError;

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CompletionUsageCopyWith<CompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompletionUsageCopyWith<$Res> {
  factory $CompletionUsageCopyWith(
          CompletionUsage value, $Res Function(CompletionUsage) then) =
      _$CompletionUsageCopyWithImpl<$Res, CompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$CompletionUsageCopyWithImpl<$Res, $Val extends CompletionUsage>
    implements $CompletionUsageCopyWith<$Res> {
  _$CompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompletionUsageImplCopyWith<$Res>
    implements $CompletionUsageCopyWith<$Res> {
  factory _$$CompletionUsageImplCopyWith(_$CompletionUsageImpl value,
          $Res Function(_$CompletionUsageImpl) then) =
      __$$CompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int? completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$CompletionUsageImplCopyWithImpl<$Res>
    extends _$CompletionUsageCopyWithImpl<$Res, _$CompletionUsageImpl>
    implements _$$CompletionUsageImplCopyWith<$Res> {
  __$$CompletionUsageImplCopyWithImpl(
      _$CompletionUsageImpl _value, $Res Function(_$CompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = freezed,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$CompletionUsageImpl(
      completionTokens: freezed == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompletionUsageImpl extends _CompletionUsage {
  const _$CompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$CompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletionUsageImplFromJson(json);

  /// Number of tokens in the generated completion.
  @override
  @JsonKey(name: 'completion_tokens')
  final int? completionTokens;

  /// Number of tokens in the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used in the request (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'CompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      __$$CompletionUsageImplCopyWithImpl<_$CompletionUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _CompletionUsage extends CompletionUsage {
  const factory _CompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int? completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$CompletionUsageImpl;
  const _CompletionUsage._() : super._();

  factory _CompletionUsage.fromJson(Map<String, dynamic> json) =
      _$CompletionUsageImpl.fromJson;

  @override

  /// Number of tokens in the generated completion.
  @JsonKey(name: 'completion_tokens')
  int? get completionTokens;
  @override

  /// Number of tokens in the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used in the request (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$CompletionUsageImplCopyWith<_$CompletionUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateEmbeddingRequest _$CreateEmbeddingRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model => throw _privateConstructorUsedError;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input => throw _privateConstructorUsedError;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat =>
      throw _privateConstructorUsedError;

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @JsonKey(includeIfNull: false)
  int? get dimensions => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingRequestCopyWith<CreateEmbeddingRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingRequestCopyWith<$Res> {
  factory $CreateEmbeddingRequestCopyWith(CreateEmbeddingRequest value,
          $Res Function(CreateEmbeddingRequest) then) =
      _$CreateEmbeddingRequestCopyWithImpl<$Res, CreateEmbeddingRequest>;
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) int? dimensions,
      @JsonKey(includeIfNull: false) String? user});

  $EmbeddingModelCopyWith<$Res> get model;
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateEmbeddingRequestCopyWithImpl<$Res,
        $Val extends CreateEmbeddingRequest>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  _$CreateEmbeddingRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? dimensions = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      dimensions: freezed == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as int?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingModelCopyWith<$Res> get model {
    return $EmbeddingModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingInputCopyWith<$Res> get input {
    return $EmbeddingInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingRequestImplCopyWith<$Res>
    implements $CreateEmbeddingRequestCopyWith<$Res> {
  factory _$$CreateEmbeddingRequestImplCopyWith(
          _$CreateEmbeddingRequestImpl value,
          $Res Function(_$CreateEmbeddingRequestImpl) then) =
      __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_EmbeddingModelConverter() EmbeddingModel model,
      @_EmbeddingInputConverter() EmbeddingInput input,
      @JsonKey(name: 'encoding_format') EmbeddingEncodingFormat encodingFormat,
      @JsonKey(includeIfNull: false) int? dimensions,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $EmbeddingModelCopyWith<$Res> get model;
  @override
  $EmbeddingInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateEmbeddingRequestImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingRequestCopyWithImpl<$Res,
        _$CreateEmbeddingRequestImpl>
    implements _$$CreateEmbeddingRequestImplCopyWith<$Res> {
  __$$CreateEmbeddingRequestImplCopyWithImpl(
      _$CreateEmbeddingRequestImpl _value,
      $Res Function(_$CreateEmbeddingRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? input = null,
    Object? encodingFormat = null,
    Object? dimensions = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateEmbeddingRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EmbeddingModel,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as EmbeddingInput,
      encodingFormat: null == encodingFormat
          ? _value.encodingFormat
          : encodingFormat // ignore: cast_nullable_to_non_nullable
              as EmbeddingEncodingFormat,
      dimensions: freezed == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as int?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingRequestImpl extends _CreateEmbeddingRequest {
  const _$CreateEmbeddingRequestImpl(
      {@_EmbeddingModelConverter() required this.model,
      @_EmbeddingInputConverter() required this.input,
      @JsonKey(name: 'encoding_format')
      this.encodingFormat = EmbeddingEncodingFormat.float,
      @JsonKey(includeIfNull: false) this.dimensions,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateEmbeddingRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @_EmbeddingModelConverter()
  final EmbeddingModel model;

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @override
  @_EmbeddingInputConverter()
  final EmbeddingInput input;

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @override
  @JsonKey(name: 'encoding_format')
  final EmbeddingEncodingFormat encodingFormat;

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @override
  @JsonKey(includeIfNull: false)
  final int? dimensions;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateEmbeddingRequest(model: $model, input: $input, encodingFormat: $encodingFormat, dimensions: $dimensions, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.encodingFormat, encodingFormat) ||
                other.encodingFormat == encodingFormat) &&
            (identical(other.dimensions, dimensions) ||
                other.dimensions == dimensions) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, model, input, encodingFormat, dimensions, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => __$$CreateEmbeddingRequestImplCopyWithImpl<
          _$CreateEmbeddingRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingRequest extends CreateEmbeddingRequest {
  const factory _CreateEmbeddingRequest(
          {@_EmbeddingModelConverter() required final EmbeddingModel model,
          @_EmbeddingInputConverter() required final EmbeddingInput input,
          @JsonKey(name: 'encoding_format')
          final EmbeddingEncodingFormat encodingFormat,
          @JsonKey(includeIfNull: false) final int? dimensions,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateEmbeddingRequestImpl;
  const _CreateEmbeddingRequest._() : super._();

  factory _CreateEmbeddingRequest.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_EmbeddingModelConverter()
  EmbeddingModel get model;
  @override

  /// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
  @_EmbeddingInputConverter()
  EmbeddingInput get input;
  @override

  /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
  @JsonKey(name: 'encoding_format')
  EmbeddingEncodingFormat get encodingFormat;
  @override

  /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
  @JsonKey(includeIfNull: false)
  int? get dimensions;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingRequestImplCopyWith<_$CreateEmbeddingRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingModel _$EmbeddingModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return EmbeddingModelEnumeration.fromJson(json);
    case 'modelId':
      return EmbeddingModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingModelCopyWith<$Res> {
  factory $EmbeddingModelCopyWith(
          EmbeddingModel value, $Res Function(EmbeddingModel) then) =
      _$EmbeddingModelCopyWithImpl<$Res, EmbeddingModel>;
}

/// @nodoc
class _$EmbeddingModelCopyWithImpl<$Res, $Val extends EmbeddingModel>
    implements $EmbeddingModelCopyWith<$Res> {
  _$EmbeddingModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingModelEnumerationImplCopyWith<$Res> {
  factory _$$EmbeddingModelEnumerationImplCopyWith(
          _$EmbeddingModelEnumerationImpl value,
          $Res Function(_$EmbeddingModelEnumerationImpl) then) =
      __$$EmbeddingModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({EmbeddingModels value});
}

/// @nodoc
class __$$EmbeddingModelEnumerationImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$EmbeddingModelEnumerationImpl>
    implements _$$EmbeddingModelEnumerationImplCopyWith<$Res> {
  __$$EmbeddingModelEnumerationImplCopyWithImpl(
      _$EmbeddingModelEnumerationImpl _value,
      $Res Function(_$EmbeddingModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as EmbeddingModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingModelEnumerationImpl extends EmbeddingModelEnumeration {
  const _$EmbeddingModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$EmbeddingModelEnumerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingModelEnumerationImplFromJson(json);

  @override
  final EmbeddingModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingModelEnumerationImplCopyWith<_$EmbeddingModelEnumerationImpl>
      get copyWith => __$$EmbeddingModelEnumerationImplCopyWithImpl<
          _$EmbeddingModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class EmbeddingModelEnumeration extends EmbeddingModel {
  const factory EmbeddingModelEnumeration(final EmbeddingModels value) =
      _$EmbeddingModelEnumerationImpl;
  const EmbeddingModelEnumeration._() : super._();

  factory EmbeddingModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$EmbeddingModelEnumerationImpl.fromJson;

  @override
  EmbeddingModels get value;
  @JsonKey(ignore: true)
  _$$EmbeddingModelEnumerationImplCopyWith<_$EmbeddingModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingModelStringImplCopyWith<$Res> {
  factory _$$EmbeddingModelStringImplCopyWith(_$EmbeddingModelStringImpl value,
          $Res Function(_$EmbeddingModelStringImpl) then) =
      __$$EmbeddingModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingModelStringImplCopyWithImpl<$Res>
    extends _$EmbeddingModelCopyWithImpl<$Res, _$EmbeddingModelStringImpl>
    implements _$$EmbeddingModelStringImplCopyWith<$Res> {
  __$$EmbeddingModelStringImplCopyWithImpl(_$EmbeddingModelStringImpl _value,
      $Res Function(_$EmbeddingModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingModelStringImpl extends EmbeddingModelString {
  const _$EmbeddingModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$EmbeddingModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingModelStringImplCopyWith<_$EmbeddingModelStringImpl>
      get copyWith =>
          __$$EmbeddingModelStringImplCopyWithImpl<_$EmbeddingModelStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbeddingModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbeddingModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingModelEnumeration value) model,
    required TResult Function(EmbeddingModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingModelEnumeration value)? model,
    TResult? Function(EmbeddingModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingModelEnumeration value)? model,
    TResult Function(EmbeddingModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingModelStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingModelString extends EmbeddingModel {
  const factory EmbeddingModelString(final String value) =
      _$EmbeddingModelStringImpl;
  const EmbeddingModelString._() : super._();

  factory EmbeddingModelString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingModelStringImplCopyWith<_$EmbeddingModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingInput _$EmbeddingInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listTokens':
      return EmbeddingInputListListInt.fromJson(json);
    case 'tokens':
      return EmbeddingInputListInt.fromJson(json);
    case 'listString':
      return EmbeddingInputListString.fromJson(json);
    case 'string':
      return EmbeddingInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingInputCopyWith<$Res> {
  factory $EmbeddingInputCopyWith(
          EmbeddingInput value, $Res Function(EmbeddingInput) then) =
      _$EmbeddingInputCopyWithImpl<$Res, EmbeddingInput>;
}

/// @nodoc
class _$EmbeddingInputCopyWithImpl<$Res, $Val extends EmbeddingInput>
    implements $EmbeddingInputCopyWith<$Res> {
  _$EmbeddingInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingInputListListIntImplCopyWith<$Res> {
  factory _$$EmbeddingInputListListIntImplCopyWith(
          _$EmbeddingInputListListIntImpl value,
          $Res Function(_$EmbeddingInputListListIntImpl) then) =
      __$$EmbeddingInputListListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<List<int>> value});
}

/// @nodoc
class __$$EmbeddingInputListListIntImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListListIntImpl>
    implements _$$EmbeddingInputListListIntImplCopyWith<$Res> {
  __$$EmbeddingInputListListIntImplCopyWithImpl(
      _$EmbeddingInputListListIntImpl _value,
      $Res Function(_$EmbeddingInputListListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListListIntImpl extends EmbeddingInputListListInt {
  const _$EmbeddingInputListListIntImpl(final List<List<int>> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listTokens',
        super._();

  factory _$EmbeddingInputListListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListListIntImplFromJson(json);

  final List<List<int>> _value;
  @override
  List<List<int>> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.listTokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListListIntImplCopyWith<_$EmbeddingInputListListIntImpl>
      get copyWith => __$$EmbeddingInputListListIntImplCopyWithImpl<
          _$EmbeddingInputListListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listTokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listTokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return listTokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return listTokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (listTokens != null) {
      return listTokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListListIntImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListListInt extends EmbeddingInput {
  const factory EmbeddingInputListListInt(final List<List<int>> value) =
      _$EmbeddingInputListListIntImpl;
  const EmbeddingInputListListInt._() : super._();

  factory EmbeddingInputListListInt.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListListIntImpl.fromJson;

  @override
  List<List<int>> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListListIntImplCopyWith<_$EmbeddingInputListListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputListIntImplCopyWith<$Res> {
  factory _$$EmbeddingInputListIntImplCopyWith(
          _$EmbeddingInputListIntImpl value,
          $Res Function(_$EmbeddingInputListIntImpl) then) =
      __$$EmbeddingInputListIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$EmbeddingInputListIntImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListIntImpl>
    implements _$$EmbeddingInputListIntImplCopyWith<$Res> {
  __$$EmbeddingInputListIntImplCopyWithImpl(_$EmbeddingInputListIntImpl _value,
      $Res Function(_$EmbeddingInputListIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListIntImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListIntImpl extends EmbeddingInputListInt {
  const _$EmbeddingInputListIntImpl(final List<int> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'tokens',
        super._();

  factory _$EmbeddingInputListIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListIntImplFromJson(json);

  final List<int> _value;
  @override
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.tokens(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListIntImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListIntImplCopyWith<_$EmbeddingInputListIntImpl>
      get copyWith => __$$EmbeddingInputListIntImplCopyWithImpl<
          _$EmbeddingInputListIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return tokens(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return tokens?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return tokens(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return tokens?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (tokens != null) {
      return tokens(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListIntImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListInt extends EmbeddingInput {
  const factory EmbeddingInputListInt(final List<int> value) =
      _$EmbeddingInputListIntImpl;
  const EmbeddingInputListInt._() : super._();

  factory EmbeddingInputListInt.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListIntImpl.fromJson;

  @override
  List<int> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListIntImplCopyWith<_$EmbeddingInputListIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputListStringImplCopyWith<$Res> {
  factory _$$EmbeddingInputListStringImplCopyWith(
          _$EmbeddingInputListStringImpl value,
          $Res Function(_$EmbeddingInputListStringImpl) then) =
      __$$EmbeddingInputListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$EmbeddingInputListStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputListStringImpl>
    implements _$$EmbeddingInputListStringImplCopyWith<$Res> {
  __$$EmbeddingInputListStringImplCopyWithImpl(
      _$EmbeddingInputListStringImpl _value,
      $Res Function(_$EmbeddingInputListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputListStringImpl extends EmbeddingInputListString {
  const _$EmbeddingInputListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$EmbeddingInputListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputListStringImplCopyWith<_$EmbeddingInputListStringImpl>
      get copyWith => __$$EmbeddingInputListStringImplCopyWithImpl<
          _$EmbeddingInputListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputListStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputListString extends EmbeddingInput {
  const factory EmbeddingInputListString(final List<String> value) =
      _$EmbeddingInputListStringImpl;
  const EmbeddingInputListString._() : super._();

  factory EmbeddingInputListString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputListStringImplCopyWith<_$EmbeddingInputListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingInputStringImplCopyWith<$Res> {
  factory _$$EmbeddingInputStringImplCopyWith(_$EmbeddingInputStringImpl value,
          $Res Function(_$EmbeddingInputStringImpl) then) =
      __$$EmbeddingInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingInputStringImplCopyWithImpl<$Res>
    extends _$EmbeddingInputCopyWithImpl<$Res, _$EmbeddingInputStringImpl>
    implements _$$EmbeddingInputStringImplCopyWith<$Res> {
  __$$EmbeddingInputStringImplCopyWithImpl(_$EmbeddingInputStringImpl _value,
      $Res Function(_$EmbeddingInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingInputStringImpl extends EmbeddingInputString {
  const _$EmbeddingInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$EmbeddingInputStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingInput.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingInputStringImplCopyWith<_$EmbeddingInputStringImpl>
      get copyWith =>
          __$$EmbeddingInputStringImplCopyWithImpl<_$EmbeddingInputStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<List<int>> value) listTokens,
    required TResult Function(List<int> value) tokens,
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<List<int>> value)? listTokens,
    TResult? Function(List<int> value)? tokens,
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<List<int>> value)? listTokens,
    TResult Function(List<int> value)? tokens,
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingInputListListInt value) listTokens,
    required TResult Function(EmbeddingInputListInt value) tokens,
    required TResult Function(EmbeddingInputListString value) listString,
    required TResult Function(EmbeddingInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingInputListListInt value)? listTokens,
    TResult? Function(EmbeddingInputListInt value)? tokens,
    TResult? Function(EmbeddingInputListString value)? listString,
    TResult? Function(EmbeddingInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingInputListListInt value)? listTokens,
    TResult Function(EmbeddingInputListInt value)? tokens,
    TResult Function(EmbeddingInputListString value)? listString,
    TResult Function(EmbeddingInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingInputStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingInputString extends EmbeddingInput {
  const factory EmbeddingInputString(final String value) =
      _$EmbeddingInputStringImpl;
  const EmbeddingInputString._() : super._();

  factory EmbeddingInputString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingInputStringImplCopyWith<_$EmbeddingInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateEmbeddingResponse _$CreateEmbeddingResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateEmbeddingResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateEmbeddingResponse {
  /// The list of embeddings generated by the model.
  List<Embedding> get data => throw _privateConstructorUsedError;

  /// The name of the model used to generate the embedding.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  CreateEmbeddingResponseObject get object =>
      throw _privateConstructorUsedError;

  /// The usage information for the request.
  @JsonKey(includeIfNull: false)
  EmbeddingUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateEmbeddingResponseCopyWith<CreateEmbeddingResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEmbeddingResponseCopyWith<$Res> {
  factory $CreateEmbeddingResponseCopyWith(CreateEmbeddingResponse value,
          $Res Function(CreateEmbeddingResponse) then) =
      _$CreateEmbeddingResponseCopyWithImpl<$Res, CreateEmbeddingResponse>;
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      @JsonKey(includeIfNull: false) EmbeddingUsage? usage});

  $EmbeddingUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$CreateEmbeddingResponseCopyWithImpl<$Res,
        $Val extends CreateEmbeddingResponse>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  _$CreateEmbeddingResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $EmbeddingUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateEmbeddingResponseImplCopyWith<$Res>
    implements $CreateEmbeddingResponseCopyWith<$Res> {
  factory _$$CreateEmbeddingResponseImplCopyWith(
          _$CreateEmbeddingResponseImpl value,
          $Res Function(_$CreateEmbeddingResponseImpl) then) =
      __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Embedding> data,
      String model,
      CreateEmbeddingResponseObject object,
      @JsonKey(includeIfNull: false) EmbeddingUsage? usage});

  @override
  $EmbeddingUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$CreateEmbeddingResponseImplCopyWithImpl<$Res>
    extends _$CreateEmbeddingResponseCopyWithImpl<$Res,
        _$CreateEmbeddingResponseImpl>
    implements _$$CreateEmbeddingResponseImplCopyWith<$Res> {
  __$$CreateEmbeddingResponseImplCopyWithImpl(
      _$CreateEmbeddingResponseImpl _value,
      $Res Function(_$CreateEmbeddingResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? model = null,
    Object? object = null,
    Object? usage = freezed,
  }) {
    return _then(_$CreateEmbeddingResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Embedding>,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as CreateEmbeddingResponseObject,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as EmbeddingUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateEmbeddingResponseImpl extends _CreateEmbeddingResponse {
  const _$CreateEmbeddingResponseImpl(
      {required final List<Embedding> data,
      required this.model,
      required this.object,
      @JsonKey(includeIfNull: false) this.usage})
      : _data = data,
        super._();

  factory _$CreateEmbeddingResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateEmbeddingResponseImplFromJson(json);

  /// The list of embeddings generated by the model.
  final List<Embedding> _data;

  /// The list of embeddings generated by the model.
  @override
  List<Embedding> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The name of the model used to generate the embedding.
  @override
  final String model;

  /// The object type, which is always "list".
  @override
  final CreateEmbeddingResponseObject object;

  /// The usage information for the request.
  @override
  @JsonKey(includeIfNull: false)
  final EmbeddingUsage? usage;

  @override
  String toString() {
    return 'CreateEmbeddingResponse(data: $data, model: $model, object: $object, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEmbeddingResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_data), model, object, usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => __$$CreateEmbeddingResponseImplCopyWithImpl<
          _$CreateEmbeddingResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateEmbeddingResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateEmbeddingResponse extends CreateEmbeddingResponse {
  const factory _CreateEmbeddingResponse(
          {required final List<Embedding> data,
          required final String model,
          required final CreateEmbeddingResponseObject object,
          @JsonKey(includeIfNull: false) final EmbeddingUsage? usage}) =
      _$CreateEmbeddingResponseImpl;
  const _CreateEmbeddingResponse._() : super._();

  factory _CreateEmbeddingResponse.fromJson(Map<String, dynamic> json) =
      _$CreateEmbeddingResponseImpl.fromJson;

  @override

  /// The list of embeddings generated by the model.
  List<Embedding> get data;
  @override

  /// The name of the model used to generate the embedding.
  String get model;
  @override

  /// The object type, which is always "list".
  CreateEmbeddingResponseObject get object;
  @override

  /// The usage information for the request.
  @JsonKey(includeIfNull: false)
  EmbeddingUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$CreateEmbeddingResponseImplCopyWith<_$CreateEmbeddingResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Embedding _$EmbeddingFromJson(Map<String, dynamic> json) {
  return _Embedding.fromJson(json);
}

/// @nodoc
mixin _$Embedding {
  /// The index of the embedding in the list of embeddings.
  int get index => throw _privateConstructorUsedError;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding => throw _privateConstructorUsedError;

  /// The object type, which is always "embedding".
  EmbeddingObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingCopyWith<Embedding> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingCopyWith<$Res> {
  factory $EmbeddingCopyWith(Embedding value, $Res Function(Embedding) then) =
      _$EmbeddingCopyWithImpl<$Res, Embedding>;
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class _$EmbeddingCopyWithImpl<$Res, $Val extends Embedding>
    implements $EmbeddingCopyWith<$Res> {
  _$EmbeddingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EmbeddingVectorCopyWith<$Res> get embedding {
    return $EmbeddingVectorCopyWith<$Res>(_value.embedding, (value) {
      return _then(_value.copyWith(embedding: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EmbeddingImplCopyWith<$Res>
    implements $EmbeddingCopyWith<$Res> {
  factory _$$EmbeddingImplCopyWith(
          _$EmbeddingImpl value, $Res Function(_$EmbeddingImpl) then) =
      __$$EmbeddingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @_EmbeddingVectorConverter() EmbeddingVector embedding,
      EmbeddingObject object});

  @override
  $EmbeddingVectorCopyWith<$Res> get embedding;
}

/// @nodoc
class __$$EmbeddingImplCopyWithImpl<$Res>
    extends _$EmbeddingCopyWithImpl<$Res, _$EmbeddingImpl>
    implements _$$EmbeddingImplCopyWith<$Res> {
  __$$EmbeddingImplCopyWithImpl(
      _$EmbeddingImpl _value, $Res Function(_$EmbeddingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? embedding = null,
    Object? object = null,
  }) {
    return _then(_$EmbeddingImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      embedding: null == embedding
          ? _value.embedding
          : embedding // ignore: cast_nullable_to_non_nullable
              as EmbeddingVector,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as EmbeddingObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingImpl extends _Embedding {
  const _$EmbeddingImpl(
      {required this.index,
      @_EmbeddingVectorConverter() required this.embedding,
      required this.object})
      : super._();

  factory _$EmbeddingImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingImplFromJson(json);

  /// The index of the embedding in the list of embeddings.
  @override
  final int index;

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @override
  @_EmbeddingVectorConverter()
  final EmbeddingVector embedding;

  /// The object type, which is always "embedding".
  @override
  final EmbeddingObject object;

  @override
  String toString() {
    return 'Embedding(index: $index, embedding: $embedding, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.embedding, embedding) ||
                other.embedding == embedding) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, embedding, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      __$$EmbeddingImplCopyWithImpl<_$EmbeddingImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingImplToJson(
      this,
    );
  }
}

abstract class _Embedding extends Embedding {
  const factory _Embedding(
      {required final int index,
      @_EmbeddingVectorConverter() required final EmbeddingVector embedding,
      required final EmbeddingObject object}) = _$EmbeddingImpl;
  const _Embedding._() : super._();

  factory _Embedding.fromJson(Map<String, dynamic> json) =
      _$EmbeddingImpl.fromJson;

  @override

  /// The index of the embedding in the list of embeddings.
  int get index;
  @override

  /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).
  @_EmbeddingVectorConverter()
  EmbeddingVector get embedding;
  @override

  /// The object type, which is always "embedding".
  EmbeddingObject get object;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingImplCopyWith<_$EmbeddingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EmbeddingVector _$EmbeddingVectorFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'vector':
      return EmbeddingVectorListDouble.fromJson(json);
    case 'vectorBase64':
      return EmbeddingVectorString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'EmbeddingVector',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EmbeddingVector {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingVectorCopyWith<$Res> {
  factory $EmbeddingVectorCopyWith(
          EmbeddingVector value, $Res Function(EmbeddingVector) then) =
      _$EmbeddingVectorCopyWithImpl<$Res, EmbeddingVector>;
}

/// @nodoc
class _$EmbeddingVectorCopyWithImpl<$Res, $Val extends EmbeddingVector>
    implements $EmbeddingVectorCopyWith<$Res> {
  _$EmbeddingVectorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmbeddingVectorListDoubleImplCopyWith<$Res> {
  factory _$$EmbeddingVectorListDoubleImplCopyWith(
          _$EmbeddingVectorListDoubleImpl value,
          $Res Function(_$EmbeddingVectorListDoubleImpl) then) =
      __$$EmbeddingVectorListDoubleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<double> value});
}

/// @nodoc
class __$$EmbeddingVectorListDoubleImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res, _$EmbeddingVectorListDoubleImpl>
    implements _$$EmbeddingVectorListDoubleImplCopyWith<$Res> {
  __$$EmbeddingVectorListDoubleImplCopyWithImpl(
      _$EmbeddingVectorListDoubleImpl _value,
      $Res Function(_$EmbeddingVectorListDoubleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingVectorListDoubleImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<double>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingVectorListDoubleImpl extends EmbeddingVectorListDouble {
  const _$EmbeddingVectorListDoubleImpl(final List<double> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'vector',
        super._();

  factory _$EmbeddingVectorListDoubleImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingVectorListDoubleImplFromJson(json);

  final List<double> _value;
  @override
  List<double> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.vector(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingVectorListDoubleImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingVectorListDoubleImplCopyWith<_$EmbeddingVectorListDoubleImpl>
      get copyWith => __$$EmbeddingVectorListDoubleImplCopyWithImpl<
          _$EmbeddingVectorListDoubleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) {
    return vector(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) {
    return vector?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vector != null) {
      return vector(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) {
    return vector(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) {
    return vector?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vector != null) {
      return vector(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingVectorListDoubleImplToJson(
      this,
    );
  }
}

abstract class EmbeddingVectorListDouble extends EmbeddingVector {
  const factory EmbeddingVectorListDouble(final List<double> value) =
      _$EmbeddingVectorListDoubleImpl;
  const EmbeddingVectorListDouble._() : super._();

  factory EmbeddingVectorListDouble.fromJson(Map<String, dynamic> json) =
      _$EmbeddingVectorListDoubleImpl.fromJson;

  @override
  List<double> get value;
  @JsonKey(ignore: true)
  _$$EmbeddingVectorListDoubleImplCopyWith<_$EmbeddingVectorListDoubleImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmbeddingVectorStringImplCopyWith<$Res> {
  factory _$$EmbeddingVectorStringImplCopyWith(
          _$EmbeddingVectorStringImpl value,
          $Res Function(_$EmbeddingVectorStringImpl) then) =
      __$$EmbeddingVectorStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$EmbeddingVectorStringImplCopyWithImpl<$Res>
    extends _$EmbeddingVectorCopyWithImpl<$Res, _$EmbeddingVectorStringImpl>
    implements _$$EmbeddingVectorStringImplCopyWith<$Res> {
  __$$EmbeddingVectorStringImplCopyWithImpl(_$EmbeddingVectorStringImpl _value,
      $Res Function(_$EmbeddingVectorStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$EmbeddingVectorStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingVectorStringImpl extends EmbeddingVectorString {
  const _$EmbeddingVectorStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'vectorBase64',
        super._();

  factory _$EmbeddingVectorStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingVectorStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EmbeddingVector.vectorBase64(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingVectorStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingVectorStringImplCopyWith<_$EmbeddingVectorStringImpl>
      get copyWith => __$$EmbeddingVectorStringImplCopyWithImpl<
          _$EmbeddingVectorStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<double> value) vector,
    required TResult Function(String value) vectorBase64,
  }) {
    return vectorBase64(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<double> value)? vector,
    TResult? Function(String value)? vectorBase64,
  }) {
    return vectorBase64?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<double> value)? vector,
    TResult Function(String value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vectorBase64 != null) {
      return vectorBase64(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmbeddingVectorListDouble value) vector,
    required TResult Function(EmbeddingVectorString value) vectorBase64,
  }) {
    return vectorBase64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmbeddingVectorListDouble value)? vector,
    TResult? Function(EmbeddingVectorString value)? vectorBase64,
  }) {
    return vectorBase64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmbeddingVectorListDouble value)? vector,
    TResult Function(EmbeddingVectorString value)? vectorBase64,
    required TResult orElse(),
  }) {
    if (vectorBase64 != null) {
      return vectorBase64(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingVectorStringImplToJson(
      this,
    );
  }
}

abstract class EmbeddingVectorString extends EmbeddingVector {
  const factory EmbeddingVectorString(final String value) =
      _$EmbeddingVectorStringImpl;
  const EmbeddingVectorString._() : super._();

  factory EmbeddingVectorString.fromJson(Map<String, dynamic> json) =
      _$EmbeddingVectorStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$EmbeddingVectorStringImplCopyWith<_$EmbeddingVectorStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EmbeddingUsage _$EmbeddingUsageFromJson(Map<String, dynamic> json) {
  return _EmbeddingUsage.fromJson(json);
}

/// @nodoc
mixin _$EmbeddingUsage {
  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmbeddingUsageCopyWith<EmbeddingUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbeddingUsageCopyWith<$Res> {
  factory $EmbeddingUsageCopyWith(
          EmbeddingUsage value, $Res Function(EmbeddingUsage) then) =
      _$EmbeddingUsageCopyWithImpl<$Res, EmbeddingUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$EmbeddingUsageCopyWithImpl<$Res, $Val extends EmbeddingUsage>
    implements $EmbeddingUsageCopyWith<$Res> {
  _$EmbeddingUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EmbeddingUsageImplCopyWith<$Res>
    implements $EmbeddingUsageCopyWith<$Res> {
  factory _$$EmbeddingUsageImplCopyWith(_$EmbeddingUsageImpl value,
          $Res Function(_$EmbeddingUsageImpl) then) =
      __$$EmbeddingUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$EmbeddingUsageImplCopyWithImpl<$Res>
    extends _$EmbeddingUsageCopyWithImpl<$Res, _$EmbeddingUsageImpl>
    implements _$$EmbeddingUsageImplCopyWith<$Res> {
  __$$EmbeddingUsageImplCopyWithImpl(
      _$EmbeddingUsageImpl _value, $Res Function(_$EmbeddingUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$EmbeddingUsageImpl(
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EmbeddingUsageImpl extends _EmbeddingUsage {
  const _$EmbeddingUsageImpl(
      {@JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$EmbeddingUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$EmbeddingUsageImplFromJson(json);

  /// The number of tokens used by the prompt.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// The total number of tokens used by the request.
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'EmbeddingUsage(promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmbeddingUsageImpl &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      __$$EmbeddingUsageImplCopyWithImpl<_$EmbeddingUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EmbeddingUsageImplToJson(
      this,
    );
  }
}

abstract class _EmbeddingUsage extends EmbeddingUsage {
  const factory _EmbeddingUsage(
          {@JsonKey(name: 'prompt_tokens') required final int promptTokens,
          @JsonKey(name: 'total_tokens') required final int totalTokens}) =
      _$EmbeddingUsageImpl;
  const _EmbeddingUsage._() : super._();

  factory _EmbeddingUsage.fromJson(Map<String, dynamic> json) =
      _$EmbeddingUsageImpl.fromJson;

  @override

  /// The number of tokens used by the prompt.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// The total number of tokens used by the request.
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$EmbeddingUsageImplCopyWith<_$EmbeddingUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateFineTuningJobRequest _$CreateFineTuningJobRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateFineTuningJobRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateFineTuningJobRequest {
  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose
  /// `fine-tune`.
  ///
  /// The contents of the file should differ depending on if the model uses the
  /// [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
  /// [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input) format.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters =>
      throw _privateConstructorUsedError;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix => throw _privateConstructorUsedError;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile => throw _privateConstructorUsedError;

  /// A list of integrations to enable for your fine-tuning job.
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations =>
      throw _privateConstructorUsedError;

  /// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
  /// If a seed is not specified, one will be generated for you.
  @JsonKey(includeIfNull: false)
  int? get seed => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateFineTuningJobRequestCopyWith<CreateFineTuningJobRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateFineTuningJobRequestCopyWith<$Res> {
  factory $CreateFineTuningJobRequestCopyWith(CreateFineTuningJobRequest value,
          $Res Function(CreateFineTuningJobRequest) then) =
      _$CreateFineTuningJobRequestCopyWithImpl<$Res,
          CreateFineTuningJobRequest>;
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile,
      @JsonKey(includeIfNull: false) List<FineTuningIntegration>? integrations,
      @JsonKey(includeIfNull: false) int? seed});

  $FineTuningModelCopyWith<$Res> get model;
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        $Val extends CreateFineTuningJobRequest>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  _$CreateFineTuningJobRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
    Object? integrations = freezed,
    Object? seed = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _value.integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningModelCopyWith<$Res> get model {
    return $FineTuningModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters {
    if (_value.hyperparameters == null) {
      return null;
    }

    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters!,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateFineTuningJobRequestImplCopyWith<$Res>
    implements $CreateFineTuningJobRequestCopyWith<$Res> {
  factory _$$CreateFineTuningJobRequestImplCopyWith(
          _$CreateFineTuningJobRequestImpl value,
          $Res Function(_$CreateFineTuningJobRequestImpl) then) =
      __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningModelConverter() FineTuningModel model,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(includeIfNull: false)
      FineTuningJobHyperparameters? hyperparameters,
      @JsonKey(includeIfNull: false) String? suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      String? validationFile,
      @JsonKey(includeIfNull: false) List<FineTuningIntegration>? integrations,
      @JsonKey(includeIfNull: false) int? seed});

  @override
  $FineTuningModelCopyWith<$Res> get model;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res>? get hyperparameters;
}

/// @nodoc
class __$$CreateFineTuningJobRequestImplCopyWithImpl<$Res>
    extends _$CreateFineTuningJobRequestCopyWithImpl<$Res,
        _$CreateFineTuningJobRequestImpl>
    implements _$$CreateFineTuningJobRequestImplCopyWith<$Res> {
  __$$CreateFineTuningJobRequestImplCopyWithImpl(
      _$CreateFineTuningJobRequestImpl _value,
      $Res Function(_$CreateFineTuningJobRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? trainingFile = null,
    Object? hyperparameters = freezed,
    Object? suffix = freezed,
    Object? validationFile = freezed,
    Object? integrations = freezed,
    Object? seed = freezed,
  }) {
    return _then(_$CreateFineTuningJobRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FineTuningModel,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      hyperparameters: freezed == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters?,
      suffix: freezed == suffix
          ? _value.suffix
          : suffix // ignore: cast_nullable_to_non_nullable
              as String?,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _value._integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateFineTuningJobRequestImpl extends _CreateFineTuningJobRequest {
  const _$CreateFineTuningJobRequestImpl(
      {@_FineTuningModelConverter() required this.model,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(includeIfNull: false) this.hyperparameters,
      @JsonKey(includeIfNull: false) this.suffix,
      @JsonKey(name: 'validation_file', includeIfNull: false)
      this.validationFile,
      @JsonKey(includeIfNull: false)
      final List<FineTuningIntegration>? integrations,
      @JsonKey(includeIfNull: false) this.seed})
      : _integrations = integrations,
        super._();

  factory _$CreateFineTuningJobRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateFineTuningJobRequestImplFromJson(json);

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @override
  @_FineTuningModelConverter()
  final FineTuningModel model;

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose
  /// `fine-tune`.
  ///
  /// The contents of the file should differ depending on if the model uses the
  /// [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
  /// [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input) format.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(includeIfNull: false)
  final FineTuningJobHyperparameters? hyperparameters;

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @override
  @JsonKey(includeIfNull: false)
  final String? suffix;

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  @JsonKey(name: 'validation_file', includeIfNull: false)
  final String? validationFile;

  /// A list of integrations to enable for your fine-tuning job.
  final List<FineTuningIntegration>? _integrations;

  /// A list of integrations to enable for your fine-tuning job.
  @override
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations {
    final value = _integrations;
    if (value == null) return null;
    if (_integrations is EqualUnmodifiableListView) return _integrations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
  /// If a seed is not specified, one will be generated for you.
  @override
  @JsonKey(includeIfNull: false)
  final int? seed;

  @override
  String toString() {
    return 'CreateFineTuningJobRequest(model: $model, trainingFile: $trainingFile, hyperparameters: $hyperparameters, suffix: $suffix, validationFile: $validationFile, integrations: $integrations, seed: $seed)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateFineTuningJobRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.suffix, suffix) || other.suffix == suffix) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile) &&
            const DeepCollectionEquality()
                .equals(other._integrations, _integrations) &&
            (identical(other.seed, seed) || other.seed == seed));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      trainingFile,
      hyperparameters,
      suffix,
      validationFile,
      const DeepCollectionEquality().hash(_integrations),
      seed);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => __$$CreateFineTuningJobRequestImplCopyWithImpl<
          _$CreateFineTuningJobRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateFineTuningJobRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateFineTuningJobRequest extends CreateFineTuningJobRequest {
  const factory _CreateFineTuningJobRequest(
          {@_FineTuningModelConverter() required final FineTuningModel model,
          @JsonKey(name: 'training_file') required final String trainingFile,
          @JsonKey(includeIfNull: false)
          final FineTuningJobHyperparameters? hyperparameters,
          @JsonKey(includeIfNull: false) final String? suffix,
          @JsonKey(name: 'validation_file', includeIfNull: false)
          final String? validationFile,
          @JsonKey(includeIfNull: false)
          final List<FineTuningIntegration>? integrations,
          @JsonKey(includeIfNull: false) final int? seed}) =
      _$CreateFineTuningJobRequestImpl;
  const _CreateFineTuningJobRequest._() : super._();

  factory _CreateFineTuningJobRequest.fromJson(Map<String, dynamic> json) =
      _$CreateFineTuningJobRequestImpl.fromJson;

  @override

  /// The name of the model to fine-tune. You can select one of the
  /// [supported models](https://platform.openai.com/docs/guides/fine-tuning/what-models-can-be-fine-tuned).
  @_FineTuningModelConverter()
  FineTuningModel get model;
  @override

  /// The ID of an uploaded file that contains training data.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose
  /// `fine-tune`.
  ///
  /// The contents of the file should differ depending on if the model uses the
  /// [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
  /// [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input) format.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(includeIfNull: false)
  FineTuningJobHyperparameters? get hyperparameters;
  @override

  /// A string of up to 18 characters that will be added to your fine-tuned model name.
  ///
  /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`.
  @JsonKey(includeIfNull: false)
  String? get suffix;
  @override

  /// The ID of an uploaded file that contains validation data.
  ///
  /// If you provide this file, the data is used to generate validation
  /// metrics periodically during fine-tuning. These metrics can be viewed in
  /// the fine-tuning results file.
  /// The same data should not be present in both train and validation files.
  ///
  /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
  ///
  /// See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @JsonKey(name: 'validation_file', includeIfNull: false)
  String? get validationFile;
  @override

  /// A list of integrations to enable for your fine-tuning job.
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations;
  @override

  /// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
  /// If a seed is not specified, one will be generated for you.
  @JsonKey(includeIfNull: false)
  int? get seed;
  @override
  @JsonKey(ignore: true)
  _$$CreateFineTuningJobRequestImplCopyWith<_$CreateFineTuningJobRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningModel _$FineTuningModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return FineTuningModelEnumeration.fromJson(json);
    case 'modelId':
      return FineTuningModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningModelCopyWith<$Res> {
  factory $FineTuningModelCopyWith(
          FineTuningModel value, $Res Function(FineTuningModel) then) =
      _$FineTuningModelCopyWithImpl<$Res, FineTuningModel>;
}

/// @nodoc
class _$FineTuningModelCopyWithImpl<$Res, $Val extends FineTuningModel>
    implements $FineTuningModelCopyWith<$Res> {
  _$FineTuningModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FineTuningModelEnumerationImplCopyWith<$Res> {
  factory _$$FineTuningModelEnumerationImplCopyWith(
          _$FineTuningModelEnumerationImpl value,
          $Res Function(_$FineTuningModelEnumerationImpl) then) =
      __$$FineTuningModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningModels value});
}

/// @nodoc
class __$$FineTuningModelEnumerationImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res,
        _$FineTuningModelEnumerationImpl>
    implements _$$FineTuningModelEnumerationImplCopyWith<$Res> {
  __$$FineTuningModelEnumerationImplCopyWithImpl(
      _$FineTuningModelEnumerationImpl _value,
      $Res Function(_$FineTuningModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningModelEnumerationImpl extends FineTuningModelEnumeration {
  const _$FineTuningModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$FineTuningModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningModelEnumerationImplFromJson(json);

  @override
  final FineTuningModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningModelEnumerationImplCopyWith<_$FineTuningModelEnumerationImpl>
      get copyWith => __$$FineTuningModelEnumerationImplCopyWithImpl<
          _$FineTuningModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class FineTuningModelEnumeration extends FineTuningModel {
  const factory FineTuningModelEnumeration(final FineTuningModels value) =
      _$FineTuningModelEnumerationImpl;
  const FineTuningModelEnumeration._() : super._();

  factory FineTuningModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$FineTuningModelEnumerationImpl.fromJson;

  @override
  FineTuningModels get value;
  @JsonKey(ignore: true)
  _$$FineTuningModelEnumerationImplCopyWith<_$FineTuningModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FineTuningModelStringImplCopyWith<$Res> {
  factory _$$FineTuningModelStringImplCopyWith(
          _$FineTuningModelStringImpl value,
          $Res Function(_$FineTuningModelStringImpl) then) =
      __$$FineTuningModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$FineTuningModelStringImplCopyWithImpl<$Res>
    extends _$FineTuningModelCopyWithImpl<$Res, _$FineTuningModelStringImpl>
    implements _$$FineTuningModelStringImplCopyWith<$Res> {
  __$$FineTuningModelStringImplCopyWithImpl(_$FineTuningModelStringImpl _value,
      $Res Function(_$FineTuningModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningModelStringImpl extends FineTuningModelString {
  const _$FineTuningModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$FineTuningModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningModelStringImplCopyWith<_$FineTuningModelStringImpl>
      get copyWith => __$$FineTuningModelStringImplCopyWithImpl<
          _$FineTuningModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningModelEnumeration value) model,
    required TResult Function(FineTuningModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningModelEnumeration value)? model,
    TResult? Function(FineTuningModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningModelEnumeration value)? model,
    TResult Function(FineTuningModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningModelStringImplToJson(
      this,
    );
  }
}

abstract class FineTuningModelString extends FineTuningModel {
  const factory FineTuningModelString(final String value) =
      _$FineTuningModelStringImpl;
  const FineTuningModelString._() : super._();

  factory FineTuningModelString.fromJson(Map<String, dynamic> json) =
      _$FineTuningModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$FineTuningModelStringImplCopyWith<_$FineTuningModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJob _$FineTuningJobFromJson(Map<String, dynamic> json) {
  return _FineTuningJob.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJob {
  /// The object identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error => throw _privateConstructorUsedError;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt => throw _privateConstructorUsedError;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters =>
      throw _privateConstructorUsedError;

  /// The base model that is being fine-tuned.
  String get model => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job".
  FineTuningJobObject get object => throw _privateConstructorUsedError;

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId => throw _privateConstructorUsedError;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles => throw _privateConstructorUsedError;

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status => throw _privateConstructorUsedError;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens => throw _privateConstructorUsedError;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile => throw _privateConstructorUsedError;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile => throw _privateConstructorUsedError;

  /// A list of integrations to enable for this fine-tuning job.
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobCopyWith<FineTuningJob> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobCopyWith<$Res> {
  factory $FineTuningJobCopyWith(
          FineTuningJob value, $Res Function(FineTuningJob) then) =
      _$FineTuningJobCopyWithImpl<$Res, FineTuningJob>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile,
      @JsonKey(includeIfNull: false)
      List<FineTuningIntegration>? integrations});

  $FineTuningJobErrorCopyWith<$Res>? get error;
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class _$FineTuningJobCopyWithImpl<$Res, $Val extends FineTuningJob>
    implements $FineTuningJobCopyWith<$Res> {
  _$FineTuningJobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
    Object? integrations = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value.resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _value.integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobErrorCopyWith<$Res>? get error {
    if (_value.error == null) {
      return null;
    }

    return $FineTuningJobErrorCopyWith<$Res>(_value.error!, (value) {
      return _then(_value.copyWith(error: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters {
    return $FineTuningJobHyperparametersCopyWith<$Res>(_value.hyperparameters,
        (value) {
      return _then(_value.copyWith(hyperparameters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobImplCopyWith<$Res>
    implements $FineTuningJobCopyWith<$Res> {
  factory _$$FineTuningJobImplCopyWith(
          _$FineTuningJobImpl value, $Res Function(_$FineTuningJobImpl) then) =
      __$$FineTuningJobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') String? fineTunedModel,
      @JsonKey(name: 'finished_at') int? finishedAt,
      FineTuningJobHyperparameters hyperparameters,
      String model,
      FineTuningJobObject object,
      @JsonKey(name: 'organization_id') String organizationId,
      @JsonKey(name: 'result_files') List<String> resultFiles,
      FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') int? trainedTokens,
      @JsonKey(name: 'training_file') String trainingFile,
      @JsonKey(name: 'validation_file') String? validationFile,
      @JsonKey(includeIfNull: false)
      List<FineTuningIntegration>? integrations});

  @override
  $FineTuningJobErrorCopyWith<$Res>? get error;
  @override
  $FineTuningJobHyperparametersCopyWith<$Res> get hyperparameters;
}

/// @nodoc
class __$$FineTuningJobImplCopyWithImpl<$Res>
    extends _$FineTuningJobCopyWithImpl<$Res, _$FineTuningJobImpl>
    implements _$$FineTuningJobImplCopyWith<$Res> {
  __$$FineTuningJobImplCopyWithImpl(
      _$FineTuningJobImpl _value, $Res Function(_$FineTuningJobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? error = freezed,
    Object? fineTunedModel = freezed,
    Object? finishedAt = freezed,
    Object? hyperparameters = null,
    Object? model = null,
    Object? object = null,
    Object? organizationId = null,
    Object? resultFiles = null,
    Object? status = null,
    Object? trainedTokens = freezed,
    Object? trainingFile = null,
    Object? validationFile = freezed,
    Object? integrations = freezed,
  }) {
    return _then(_$FineTuningJobImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as FineTuningJobError?,
      fineTunedModel: freezed == fineTunedModel
          ? _value.fineTunedModel
          : fineTunedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      finishedAt: freezed == finishedAt
          ? _value.finishedAt
          : finishedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      hyperparameters: null == hyperparameters
          ? _value.hyperparameters
          : hyperparameters // ignore: cast_nullable_to_non_nullable
              as FineTuningJobHyperparameters,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobObject,
      organizationId: null == organizationId
          ? _value.organizationId
          : organizationId // ignore: cast_nullable_to_non_nullable
              as String,
      resultFiles: null == resultFiles
          ? _value._resultFiles
          : resultFiles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FineTuningJobStatus,
      trainedTokens: freezed == trainedTokens
          ? _value.trainedTokens
          : trainedTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      trainingFile: null == trainingFile
          ? _value.trainingFile
          : trainingFile // ignore: cast_nullable_to_non_nullable
              as String,
      validationFile: freezed == validationFile
          ? _value.validationFile
          : validationFile // ignore: cast_nullable_to_non_nullable
              as String?,
      integrations: freezed == integrations
          ? _value._integrations
          : integrations // ignore: cast_nullable_to_non_nullable
              as List<FineTuningIntegration>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobImpl extends _FineTuningJob {
  const _$FineTuningJobImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.error,
      @JsonKey(name: 'fine_tuned_model') required this.fineTunedModel,
      @JsonKey(name: 'finished_at') required this.finishedAt,
      required this.hyperparameters,
      required this.model,
      required this.object,
      @JsonKey(name: 'organization_id') required this.organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required this.status,
      @JsonKey(name: 'trained_tokens') required this.trainedTokens,
      @JsonKey(name: 'training_file') required this.trainingFile,
      @JsonKey(name: 'validation_file') required this.validationFile,
      @JsonKey(includeIfNull: false)
      final List<FineTuningIntegration>? integrations})
      : _resultFiles = resultFiles,
        _integrations = integrations,
        super._();

  factory _$FineTuningJobImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobImplFromJson(json);

  /// The object identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  @override
  final FineTuningJobError? error;

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'fine_tuned_model')
  final String? fineTunedModel;

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'finished_at')
  final int? finishedAt;

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  @override
  final FineTuningJobHyperparameters hyperparameters;

  /// The base model that is being fine-tuned.
  @override
  final String model;

  /// The object type, which is always "fine_tuning.job".
  @override
  final FineTuningJobObject object;

  /// The organization that owns the fine-tuning job.
  @override
  @JsonKey(name: 'organization_id')
  final String organizationId;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  final List<String> _resultFiles;

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'result_files')
  List<String> get resultFiles {
    if (_resultFiles is EqualUnmodifiableListView) return _resultFiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_resultFiles);
  }

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  @override
  final FineTuningJobStatus status;

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @override
  @JsonKey(name: 'trained_tokens')
  final int? trainedTokens;

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'training_file')
  final String trainingFile;

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @override
  @JsonKey(name: 'validation_file')
  final String? validationFile;

  /// A list of integrations to enable for this fine-tuning job.
  final List<FineTuningIntegration>? _integrations;

  /// A list of integrations to enable for this fine-tuning job.
  @override
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations {
    final value = _integrations;
    if (value == null) return null;
    if (_integrations is EqualUnmodifiableListView) return _integrations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'FineTuningJob(id: $id, createdAt: $createdAt, error: $error, fineTunedModel: $fineTunedModel, finishedAt: $finishedAt, hyperparameters: $hyperparameters, model: $model, object: $object, organizationId: $organizationId, resultFiles: $resultFiles, status: $status, trainedTokens: $trainedTokens, trainingFile: $trainingFile, validationFile: $validationFile, integrations: $integrations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.fineTunedModel, fineTunedModel) ||
                other.fineTunedModel == fineTunedModel) &&
            (identical(other.finishedAt, finishedAt) ||
                other.finishedAt == finishedAt) &&
            (identical(other.hyperparameters, hyperparameters) ||
                other.hyperparameters == hyperparameters) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.organizationId, organizationId) ||
                other.organizationId == organizationId) &&
            const DeepCollectionEquality()
                .equals(other._resultFiles, _resultFiles) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.trainedTokens, trainedTokens) ||
                other.trainedTokens == trainedTokens) &&
            (identical(other.trainingFile, trainingFile) ||
                other.trainingFile == trainingFile) &&
            (identical(other.validationFile, validationFile) ||
                other.validationFile == validationFile) &&
            const DeepCollectionEquality()
                .equals(other._integrations, _integrations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      createdAt,
      error,
      fineTunedModel,
      finishedAt,
      hyperparameters,
      model,
      object,
      organizationId,
      const DeepCollectionEquality().hash(_resultFiles),
      status,
      trainedTokens,
      trainingFile,
      validationFile,
      const DeepCollectionEquality().hash(_integrations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      __$$FineTuningJobImplCopyWithImpl<_$FineTuningJobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJob extends FineTuningJob {
  const factory _FineTuningJob(
      {required final String id,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final FineTuningJobError? error,
      @JsonKey(name: 'fine_tuned_model') required final String? fineTunedModel,
      @JsonKey(name: 'finished_at') required final int? finishedAt,
      required final FineTuningJobHyperparameters hyperparameters,
      required final String model,
      required final FineTuningJobObject object,
      @JsonKey(name: 'organization_id') required final String organizationId,
      @JsonKey(name: 'result_files') required final List<String> resultFiles,
      required final FineTuningJobStatus status,
      @JsonKey(name: 'trained_tokens') required final int? trainedTokens,
      @JsonKey(name: 'training_file') required final String trainingFile,
      @JsonKey(name: 'validation_file') required final String? validationFile,
      @JsonKey(includeIfNull: false)
      final List<FineTuningIntegration>? integrations}) = _$FineTuningJobImpl;
  const _FineTuningJob._() : super._();

  factory _FineTuningJob.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobImpl.fromJson;

  @override

  /// The object identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
  FineTuningJobError? get error;
  @override

  /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'fine_tuned_model')
  String? get fineTunedModel;
  @override

  /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'finished_at')
  int? get finishedAt;
  @override

  /// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.
  FineTuningJobHyperparameters get hyperparameters;
  @override

  /// The base model that is being fine-tuned.
  String get model;
  @override

  /// The object type, which is always "fine_tuning.job".
  FineTuningJobObject get object;
  @override

  /// The organization that owns the fine-tuning job.
  @JsonKey(name: 'organization_id')
  String get organizationId;
  @override

  /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'result_files')
  List<String> get resultFiles;
  @override

  /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  FineTuningJobStatus get status;
  @override

  /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  @JsonKey(name: 'trained_tokens')
  int? get trainedTokens;
  @override

  /// The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'training_file')
  String get trainingFile;
  @override

  /// The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).
  @JsonKey(name: 'validation_file')
  String? get validationFile;
  @override

  /// A list of integrations to enable for this fine-tuning job.
  @JsonKey(includeIfNull: false)
  List<FineTuningIntegration>? get integrations;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobImplCopyWith<_$FineTuningJobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningIntegration _$FineTuningIntegrationFromJson(
    Map<String, dynamic> json) {
  return _FineTuningIntegration.fromJson(json);
}

/// @nodoc
mixin _$FineTuningIntegration {
  /// The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
  FineTuningIntegrationType get type => throw _privateConstructorUsedError;

  /// The settings for your integration with Weights and Biases. This payload specifies the project that
  /// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
  /// to your run, and set a default entity (team, username, etc) to be associated with your run.
  FineTuningIntegrationWandb get wandb => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningIntegrationCopyWith<FineTuningIntegration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningIntegrationCopyWith<$Res> {
  factory $FineTuningIntegrationCopyWith(FineTuningIntegration value,
          $Res Function(FineTuningIntegration) then) =
      _$FineTuningIntegrationCopyWithImpl<$Res, FineTuningIntegration>;
  @useResult
  $Res call({FineTuningIntegrationType type, FineTuningIntegrationWandb wandb});

  $FineTuningIntegrationWandbCopyWith<$Res> get wandb;
}

/// @nodoc
class _$FineTuningIntegrationCopyWithImpl<$Res,
        $Val extends FineTuningIntegration>
    implements $FineTuningIntegrationCopyWith<$Res> {
  _$FineTuningIntegrationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? wandb = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationType,
      wandb: null == wandb
          ? _value.wandb
          : wandb // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationWandb,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningIntegrationWandbCopyWith<$Res> get wandb {
    return $FineTuningIntegrationWandbCopyWith<$Res>(_value.wandb, (value) {
      return _then(_value.copyWith(wandb: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningIntegrationImplCopyWith<$Res>
    implements $FineTuningIntegrationCopyWith<$Res> {
  factory _$$FineTuningIntegrationImplCopyWith(
          _$FineTuningIntegrationImpl value,
          $Res Function(_$FineTuningIntegrationImpl) then) =
      __$$FineTuningIntegrationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({FineTuningIntegrationType type, FineTuningIntegrationWandb wandb});

  @override
  $FineTuningIntegrationWandbCopyWith<$Res> get wandb;
}

/// @nodoc
class __$$FineTuningIntegrationImplCopyWithImpl<$Res>
    extends _$FineTuningIntegrationCopyWithImpl<$Res,
        _$FineTuningIntegrationImpl>
    implements _$$FineTuningIntegrationImplCopyWith<$Res> {
  __$$FineTuningIntegrationImplCopyWithImpl(_$FineTuningIntegrationImpl _value,
      $Res Function(_$FineTuningIntegrationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? wandb = null,
  }) {
    return _then(_$FineTuningIntegrationImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationType,
      wandb: null == wandb
          ? _value.wandb
          : wandb // ignore: cast_nullable_to_non_nullable
              as FineTuningIntegrationWandb,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningIntegrationImpl extends _FineTuningIntegration {
  const _$FineTuningIntegrationImpl({required this.type, required this.wandb})
      : super._();

  factory _$FineTuningIntegrationImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningIntegrationImplFromJson(json);

  /// The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
  @override
  final FineTuningIntegrationType type;

  /// The settings for your integration with Weights and Biases. This payload specifies the project that
  /// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
  /// to your run, and set a default entity (team, username, etc) to be associated with your run.
  @override
  final FineTuningIntegrationWandb wandb;

  @override
  String toString() {
    return 'FineTuningIntegration(type: $type, wandb: $wandb)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningIntegrationImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.wandb, wandb) || other.wandb == wandb));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, wandb);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningIntegrationImplCopyWith<_$FineTuningIntegrationImpl>
      get copyWith => __$$FineTuningIntegrationImplCopyWithImpl<
          _$FineTuningIntegrationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningIntegrationImplToJson(
      this,
    );
  }
}

abstract class _FineTuningIntegration extends FineTuningIntegration {
  const factory _FineTuningIntegration(
          {required final FineTuningIntegrationType type,
          required final FineTuningIntegrationWandb wandb}) =
      _$FineTuningIntegrationImpl;
  const _FineTuningIntegration._() : super._();

  factory _FineTuningIntegration.fromJson(Map<String, dynamic> json) =
      _$FineTuningIntegrationImpl.fromJson;

  @override

  /// The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
  FineTuningIntegrationType get type;
  @override

  /// The settings for your integration with Weights and Biases. This payload specifies the project that
  /// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
  /// to your run, and set a default entity (team, username, etc) to be associated with your run.
  FineTuningIntegrationWandb get wandb;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningIntegrationImplCopyWith<_$FineTuningIntegrationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningIntegrationWandb _$FineTuningIntegrationWandbFromJson(
    Map<String, dynamic> json) {
  return _FineTuningIntegrationWandb.fromJson(json);
}

/// @nodoc
mixin _$FineTuningIntegrationWandb {
  /// The name of the project that the new run will be created under.
  String get project => throw _privateConstructorUsedError;

  /// A display name to set for the run. If not set, we will use the Job ID as the name.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The entity to use for the run. This allows you to set the team or username of the WandB user that you would
  /// like associated with the run. If not set, the default entity for the registered WandB API key is used.
  @JsonKey(includeIfNull: false)
  String? get entity => throw _privateConstructorUsedError;

  /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
  /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
  @JsonKey(includeIfNull: false)
  List<String>? get tags => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningIntegrationWandbCopyWith<FineTuningIntegrationWandb>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningIntegrationWandbCopyWith<$Res> {
  factory $FineTuningIntegrationWandbCopyWith(FineTuningIntegrationWandb value,
          $Res Function(FineTuningIntegrationWandb) then) =
      _$FineTuningIntegrationWandbCopyWithImpl<$Res,
          FineTuningIntegrationWandb>;
  @useResult
  $Res call(
      {String project,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? entity,
      @JsonKey(includeIfNull: false) List<String>? tags});
}

/// @nodoc
class _$FineTuningIntegrationWandbCopyWithImpl<$Res,
        $Val extends FineTuningIntegrationWandb>
    implements $FineTuningIntegrationWandbCopyWith<$Res> {
  _$FineTuningIntegrationWandbCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? project = null,
    Object? name = freezed,
    Object? entity = freezed,
    Object? tags = freezed,
  }) {
    return _then(_value.copyWith(
      project: null == project
          ? _value.project
          : project // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      entity: freezed == entity
          ? _value.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningIntegrationWandbImplCopyWith<$Res>
    implements $FineTuningIntegrationWandbCopyWith<$Res> {
  factory _$$FineTuningIntegrationWandbImplCopyWith(
          _$FineTuningIntegrationWandbImpl value,
          $Res Function(_$FineTuningIntegrationWandbImpl) then) =
      __$$FineTuningIntegrationWandbImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String project,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? entity,
      @JsonKey(includeIfNull: false) List<String>? tags});
}

/// @nodoc
class __$$FineTuningIntegrationWandbImplCopyWithImpl<$Res>
    extends _$FineTuningIntegrationWandbCopyWithImpl<$Res,
        _$FineTuningIntegrationWandbImpl>
    implements _$$FineTuningIntegrationWandbImplCopyWith<$Res> {
  __$$FineTuningIntegrationWandbImplCopyWithImpl(
      _$FineTuningIntegrationWandbImpl _value,
      $Res Function(_$FineTuningIntegrationWandbImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? project = null,
    Object? name = freezed,
    Object? entity = freezed,
    Object? tags = freezed,
  }) {
    return _then(_$FineTuningIntegrationWandbImpl(
      project: null == project
          ? _value.project
          : project // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      entity: freezed == entity
          ? _value.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningIntegrationWandbImpl extends _FineTuningIntegrationWandb {
  const _$FineTuningIntegrationWandbImpl(
      {required this.project,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.entity,
      @JsonKey(includeIfNull: false) final List<String>? tags})
      : _tags = tags,
        super._();

  factory _$FineTuningIntegrationWandbImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningIntegrationWandbImplFromJson(json);

  /// The name of the project that the new run will be created under.
  @override
  final String project;

  /// A display name to set for the run. If not set, we will use the Job ID as the name.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The entity to use for the run. This allows you to set the team or username of the WandB user that you would
  /// like associated with the run. If not set, the default entity for the registered WandB API key is used.
  @override
  @JsonKey(includeIfNull: false)
  final String? entity;

  /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
  /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
  final List<String>? _tags;

  /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
  /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
  @override
  @JsonKey(includeIfNull: false)
  List<String>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'FineTuningIntegrationWandb(project: $project, name: $name, entity: $entity, tags: $tags)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningIntegrationWandbImpl &&
            (identical(other.project, project) || other.project == project) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.entity, entity) || other.entity == entity) &&
            const DeepCollectionEquality().equals(other._tags, _tags));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, project, name, entity,
      const DeepCollectionEquality().hash(_tags));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningIntegrationWandbImplCopyWith<_$FineTuningIntegrationWandbImpl>
      get copyWith => __$$FineTuningIntegrationWandbImplCopyWithImpl<
          _$FineTuningIntegrationWandbImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningIntegrationWandbImplToJson(
      this,
    );
  }
}

abstract class _FineTuningIntegrationWandb extends FineTuningIntegrationWandb {
  const factory _FineTuningIntegrationWandb(
          {required final String project,
          @JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? entity,
          @JsonKey(includeIfNull: false) final List<String>? tags}) =
      _$FineTuningIntegrationWandbImpl;
  const _FineTuningIntegrationWandb._() : super._();

  factory _FineTuningIntegrationWandb.fromJson(Map<String, dynamic> json) =
      _$FineTuningIntegrationWandbImpl.fromJson;

  @override

  /// The name of the project that the new run will be created under.
  String get project;
  @override

  /// A display name to set for the run. If not set, we will use the Job ID as the name.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The entity to use for the run. This allows you to set the team or username of the WandB user that you would
  /// like associated with the run. If not set, the default entity for the registered WandB API key is used.
  @JsonKey(includeIfNull: false)
  String? get entity;
  @override

  /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
  /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
  @JsonKey(includeIfNull: false)
  List<String>? get tags;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningIntegrationWandbImplCopyWith<_$FineTuningIntegrationWandbImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJobError _$FineTuningJobErrorFromJson(Map<String, dynamic> json) {
  return _FineTuningJobError.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobError {
  /// A machine-readable error code.
  String get code => throw _privateConstructorUsedError;

  /// A human-readable error message.
  String get message => throw _privateConstructorUsedError;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobErrorCopyWith<FineTuningJobError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobErrorCopyWith<$Res> {
  factory $FineTuningJobErrorCopyWith(
          FineTuningJobError value, $Res Function(FineTuningJobError) then) =
      _$FineTuningJobErrorCopyWithImpl<$Res, FineTuningJobError>;
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class _$FineTuningJobErrorCopyWithImpl<$Res, $Val extends FineTuningJobError>
    implements $FineTuningJobErrorCopyWith<$Res> {
  _$FineTuningJobErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobErrorImplCopyWith<$Res>
    implements $FineTuningJobErrorCopyWith<$Res> {
  factory _$$FineTuningJobErrorImplCopyWith(_$FineTuningJobErrorImpl value,
          $Res Function(_$FineTuningJobErrorImpl) then) =
      __$$FineTuningJobErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String code, String message, String? param});
}

/// @nodoc
class __$$FineTuningJobErrorImplCopyWithImpl<$Res>
    extends _$FineTuningJobErrorCopyWithImpl<$Res, _$FineTuningJobErrorImpl>
    implements _$$FineTuningJobErrorImplCopyWith<$Res> {
  __$$FineTuningJobErrorImplCopyWithImpl(_$FineTuningJobErrorImpl _value,
      $Res Function(_$FineTuningJobErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
    Object? param = freezed,
  }) {
    return _then(_$FineTuningJobErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobErrorImpl extends _FineTuningJobError {
  const _$FineTuningJobErrorImpl(
      {required this.code, required this.message, required this.param})
      : super._();

  factory _$FineTuningJobErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobErrorImplFromJson(json);

  /// A machine-readable error code.
  @override
  final String code;

  /// A human-readable error message.
  @override
  final String message;

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  @override
  final String? param;

  @override
  String toString() {
    return 'FineTuningJobError(code: $code, message: $message, param: $param)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      __$$FineTuningJobErrorImplCopyWithImpl<_$FineTuningJobErrorImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobErrorImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobError extends FineTuningJobError {
  const factory _FineTuningJobError(
      {required final String code,
      required final String message,
      required final String? param}) = _$FineTuningJobErrorImpl;
  const _FineTuningJobError._() : super._();

  factory _FineTuningJobError.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobErrorImpl.fromJson;

  @override

  /// A machine-readable error code.
  String get code;
  @override

  /// A human-readable error message.
  String get message;
  @override

  /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  String? get param;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobErrorImplCopyWith<_$FineTuningJobErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobHyperparameters _$FineTuningJobHyperparametersFromJson(
    Map<String, dynamic> json) {
  return _FineTuningJobHyperparameters.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobHyperparameters {
  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobHyperparametersCopyWith<FineTuningJobHyperparameters>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobHyperparametersCopyWith<$Res> {
  factory $FineTuningJobHyperparametersCopyWith(
          FineTuningJobHyperparameters value,
          $Res Function(FineTuningJobHyperparameters) then) =
      _$FineTuningJobHyperparametersCopyWithImpl<$Res,
          FineTuningJobHyperparameters>;
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        $Val extends FineTuningJobHyperparameters>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  _$FineTuningJobHyperparametersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_value.copyWith(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningNEpochsCopyWith<$Res> get nEpochs {
    return $FineTuningNEpochsCopyWith<$Res>(_value.nEpochs, (value) {
      return _then(_value.copyWith(nEpochs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobHyperparametersImplCopyWith<$Res>
    implements $FineTuningJobHyperparametersCopyWith<$Res> {
  factory _$$FineTuningJobHyperparametersImplCopyWith(
          _$FineTuningJobHyperparametersImpl value,
          $Res Function(_$FineTuningJobHyperparametersImpl) then) =
      __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      FineTuningNEpochs nEpochs});

  @override
  $FineTuningNEpochsCopyWith<$Res> get nEpochs;
}

/// @nodoc
class __$$FineTuningJobHyperparametersImplCopyWithImpl<$Res>
    extends _$FineTuningJobHyperparametersCopyWithImpl<$Res,
        _$FineTuningJobHyperparametersImpl>
    implements _$$FineTuningJobHyperparametersImplCopyWith<$Res> {
  __$$FineTuningJobHyperparametersImplCopyWithImpl(
      _$FineTuningJobHyperparametersImpl _value,
      $Res Function(_$FineTuningJobHyperparametersImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nEpochs = null,
  }) {
    return _then(_$FineTuningJobHyperparametersImpl(
      nEpochs: null == nEpochs
          ? _value.nEpochs
          : nEpochs // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochs,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobHyperparametersImpl extends _FineTuningJobHyperparameters {
  const _$FineTuningJobHyperparametersImpl(
      {@_FineTuningNEpochsConverter()
      @JsonKey(name: 'n_epochs')
      required this.nEpochs})
      : super._();

  factory _$FineTuningJobHyperparametersImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningJobHyperparametersImplFromJson(json);

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @override
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  final FineTuningNEpochs nEpochs;

  @override
  String toString() {
    return 'FineTuningJobHyperparameters(nEpochs: $nEpochs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobHyperparametersImpl &&
            (identical(other.nEpochs, nEpochs) || other.nEpochs == nEpochs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, nEpochs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => __$$FineTuningJobHyperparametersImplCopyWithImpl<
          _$FineTuningJobHyperparametersImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobHyperparametersImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobHyperparameters
    extends FineTuningJobHyperparameters {
  const factory _FineTuningJobHyperparameters(
          {@_FineTuningNEpochsConverter()
          @JsonKey(name: 'n_epochs')
          required final FineTuningNEpochs nEpochs}) =
      _$FineTuningJobHyperparametersImpl;
  const _FineTuningJobHyperparameters._() : super._();

  factory _FineTuningJobHyperparameters.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobHyperparametersImpl.fromJson;

  @override

  /// The number of epochs to train the model for. An epoch refers to one
  /// full cycle through the training dataset.
  @_FineTuningNEpochsConverter()
  @JsonKey(name: 'n_epochs')
  FineTuningNEpochs get nEpochs;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobHyperparametersImplCopyWith<
          _$FineTuningJobHyperparametersImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningNEpochs _$FineTuningNEpochsFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return FineTuningNEpochsEnumeration.fromJson(json);
    case 'number':
      return FineTuningNEpochsInt.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FineTuningNEpochs',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FineTuningNEpochs {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningNEpochsCopyWith<$Res> {
  factory $FineTuningNEpochsCopyWith(
          FineTuningNEpochs value, $Res Function(FineTuningNEpochs) then) =
      _$FineTuningNEpochsCopyWithImpl<$Res, FineTuningNEpochs>;
}

/// @nodoc
class _$FineTuningNEpochsCopyWithImpl<$Res, $Val extends FineTuningNEpochs>
    implements $FineTuningNEpochsCopyWith<$Res> {
  _$FineTuningNEpochsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FineTuningNEpochsEnumerationImplCopyWith<$Res> {
  factory _$$FineTuningNEpochsEnumerationImplCopyWith(
          _$FineTuningNEpochsEnumerationImpl value,
          $Res Function(_$FineTuningNEpochsEnumerationImpl) then) =
      __$$FineTuningNEpochsEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FineTuningNEpochsOptions value});
}

/// @nodoc
class __$$FineTuningNEpochsEnumerationImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res,
        _$FineTuningNEpochsEnumerationImpl>
    implements _$$FineTuningNEpochsEnumerationImplCopyWith<$Res> {
  __$$FineTuningNEpochsEnumerationImplCopyWithImpl(
      _$FineTuningNEpochsEnumerationImpl _value,
      $Res Function(_$FineTuningNEpochsEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningNEpochsEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as FineTuningNEpochsOptions,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningNEpochsEnumerationImpl extends FineTuningNEpochsEnumeration {
  const _$FineTuningNEpochsEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$FineTuningNEpochsEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningNEpochsEnumerationImplFromJson(json);

  @override
  final FineTuningNEpochsOptions value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningNEpochsEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningNEpochsEnumerationImplCopyWith<
          _$FineTuningNEpochsEnumerationImpl>
      get copyWith => __$$FineTuningNEpochsEnumerationImplCopyWithImpl<
          _$FineTuningNEpochsEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningNEpochsEnumerationImplToJson(
      this,
    );
  }
}

abstract class FineTuningNEpochsEnumeration extends FineTuningNEpochs {
  const factory FineTuningNEpochsEnumeration(
          final FineTuningNEpochsOptions value) =
      _$FineTuningNEpochsEnumerationImpl;
  const FineTuningNEpochsEnumeration._() : super._();

  factory FineTuningNEpochsEnumeration.fromJson(Map<String, dynamic> json) =
      _$FineTuningNEpochsEnumerationImpl.fromJson;

  @override
  FineTuningNEpochsOptions get value;
  @JsonKey(ignore: true)
  _$$FineTuningNEpochsEnumerationImplCopyWith<
          _$FineTuningNEpochsEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FineTuningNEpochsIntImplCopyWith<$Res> {
  factory _$$FineTuningNEpochsIntImplCopyWith(_$FineTuningNEpochsIntImpl value,
          $Res Function(_$FineTuningNEpochsIntImpl) then) =
      __$$FineTuningNEpochsIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$FineTuningNEpochsIntImplCopyWithImpl<$Res>
    extends _$FineTuningNEpochsCopyWithImpl<$Res, _$FineTuningNEpochsIntImpl>
    implements _$$FineTuningNEpochsIntImplCopyWith<$Res> {
  __$$FineTuningNEpochsIntImplCopyWithImpl(_$FineTuningNEpochsIntImpl _value,
      $Res Function(_$FineTuningNEpochsIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$FineTuningNEpochsIntImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningNEpochsIntImpl extends FineTuningNEpochsInt {
  const _$FineTuningNEpochsIntImpl(this.value, {final String? $type})
      : $type = $type ?? 'number',
        super._();

  factory _$FineTuningNEpochsIntImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningNEpochsIntImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FineTuningNEpochs.number(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningNEpochsIntImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningNEpochsIntImplCopyWith<_$FineTuningNEpochsIntImpl>
      get copyWith =>
          __$$FineTuningNEpochsIntImplCopyWithImpl<_$FineTuningNEpochsIntImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsOptions value) mode,
    required TResult Function(int value) number,
  }) {
    return number(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsOptions value)? mode,
    TResult? Function(int value)? number,
  }) {
    return number?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(FineTuningNEpochsOptions value)? mode,
    TResult Function(int value)? number,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FineTuningNEpochsEnumeration value) mode,
    required TResult Function(FineTuningNEpochsInt value) number,
  }) {
    return number(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FineTuningNEpochsEnumeration value)? mode,
    TResult? Function(FineTuningNEpochsInt value)? number,
  }) {
    return number?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FineTuningNEpochsEnumeration value)? mode,
    TResult Function(FineTuningNEpochsInt value)? number,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningNEpochsIntImplToJson(
      this,
    );
  }
}

abstract class FineTuningNEpochsInt extends FineTuningNEpochs {
  const factory FineTuningNEpochsInt(final int value) =
      _$FineTuningNEpochsIntImpl;
  const FineTuningNEpochsInt._() : super._();

  factory FineTuningNEpochsInt.fromJson(Map<String, dynamic> json) =
      _$FineTuningNEpochsIntImpl.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$FineTuningNEpochsIntImplCopyWith<_$FineTuningNEpochsIntImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListPaginatedFineTuningJobsResponse
    _$ListPaginatedFineTuningJobsResponseFromJson(Map<String, dynamic> json) {
  return _ListPaginatedFineTuningJobsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListPaginatedFineTuningJobsResponse {
  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data => throw _privateConstructorUsedError;

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  ListPaginatedFineTuningJobsResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListPaginatedFineTuningJobsResponseCopyWith<
          ListPaginatedFineTuningJobsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory $ListPaginatedFineTuningJobsResponseCopyWith(
          ListPaginatedFineTuningJobsResponse value,
          $Res Function(ListPaginatedFineTuningJobsResponse) then) =
      _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
          ListPaginatedFineTuningJobsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        $Val extends ListPaginatedFineTuningJobsResponse>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  _$ListPaginatedFineTuningJobsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res>
    implements $ListPaginatedFineTuningJobsResponseCopyWith<$Res> {
  factory _$$ListPaginatedFineTuningJobsResponseImplCopyWith(
          _$ListPaginatedFineTuningJobsResponseImpl value,
          $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) then) =
      __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJob> data,
      @JsonKey(name: 'has_more') bool hasMore,
      ListPaginatedFineTuningJobsResponseObject object});
}

/// @nodoc
class __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<$Res>
    extends _$ListPaginatedFineTuningJobsResponseCopyWithImpl<$Res,
        _$ListPaginatedFineTuningJobsResponseImpl>
    implements _$$ListPaginatedFineTuningJobsResponseImplCopyWith<$Res> {
  __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl(
      _$ListPaginatedFineTuningJobsResponseImpl _value,
      $Res Function(_$ListPaginatedFineTuningJobsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_$ListPaginatedFineTuningJobsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJob>,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListPaginatedFineTuningJobsResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListPaginatedFineTuningJobsResponseImpl
    extends _ListPaginatedFineTuningJobsResponse {
  const _$ListPaginatedFineTuningJobsResponseImpl(
      {required final List<FineTuningJob> data,
      @JsonKey(name: 'has_more') required this.hasMore,
      required this.object})
      : _data = data,
        super._();

  factory _$ListPaginatedFineTuningJobsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListPaginatedFineTuningJobsResponseImplFromJson(json);

  /// The list of fine-tuning jobs.
  final List<FineTuningJob> _data;

  /// The list of fine-tuning jobs.
  @override
  List<FineTuningJob> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// Whether there are more fine-tuning jobs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// The object type, which is always "list".
  @override
  final ListPaginatedFineTuningJobsResponseObject object;

  @override
  String toString() {
    return 'ListPaginatedFineTuningJobsResponse(data: $data, hasMore: $hasMore, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListPaginatedFineTuningJobsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), hasMore, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => __$$ListPaginatedFineTuningJobsResponseImplCopyWithImpl<
          _$ListPaginatedFineTuningJobsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListPaginatedFineTuningJobsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListPaginatedFineTuningJobsResponse
    extends ListPaginatedFineTuningJobsResponse {
  const factory _ListPaginatedFineTuningJobsResponse(
          {required final List<FineTuningJob> data,
          @JsonKey(name: 'has_more') required final bool hasMore,
          required final ListPaginatedFineTuningJobsResponseObject object}) =
      _$ListPaginatedFineTuningJobsResponseImpl;
  const _ListPaginatedFineTuningJobsResponse._() : super._();

  factory _ListPaginatedFineTuningJobsResponse.fromJson(
          Map<String, dynamic> json) =
      _$ListPaginatedFineTuningJobsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning jobs.
  List<FineTuningJob> get data;
  @override

  /// Whether there are more fine-tuning jobs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override

  /// The object type, which is always "list".
  ListPaginatedFineTuningJobsResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$ListPaginatedFineTuningJobsResponseImplCopyWith<
          _$ListPaginatedFineTuningJobsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListFineTuningJobEventsResponse _$ListFineTuningJobEventsResponseFromJson(
    Map<String, dynamic> json) {
  return _ListFineTuningJobEventsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListFineTuningJobEventsResponse {
  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  ListFineTuningJobEventsResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListFineTuningJobEventsResponseCopyWith<ListFineTuningJobEventsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory $ListFineTuningJobEventsResponseCopyWith(
          ListFineTuningJobEventsResponse value,
          $Res Function(ListFineTuningJobEventsResponse) then) =
      _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
          ListFineTuningJobEventsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        $Val extends ListFineTuningJobEventsResponse>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  _$ListFineTuningJobEventsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListFineTuningJobEventsResponseImplCopyWith<$Res>
    implements $ListFineTuningJobEventsResponseCopyWith<$Res> {
  factory _$$ListFineTuningJobEventsResponseImplCopyWith(
          _$ListFineTuningJobEventsResponseImpl value,
          $Res Function(_$ListFineTuningJobEventsResponseImpl) then) =
      __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJobEvent> data,
      ListFineTuningJobEventsResponseObject object});
}

/// @nodoc
class __$$ListFineTuningJobEventsResponseImplCopyWithImpl<$Res>
    extends _$ListFineTuningJobEventsResponseCopyWithImpl<$Res,
        _$ListFineTuningJobEventsResponseImpl>
    implements _$$ListFineTuningJobEventsResponseImplCopyWith<$Res> {
  __$$ListFineTuningJobEventsResponseImplCopyWithImpl(
      _$ListFineTuningJobEventsResponseImpl _value,
      $Res Function(_$ListFineTuningJobEventsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
  }) {
    return _then(_$ListFineTuningJobEventsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobEvent>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobEventsResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListFineTuningJobEventsResponseImpl
    extends _ListFineTuningJobEventsResponse {
  const _$ListFineTuningJobEventsResponseImpl(
      {required final List<FineTuningJobEvent> data, required this.object})
      : _data = data,
        super._();

  factory _$ListFineTuningJobEventsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListFineTuningJobEventsResponseImplFromJson(json);

  /// The list of fine-tuning job events.
  final List<FineTuningJobEvent> _data;

  /// The list of fine-tuning job events.
  @override
  List<FineTuningJobEvent> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The object type, which is always "list".
  @override
  final ListFineTuningJobEventsResponseObject object;

  @override
  String toString() {
    return 'ListFineTuningJobEventsResponse(data: $data, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListFineTuningJobEventsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => __$$ListFineTuningJobEventsResponseImplCopyWithImpl<
          _$ListFineTuningJobEventsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListFineTuningJobEventsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListFineTuningJobEventsResponse
    extends ListFineTuningJobEventsResponse {
  const factory _ListFineTuningJobEventsResponse(
          {required final List<FineTuningJobEvent> data,
          required final ListFineTuningJobEventsResponseObject object}) =
      _$ListFineTuningJobEventsResponseImpl;
  const _ListFineTuningJobEventsResponse._() : super._();

  factory _ListFineTuningJobEventsResponse.fromJson(Map<String, dynamic> json) =
      _$ListFineTuningJobEventsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning job events.
  List<FineTuningJobEvent> get data;
  @override

  /// The object type, which is always "list".
  ListFineTuningJobEventsResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$ListFineTuningJobEventsResponseImplCopyWith<
          _$ListFineTuningJobEventsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListFineTuningJobCheckpointsResponse
    _$ListFineTuningJobCheckpointsResponseFromJson(Map<String, dynamic> json) {
  return _ListFineTuningJobCheckpointsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListFineTuningJobCheckpointsResponse {
  /// The list of fine-tuning job checkpoints.
  List<FineTuningJobCheckpoint> get data => throw _privateConstructorUsedError;

  /// The object type, which is always "list".
  ListFineTuningJobCheckpointsResponseObject get object =>
      throw _privateConstructorUsedError;

  /// The ID of the first checkpoint in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId => throw _privateConstructorUsedError;

  /// The ID of the last checkpoint in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId => throw _privateConstructorUsedError;

  /// Whether there are more checkpoints to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListFineTuningJobCheckpointsResponseCopyWith<
          ListFineTuningJobCheckpointsResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListFineTuningJobCheckpointsResponseCopyWith<$Res> {
  factory $ListFineTuningJobCheckpointsResponseCopyWith(
          ListFineTuningJobCheckpointsResponse value,
          $Res Function(ListFineTuningJobCheckpointsResponse) then) =
      _$ListFineTuningJobCheckpointsResponseCopyWithImpl<$Res,
          ListFineTuningJobCheckpointsResponse>;
  @useResult
  $Res call(
      {List<FineTuningJobCheckpoint> data,
      ListFineTuningJobCheckpointsResponseObject object,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListFineTuningJobCheckpointsResponseCopyWithImpl<$Res,
        $Val extends ListFineTuningJobCheckpointsResponse>
    implements $ListFineTuningJobCheckpointsResponseCopyWith<$Res> {
  _$ListFineTuningJobCheckpointsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobCheckpoint>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobCheckpointsResponseObject,
      firstId: freezed == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListFineTuningJobCheckpointsResponseImplCopyWith<$Res>
    implements $ListFineTuningJobCheckpointsResponseCopyWith<$Res> {
  factory _$$ListFineTuningJobCheckpointsResponseImplCopyWith(
          _$ListFineTuningJobCheckpointsResponseImpl value,
          $Res Function(_$ListFineTuningJobCheckpointsResponseImpl) then) =
      __$$ListFineTuningJobCheckpointsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<FineTuningJobCheckpoint> data,
      ListFineTuningJobCheckpointsResponseObject object,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListFineTuningJobCheckpointsResponseImplCopyWithImpl<$Res>
    extends _$ListFineTuningJobCheckpointsResponseCopyWithImpl<$Res,
        _$ListFineTuningJobCheckpointsResponseImpl>
    implements _$$ListFineTuningJobCheckpointsResponseImplCopyWith<$Res> {
  __$$ListFineTuningJobCheckpointsResponseImplCopyWithImpl(
      _$ListFineTuningJobCheckpointsResponseImpl _value,
      $Res Function(_$ListFineTuningJobCheckpointsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? object = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_$ListFineTuningJobCheckpointsResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<FineTuningJobCheckpoint>,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListFineTuningJobCheckpointsResponseObject,
      firstId: freezed == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListFineTuningJobCheckpointsResponseImpl
    extends _ListFineTuningJobCheckpointsResponse {
  const _$ListFineTuningJobCheckpointsResponseImpl(
      {required final List<FineTuningJobCheckpoint> data,
      required this.object,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListFineTuningJobCheckpointsResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListFineTuningJobCheckpointsResponseImplFromJson(json);

  /// The list of fine-tuning job checkpoints.
  final List<FineTuningJobCheckpoint> _data;

  /// The list of fine-tuning job checkpoints.
  @override
  List<FineTuningJobCheckpoint> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The object type, which is always "list".
  @override
  final ListFineTuningJobCheckpointsResponseObject object;

  /// The ID of the first checkpoint in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last checkpoint in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more checkpoints to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListFineTuningJobCheckpointsResponse(data: $data, object: $object, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListFineTuningJobCheckpointsResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_data),
      object,
      firstId,
      lastId,
      hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListFineTuningJobCheckpointsResponseImplCopyWith<
          _$ListFineTuningJobCheckpointsResponseImpl>
      get copyWith => __$$ListFineTuningJobCheckpointsResponseImplCopyWithImpl<
          _$ListFineTuningJobCheckpointsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListFineTuningJobCheckpointsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListFineTuningJobCheckpointsResponse
    extends ListFineTuningJobCheckpointsResponse {
  const factory _ListFineTuningJobCheckpointsResponse(
      {required final List<FineTuningJobCheckpoint> data,
      required final ListFineTuningJobCheckpointsResponseObject object,
      @JsonKey(name: 'first_id', includeIfNull: false) final String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) final String? lastId,
      @JsonKey(name: 'has_more')
      required final bool
          hasMore}) = _$ListFineTuningJobCheckpointsResponseImpl;
  const _ListFineTuningJobCheckpointsResponse._() : super._();

  factory _ListFineTuningJobCheckpointsResponse.fromJson(
          Map<String, dynamic> json) =
      _$ListFineTuningJobCheckpointsResponseImpl.fromJson;

  @override

  /// The list of fine-tuning job checkpoints.
  List<FineTuningJobCheckpoint> get data;
  @override

  /// The object type, which is always "list".
  ListFineTuningJobCheckpointsResponseObject get object;
  @override

  /// The ID of the first checkpoint in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;
  @override

  /// The ID of the last checkpoint in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;
  @override

  /// Whether there are more checkpoints to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListFineTuningJobCheckpointsResponseImplCopyWith<
          _$ListFineTuningJobCheckpointsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJobEvent _$FineTuningJobEventFromJson(Map<String, dynamic> json) {
  return _FineTuningJobEvent.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobEvent {
  /// The event identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The log level of the event.
  FineTuningJobEventLevel get level => throw _privateConstructorUsedError;

  /// The message of the event.
  String get message => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job.event".
  FineTuningJobEventObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobEventCopyWith<FineTuningJobEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobEventCopyWith<$Res> {
  factory $FineTuningJobEventCopyWith(
          FineTuningJobEvent value, $Res Function(FineTuningJobEvent) then) =
      _$FineTuningJobEventCopyWithImpl<$Res, FineTuningJobEvent>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class _$FineTuningJobEventCopyWithImpl<$Res, $Val extends FineTuningJobEvent>
    implements $FineTuningJobEventCopyWith<$Res> {
  _$FineTuningJobEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobEventImplCopyWith<$Res>
    implements $FineTuningJobEventCopyWith<$Res> {
  factory _$$FineTuningJobEventImplCopyWith(_$FineTuningJobEventImpl value,
          $Res Function(_$FineTuningJobEventImpl) then) =
      __$$FineTuningJobEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      FineTuningJobEventLevel level,
      String message,
      FineTuningJobEventObject object});
}

/// @nodoc
class __$$FineTuningJobEventImplCopyWithImpl<$Res>
    extends _$FineTuningJobEventCopyWithImpl<$Res, _$FineTuningJobEventImpl>
    implements _$$FineTuningJobEventImplCopyWith<$Res> {
  __$$FineTuningJobEventImplCopyWithImpl(_$FineTuningJobEventImpl _value,
      $Res Function(_$FineTuningJobEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? level = null,
    Object? message = null,
    Object? object = null,
  }) {
    return _then(_$FineTuningJobEventImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      level: null == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventLevel,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobEventObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobEventImpl extends _FineTuningJobEvent {
  const _$FineTuningJobEventImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.level,
      required this.message,
      required this.object})
      : super._();

  factory _$FineTuningJobEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobEventImplFromJson(json);

  /// The event identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the event was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The log level of the event.
  @override
  final FineTuningJobEventLevel level;

  /// The message of the event.
  @override
  final String message;

  /// The object type, which is always "fine_tuning.job.event".
  @override
  final FineTuningJobEventObject object;

  @override
  String toString() {
    return 'FineTuningJobEvent(id: $id, createdAt: $createdAt, level: $level, message: $message, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobEventImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, createdAt, level, message, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      __$$FineTuningJobEventImplCopyWithImpl<_$FineTuningJobEventImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobEventImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobEvent extends FineTuningJobEvent {
  const factory _FineTuningJobEvent(
          {required final String id,
          @JsonKey(name: 'created_at') required final int createdAt,
          required final FineTuningJobEventLevel level,
          required final String message,
          required final FineTuningJobEventObject object}) =
      _$FineTuningJobEventImpl;
  const _FineTuningJobEvent._() : super._();

  factory _FineTuningJobEvent.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobEventImpl.fromJson;

  @override

  /// The event identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the event was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The log level of the event.
  FineTuningJobEventLevel get level;
  @override

  /// The message of the event.
  String get message;
  @override

  /// The object type, which is always "fine_tuning.job.event".
  FineTuningJobEventObject get object;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobEventImplCopyWith<_$FineTuningJobEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FineTuningJobCheckpoint _$FineTuningJobCheckpointFromJson(
    Map<String, dynamic> json) {
  return _FineTuningJobCheckpoint.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobCheckpoint {
  /// The checkpoint identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the checkpoint was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The name of the fine-tuned checkpoint model that is created.
  @JsonKey(name: 'fine_tuned_model_checkpoint')
  String get fineTunedModelCheckpoint => throw _privateConstructorUsedError;

  /// The step number that the checkpoint was created at.
  @JsonKey(name: 'step_number')
  int get stepNumber => throw _privateConstructorUsedError;

  /// Metrics at the step number during the fine-tuning job.
  FineTuningJobCheckpointMetrics get metrics =>
      throw _privateConstructorUsedError;

  /// The name of the fine-tuning job that this checkpoint was created from.
  @JsonKey(name: 'fine_tuning_job_id')
  String get fineTuningJobId => throw _privateConstructorUsedError;

  /// The object type, which is always "fine_tuning.job.checkpoint".
  FineTuningJobCheckpointObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobCheckpointCopyWith<FineTuningJobCheckpoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobCheckpointCopyWith<$Res> {
  factory $FineTuningJobCheckpointCopyWith(FineTuningJobCheckpoint value,
          $Res Function(FineTuningJobCheckpoint) then) =
      _$FineTuningJobCheckpointCopyWithImpl<$Res, FineTuningJobCheckpoint>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'fine_tuned_model_checkpoint')
      String fineTunedModelCheckpoint,
      @JsonKey(name: 'step_number') int stepNumber,
      FineTuningJobCheckpointMetrics metrics,
      @JsonKey(name: 'fine_tuning_job_id') String fineTuningJobId,
      FineTuningJobCheckpointObject object});

  $FineTuningJobCheckpointMetricsCopyWith<$Res> get metrics;
}

/// @nodoc
class _$FineTuningJobCheckpointCopyWithImpl<$Res,
        $Val extends FineTuningJobCheckpoint>
    implements $FineTuningJobCheckpointCopyWith<$Res> {
  _$FineTuningJobCheckpointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? fineTunedModelCheckpoint = null,
    Object? stepNumber = null,
    Object? metrics = null,
    Object? fineTuningJobId = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      fineTunedModelCheckpoint: null == fineTunedModelCheckpoint
          ? _value.fineTunedModelCheckpoint
          : fineTunedModelCheckpoint // ignore: cast_nullable_to_non_nullable
              as String,
      stepNumber: null == stepNumber
          ? _value.stepNumber
          : stepNumber // ignore: cast_nullable_to_non_nullable
              as int,
      metrics: null == metrics
          ? _value.metrics
          : metrics // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointMetrics,
      fineTuningJobId: null == fineTuningJobId
          ? _value.fineTuningJobId
          : fineTuningJobId // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointObject,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FineTuningJobCheckpointMetricsCopyWith<$Res> get metrics {
    return $FineTuningJobCheckpointMetricsCopyWith<$Res>(_value.metrics,
        (value) {
      return _then(_value.copyWith(metrics: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FineTuningJobCheckpointImplCopyWith<$Res>
    implements $FineTuningJobCheckpointCopyWith<$Res> {
  factory _$$FineTuningJobCheckpointImplCopyWith(
          _$FineTuningJobCheckpointImpl value,
          $Res Function(_$FineTuningJobCheckpointImpl) then) =
      __$$FineTuningJobCheckpointImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'fine_tuned_model_checkpoint')
      String fineTunedModelCheckpoint,
      @JsonKey(name: 'step_number') int stepNumber,
      FineTuningJobCheckpointMetrics metrics,
      @JsonKey(name: 'fine_tuning_job_id') String fineTuningJobId,
      FineTuningJobCheckpointObject object});

  @override
  $FineTuningJobCheckpointMetricsCopyWith<$Res> get metrics;
}

/// @nodoc
class __$$FineTuningJobCheckpointImplCopyWithImpl<$Res>
    extends _$FineTuningJobCheckpointCopyWithImpl<$Res,
        _$FineTuningJobCheckpointImpl>
    implements _$$FineTuningJobCheckpointImplCopyWith<$Res> {
  __$$FineTuningJobCheckpointImplCopyWithImpl(
      _$FineTuningJobCheckpointImpl _value,
      $Res Function(_$FineTuningJobCheckpointImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? createdAt = null,
    Object? fineTunedModelCheckpoint = null,
    Object? stepNumber = null,
    Object? metrics = null,
    Object? fineTuningJobId = null,
    Object? object = null,
  }) {
    return _then(_$FineTuningJobCheckpointImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      fineTunedModelCheckpoint: null == fineTunedModelCheckpoint
          ? _value.fineTunedModelCheckpoint
          : fineTunedModelCheckpoint // ignore: cast_nullable_to_non_nullable
              as String,
      stepNumber: null == stepNumber
          ? _value.stepNumber
          : stepNumber // ignore: cast_nullable_to_non_nullable
              as int,
      metrics: null == metrics
          ? _value.metrics
          : metrics // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointMetrics,
      fineTuningJobId: null == fineTuningJobId
          ? _value.fineTuningJobId
          : fineTuningJobId // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as FineTuningJobCheckpointObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobCheckpointImpl extends _FineTuningJobCheckpoint {
  const _$FineTuningJobCheckpointImpl(
      {required this.id,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'fine_tuned_model_checkpoint')
      required this.fineTunedModelCheckpoint,
      @JsonKey(name: 'step_number') required this.stepNumber,
      required this.metrics,
      @JsonKey(name: 'fine_tuning_job_id') required this.fineTuningJobId,
      required this.object})
      : super._();

  factory _$FineTuningJobCheckpointImpl.fromJson(Map<String, dynamic> json) =>
      _$$FineTuningJobCheckpointImplFromJson(json);

  /// The checkpoint identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) for when the checkpoint was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The name of the fine-tuned checkpoint model that is created.
  @override
  @JsonKey(name: 'fine_tuned_model_checkpoint')
  final String fineTunedModelCheckpoint;

  /// The step number that the checkpoint was created at.
  @override
  @JsonKey(name: 'step_number')
  final int stepNumber;

  /// Metrics at the step number during the fine-tuning job.
  @override
  final FineTuningJobCheckpointMetrics metrics;

  /// The name of the fine-tuning job that this checkpoint was created from.
  @override
  @JsonKey(name: 'fine_tuning_job_id')
  final String fineTuningJobId;

  /// The object type, which is always "fine_tuning.job.checkpoint".
  @override
  final FineTuningJobCheckpointObject object;

  @override
  String toString() {
    return 'FineTuningJobCheckpoint(id: $id, createdAt: $createdAt, fineTunedModelCheckpoint: $fineTunedModelCheckpoint, stepNumber: $stepNumber, metrics: $metrics, fineTuningJobId: $fineTuningJobId, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobCheckpointImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(
                    other.fineTunedModelCheckpoint, fineTunedModelCheckpoint) ||
                other.fineTunedModelCheckpoint == fineTunedModelCheckpoint) &&
            (identical(other.stepNumber, stepNumber) ||
                other.stepNumber == stepNumber) &&
            (identical(other.metrics, metrics) || other.metrics == metrics) &&
            (identical(other.fineTuningJobId, fineTuningJobId) ||
                other.fineTuningJobId == fineTuningJobId) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, createdAt,
      fineTunedModelCheckpoint, stepNumber, metrics, fineTuningJobId, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobCheckpointImplCopyWith<_$FineTuningJobCheckpointImpl>
      get copyWith => __$$FineTuningJobCheckpointImplCopyWithImpl<
          _$FineTuningJobCheckpointImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobCheckpointImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobCheckpoint extends FineTuningJobCheckpoint {
  const factory _FineTuningJobCheckpoint(
          {required final String id,
          @JsonKey(name: 'created_at') required final int createdAt,
          @JsonKey(name: 'fine_tuned_model_checkpoint')
          required final String fineTunedModelCheckpoint,
          @JsonKey(name: 'step_number') required final int stepNumber,
          required final FineTuningJobCheckpointMetrics metrics,
          @JsonKey(name: 'fine_tuning_job_id')
          required final String fineTuningJobId,
          required final FineTuningJobCheckpointObject object}) =
      _$FineTuningJobCheckpointImpl;
  const _FineTuningJobCheckpoint._() : super._();

  factory _FineTuningJobCheckpoint.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobCheckpointImpl.fromJson;

  @override

  /// The checkpoint identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) for when the checkpoint was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The name of the fine-tuned checkpoint model that is created.
  @JsonKey(name: 'fine_tuned_model_checkpoint')
  String get fineTunedModelCheckpoint;
  @override

  /// The step number that the checkpoint was created at.
  @JsonKey(name: 'step_number')
  int get stepNumber;
  @override

  /// Metrics at the step number during the fine-tuning job.
  FineTuningJobCheckpointMetrics get metrics;
  @override

  /// The name of the fine-tuning job that this checkpoint was created from.
  @JsonKey(name: 'fine_tuning_job_id')
  String get fineTuningJobId;
  @override

  /// The object type, which is always "fine_tuning.job.checkpoint".
  FineTuningJobCheckpointObject get object;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobCheckpointImplCopyWith<_$FineTuningJobCheckpointImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FineTuningJobCheckpointMetrics _$FineTuningJobCheckpointMetricsFromJson(
    Map<String, dynamic> json) {
  return _FineTuningJobCheckpointMetrics.fromJson(json);
}

/// @nodoc
mixin _$FineTuningJobCheckpointMetrics {
  /// The step number that the metrics were recorded at.
  @JsonKey(includeIfNull: false)
  double? get step => throw _privateConstructorUsedError;

  /// The training loss at the step number.
  @JsonKey(name: 'train_loss', includeIfNull: false)
  double? get trainLoss => throw _privateConstructorUsedError;

  /// The training mean token accuracy at the step number.
  @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
  double? get trainMeanTokenAccuracy => throw _privateConstructorUsedError;

  /// The validation loss at the step number.
  @JsonKey(name: 'valid_loss', includeIfNull: false)
  double? get validLoss => throw _privateConstructorUsedError;

  /// The validation mean token accuracy at the step number.
  @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
  double? get validMeanTokenAccuracy => throw _privateConstructorUsedError;

  /// The full validation loss at the step number.
  @JsonKey(name: 'full_valid_loss', includeIfNull: false)
  double? get fullValidLoss => throw _privateConstructorUsedError;

  /// The full validation mean token accuracy at the step number.
  @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
  double? get fullValidMeanTokenAccuracy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FineTuningJobCheckpointMetricsCopyWith<FineTuningJobCheckpointMetrics>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FineTuningJobCheckpointMetricsCopyWith<$Res> {
  factory $FineTuningJobCheckpointMetricsCopyWith(
          FineTuningJobCheckpointMetrics value,
          $Res Function(FineTuningJobCheckpointMetrics) then) =
      _$FineTuningJobCheckpointMetricsCopyWithImpl<$Res,
          FineTuningJobCheckpointMetrics>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) double? step,
      @JsonKey(name: 'train_loss', includeIfNull: false) double? trainLoss,
      @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
      double? trainMeanTokenAccuracy,
      @JsonKey(name: 'valid_loss', includeIfNull: false) double? validLoss,
      @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
      double? validMeanTokenAccuracy,
      @JsonKey(name: 'full_valid_loss', includeIfNull: false)
      double? fullValidLoss,
      @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
      double? fullValidMeanTokenAccuracy});
}

/// @nodoc
class _$FineTuningJobCheckpointMetricsCopyWithImpl<$Res,
        $Val extends FineTuningJobCheckpointMetrics>
    implements $FineTuningJobCheckpointMetricsCopyWith<$Res> {
  _$FineTuningJobCheckpointMetricsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = freezed,
    Object? trainLoss = freezed,
    Object? trainMeanTokenAccuracy = freezed,
    Object? validLoss = freezed,
    Object? validMeanTokenAccuracy = freezed,
    Object? fullValidLoss = freezed,
    Object? fullValidMeanTokenAccuracy = freezed,
  }) {
    return _then(_value.copyWith(
      step: freezed == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as double?,
      trainLoss: freezed == trainLoss
          ? _value.trainLoss
          : trainLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      trainMeanTokenAccuracy: freezed == trainMeanTokenAccuracy
          ? _value.trainMeanTokenAccuracy
          : trainMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      validLoss: freezed == validLoss
          ? _value.validLoss
          : validLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      validMeanTokenAccuracy: freezed == validMeanTokenAccuracy
          ? _value.validMeanTokenAccuracy
          : validMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidLoss: freezed == fullValidLoss
          ? _value.fullValidLoss
          : fullValidLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidMeanTokenAccuracy: freezed == fullValidMeanTokenAccuracy
          ? _value.fullValidMeanTokenAccuracy
          : fullValidMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FineTuningJobCheckpointMetricsImplCopyWith<$Res>
    implements $FineTuningJobCheckpointMetricsCopyWith<$Res> {
  factory _$$FineTuningJobCheckpointMetricsImplCopyWith(
          _$FineTuningJobCheckpointMetricsImpl value,
          $Res Function(_$FineTuningJobCheckpointMetricsImpl) then) =
      __$$FineTuningJobCheckpointMetricsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) double? step,
      @JsonKey(name: 'train_loss', includeIfNull: false) double? trainLoss,
      @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
      double? trainMeanTokenAccuracy,
      @JsonKey(name: 'valid_loss', includeIfNull: false) double? validLoss,
      @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
      double? validMeanTokenAccuracy,
      @JsonKey(name: 'full_valid_loss', includeIfNull: false)
      double? fullValidLoss,
      @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
      double? fullValidMeanTokenAccuracy});
}

/// @nodoc
class __$$FineTuningJobCheckpointMetricsImplCopyWithImpl<$Res>
    extends _$FineTuningJobCheckpointMetricsCopyWithImpl<$Res,
        _$FineTuningJobCheckpointMetricsImpl>
    implements _$$FineTuningJobCheckpointMetricsImplCopyWith<$Res> {
  __$$FineTuningJobCheckpointMetricsImplCopyWithImpl(
      _$FineTuningJobCheckpointMetricsImpl _value,
      $Res Function(_$FineTuningJobCheckpointMetricsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = freezed,
    Object? trainLoss = freezed,
    Object? trainMeanTokenAccuracy = freezed,
    Object? validLoss = freezed,
    Object? validMeanTokenAccuracy = freezed,
    Object? fullValidLoss = freezed,
    Object? fullValidMeanTokenAccuracy = freezed,
  }) {
    return _then(_$FineTuningJobCheckpointMetricsImpl(
      step: freezed == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as double?,
      trainLoss: freezed == trainLoss
          ? _value.trainLoss
          : trainLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      trainMeanTokenAccuracy: freezed == trainMeanTokenAccuracy
          ? _value.trainMeanTokenAccuracy
          : trainMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      validLoss: freezed == validLoss
          ? _value.validLoss
          : validLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      validMeanTokenAccuracy: freezed == validMeanTokenAccuracy
          ? _value.validMeanTokenAccuracy
          : validMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidLoss: freezed == fullValidLoss
          ? _value.fullValidLoss
          : fullValidLoss // ignore: cast_nullable_to_non_nullable
              as double?,
      fullValidMeanTokenAccuracy: freezed == fullValidMeanTokenAccuracy
          ? _value.fullValidMeanTokenAccuracy
          : fullValidMeanTokenAccuracy // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FineTuningJobCheckpointMetricsImpl
    extends _FineTuningJobCheckpointMetrics {
  const _$FineTuningJobCheckpointMetricsImpl(
      {@JsonKey(includeIfNull: false) this.step,
      @JsonKey(name: 'train_loss', includeIfNull: false) this.trainLoss,
      @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
      this.trainMeanTokenAccuracy,
      @JsonKey(name: 'valid_loss', includeIfNull: false) this.validLoss,
      @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
      this.validMeanTokenAccuracy,
      @JsonKey(name: 'full_valid_loss', includeIfNull: false)
      this.fullValidLoss,
      @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
      this.fullValidMeanTokenAccuracy})
      : super._();

  factory _$FineTuningJobCheckpointMetricsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$FineTuningJobCheckpointMetricsImplFromJson(json);

  /// The step number that the metrics were recorded at.
  @override
  @JsonKey(includeIfNull: false)
  final double? step;

  /// The training loss at the step number.
  @override
  @JsonKey(name: 'train_loss', includeIfNull: false)
  final double? trainLoss;

  /// The training mean token accuracy at the step number.
  @override
  @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
  final double? trainMeanTokenAccuracy;

  /// The validation loss at the step number.
  @override
  @JsonKey(name: 'valid_loss', includeIfNull: false)
  final double? validLoss;

  /// The validation mean token accuracy at the step number.
  @override
  @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
  final double? validMeanTokenAccuracy;

  /// The full validation loss at the step number.
  @override
  @JsonKey(name: 'full_valid_loss', includeIfNull: false)
  final double? fullValidLoss;

  /// The full validation mean token accuracy at the step number.
  @override
  @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
  final double? fullValidMeanTokenAccuracy;

  @override
  String toString() {
    return 'FineTuningJobCheckpointMetrics(step: $step, trainLoss: $trainLoss, trainMeanTokenAccuracy: $trainMeanTokenAccuracy, validLoss: $validLoss, validMeanTokenAccuracy: $validMeanTokenAccuracy, fullValidLoss: $fullValidLoss, fullValidMeanTokenAccuracy: $fullValidMeanTokenAccuracy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FineTuningJobCheckpointMetricsImpl &&
            (identical(other.step, step) || other.step == step) &&
            (identical(other.trainLoss, trainLoss) ||
                other.trainLoss == trainLoss) &&
            (identical(other.trainMeanTokenAccuracy, trainMeanTokenAccuracy) ||
                other.trainMeanTokenAccuracy == trainMeanTokenAccuracy) &&
            (identical(other.validLoss, validLoss) ||
                other.validLoss == validLoss) &&
            (identical(other.validMeanTokenAccuracy, validMeanTokenAccuracy) ||
                other.validMeanTokenAccuracy == validMeanTokenAccuracy) &&
            (identical(other.fullValidLoss, fullValidLoss) ||
                other.fullValidLoss == fullValidLoss) &&
            (identical(other.fullValidMeanTokenAccuracy,
                    fullValidMeanTokenAccuracy) ||
                other.fullValidMeanTokenAccuracy ==
                    fullValidMeanTokenAccuracy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      step,
      trainLoss,
      trainMeanTokenAccuracy,
      validLoss,
      validMeanTokenAccuracy,
      fullValidLoss,
      fullValidMeanTokenAccuracy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FineTuningJobCheckpointMetricsImplCopyWith<
          _$FineTuningJobCheckpointMetricsImpl>
      get copyWith => __$$FineTuningJobCheckpointMetricsImplCopyWithImpl<
          _$FineTuningJobCheckpointMetricsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FineTuningJobCheckpointMetricsImplToJson(
      this,
    );
  }
}

abstract class _FineTuningJobCheckpointMetrics
    extends FineTuningJobCheckpointMetrics {
  const factory _FineTuningJobCheckpointMetrics(
          {@JsonKey(includeIfNull: false) final double? step,
          @JsonKey(name: 'train_loss', includeIfNull: false)
          final double? trainLoss,
          @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
          final double? trainMeanTokenAccuracy,
          @JsonKey(name: 'valid_loss', includeIfNull: false)
          final double? validLoss,
          @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
          final double? validMeanTokenAccuracy,
          @JsonKey(name: 'full_valid_loss', includeIfNull: false)
          final double? fullValidLoss,
          @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
          final double? fullValidMeanTokenAccuracy}) =
      _$FineTuningJobCheckpointMetricsImpl;
  const _FineTuningJobCheckpointMetrics._() : super._();

  factory _FineTuningJobCheckpointMetrics.fromJson(Map<String, dynamic> json) =
      _$FineTuningJobCheckpointMetricsImpl.fromJson;

  @override

  /// The step number that the metrics were recorded at.
  @JsonKey(includeIfNull: false)
  double? get step;
  @override

  /// The training loss at the step number.
  @JsonKey(name: 'train_loss', includeIfNull: false)
  double? get trainLoss;
  @override

  /// The training mean token accuracy at the step number.
  @JsonKey(name: 'train_mean_token_accuracy', includeIfNull: false)
  double? get trainMeanTokenAccuracy;
  @override

  /// The validation loss at the step number.
  @JsonKey(name: 'valid_loss', includeIfNull: false)
  double? get validLoss;
  @override

  /// The validation mean token accuracy at the step number.
  @JsonKey(name: 'valid_mean_token_accuracy', includeIfNull: false)
  double? get validMeanTokenAccuracy;
  @override

  /// The full validation loss at the step number.
  @JsonKey(name: 'full_valid_loss', includeIfNull: false)
  double? get fullValidLoss;
  @override

  /// The full validation mean token accuracy at the step number.
  @JsonKey(name: 'full_valid_mean_token_accuracy', includeIfNull: false)
  double? get fullValidMeanTokenAccuracy;
  @override
  @JsonKey(ignore: true)
  _$$FineTuningJobCheckpointMetricsImplCopyWith<
          _$FineTuningJobCheckpointMetricsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateImageRequest _$CreateImageRequestFromJson(Map<String, dynamic> json) {
  return _CreateImageRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateImageRequest {
  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  String get prompt => throw _privateConstructorUsedError;

  /// The model to use for image generation.
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateImageRequestModel? get model => throw _privateConstructorUsedError;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @JsonKey(includeIfNull: false)
  int? get n => throw _privateConstructorUsedError;

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  ImageQuality get quality => throw _privateConstructorUsedError;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat => throw _privateConstructorUsedError;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size => throw _privateConstructorUsedError;

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageStyle? get style => throw _privateConstructorUsedError;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateImageRequestCopyWith<CreateImageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateImageRequestCopyWith<$Res> {
  factory $CreateImageRequestCopyWith(
          CreateImageRequest value, $Res Function(CreateImageRequest) then) =
      _$CreateImageRequestCopyWithImpl<$Res, CreateImageRequest>;
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      ImageQuality quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class _$CreateImageRequestCopyWithImpl<$Res, $Val extends CreateImageRequest>
    implements $CreateImageRequestCopyWith<$Res> {
  _$CreateImageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = null,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateImageRequestModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $CreateImageRequestModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateImageRequestImplCopyWith<$Res>
    implements $CreateImageRequestCopyWith<$Res> {
  factory _$$CreateImageRequestImplCopyWith(_$CreateImageRequestImpl value,
          $Res Function(_$CreateImageRequestImpl) then) =
      __$$CreateImageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateImageRequestModel? model,
      @JsonKey(includeIfNull: false) int? n,
      ImageQuality quality,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageResponseFormat? responseFormat,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageSize? size,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      ImageStyle? style,
      @JsonKey(includeIfNull: false) String? user});

  @override
  $CreateImageRequestModelCopyWith<$Res>? get model;
}

/// @nodoc
class __$$CreateImageRequestImplCopyWithImpl<$Res>
    extends _$CreateImageRequestCopyWithImpl<$Res, _$CreateImageRequestImpl>
    implements _$$CreateImageRequestImplCopyWith<$Res> {
  __$$CreateImageRequestImplCopyWithImpl(_$CreateImageRequestImpl _value,
      $Res Function(_$CreateImageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? prompt = null,
    Object? model = freezed,
    Object? n = freezed,
    Object? quality = null,
    Object? responseFormat = freezed,
    Object? size = freezed,
    Object? style = freezed,
    Object? user = freezed,
  }) {
    return _then(_$CreateImageRequestImpl(
      prompt: null == prompt
          ? _value.prompt
          : prompt // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateImageRequestModel?,
      n: freezed == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as ImageQuality,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ImageResponseFormat?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ImageSize?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ImageStyle?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestImpl extends _CreateImageRequest {
  const _$CreateImageRequestImpl(
      {required this.prompt,
      @_CreateImageRequestModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const CreateImageRequestModelString('dall-e-2'),
      @JsonKey(includeIfNull: false) this.n = 1,
      this.quality = ImageQuality.standard,
      @JsonKey(
          name: 'response_format',
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.responseFormat = ImageResponseFormat.url,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.size = ImageSize.v1024x1024,
      @JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.style = ImageStyle.vivid,
      @JsonKey(includeIfNull: false) this.user})
      : super._();

  factory _$CreateImageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateImageRequestImplFromJson(json);

  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  @override
  final String prompt;

  /// The model to use for image generation.
  @override
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  final CreateImageRequestModel? model;

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @override
  @JsonKey(includeIfNull: false)
  final int? n;

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  @override
  @JsonKey()
  final ImageQuality quality;

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
  @override
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageResponseFormat? responseFormat;

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageSize? size;

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final ImageStyle? style;

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @override
  @JsonKey(includeIfNull: false)
  final String? user;

  @override
  String toString() {
    return 'CreateImageRequest(prompt: $prompt, model: $model, n: $n, quality: $quality, responseFormat: $responseFormat, size: $size, style: $style, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestImpl &&
            (identical(other.prompt, prompt) || other.prompt == prompt) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.user, user) || other.user == user));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, prompt, model, n, quality,
      responseFormat, size, style, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      __$$CreateImageRequestImplCopyWithImpl<_$CreateImageRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateImageRequest extends CreateImageRequest {
  const factory _CreateImageRequest(
          {required final String prompt,
          @_CreateImageRequestModelConverter()
          @JsonKey(includeIfNull: false)
          final CreateImageRequestModel? model,
          @JsonKey(includeIfNull: false) final int? n,
          final ImageQuality quality,
          @JsonKey(
              name: 'response_format',
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageResponseFormat? responseFormat,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageSize? size,
          @JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final ImageStyle? style,
          @JsonKey(includeIfNull: false) final String? user}) =
      _$CreateImageRequestImpl;
  const _CreateImageRequest._() : super._();

  factory _CreateImageRequest.fromJson(Map<String, dynamic> json) =
      _$CreateImageRequestImpl.fromJson;

  @override

  /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  String get prompt;
  @override

  /// The model to use for image generation.
  @_CreateImageRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateImageRequestModel? get model;
  @override

  /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
  @JsonKey(includeIfNull: false)
  int? get n;
  @override

  /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
  ImageQuality get quality;
  @override

  /// The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
  @JsonKey(
      name: 'response_format',
      includeIfNull: false,
      unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageResponseFormat? get responseFormat;
  @override

  /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageSize? get size;
  @override

  /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  ImageStyle? get style;
  @override

  /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  @JsonKey(includeIfNull: false)
  String? get user;
  @override
  @JsonKey(ignore: true)
  _$$CreateImageRequestImplCopyWith<_$CreateImageRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateImageRequestModel _$CreateImageRequestModelFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CreateImageRequestModelEnumeration.fromJson(json);
    case 'modelId':
      return CreateImageRequestModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateImageRequestModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateImageRequestModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateImageRequestModelCopyWith<$Res> {
  factory $CreateImageRequestModelCopyWith(CreateImageRequestModel value,
          $Res Function(CreateImageRequestModel) then) =
      _$CreateImageRequestModelCopyWithImpl<$Res, CreateImageRequestModel>;
}

/// @nodoc
class _$CreateImageRequestModelCopyWithImpl<$Res,
        $Val extends CreateImageRequestModel>
    implements $CreateImageRequestModelCopyWith<$Res> {
  _$CreateImageRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateImageRequestModelEnumerationImplCopyWith<$Res> {
  factory _$$CreateImageRequestModelEnumerationImplCopyWith(
          _$CreateImageRequestModelEnumerationImpl value,
          $Res Function(_$CreateImageRequestModelEnumerationImpl) then) =
      __$$CreateImageRequestModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ImageModels value});
}

/// @nodoc
class __$$CreateImageRequestModelEnumerationImplCopyWithImpl<$Res>
    extends _$CreateImageRequestModelCopyWithImpl<$Res,
        _$CreateImageRequestModelEnumerationImpl>
    implements _$$CreateImageRequestModelEnumerationImplCopyWith<$Res> {
  __$$CreateImageRequestModelEnumerationImplCopyWithImpl(
      _$CreateImageRequestModelEnumerationImpl _value,
      $Res Function(_$CreateImageRequestModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateImageRequestModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ImageModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestModelEnumerationImpl
    extends CreateImageRequestModelEnumeration {
  const _$CreateImageRequestModelEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$CreateImageRequestModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateImageRequestModelEnumerationImplFromJson(json);

  @override
  final ImageModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateImageRequestModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestModelEnumerationImplCopyWith<
          _$CreateImageRequestModelEnumerationImpl>
      get copyWith => __$$CreateImageRequestModelEnumerationImplCopyWithImpl<
          _$CreateImageRequestModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateImageRequestModelEnumeration
    extends CreateImageRequestModel {
  const factory CreateImageRequestModelEnumeration(final ImageModels value) =
      _$CreateImageRequestModelEnumerationImpl;
  const CreateImageRequestModelEnumeration._() : super._();

  factory CreateImageRequestModelEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateImageRequestModelEnumerationImpl.fromJson;

  @override
  ImageModels get value;
  @JsonKey(ignore: true)
  _$$CreateImageRequestModelEnumerationImplCopyWith<
          _$CreateImageRequestModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateImageRequestModelStringImplCopyWith<$Res> {
  factory _$$CreateImageRequestModelStringImplCopyWith(
          _$CreateImageRequestModelStringImpl value,
          $Res Function(_$CreateImageRequestModelStringImpl) then) =
      __$$CreateImageRequestModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CreateImageRequestModelStringImplCopyWithImpl<$Res>
    extends _$CreateImageRequestModelCopyWithImpl<$Res,
        _$CreateImageRequestModelStringImpl>
    implements _$$CreateImageRequestModelStringImplCopyWith<$Res> {
  __$$CreateImageRequestModelStringImplCopyWithImpl(
      _$CreateImageRequestModelStringImpl _value,
      $Res Function(_$CreateImageRequestModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateImageRequestModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateImageRequestModelStringImpl
    extends CreateImageRequestModelString {
  const _$CreateImageRequestModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$CreateImageRequestModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateImageRequestModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateImageRequestModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateImageRequestModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateImageRequestModelStringImplCopyWith<
          _$CreateImageRequestModelStringImpl>
      get copyWith => __$$CreateImageRequestModelStringImplCopyWithImpl<
          _$CreateImageRequestModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ImageModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ImageModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ImageModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateImageRequestModelEnumeration value) model,
    required TResult Function(CreateImageRequestModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateImageRequestModelEnumeration value)? model,
    TResult? Function(CreateImageRequestModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateImageRequestModelEnumeration value)? model,
    TResult Function(CreateImageRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateImageRequestModelStringImplToJson(
      this,
    );
  }
}

abstract class CreateImageRequestModelString extends CreateImageRequestModel {
  const factory CreateImageRequestModelString(final String value) =
      _$CreateImageRequestModelStringImpl;
  const CreateImageRequestModelString._() : super._();

  factory CreateImageRequestModelString.fromJson(Map<String, dynamic> json) =
      _$CreateImageRequestModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CreateImageRequestModelStringImplCopyWith<
          _$CreateImageRequestModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ImagesResponse _$ImagesResponseFromJson(Map<String, dynamic> json) {
  return _ImagesResponse.fromJson(json);
}

/// @nodoc
mixin _$ImagesResponse {
  /// The Unix timestamp (in seconds) when the image was created.
  int get created => throw _privateConstructorUsedError;

  /// The list of images generated by the model.
  List<Image> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImagesResponseCopyWith<ImagesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImagesResponseCopyWith<$Res> {
  factory $ImagesResponseCopyWith(
          ImagesResponse value, $Res Function(ImagesResponse) then) =
      _$ImagesResponseCopyWithImpl<$Res, ImagesResponse>;
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class _$ImagesResponseCopyWithImpl<$Res, $Val extends ImagesResponse>
    implements $ImagesResponseCopyWith<$Res> {
  _$ImagesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImagesResponseImplCopyWith<$Res>
    implements $ImagesResponseCopyWith<$Res> {
  factory _$$ImagesResponseImplCopyWith(_$ImagesResponseImpl value,
          $Res Function(_$ImagesResponseImpl) then) =
      __$$ImagesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int created, List<Image> data});
}

/// @nodoc
class __$$ImagesResponseImplCopyWithImpl<$Res>
    extends _$ImagesResponseCopyWithImpl<$Res, _$ImagesResponseImpl>
    implements _$$ImagesResponseImplCopyWith<$Res> {
  __$$ImagesResponseImplCopyWithImpl(
      _$ImagesResponseImpl _value, $Res Function(_$ImagesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? created = null,
    Object? data = null,
  }) {
    return _then(_$ImagesResponseImpl(
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Image>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImagesResponseImpl extends _ImagesResponse {
  const _$ImagesResponseImpl(
      {required this.created, required final List<Image> data})
      : _data = data,
        super._();

  factory _$ImagesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImagesResponseImplFromJson(json);

  /// The Unix timestamp (in seconds) when the image was created.
  @override
  final int created;

  /// The list of images generated by the model.
  final List<Image> _data;

  /// The list of images generated by the model.
  @override
  List<Image> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ImagesResponse(created: $created, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImagesResponseImpl &&
            (identical(other.created, created) || other.created == created) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, created, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      __$$ImagesResponseImplCopyWithImpl<_$ImagesResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImagesResponseImplToJson(
      this,
    );
  }
}

abstract class _ImagesResponse extends ImagesResponse {
  const factory _ImagesResponse(
      {required final int created,
      required final List<Image> data}) = _$ImagesResponseImpl;
  const _ImagesResponse._() : super._();

  factory _ImagesResponse.fromJson(Map<String, dynamic> json) =
      _$ImagesResponseImpl.fromJson;

  @override

  /// The Unix timestamp (in seconds) when the image was created.
  int get created;
  @override

  /// The list of images generated by the model.
  List<Image> get data;
  @override
  @JsonKey(ignore: true)
  _$$ImagesResponseImplCopyWith<_$ImagesResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Image _$ImageFromJson(Map<String, dynamic> json) {
  return _Image.fromJson(json);
}

/// @nodoc
mixin _$Image {
  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json => throw _privateConstructorUsedError;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url => throw _privateConstructorUsedError;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  String? get revisedPrompt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageCopyWith<Image> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageCopyWith<$Res> {
  factory $ImageCopyWith(Image value, $Res Function(Image) then) =
      _$ImageCopyWithImpl<$Res, Image>;
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class _$ImageCopyWithImpl<$Res, $Val extends Image>
    implements $ImageCopyWith<$Res> {
  _$ImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_value.copyWith(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _value.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageImplCopyWith<$Res> implements $ImageCopyWith<$Res> {
  factory _$$ImageImplCopyWith(
          _$ImageImpl value, $Res Function(_$ImageImpl) then) =
      __$$ImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'b64_json', includeIfNull: false) String? b64Json,
      @JsonKey(includeIfNull: false) String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      String? revisedPrompt});
}

/// @nodoc
class __$$ImageImplCopyWithImpl<$Res>
    extends _$ImageCopyWithImpl<$Res, _$ImageImpl>
    implements _$$ImageImplCopyWith<$Res> {
  __$$ImageImplCopyWithImpl(
      _$ImageImpl _value, $Res Function(_$ImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? b64Json = freezed,
    Object? url = freezed,
    Object? revisedPrompt = freezed,
  }) {
    return _then(_$ImageImpl(
      b64Json: freezed == b64Json
          ? _value.b64Json
          : b64Json // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      revisedPrompt: freezed == revisedPrompt
          ? _value.revisedPrompt
          : revisedPrompt // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageImpl extends _Image {
  const _$ImageImpl(
      {@JsonKey(name: 'b64_json', includeIfNull: false) this.b64Json,
      @JsonKey(includeIfNull: false) this.url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      this.revisedPrompt})
      : super._();

  factory _$ImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImageImplFromJson(json);

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @override
  @JsonKey(name: 'b64_json', includeIfNull: false)
  final String? b64Json;

  /// The URL of the generated image, if `response_format` is `url` (default).
  @override
  @JsonKey(includeIfNull: false)
  final String? url;

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @override
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  final String? revisedPrompt;

  @override
  String toString() {
    return 'Image(b64Json: $b64Json, url: $url, revisedPrompt: $revisedPrompt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageImpl &&
            (identical(other.b64Json, b64Json) || other.b64Json == b64Json) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.revisedPrompt, revisedPrompt) ||
                other.revisedPrompt == revisedPrompt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, b64Json, url, revisedPrompt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      __$$ImageImplCopyWithImpl<_$ImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageImplToJson(
      this,
    );
  }
}

abstract class _Image extends Image {
  const factory _Image(
      {@JsonKey(name: 'b64_json', includeIfNull: false) final String? b64Json,
      @JsonKey(includeIfNull: false) final String? url,
      @JsonKey(name: 'revised_prompt', includeIfNull: false)
      final String? revisedPrompt}) = _$ImageImpl;
  const _Image._() : super._();

  factory _Image.fromJson(Map<String, dynamic> json) = _$ImageImpl.fromJson;

  @override

  /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
  @JsonKey(name: 'b64_json', includeIfNull: false)
  String? get b64Json;
  @override

  /// The URL of the generated image, if `response_format` is `url` (default).
  @JsonKey(includeIfNull: false)
  String? get url;
  @override

  /// The prompt that was used to generate the image, if there was any revision to the prompt.
  @JsonKey(name: 'revised_prompt', includeIfNull: false)
  String? get revisedPrompt;
  @override
  @JsonKey(ignore: true)
  _$$ImageImplCopyWith<_$ImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Model _$ModelFromJson(Map<String, dynamic> json) {
  return _Model.fromJson(json);
}

/// @nodoc
mixin _$Model {
  /// The model identifier, which can be referenced in the API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) when the model was created.
  int get created => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  ModelObject get object => throw _privateConstructorUsedError;

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModelCopyWith<Model> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) then) =
      _$ModelCopyWithImpl<$Res, Model>;
  @useResult
  $Res call(
      {String id,
      int created,
      ModelObject object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class _$ModelCopyWithImpl<$Res, $Val extends Model>
    implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModelImplCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$$ModelImplCopyWith(
          _$ModelImpl value, $Res Function(_$ModelImpl) then) =
      __$$ModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      int created,
      ModelObject object,
      @JsonKey(name: 'owned_by') String ownedBy});
}

/// @nodoc
class __$$ModelImplCopyWithImpl<$Res>
    extends _$ModelCopyWithImpl<$Res, _$ModelImpl>
    implements _$$ModelImplCopyWith<$Res> {
  __$$ModelImplCopyWithImpl(
      _$ModelImpl _value, $Res Function(_$ModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? object = null,
    Object? ownedBy = null,
  }) {
    return _then(_$ModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ModelObject,
      ownedBy: null == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModelImpl extends _Model {
  const _$ModelImpl(
      {required this.id,
      required this.created,
      required this.object,
      @JsonKey(name: 'owned_by') required this.ownedBy})
      : super._();

  factory _$ModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModelImplFromJson(json);

  /// The model identifier, which can be referenced in the API endpoints.
  @override
  final String id;

  /// The Unix timestamp (in seconds) when the model was created.
  @override
  final int created;

  /// The object type, which is always "model".
  @override
  final ModelObject object;

  /// The organization that owns the model.
  @override
  @JsonKey(name: 'owned_by')
  final String ownedBy;

  @override
  String toString() {
    return 'Model(id: $id, created: $created, object: $object, ownedBy: $ownedBy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.ownedBy, ownedBy) || other.ownedBy == ownedBy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, created, object, ownedBy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      __$$ModelImplCopyWithImpl<_$ModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModelImplToJson(
      this,
    );
  }
}

abstract class _Model extends Model {
  const factory _Model(
      {required final String id,
      required final int created,
      required final ModelObject object,
      @JsonKey(name: 'owned_by') required final String ownedBy}) = _$ModelImpl;
  const _Model._() : super._();

  factory _Model.fromJson(Map<String, dynamic> json) = _$ModelImpl.fromJson;

  @override

  /// The model identifier, which can be referenced in the API endpoints.
  String get id;
  @override

  /// The Unix timestamp (in seconds) when the model was created.
  int get created;
  @override

  /// The object type, which is always "model".
  ModelObject get object;
  @override

  /// The organization that owns the model.
  @JsonKey(name: 'owned_by')
  String get ownedBy;
  @override
  @JsonKey(ignore: true)
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListModelsResponse _$ListModelsResponseFromJson(Map<String, dynamic> json) {
  return _ListModelsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListModelsResponse {
  /// The object type, which is always "list".
  ListModelsResponseObject get object => throw _privateConstructorUsedError;

  /// The list of models.
  List<Model> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListModelsResponseCopyWith<ListModelsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListModelsResponseCopyWith<$Res> {
  factory $ListModelsResponseCopyWith(
          ListModelsResponse value, $Res Function(ListModelsResponse) then) =
      _$ListModelsResponseCopyWithImpl<$Res, ListModelsResponse>;
  @useResult
  $Res call({ListModelsResponseObject object, List<Model> data});
}

/// @nodoc
class _$ListModelsResponseCopyWithImpl<$Res, $Val extends ListModelsResponse>
    implements $ListModelsResponseCopyWith<$Res> {
  _$ListModelsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListModelsResponseImplCopyWith<$Res>
    implements $ListModelsResponseCopyWith<$Res> {
  factory _$$ListModelsResponseImplCopyWith(_$ListModelsResponseImpl value,
          $Res Function(_$ListModelsResponseImpl) then) =
      __$$ListModelsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ListModelsResponseObject object, List<Model> data});
}

/// @nodoc
class __$$ListModelsResponseImplCopyWithImpl<$Res>
    extends _$ListModelsResponseCopyWithImpl<$Res, _$ListModelsResponseImpl>
    implements _$$ListModelsResponseImplCopyWith<$Res> {
  __$$ListModelsResponseImplCopyWithImpl(_$ListModelsResponseImpl _value,
      $Res Function(_$ListModelsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
  }) {
    return _then(_$ListModelsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListModelsResponseObject,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Model>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListModelsResponseImpl extends _ListModelsResponse {
  const _$ListModelsResponseImpl(
      {required this.object, required final List<Model> data})
      : _data = data,
        super._();

  factory _$ListModelsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListModelsResponseImplFromJson(json);

  /// The object type, which is always "list".
  @override
  final ListModelsResponseObject object;

  /// The list of models.
  final List<Model> _data;

  /// The list of models.
  @override
  List<Model> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'ListModelsResponse(object: $object, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListModelsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      __$$ListModelsResponseImplCopyWithImpl<_$ListModelsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListModelsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListModelsResponse extends ListModelsResponse {
  const factory _ListModelsResponse(
      {required final ListModelsResponseObject object,
      required final List<Model> data}) = _$ListModelsResponseImpl;
  const _ListModelsResponse._() : super._();

  factory _ListModelsResponse.fromJson(Map<String, dynamic> json) =
      _$ListModelsResponseImpl.fromJson;

  @override

  /// The object type, which is always "list".
  ListModelsResponseObject get object;
  @override

  /// The list of models.
  List<Model> get data;
  @override
  @JsonKey(ignore: true)
  _$$ListModelsResponseImplCopyWith<_$ListModelsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeleteModelResponse _$DeleteModelResponseFromJson(Map<String, dynamic> json) {
  return _DeleteModelResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteModelResponse {
  /// The model identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the model was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always "model".
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteModelResponseCopyWith<DeleteModelResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteModelResponseCopyWith<$Res> {
  factory $DeleteModelResponseCopyWith(
          DeleteModelResponse value, $Res Function(DeleteModelResponse) then) =
      _$DeleteModelResponseCopyWithImpl<$Res, DeleteModelResponse>;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteModelResponseCopyWithImpl<$Res, $Val extends DeleteModelResponse>
    implements $DeleteModelResponseCopyWith<$Res> {
  _$DeleteModelResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteModelResponseImplCopyWith<$Res>
    implements $DeleteModelResponseCopyWith<$Res> {
  factory _$$DeleteModelResponseImplCopyWith(_$DeleteModelResponseImpl value,
          $Res Function(_$DeleteModelResponseImpl) then) =
      __$$DeleteModelResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$$DeleteModelResponseImplCopyWithImpl<$Res>
    extends _$DeleteModelResponseCopyWithImpl<$Res, _$DeleteModelResponseImpl>
    implements _$$DeleteModelResponseImplCopyWith<$Res> {
  __$$DeleteModelResponseImplCopyWithImpl(_$DeleteModelResponseImpl _value,
      $Res Function(_$DeleteModelResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteModelResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteModelResponseImpl extends _DeleteModelResponse {
  const _$DeleteModelResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteModelResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteModelResponseImplFromJson(json);

  /// The model identifier.
  @override
  final String id;

  /// Whether the model was deleted.
  @override
  final bool deleted;

  /// The object type, which is always "model".
  @override
  final String object;

  @override
  String toString() {
    return 'DeleteModelResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteModelResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      __$$DeleteModelResponseImplCopyWithImpl<_$DeleteModelResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteModelResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteModelResponse extends DeleteModelResponse {
  const factory _DeleteModelResponse(
      {required final String id,
      required final bool deleted,
      required final String object}) = _$DeleteModelResponseImpl;
  const _DeleteModelResponse._() : super._();

  factory _DeleteModelResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteModelResponseImpl.fromJson;

  @override

  /// The model identifier.
  String get id;
  @override

  /// Whether the model was deleted.
  bool get deleted;
  @override

  /// The object type, which is always "model".
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteModelResponseImplCopyWith<_$DeleteModelResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateModerationRequest _$CreateModerationRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationRequest {
  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model => throw _privateConstructorUsedError;

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationRequestCopyWith<CreateModerationRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationRequestCopyWith<$Res> {
  factory $CreateModerationRequestCopyWith(CreateModerationRequest value,
          $Res Function(CreateModerationRequest) then) =
      _$CreateModerationRequestCopyWithImpl<$Res, CreateModerationRequest>;
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  $ModerationModelCopyWith<$Res>? get model;
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class _$CreateModerationRequestCopyWithImpl<$Res,
        $Val extends CreateModerationRequest>
    implements $CreateModerationRequestCopyWith<$Res> {
  _$CreateModerationRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_value.copyWith(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $ModerationModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationInputCopyWith<$Res> get input {
    return $ModerationInputCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateModerationRequestImplCopyWith<$Res>
    implements $CreateModerationRequestCopyWith<$Res> {
  factory _$$CreateModerationRequestImplCopyWith(
          _$CreateModerationRequestImpl value,
          $Res Function(_$CreateModerationRequestImpl) then) =
      __$$CreateModerationRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      ModerationModel? model,
      @_ModerationInputConverter() ModerationInput input});

  @override
  $ModerationModelCopyWith<$Res>? get model;
  @override
  $ModerationInputCopyWith<$Res> get input;
}

/// @nodoc
class __$$CreateModerationRequestImplCopyWithImpl<$Res>
    extends _$CreateModerationRequestCopyWithImpl<$Res,
        _$CreateModerationRequestImpl>
    implements _$$CreateModerationRequestImplCopyWith<$Res> {
  __$$CreateModerationRequestImplCopyWithImpl(
      _$CreateModerationRequestImpl _value,
      $Res Function(_$CreateModerationRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? input = null,
  }) {
    return _then(_$CreateModerationRequestImpl(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ModerationModel?,
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as ModerationInput,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationRequestImpl extends _CreateModerationRequest {
  const _$CreateModerationRequestImpl(
      {@_ModerationModelConverter()
      @JsonKey(includeIfNull: false)
      this.model = const ModerationModelString('text-moderation-latest'),
      @_ModerationInputConverter() required this.input})
      : super._();

  factory _$CreateModerationRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationRequestImplFromJson(json);

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @override
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  final ModerationModel? model;

  /// The input text to classify
  @override
  @_ModerationInputConverter()
  final ModerationInput input;

  @override
  String toString() {
    return 'CreateModerationRequest(model: $model, input: $input)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.input, input) || other.input == input));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, model, input);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => __$$CreateModerationRequestImplCopyWithImpl<
          _$CreateModerationRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationRequest extends CreateModerationRequest {
  const factory _CreateModerationRequest(
          {@_ModerationModelConverter()
          @JsonKey(includeIfNull: false)
          final ModerationModel? model,
          @_ModerationInputConverter() required final ModerationInput input}) =
      _$CreateModerationRequestImpl;
  const _CreateModerationRequest._() : super._();

  factory _CreateModerationRequest.fromJson(Map<String, dynamic> json) =
      _$CreateModerationRequestImpl.fromJson;

  @override

  /// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.
  ///
  /// The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`.
  @_ModerationModelConverter()
  @JsonKey(includeIfNull: false)
  ModerationModel? get model;
  @override

  /// The input text to classify
  @_ModerationInputConverter()
  ModerationInput get input;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationRequestImplCopyWith<_$CreateModerationRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationModel _$ModerationModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ModerationModelEnumeration.fromJson(json);
    case 'modelId':
      return ModerationModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationModelCopyWith<$Res> {
  factory $ModerationModelCopyWith(
          ModerationModel value, $Res Function(ModerationModel) then) =
      _$ModerationModelCopyWithImpl<$Res, ModerationModel>;
}

/// @nodoc
class _$ModerationModelCopyWithImpl<$Res, $Val extends ModerationModel>
    implements $ModerationModelCopyWith<$Res> {
  _$ModerationModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ModerationModelEnumerationImplCopyWith<$Res> {
  factory _$$ModerationModelEnumerationImplCopyWith(
          _$ModerationModelEnumerationImpl value,
          $Res Function(_$ModerationModelEnumerationImpl) then) =
      __$$ModerationModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ModerationModels value});
}

/// @nodoc
class __$$ModerationModelEnumerationImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res,
        _$ModerationModelEnumerationImpl>
    implements _$$ModerationModelEnumerationImplCopyWith<$Res> {
  __$$ModerationModelEnumerationImplCopyWithImpl(
      _$ModerationModelEnumerationImpl _value,
      $Res Function(_$ModerationModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ModerationModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationModelEnumerationImpl extends ModerationModelEnumeration {
  const _$ModerationModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$ModerationModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModerationModelEnumerationImplFromJson(json);

  @override
  final ModerationModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationModelEnumerationImplCopyWith<_$ModerationModelEnumerationImpl>
      get copyWith => __$$ModerationModelEnumerationImplCopyWithImpl<
          _$ModerationModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class ModerationModelEnumeration extends ModerationModel {
  const factory ModerationModelEnumeration(final ModerationModels value) =
      _$ModerationModelEnumerationImpl;
  const ModerationModelEnumeration._() : super._();

  factory ModerationModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$ModerationModelEnumerationImpl.fromJson;

  @override
  ModerationModels get value;
  @JsonKey(ignore: true)
  _$$ModerationModelEnumerationImplCopyWith<_$ModerationModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModerationModelStringImplCopyWith<$Res> {
  factory _$$ModerationModelStringImplCopyWith(
          _$ModerationModelStringImpl value,
          $Res Function(_$ModerationModelStringImpl) then) =
      __$$ModerationModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ModerationModelStringImplCopyWithImpl<$Res>
    extends _$ModerationModelCopyWithImpl<$Res, _$ModerationModelStringImpl>
    implements _$$ModerationModelStringImplCopyWith<$Res> {
  __$$ModerationModelStringImplCopyWithImpl(_$ModerationModelStringImpl _value,
      $Res Function(_$ModerationModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationModelStringImpl extends ModerationModelString {
  const _$ModerationModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$ModerationModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationModelStringImplCopyWith<_$ModerationModelStringImpl>
      get copyWith => __$$ModerationModelStringImplCopyWithImpl<
          _$ModerationModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModerationModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModerationModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModerationModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationModelEnumeration value) model,
    required TResult Function(ModerationModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationModelEnumeration value)? model,
    TResult? Function(ModerationModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationModelEnumeration value)? model,
    TResult Function(ModerationModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationModelStringImplToJson(
      this,
    );
  }
}

abstract class ModerationModelString extends ModerationModel {
  const factory ModerationModelString(final String value) =
      _$ModerationModelStringImpl;
  const ModerationModelString._() : super._();

  factory ModerationModelString.fromJson(Map<String, dynamic> json) =
      _$ModerationModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ModerationModelStringImplCopyWith<_$ModerationModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationInput _$ModerationInputFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'listString':
      return ModerationInputListString.fromJson(json);
    case 'string':
      return ModerationInputString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ModerationInput',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModerationInput {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationInputCopyWith<$Res> {
  factory $ModerationInputCopyWith(
          ModerationInput value, $Res Function(ModerationInput) then) =
      _$ModerationInputCopyWithImpl<$Res, ModerationInput>;
}

/// @nodoc
class _$ModerationInputCopyWithImpl<$Res, $Val extends ModerationInput>
    implements $ModerationInputCopyWith<$Res> {
  _$ModerationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ModerationInputListStringImplCopyWith<$Res> {
  factory _$$ModerationInputListStringImplCopyWith(
          _$ModerationInputListStringImpl value,
          $Res Function(_$ModerationInputListStringImpl) then) =
      __$$ModerationInputListStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> value});
}

/// @nodoc
class __$$ModerationInputListStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res, _$ModerationInputListStringImpl>
    implements _$$ModerationInputListStringImplCopyWith<$Res> {
  __$$ModerationInputListStringImplCopyWithImpl(
      _$ModerationInputListStringImpl _value,
      $Res Function(_$ModerationInputListStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationInputListStringImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationInputListStringImpl extends ModerationInputListString {
  const _$ModerationInputListStringImpl(final List<String> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'listString',
        super._();

  factory _$ModerationInputListStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationInputListStringImplFromJson(json);

  final List<String> _value;
  @override
  List<String> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.listString(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationInputListStringImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationInputListStringImplCopyWith<_$ModerationInputListStringImpl>
      get copyWith => __$$ModerationInputListStringImplCopyWithImpl<
          _$ModerationInputListStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return listString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return listString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) {
    return listString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) {
    return listString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (listString != null) {
      return listString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationInputListStringImplToJson(
      this,
    );
  }
}

abstract class ModerationInputListString extends ModerationInput {
  const factory ModerationInputListString(final List<String> value) =
      _$ModerationInputListStringImpl;
  const ModerationInputListString._() : super._();

  factory ModerationInputListString.fromJson(Map<String, dynamic> json) =
      _$ModerationInputListStringImpl.fromJson;

  @override
  List<String> get value;
  @JsonKey(ignore: true)
  _$$ModerationInputListStringImplCopyWith<_$ModerationInputListStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModerationInputStringImplCopyWith<$Res> {
  factory _$$ModerationInputStringImplCopyWith(
          _$ModerationInputStringImpl value,
          $Res Function(_$ModerationInputStringImpl) then) =
      __$$ModerationInputStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ModerationInputStringImplCopyWithImpl<$Res>
    extends _$ModerationInputCopyWithImpl<$Res, _$ModerationInputStringImpl>
    implements _$$ModerationInputStringImplCopyWith<$Res> {
  __$$ModerationInputStringImplCopyWithImpl(_$ModerationInputStringImpl _value,
      $Res Function(_$ModerationInputStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModerationInputStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationInputStringImpl extends ModerationInputString {
  const _$ModerationInputStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ModerationInputStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationInputStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModerationInput.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationInputStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationInputStringImplCopyWith<_$ModerationInputStringImpl>
      get copyWith => __$$ModerationInputStringImplCopyWithImpl<
          _$ModerationInputStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> value) listString,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> value)? listString,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> value)? listString,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ModerationInputListString value) listString,
    required TResult Function(ModerationInputString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModerationInputListString value)? listString,
    TResult? Function(ModerationInputString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModerationInputListString value)? listString,
    TResult Function(ModerationInputString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationInputStringImplToJson(
      this,
    );
  }
}

abstract class ModerationInputString extends ModerationInput {
  const factory ModerationInputString(final String value) =
      _$ModerationInputStringImpl;
  const ModerationInputString._() : super._();

  factory ModerationInputString.fromJson(Map<String, dynamic> json) =
      _$ModerationInputStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ModerationInputStringImplCopyWith<_$ModerationInputStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateModerationResponse _$CreateModerationResponseFromJson(
    Map<String, dynamic> json) {
  return _CreateModerationResponse.fromJson(json);
}

/// @nodoc
mixin _$CreateModerationResponse {
  /// The unique identifier for the moderation request.
  String get id => throw _privateConstructorUsedError;

  /// The model used to generate the moderation results.
  String get model => throw _privateConstructorUsedError;

  /// A list of moderation objects.
  List<Moderation> get results => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateModerationResponseCopyWith<CreateModerationResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateModerationResponseCopyWith<$Res> {
  factory $CreateModerationResponseCopyWith(CreateModerationResponse value,
          $Res Function(CreateModerationResponse) then) =
      _$CreateModerationResponseCopyWithImpl<$Res, CreateModerationResponse>;
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class _$CreateModerationResponseCopyWithImpl<$Res,
        $Val extends CreateModerationResponse>
    implements $CreateModerationResponseCopyWith<$Res> {
  _$CreateModerationResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value.results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateModerationResponseImplCopyWith<$Res>
    implements $CreateModerationResponseCopyWith<$Res> {
  factory _$$CreateModerationResponseImplCopyWith(
          _$CreateModerationResponseImpl value,
          $Res Function(_$CreateModerationResponseImpl) then) =
      __$$CreateModerationResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String model, List<Moderation> results});
}

/// @nodoc
class __$$CreateModerationResponseImplCopyWithImpl<$Res>
    extends _$CreateModerationResponseCopyWithImpl<$Res,
        _$CreateModerationResponseImpl>
    implements _$$CreateModerationResponseImplCopyWith<$Res> {
  __$$CreateModerationResponseImplCopyWithImpl(
      _$CreateModerationResponseImpl _value,
      $Res Function(_$CreateModerationResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? model = null,
    Object? results = null,
  }) {
    return _then(_$CreateModerationResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      results: null == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<Moderation>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateModerationResponseImpl extends _CreateModerationResponse {
  const _$CreateModerationResponseImpl(
      {required this.id,
      required this.model,
      required final List<Moderation> results})
      : _results = results,
        super._();

  factory _$CreateModerationResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateModerationResponseImplFromJson(json);

  /// The unique identifier for the moderation request.
  @override
  final String id;

  /// The model used to generate the moderation results.
  @override
  final String model;

  /// A list of moderation objects.
  final List<Moderation> _results;

  /// A list of moderation objects.
  @override
  List<Moderation> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  @override
  String toString() {
    return 'CreateModerationResponse(id: $id, model: $model, results: $results)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateModerationResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.model, model) || other.model == model) &&
            const DeepCollectionEquality().equals(other._results, _results));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, model, const DeepCollectionEquality().hash(_results));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => __$$CreateModerationResponseImplCopyWithImpl<
          _$CreateModerationResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateModerationResponseImplToJson(
      this,
    );
  }
}

abstract class _CreateModerationResponse extends CreateModerationResponse {
  const factory _CreateModerationResponse(
          {required final String id,
          required final String model,
          required final List<Moderation> results}) =
      _$CreateModerationResponseImpl;
  const _CreateModerationResponse._() : super._();

  factory _CreateModerationResponse.fromJson(Map<String, dynamic> json) =
      _$CreateModerationResponseImpl.fromJson;

  @override

  /// The unique identifier for the moderation request.
  String get id;
  @override

  /// The model used to generate the moderation results.
  String get model;
  @override

  /// A list of moderation objects.
  List<Moderation> get results;
  @override
  @JsonKey(ignore: true)
  _$$CreateModerationResponseImplCopyWith<_$CreateModerationResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Moderation _$ModerationFromJson(Map<String, dynamic> json) {
  return _Moderation.fromJson(json);
}

/// @nodoc
mixin _$Moderation {
  /// Whether any of the below categories are flagged.
  bool get flagged => throw _privateConstructorUsedError;

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories => throw _privateConstructorUsedError;

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCopyWith<Moderation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCopyWith<$Res> {
  factory $ModerationCopyWith(
          Moderation value, $Res Function(Moderation) then) =
      _$ModerationCopyWithImpl<$Res, Moderation>;
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  $ModerationCategoriesCopyWith<$Res> get categories;
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class _$ModerationCopyWithImpl<$Res, $Val extends Moderation>
    implements $ModerationCopyWith<$Res> {
  _$ModerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_value.copyWith(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesCopyWith<$Res> get categories {
    return $ModerationCategoriesCopyWith<$Res>(_value.categories, (value) {
      return _then(_value.copyWith(categories: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores {
    return $ModerationCategoriesScoresCopyWith<$Res>(_value.categoryScores,
        (value) {
      return _then(_value.copyWith(categoryScores: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModerationImplCopyWith<$Res>
    implements $ModerationCopyWith<$Res> {
  factory _$$ModerationImplCopyWith(
          _$ModerationImpl value, $Res Function(_$ModerationImpl) then) =
      __$$ModerationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool flagged,
      ModerationCategories categories,
      @JsonKey(name: 'category_scores')
      ModerationCategoriesScores categoryScores});

  @override
  $ModerationCategoriesCopyWith<$Res> get categories;
  @override
  $ModerationCategoriesScoresCopyWith<$Res> get categoryScores;
}

/// @nodoc
class __$$ModerationImplCopyWithImpl<$Res>
    extends _$ModerationCopyWithImpl<$Res, _$ModerationImpl>
    implements _$$ModerationImplCopyWith<$Res> {
  __$$ModerationImplCopyWithImpl(
      _$ModerationImpl _value, $Res Function(_$ModerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flagged = null,
    Object? categories = null,
    Object? categoryScores = null,
  }) {
    return _then(_$ModerationImpl(
      flagged: null == flagged
          ? _value.flagged
          : flagged // ignore: cast_nullable_to_non_nullable
              as bool,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as ModerationCategories,
      categoryScores: null == categoryScores
          ? _value.categoryScores
          : categoryScores // ignore: cast_nullable_to_non_nullable
              as ModerationCategoriesScores,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationImpl extends _Moderation {
  const _$ModerationImpl(
      {required this.flagged,
      required this.categories,
      @JsonKey(name: 'category_scores') required this.categoryScores})
      : super._();

  factory _$ModerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationImplFromJson(json);

  /// Whether any of the below categories are flagged.
  @override
  final bool flagged;

  /// A list of the categories, and whether they are flagged or not.
  @override
  final ModerationCategories categories;

  /// A list of the categories along with their scores as predicted by model.
  @override
  @JsonKey(name: 'category_scores')
  final ModerationCategoriesScores categoryScores;

  @override
  String toString() {
    return 'Moderation(flagged: $flagged, categories: $categories, categoryScores: $categoryScores)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationImpl &&
            (identical(other.flagged, flagged) || other.flagged == flagged) &&
            (identical(other.categories, categories) ||
                other.categories == categories) &&
            (identical(other.categoryScores, categoryScores) ||
                other.categoryScores == categoryScores));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, flagged, categories, categoryScores);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      __$$ModerationImplCopyWithImpl<_$ModerationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationImplToJson(
      this,
    );
  }
}

abstract class _Moderation extends Moderation {
  const factory _Moderation(
          {required final bool flagged,
          required final ModerationCategories categories,
          @JsonKey(name: 'category_scores')
          required final ModerationCategoriesScores categoryScores}) =
      _$ModerationImpl;
  const _Moderation._() : super._();

  factory _Moderation.fromJson(Map<String, dynamic> json) =
      _$ModerationImpl.fromJson;

  @override

  /// Whether any of the below categories are flagged.
  bool get flagged;
  @override

  /// A list of the categories, and whether they are flagged or not.
  ModerationCategories get categories;
  @override

  /// A list of the categories along with their scores as predicted by model.
  @JsonKey(name: 'category_scores')
  ModerationCategoriesScores get categoryScores;
  @override
  @JsonKey(ignore: true)
  _$$ModerationImplCopyWith<_$ModerationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModerationCategories _$ModerationCategoriesFromJson(Map<String, dynamic> json) {
  return _ModerationCategories.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategories {
  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  bool get hate => throw _privateConstructorUsedError;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening => throw _privateConstructorUsedError;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment => throw _privateConstructorUsedError;

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening => throw _privateConstructorUsedError;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm => throw _privateConstructorUsedError;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent => throw _privateConstructorUsedError;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions => throw _privateConstructorUsedError;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual => throw _privateConstructorUsedError;

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury.
  bool get violence => throw _privateConstructorUsedError;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesCopyWith<ModerationCategories> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesCopyWith<$Res> {
  factory $ModerationCategoriesCopyWith(ModerationCategories value,
          $Res Function(ModerationCategories) then) =
      _$ModerationCategoriesCopyWithImpl<$Res, ModerationCategories>;
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesCopyWithImpl<$Res,
        $Val extends ModerationCategories>
    implements $ModerationCategoriesCopyWith<$Res> {
  _$ModerationCategoriesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesImplCopyWith<$Res>
    implements $ModerationCategoriesCopyWith<$Res> {
  factory _$$ModerationCategoriesImplCopyWith(_$ModerationCategoriesImpl value,
          $Res Function(_$ModerationCategoriesImpl) then) =
      __$$ModerationCategoriesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool hate,
      @JsonKey(name: 'hate/threatening') bool hateThreatening,
      bool harassment,
      @JsonKey(name: 'harassment/threatening') bool harassmentThreatening,
      @JsonKey(name: 'self-harm') bool selfHarm,
      @JsonKey(name: 'self-harm/intent') bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') bool selfHarmInstructions,
      bool sexual,
      @JsonKey(name: 'sexual/minors') bool sexualMinors,
      bool violence,
      @JsonKey(name: 'violence/graphic') bool violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesCopyWithImpl<$Res, _$ModerationCategoriesImpl>
    implements _$$ModerationCategoriesImplCopyWith<$Res> {
  __$$ModerationCategoriesImplCopyWithImpl(_$ModerationCategoriesImpl _value,
      $Res Function(_$ModerationCategoriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as bool,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as bool,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as bool,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as bool,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as bool,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as bool,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as bool,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesImpl extends _ModerationCategories {
  const _$ModerationCategoriesImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModerationCategoriesImplFromJson(json);

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  @override
  final bool hate;

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @override
  @JsonKey(name: 'hate/threatening')
  final bool hateThreatening;

  /// Content that expresses, incites, or promotes harassing language towards any target.
  @override
  final bool harassment;

  /// Harassment content that also includes violence or serious harm towards any target.
  @override
  @JsonKey(name: 'harassment/threatening')
  final bool harassmentThreatening;

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm')
  final bool selfHarm;

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @override
  @JsonKey(name: 'self-harm/intent')
  final bool selfHarmIntent;

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final bool selfHarmInstructions;

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  @override
  final bool sexual;

  /// Sexual content that includes an individual who is under 18 years old.
  @override
  @JsonKey(name: 'sexual/minors')
  final bool sexualMinors;

  /// Content that depicts death, violence, or physical injury.
  @override
  final bool violence;

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @override
  @JsonKey(name: 'violence/graphic')
  final bool violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategories(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith =>
          __$$ModerationCategoriesImplCopyWithImpl<_$ModerationCategoriesImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategories extends ModerationCategories {
  const factory _ModerationCategories(
      {required final bool hate,
      @JsonKey(name: 'hate/threatening') required final bool hateThreatening,
      required final bool harassment,
      @JsonKey(name: 'harassment/threatening')
      required final bool harassmentThreatening,
      @JsonKey(name: 'self-harm') required final bool selfHarm,
      @JsonKey(name: 'self-harm/intent') required final bool selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final bool selfHarmInstructions,
      required final bool sexual,
      @JsonKey(name: 'sexual/minors') required final bool sexualMinors,
      required final bool violence,
      @JsonKey(name: 'violence/graphic')
      required final bool violenceGraphic}) = _$ModerationCategoriesImpl;
  const _ModerationCategories._() : super._();

  factory _ModerationCategories.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesImpl.fromJson;

  @override

  /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  bool get hate;
  @override

  /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  @JsonKey(name: 'hate/threatening')
  bool get hateThreatening;
  @override

  /// Content that expresses, incites, or promotes harassing language towards any target.
  bool get harassment;
  @override

  /// Harassment content that also includes violence or serious harm towards any target.
  @JsonKey(name: 'harassment/threatening')
  bool get harassmentThreatening;
  @override

  /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm')
  bool get selfHarm;
  @override

  /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  @JsonKey(name: 'self-harm/intent')
  bool get selfHarmIntent;
  @override

  /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  @JsonKey(name: 'self-harm/instructions')
  bool get selfHarmInstructions;
  @override

  /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  bool get sexual;
  @override

  /// Sexual content that includes an individual who is under 18 years old.
  @JsonKey(name: 'sexual/minors')
  bool get sexualMinors;
  @override

  /// Content that depicts death, violence, or physical injury.
  bool get violence;
  @override

  /// Content that depicts death, violence, or physical injury in graphic detail.
  @JsonKey(name: 'violence/graphic')
  bool get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesImplCopyWith<_$ModerationCategoriesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModerationCategoriesScores _$ModerationCategoriesScoresFromJson(
    Map<String, dynamic> json) {
  return _ModerationCategoriesScores.fromJson(json);
}

/// @nodoc
mixin _$ModerationCategoriesScores {
  /// The score for the category 'hate'.
  double get hate => throw _privateConstructorUsedError;

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'harassment'.
  double get harassment => throw _privateConstructorUsedError;

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent => throw _privateConstructorUsedError;

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions => throw _privateConstructorUsedError;

  /// The score for the category 'sexual'.
  double get sexual => throw _privateConstructorUsedError;

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors => throw _privateConstructorUsedError;

  /// The score for the category 'violence'.
  double get violence => throw _privateConstructorUsedError;

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModerationCategoriesScoresCopyWith<ModerationCategoriesScores>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModerationCategoriesScoresCopyWith<$Res> {
  factory $ModerationCategoriesScoresCopyWith(ModerationCategoriesScores value,
          $Res Function(ModerationCategoriesScores) then) =
      _$ModerationCategoriesScoresCopyWithImpl<$Res,
          ModerationCategoriesScores>;
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class _$ModerationCategoriesScoresCopyWithImpl<$Res,
        $Val extends ModerationCategoriesScores>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  _$ModerationCategoriesScoresCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_value.copyWith(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModerationCategoriesScoresImplCopyWith<$Res>
    implements $ModerationCategoriesScoresCopyWith<$Res> {
  factory _$$ModerationCategoriesScoresImplCopyWith(
          _$ModerationCategoriesScoresImpl value,
          $Res Function(_$ModerationCategoriesScoresImpl) then) =
      __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double hate,
      @JsonKey(name: 'hate/threatening') double hateThreatening,
      double harassment,
      @JsonKey(name: 'harassment/threatening') double harassmentThreatening,
      @JsonKey(name: 'self-harm') double selfHarm,
      @JsonKey(name: 'self-harm/intent') double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions') double selfHarmInstructions,
      double sexual,
      @JsonKey(name: 'sexual/minors') double sexualMinors,
      double violence,
      @JsonKey(name: 'violence/graphic') double violenceGraphic});
}

/// @nodoc
class __$$ModerationCategoriesScoresImplCopyWithImpl<$Res>
    extends _$ModerationCategoriesScoresCopyWithImpl<$Res,
        _$ModerationCategoriesScoresImpl>
    implements _$$ModerationCategoriesScoresImplCopyWith<$Res> {
  __$$ModerationCategoriesScoresImplCopyWithImpl(
      _$ModerationCategoriesScoresImpl _value,
      $Res Function(_$ModerationCategoriesScoresImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hate = null,
    Object? hateThreatening = null,
    Object? harassment = null,
    Object? harassmentThreatening = null,
    Object? selfHarm = null,
    Object? selfHarmIntent = null,
    Object? selfHarmInstructions = null,
    Object? sexual = null,
    Object? sexualMinors = null,
    Object? violence = null,
    Object? violenceGraphic = null,
  }) {
    return _then(_$ModerationCategoriesScoresImpl(
      hate: null == hate
          ? _value.hate
          : hate // ignore: cast_nullable_to_non_nullable
              as double,
      hateThreatening: null == hateThreatening
          ? _value.hateThreatening
          : hateThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      harassment: null == harassment
          ? _value.harassment
          : harassment // ignore: cast_nullable_to_non_nullable
              as double,
      harassmentThreatening: null == harassmentThreatening
          ? _value.harassmentThreatening
          : harassmentThreatening // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarm: null == selfHarm
          ? _value.selfHarm
          : selfHarm // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmIntent: null == selfHarmIntent
          ? _value.selfHarmIntent
          : selfHarmIntent // ignore: cast_nullable_to_non_nullable
              as double,
      selfHarmInstructions: null == selfHarmInstructions
          ? _value.selfHarmInstructions
          : selfHarmInstructions // ignore: cast_nullable_to_non_nullable
              as double,
      sexual: null == sexual
          ? _value.sexual
          : sexual // ignore: cast_nullable_to_non_nullable
              as double,
      sexualMinors: null == sexualMinors
          ? _value.sexualMinors
          : sexualMinors // ignore: cast_nullable_to_non_nullable
              as double,
      violence: null == violence
          ? _value.violence
          : violence // ignore: cast_nullable_to_non_nullable
              as double,
      violenceGraphic: null == violenceGraphic
          ? _value.violenceGraphic
          : violenceGraphic // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModerationCategoriesScoresImpl extends _ModerationCategoriesScores {
  const _$ModerationCategoriesScoresImpl(
      {required this.hate,
      @JsonKey(name: 'hate/threatening') required this.hateThreatening,
      required this.harassment,
      @JsonKey(name: 'harassment/threatening')
      required this.harassmentThreatening,
      @JsonKey(name: 'self-harm') required this.selfHarm,
      @JsonKey(name: 'self-harm/intent') required this.selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required this.selfHarmInstructions,
      required this.sexual,
      @JsonKey(name: 'sexual/minors') required this.sexualMinors,
      required this.violence,
      @JsonKey(name: 'violence/graphic') required this.violenceGraphic})
      : super._();

  factory _$ModerationCategoriesScoresImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModerationCategoriesScoresImplFromJson(json);

  /// The score for the category 'hate'.
  @override
  final double hate;

  /// The score for the category 'hate/threatening'.
  @override
  @JsonKey(name: 'hate/threatening')
  final double hateThreatening;

  /// The score for the category 'harassment'.
  @override
  final double harassment;

  /// The score for the category 'harassment/threatening'.
  @override
  @JsonKey(name: 'harassment/threatening')
  final double harassmentThreatening;

  /// The score for the category 'self-harm'.
  @override
  @JsonKey(name: 'self-harm')
  final double selfHarm;

  /// The score for the category 'self-harm/intent'.
  @override
  @JsonKey(name: 'self-harm/intent')
  final double selfHarmIntent;

  /// The score for the category 'self-harm/instructions'.
  @override
  @JsonKey(name: 'self-harm/instructions')
  final double selfHarmInstructions;

  /// The score for the category 'sexual'.
  @override
  final double sexual;

  /// The score for the category 'sexual/minors'.
  @override
  @JsonKey(name: 'sexual/minors')
  final double sexualMinors;

  /// The score for the category 'violence'.
  @override
  final double violence;

  /// The score for the category 'violence/graphic'.
  @override
  @JsonKey(name: 'violence/graphic')
  final double violenceGraphic;

  @override
  String toString() {
    return 'ModerationCategoriesScores(hate: $hate, hateThreatening: $hateThreatening, harassment: $harassment, harassmentThreatening: $harassmentThreatening, selfHarm: $selfHarm, selfHarmIntent: $selfHarmIntent, selfHarmInstructions: $selfHarmInstructions, sexual: $sexual, sexualMinors: $sexualMinors, violence: $violence, violenceGraphic: $violenceGraphic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModerationCategoriesScoresImpl &&
            (identical(other.hate, hate) || other.hate == hate) &&
            (identical(other.hateThreatening, hateThreatening) ||
                other.hateThreatening == hateThreatening) &&
            (identical(other.harassment, harassment) ||
                other.harassment == harassment) &&
            (identical(other.harassmentThreatening, harassmentThreatening) ||
                other.harassmentThreatening == harassmentThreatening) &&
            (identical(other.selfHarm, selfHarm) ||
                other.selfHarm == selfHarm) &&
            (identical(other.selfHarmIntent, selfHarmIntent) ||
                other.selfHarmIntent == selfHarmIntent) &&
            (identical(other.selfHarmInstructions, selfHarmInstructions) ||
                other.selfHarmInstructions == selfHarmInstructions) &&
            (identical(other.sexual, sexual) || other.sexual == sexual) &&
            (identical(other.sexualMinors, sexualMinors) ||
                other.sexualMinors == sexualMinors) &&
            (identical(other.violence, violence) ||
                other.violence == violence) &&
            (identical(other.violenceGraphic, violenceGraphic) ||
                other.violenceGraphic == violenceGraphic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      hate,
      hateThreatening,
      harassment,
      harassmentThreatening,
      selfHarm,
      selfHarmIntent,
      selfHarmInstructions,
      sexual,
      sexualMinors,
      violence,
      violenceGraphic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => __$$ModerationCategoriesScoresImplCopyWithImpl<
          _$ModerationCategoriesScoresImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModerationCategoriesScoresImplToJson(
      this,
    );
  }
}

abstract class _ModerationCategoriesScores extends ModerationCategoriesScores {
  const factory _ModerationCategoriesScores(
      {required final double hate,
      @JsonKey(name: 'hate/threatening') required final double hateThreatening,
      required final double harassment,
      @JsonKey(name: 'harassment/threatening')
      required final double harassmentThreatening,
      @JsonKey(name: 'self-harm') required final double selfHarm,
      @JsonKey(name: 'self-harm/intent') required final double selfHarmIntent,
      @JsonKey(name: 'self-harm/instructions')
      required final double selfHarmInstructions,
      required final double sexual,
      @JsonKey(name: 'sexual/minors') required final double sexualMinors,
      required final double violence,
      @JsonKey(name: 'violence/graphic')
      required final double
          violenceGraphic}) = _$ModerationCategoriesScoresImpl;
  const _ModerationCategoriesScores._() : super._();

  factory _ModerationCategoriesScores.fromJson(Map<String, dynamic> json) =
      _$ModerationCategoriesScoresImpl.fromJson;

  @override

  /// The score for the category 'hate'.
  double get hate;
  @override

  /// The score for the category 'hate/threatening'.
  @JsonKey(name: 'hate/threatening')
  double get hateThreatening;
  @override

  /// The score for the category 'harassment'.
  double get harassment;
  @override

  /// The score for the category 'harassment/threatening'.
  @JsonKey(name: 'harassment/threatening')
  double get harassmentThreatening;
  @override

  /// The score for the category 'self-harm'.
  @JsonKey(name: 'self-harm')
  double get selfHarm;
  @override

  /// The score for the category 'self-harm/intent'.
  @JsonKey(name: 'self-harm/intent')
  double get selfHarmIntent;
  @override

  /// The score for the category 'self-harm/instructions'.
  @JsonKey(name: 'self-harm/instructions')
  double get selfHarmInstructions;
  @override

  /// The score for the category 'sexual'.
  double get sexual;
  @override

  /// The score for the category 'sexual/minors'.
  @JsonKey(name: 'sexual/minors')
  double get sexualMinors;
  @override

  /// The score for the category 'violence'.
  double get violence;
  @override

  /// The score for the category 'violence/graphic'.
  @JsonKey(name: 'violence/graphic')
  double get violenceGraphic;
  @override
  @JsonKey(ignore: true)
  _$$ModerationCategoriesScoresImplCopyWith<_$ModerationCategoriesScoresImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantObject _$AssistantObjectFromJson(Map<String, dynamic> json) {
  return _AssistantObject.fromJson(json);
}

/// @nodoc
mixin _$AssistantObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `assistant`.
  AssistantObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The name of the assistant. The maximum length is 256 characters.
  String? get name => throw _privateConstructorUsedError;

  /// The description of the assistant. The maximum length is 512 characters.
  String? get description => throw _privateConstructorUsedError;

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  String get model => throw _privateConstructorUsedError;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  String? get instructions => throw _privateConstructorUsedError;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_AssistantObjectResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  AssistantObjectResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantObjectCopyWith<AssistantObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantObjectCopyWith<$Res> {
  factory $AssistantObjectCopyWith(
          AssistantObject value, $Res Function(AssistantObject) then) =
      _$AssistantObjectCopyWithImpl<$Res, AssistantObject>;
  @useResult
  $Res call(
      {String id,
      AssistantObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      String? description,
      String model,
      String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_AssistantObjectResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      AssistantObjectResponseFormat? responseFormat});

  $ToolResourcesCopyWith<$Res>? get toolResources;
  $AssistantObjectResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$AssistantObjectCopyWithImpl<$Res, $Val extends AssistantObject>
    implements $AssistantObjectCopyWith<$Res> {
  _$AssistantObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? model = null,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as AssistantObjectResponseFormat?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_value.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_value.toolResources!, (value) {
      return _then(_value.copyWith(toolResources: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantObjectResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $AssistantObjectResponseFormatCopyWith<$Res>(_value.responseFormat!,
        (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AssistantObjectImplCopyWith<$Res>
    implements $AssistantObjectCopyWith<$Res> {
  factory _$$AssistantObjectImplCopyWith(_$AssistantObjectImpl value,
          $Res Function(_$AssistantObjectImpl) then) =
      __$$AssistantObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      AssistantObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      String? description,
      String model,
      String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_AssistantObjectResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      AssistantObjectResponseFormat? responseFormat});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $AssistantObjectResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$$AssistantObjectImplCopyWithImpl<$Res>
    extends _$AssistantObjectCopyWithImpl<$Res, _$AssistantObjectImpl>
    implements _$$AssistantObjectImplCopyWith<$Res> {
  __$$AssistantObjectImplCopyWithImpl(
      _$AssistantObjectImpl _value, $Res Function(_$AssistantObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? model = null,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_$AssistantObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as AssistantObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as AssistantObjectResponseFormat?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantObjectImpl extends _AssistantObject {
  const _$AssistantObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.name,
      required this.description,
      required this.model,
      required this.instructions,
      required final List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      required final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @_AssistantObjectResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat})
      : _tools = tools,
        _metadata = metadata,
        super._();

  factory _$AssistantObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `assistant`.
  @override
  final AssistantObjectObject object;

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  final String? description;

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  final String model;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @override
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  @override
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_AssistantObjectResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final AssistantObjectResponseFormat? responseFormat;

  @override
  String toString() {
    return 'AssistantObject(id: $id, object: $object, createdAt: $createdAt, name: $name, description: $description, model: $model, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      name,
      description,
      model,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      responseFormat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantObjectImplCopyWith<_$AssistantObjectImpl> get copyWith =>
      __$$AssistantObjectImplCopyWithImpl<_$AssistantObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantObjectImplToJson(
      this,
    );
  }
}

abstract class _AssistantObject extends AssistantObject {
  const factory _AssistantObject(
          {required final String id,
          required final AssistantObjectObject object,
          @JsonKey(name: 'created_at') required final int createdAt,
          required final String? name,
          required final String? description,
          required final String model,
          required final String? instructions,
          required final List<AssistantTools> tools,
          @JsonKey(name: 'tool_resources', includeIfNull: false)
          final ToolResources? toolResources,
          required final Map<String, dynamic>? metadata,
          @JsonKey(includeIfNull: false) final double? temperature,
          @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
          @_AssistantObjectResponseFormatConverter()
          @JsonKey(name: 'response_format', includeIfNull: false)
          final AssistantObjectResponseFormat? responseFormat}) =
      _$AssistantObjectImpl;
  const _AssistantObject._() : super._();

  factory _AssistantObject.fromJson(Map<String, dynamic> json) =
      _$AssistantObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `assistant`.
  AssistantObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the assistant was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The name of the assistant. The maximum length is 256 characters.
  String? get name;
  @override

  /// The description of the assistant. The maximum length is 512 characters.
  String? get description;
  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  String get model;
  @override

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  String? get instructions;
  @override

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools;
  @override

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_AssistantObjectResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  AssistantObjectResponseFormat? get responseFormat;
  @override
  @JsonKey(ignore: true)
  _$$AssistantObjectImplCopyWith<_$AssistantObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AssistantObjectResponseFormat _$AssistantObjectResponseFormatFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'enumeration':
      return AssistantObjectResponseFormatEnumeration.fromJson(json);
    case 'assistantsResponseFormat':
      return AssistantObjectResponseFormatAssistantsResponseFormat.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'AssistantObjectResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$AssistantObjectResponseFormat {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantResponseFormatMode value) enumeration,
    required TResult Function(AssistantsResponseFormat value)
        assistantsResponseFormat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantResponseFormatMode value)? enumeration,
    TResult? Function(AssistantsResponseFormat value)? assistantsResponseFormat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantResponseFormatMode value)? enumeration,
    TResult Function(AssistantsResponseFormat value)? assistantsResponseFormat,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantObjectResponseFormatEnumeration value)
        enumeration,
    required TResult Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)
        assistantsResponseFormat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantObjectResponseFormatEnumeration value)?
        enumeration,
    TResult? Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)?
        assistantsResponseFormat,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantObjectResponseFormatEnumeration value)?
        enumeration,
    TResult Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)?
        assistantsResponseFormat,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantObjectResponseFormatCopyWith<$Res> {
  factory $AssistantObjectResponseFormatCopyWith(
          AssistantObjectResponseFormat value,
          $Res Function(AssistantObjectResponseFormat) then) =
      _$AssistantObjectResponseFormatCopyWithImpl<$Res,
          AssistantObjectResponseFormat>;
}

/// @nodoc
class _$AssistantObjectResponseFormatCopyWithImpl<$Res,
        $Val extends AssistantObjectResponseFormat>
    implements $AssistantObjectResponseFormatCopyWith<$Res> {
  _$AssistantObjectResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AssistantObjectResponseFormatEnumerationImplCopyWith<$Res> {
  factory _$$AssistantObjectResponseFormatEnumerationImplCopyWith(
          _$AssistantObjectResponseFormatEnumerationImpl value,
          $Res Function(_$AssistantObjectResponseFormatEnumerationImpl) then) =
      __$$AssistantObjectResponseFormatEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AssistantResponseFormatMode value});
}

/// @nodoc
class __$$AssistantObjectResponseFormatEnumerationImplCopyWithImpl<$Res>
    extends _$AssistantObjectResponseFormatCopyWithImpl<$Res,
        _$AssistantObjectResponseFormatEnumerationImpl>
    implements _$$AssistantObjectResponseFormatEnumerationImplCopyWith<$Res> {
  __$$AssistantObjectResponseFormatEnumerationImplCopyWithImpl(
      _$AssistantObjectResponseFormatEnumerationImpl _value,
      $Res Function(_$AssistantObjectResponseFormatEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$AssistantObjectResponseFormatEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantObjectResponseFormatEnumerationImpl
    extends AssistantObjectResponseFormatEnumeration {
  const _$AssistantObjectResponseFormatEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'enumeration',
        super._();

  factory _$AssistantObjectResponseFormatEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$AssistantObjectResponseFormatEnumerationImplFromJson(json);

  @override
  final AssistantResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AssistantObjectResponseFormat.enumeration(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantObjectResponseFormatEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantObjectResponseFormatEnumerationImplCopyWith<
          _$AssistantObjectResponseFormatEnumerationImpl>
      get copyWith =>
          __$$AssistantObjectResponseFormatEnumerationImplCopyWithImpl<
              _$AssistantObjectResponseFormatEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantResponseFormatMode value) enumeration,
    required TResult Function(AssistantsResponseFormat value)
        assistantsResponseFormat,
  }) {
    return enumeration(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantResponseFormatMode value)? enumeration,
    TResult? Function(AssistantsResponseFormat value)? assistantsResponseFormat,
  }) {
    return enumeration?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantResponseFormatMode value)? enumeration,
    TResult Function(AssistantsResponseFormat value)? assistantsResponseFormat,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantObjectResponseFormatEnumeration value)
        enumeration,
    required TResult Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)
        assistantsResponseFormat,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantObjectResponseFormatEnumeration value)?
        enumeration,
    TResult? Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)?
        assistantsResponseFormat,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantObjectResponseFormatEnumeration value)?
        enumeration,
    TResult Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)?
        assistantsResponseFormat,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantObjectResponseFormatEnumerationImplToJson(
      this,
    );
  }
}

abstract class AssistantObjectResponseFormatEnumeration
    extends AssistantObjectResponseFormat {
  const factory AssistantObjectResponseFormatEnumeration(
          final AssistantResponseFormatMode value) =
      _$AssistantObjectResponseFormatEnumerationImpl;
  const AssistantObjectResponseFormatEnumeration._() : super._();

  factory AssistantObjectResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$AssistantObjectResponseFormatEnumerationImpl.fromJson;

  @override
  AssistantResponseFormatMode get value;
  @JsonKey(ignore: true)
  _$$AssistantObjectResponseFormatEnumerationImplCopyWith<
          _$AssistantObjectResponseFormatEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWith<
    $Res> {
  factory _$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWith(
          _$AssistantObjectResponseFormatAssistantsResponseFormatImpl value,
          $Res Function(
                  _$AssistantObjectResponseFormatAssistantsResponseFormatImpl)
              then) =
      __$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({AssistantsResponseFormat value});

  $AssistantsResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class __$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl<
        $Res>
    extends _$AssistantObjectResponseFormatCopyWithImpl<$Res,
        _$AssistantObjectResponseFormatAssistantsResponseFormatImpl>
    implements
        _$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWith<
            $Res> {
  __$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl(
      _$AssistantObjectResponseFormatAssistantsResponseFormatImpl _value,
      $Res Function(_$AssistantObjectResponseFormatAssistantsResponseFormatImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$AssistantObjectResponseFormatAssistantsResponseFormatImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormat,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsResponseFormatCopyWith<$Res> get value {
    return $AssistantsResponseFormatCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantObjectResponseFormatAssistantsResponseFormatImpl
    extends AssistantObjectResponseFormatAssistantsResponseFormat {
  const _$AssistantObjectResponseFormatAssistantsResponseFormatImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'assistantsResponseFormat',
        super._();

  factory _$AssistantObjectResponseFormatAssistantsResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$AssistantObjectResponseFormatAssistantsResponseFormatImplFromJson(
          json);

  @override
  final AssistantsResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AssistantObjectResponseFormat.assistantsResponseFormat(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AssistantObjectResponseFormatAssistantsResponseFormatImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWith<
          _$AssistantObjectResponseFormatAssistantsResponseFormatImpl>
      get copyWith =>
          __$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl<
                  _$AssistantObjectResponseFormatAssistantsResponseFormatImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantResponseFormatMode value) enumeration,
    required TResult Function(AssistantsResponseFormat value)
        assistantsResponseFormat,
  }) {
    return assistantsResponseFormat(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantResponseFormatMode value)? enumeration,
    TResult? Function(AssistantsResponseFormat value)? assistantsResponseFormat,
  }) {
    return assistantsResponseFormat?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantResponseFormatMode value)? enumeration,
    TResult Function(AssistantsResponseFormat value)? assistantsResponseFormat,
    required TResult orElse(),
  }) {
    if (assistantsResponseFormat != null) {
      return assistantsResponseFormat(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantObjectResponseFormatEnumeration value)
        enumeration,
    required TResult Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)
        assistantsResponseFormat,
  }) {
    return assistantsResponseFormat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantObjectResponseFormatEnumeration value)?
        enumeration,
    TResult? Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)?
        assistantsResponseFormat,
  }) {
    return assistantsResponseFormat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantObjectResponseFormatEnumeration value)?
        enumeration,
    TResult Function(
            AssistantObjectResponseFormatAssistantsResponseFormat value)?
        assistantsResponseFormat,
    required TResult orElse(),
  }) {
    if (assistantsResponseFormat != null) {
      return assistantsResponseFormat(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantObjectResponseFormatAssistantsResponseFormatImplToJson(
      this,
    );
  }
}

abstract class AssistantObjectResponseFormatAssistantsResponseFormat
    extends AssistantObjectResponseFormat {
  const factory AssistantObjectResponseFormatAssistantsResponseFormat(
          final AssistantsResponseFormat value) =
      _$AssistantObjectResponseFormatAssistantsResponseFormatImpl;
  const AssistantObjectResponseFormatAssistantsResponseFormat._() : super._();

  factory AssistantObjectResponseFormatAssistantsResponseFormat.fromJson(
          Map<String, dynamic> json) =
      _$AssistantObjectResponseFormatAssistantsResponseFormatImpl.fromJson;

  @override
  AssistantsResponseFormat get value;
  @JsonKey(ignore: true)
  _$$AssistantObjectResponseFormatAssistantsResponseFormatImplCopyWith<
          _$AssistantObjectResponseFormatAssistantsResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateAssistantRequest _$CreateAssistantRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateAssistantRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateAssistantRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_AssistantModelConverter()
  AssistantModel get model => throw _privateConstructorUsedError;

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateAssistantRequestResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateAssistantRequestCopyWith<CreateAssistantRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateAssistantRequestCopyWith<$Res> {
  factory $CreateAssistantRequestCopyWith(CreateAssistantRequest value,
          $Res Function(CreateAssistantRequest) then) =
      _$CreateAssistantRequestCopyWithImpl<$Res, CreateAssistantRequest>;
  @useResult
  $Res call(
      {@_AssistantModelConverter() AssistantModel model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_CreateAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateAssistantRequestResponseFormat? responseFormat});

  $AssistantModelCopyWith<$Res> get model;
  $ToolResourcesCopyWith<$Res>? get toolResources;
  $CreateAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$CreateAssistantRequestCopyWithImpl<$Res,
        $Val extends CreateAssistantRequest>
    implements $CreateAssistantRequestCopyWith<$Res> {
  _$CreateAssistantRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_value.copyWith(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as AssistantModel,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateAssistantRequestResponseFormat?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantModelCopyWith<$Res> get model {
    return $AssistantModelCopyWith<$Res>(_value.model, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_value.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_value.toolResources!, (value) {
      return _then(_value.copyWith(toolResources: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $CreateAssistantRequestResponseFormatCopyWith<$Res>(
        _value.responseFormat!, (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateAssistantRequestImplCopyWith<$Res>
    implements $CreateAssistantRequestCopyWith<$Res> {
  factory _$$CreateAssistantRequestImplCopyWith(
          _$CreateAssistantRequestImpl value,
          $Res Function(_$CreateAssistantRequestImpl) then) =
      __$$CreateAssistantRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_AssistantModelConverter() AssistantModel model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_CreateAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateAssistantRequestResponseFormat? responseFormat});

  @override
  $AssistantModelCopyWith<$Res> get model;
  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $CreateAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$$CreateAssistantRequestImplCopyWithImpl<$Res>
    extends _$CreateAssistantRequestCopyWithImpl<$Res,
        _$CreateAssistantRequestImpl>
    implements _$$CreateAssistantRequestImplCopyWith<$Res> {
  __$$CreateAssistantRequestImplCopyWithImpl(
      _$CreateAssistantRequestImpl _value,
      $Res Function(_$CreateAssistantRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_$CreateAssistantRequestImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as AssistantModel,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateAssistantRequestResponseFormat?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateAssistantRequestImpl extends _CreateAssistantRequest {
  const _$CreateAssistantRequestImpl(
      {@_AssistantModelConverter() required this.model,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) this.instructions,
      final List<AssistantTools> tools = const [],
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @_CreateAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat})
      : _tools = tools,
        _metadata = metadata,
        super._();

  factory _$CreateAssistantRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateAssistantRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @_AssistantModelConverter()
  final AssistantModel model;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  @override
  @JsonKey()
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_CreateAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final CreateAssistantRequestResponseFormat? responseFormat;

  @override
  String toString() {
    return 'CreateAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateAssistantRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      responseFormat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateAssistantRequestImplCopyWith<_$CreateAssistantRequestImpl>
      get copyWith => __$$CreateAssistantRequestImplCopyWithImpl<
          _$CreateAssistantRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateAssistantRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateAssistantRequest extends CreateAssistantRequest {
  const factory _CreateAssistantRequest(
          {@_AssistantModelConverter() required final AssistantModel model,
          @JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? description,
          @JsonKey(includeIfNull: false) final String? instructions,
          final List<AssistantTools> tools,
          @JsonKey(name: 'tool_resources', includeIfNull: false)
          final ToolResources? toolResources,
          @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
          @JsonKey(includeIfNull: false) final double? temperature,
          @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
          @_CreateAssistantRequestResponseFormatConverter()
          @JsonKey(name: 'response_format', includeIfNull: false)
          final CreateAssistantRequestResponseFormat? responseFormat}) =
      _$CreateAssistantRequestImpl;
  const _CreateAssistantRequest._() : super._();

  factory _CreateAssistantRequest.fromJson(Map<String, dynamic> json) =
      _$CreateAssistantRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @_AssistantModelConverter()
  AssistantModel get model;
  @override

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools;
  @override

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateAssistantRequestResponseFormat? get responseFormat;
  @override
  @JsonKey(ignore: true)
  _$$CreateAssistantRequestImplCopyWith<_$CreateAssistantRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantModel _$AssistantModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return AssistantModelEnumeration.fromJson(json);
    case 'modelId':
      return AssistantModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'AssistantModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$AssistantModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantModelEnumeration value) model,
    required TResult Function(AssistantModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantModelEnumeration value)? model,
    TResult? Function(AssistantModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantModelEnumeration value)? model,
    TResult Function(AssistantModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantModelCopyWith<$Res> {
  factory $AssistantModelCopyWith(
          AssistantModel value, $Res Function(AssistantModel) then) =
      _$AssistantModelCopyWithImpl<$Res, AssistantModel>;
}

/// @nodoc
class _$AssistantModelCopyWithImpl<$Res, $Val extends AssistantModel>
    implements $AssistantModelCopyWith<$Res> {
  _$AssistantModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AssistantModelEnumerationImplCopyWith<$Res> {
  factory _$$AssistantModelEnumerationImplCopyWith(
          _$AssistantModelEnumerationImpl value,
          $Res Function(_$AssistantModelEnumerationImpl) then) =
      __$$AssistantModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AssistantModels value});
}

/// @nodoc
class __$$AssistantModelEnumerationImplCopyWithImpl<$Res>
    extends _$AssistantModelCopyWithImpl<$Res, _$AssistantModelEnumerationImpl>
    implements _$$AssistantModelEnumerationImplCopyWith<$Res> {
  __$$AssistantModelEnumerationImplCopyWithImpl(
      _$AssistantModelEnumerationImpl _value,
      $Res Function(_$AssistantModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$AssistantModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantModelEnumerationImpl extends AssistantModelEnumeration {
  const _$AssistantModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$AssistantModelEnumerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantModelEnumerationImplFromJson(json);

  @override
  final AssistantModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AssistantModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantModelEnumerationImplCopyWith<_$AssistantModelEnumerationImpl>
      get copyWith => __$$AssistantModelEnumerationImplCopyWithImpl<
          _$AssistantModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantModelEnumeration value) model,
    required TResult Function(AssistantModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantModelEnumeration value)? model,
    TResult? Function(AssistantModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantModelEnumeration value)? model,
    TResult Function(AssistantModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class AssistantModelEnumeration extends AssistantModel {
  const factory AssistantModelEnumeration(final AssistantModels value) =
      _$AssistantModelEnumerationImpl;
  const AssistantModelEnumeration._() : super._();

  factory AssistantModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$AssistantModelEnumerationImpl.fromJson;

  @override
  AssistantModels get value;
  @JsonKey(ignore: true)
  _$$AssistantModelEnumerationImplCopyWith<_$AssistantModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssistantModelStringImplCopyWith<$Res> {
  factory _$$AssistantModelStringImplCopyWith(_$AssistantModelStringImpl value,
          $Res Function(_$AssistantModelStringImpl) then) =
      __$$AssistantModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$AssistantModelStringImplCopyWithImpl<$Res>
    extends _$AssistantModelCopyWithImpl<$Res, _$AssistantModelStringImpl>
    implements _$$AssistantModelStringImplCopyWith<$Res> {
  __$$AssistantModelStringImplCopyWithImpl(_$AssistantModelStringImpl _value,
      $Res Function(_$AssistantModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$AssistantModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantModelStringImpl extends AssistantModelString {
  const _$AssistantModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$AssistantModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AssistantModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantModelStringImplCopyWith<_$AssistantModelStringImpl>
      get copyWith =>
          __$$AssistantModelStringImplCopyWithImpl<_$AssistantModelStringImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AssistantModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AssistantModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AssistantModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantModelEnumeration value) model,
    required TResult Function(AssistantModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantModelEnumeration value)? model,
    TResult? Function(AssistantModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantModelEnumeration value)? model,
    TResult Function(AssistantModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantModelStringImplToJson(
      this,
    );
  }
}

abstract class AssistantModelString extends AssistantModel {
  const factory AssistantModelString(final String value) =
      _$AssistantModelStringImpl;
  const AssistantModelString._() : super._();

  factory AssistantModelString.fromJson(Map<String, dynamic> json) =
      _$AssistantModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$AssistantModelStringImplCopyWith<_$AssistantModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateAssistantRequestResponseFormat
    _$CreateAssistantRequestResponseFormatFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateAssistantRequestResponseFormatEnumeration.fromJson(json);
    case 'format':
      return CreateAssistantRequestResponseFormatAssistantsResponseFormat
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateAssistantRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateAssistantRequestResponseFormat {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateAssistantResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateAssistantResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateAssistantRequestResponseFormatCopyWith<$Res> {
  factory $CreateAssistantRequestResponseFormatCopyWith(
          CreateAssistantRequestResponseFormat value,
          $Res Function(CreateAssistantRequestResponseFormat) then) =
      _$CreateAssistantRequestResponseFormatCopyWithImpl<$Res,
          CreateAssistantRequestResponseFormat>;
}

/// @nodoc
class _$CreateAssistantRequestResponseFormatCopyWithImpl<$Res,
        $Val extends CreateAssistantRequestResponseFormat>
    implements $CreateAssistantRequestResponseFormatCopyWith<$Res> {
  _$CreateAssistantRequestResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateAssistantRequestResponseFormatEnumerationImplCopyWith<
    $Res> {
  factory _$$CreateAssistantRequestResponseFormatEnumerationImplCopyWith(
          _$CreateAssistantRequestResponseFormatEnumerationImpl value,
          $Res Function(_$CreateAssistantRequestResponseFormatEnumerationImpl)
              then) =
      __$$CreateAssistantRequestResponseFormatEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CreateAssistantResponseFormatMode value});
}

/// @nodoc
class __$$CreateAssistantRequestResponseFormatEnumerationImplCopyWithImpl<$Res>
    extends _$CreateAssistantRequestResponseFormatCopyWithImpl<$Res,
        _$CreateAssistantRequestResponseFormatEnumerationImpl>
    implements
        _$$CreateAssistantRequestResponseFormatEnumerationImplCopyWith<$Res> {
  __$$CreateAssistantRequestResponseFormatEnumerationImplCopyWithImpl(
      _$CreateAssistantRequestResponseFormatEnumerationImpl _value,
      $Res Function(_$CreateAssistantRequestResponseFormatEnumerationImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateAssistantRequestResponseFormatEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateAssistantResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateAssistantRequestResponseFormatEnumerationImpl
    extends CreateAssistantRequestResponseFormatEnumeration {
  const _$CreateAssistantRequestResponseFormatEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$CreateAssistantRequestResponseFormatEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateAssistantRequestResponseFormatEnumerationImplFromJson(json);

  @override
  final CreateAssistantResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateAssistantRequestResponseFormat.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateAssistantRequestResponseFormatEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateAssistantRequestResponseFormatEnumerationImplCopyWith<
          _$CreateAssistantRequestResponseFormatEnumerationImpl>
      get copyWith =>
          __$$CreateAssistantRequestResponseFormatEnumerationImplCopyWithImpl<
                  _$CreateAssistantRequestResponseFormatEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateAssistantResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateAssistantResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateAssistantRequestResponseFormatEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateAssistantRequestResponseFormatEnumeration
    extends CreateAssistantRequestResponseFormat {
  const factory CreateAssistantRequestResponseFormatEnumeration(
          final CreateAssistantResponseFormatMode value) =
      _$CreateAssistantRequestResponseFormatEnumerationImpl;
  const CreateAssistantRequestResponseFormatEnumeration._() : super._();

  factory CreateAssistantRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateAssistantRequestResponseFormatEnumerationImpl.fromJson;

  @override
  CreateAssistantResponseFormatMode get value;
  @JsonKey(ignore: true)
  _$$CreateAssistantRequestResponseFormatEnumerationImplCopyWith<
          _$CreateAssistantRequestResponseFormatEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
    $Res> {
  factory _$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith(
          _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl value,
          $Res Function(
                  _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl)
              then) =
      __$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({AssistantsResponseFormat value});

  $AssistantsResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class __$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
        $Res>
    extends _$CreateAssistantRequestResponseFormatCopyWithImpl<$Res,
        _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl>
    implements
        _$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
            $Res> {
  __$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl(
      _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl _value,
      $Res Function(
              _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormat,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsResponseFormatCopyWith<$Res> get value {
    return $AssistantsResponseFormatCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl
    extends CreateAssistantRequestResponseFormatAssistantsResponseFormat {
  const _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'format',
        super._();

  factory _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplFromJson(
          json);

  @override
  final AssistantsResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateAssistantRequestResponseFormat.format(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith =>
          __$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
                  _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateAssistantResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return format(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return format?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateAssistantResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return format(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return format?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            CreateAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplToJson(
      this,
    );
  }
}

abstract class CreateAssistantRequestResponseFormatAssistantsResponseFormat
    extends CreateAssistantRequestResponseFormat {
  const factory CreateAssistantRequestResponseFormatAssistantsResponseFormat(
          final AssistantsResponseFormat value) =
      _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl;
  const CreateAssistantRequestResponseFormatAssistantsResponseFormat._()
      : super._();

  factory CreateAssistantRequestResponseFormatAssistantsResponseFormat.fromJson(
          Map<String, dynamic> json) =
      _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl
      .fromJson;

  @override
  AssistantsResponseFormat get value;
  @JsonKey(ignore: true)
  _$$CreateAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$CreateAssistantRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModifyAssistantRequest _$ModifyAssistantRequestFromJson(
    Map<String, dynamic> json) {
  return _ModifyAssistantRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyAssistantRequest {
  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @JsonKey(includeIfNull: false)
  String? get model => throw _privateConstructorUsedError;

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description => throw _privateConstructorUsedError;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_ModifyAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  ModifyAssistantRequestResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyAssistantRequestCopyWith<ModifyAssistantRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyAssistantRequestCopyWith<$Res> {
  factory $ModifyAssistantRequestCopyWith(ModifyAssistantRequest value,
          $Res Function(ModifyAssistantRequest) then) =
      _$ModifyAssistantRequestCopyWithImpl<$Res, ModifyAssistantRequest>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_ModifyAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      ModifyAssistantRequestResponseFormat? responseFormat});

  $ToolResourcesCopyWith<$Res>? get toolResources;
  $ModifyAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$ModifyAssistantRequestCopyWithImpl<$Res,
        $Val extends ModifyAssistantRequest>
    implements $ModifyAssistantRequestCopyWith<$Res> {
  _$ModifyAssistantRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_value.copyWith(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ModifyAssistantRequestResponseFormat?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_value.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_value.toolResources!, (value) {
      return _then(_value.copyWith(toolResources: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModifyAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $ModifyAssistantRequestResponseFormatCopyWith<$Res>(
        _value.responseFormat!, (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModifyAssistantRequestImplCopyWith<$Res>
    implements $ModifyAssistantRequestCopyWith<$Res> {
  factory _$$ModifyAssistantRequestImplCopyWith(
          _$ModifyAssistantRequestImpl value,
          $Res Function(_$ModifyAssistantRequestImpl) then) =
      __$$ModifyAssistantRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? model,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? description,
      @JsonKey(includeIfNull: false) String? instructions,
      List<AssistantTools> tools,
      @JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @_ModifyAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      ModifyAssistantRequestResponseFormat? responseFormat});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $ModifyAssistantRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$$ModifyAssistantRequestImplCopyWithImpl<$Res>
    extends _$ModifyAssistantRequestCopyWithImpl<$Res,
        _$ModifyAssistantRequestImpl>
    implements _$$ModifyAssistantRequestImplCopyWith<$Res> {
  __$$ModifyAssistantRequestImplCopyWithImpl(
      _$ModifyAssistantRequestImpl _value,
      $Res Function(_$ModifyAssistantRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? instructions = freezed,
    Object? tools = null,
    Object? fileIds = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? responseFormat = freezed,
  }) {
    return _then(_$ModifyAssistantRequestImpl(
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as ModifyAssistantRequestResponseFormat?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyAssistantRequestImpl extends _ModifyAssistantRequest {
  const _$ModifyAssistantRequestImpl(
      {@JsonKey(includeIfNull: false) this.model,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.description,
      @JsonKey(includeIfNull: false) this.instructions,
      final List<AssistantTools> tools = const [],
      @JsonKey(name: 'file_ids') final List<String> fileIds = const [],
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @_ModifyAssistantRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat})
      : _tools = tools,
        _fileIds = fileIds,
        _metadata = metadata,
        super._();

  factory _$ModifyAssistantRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyAssistantRequestImplFromJson(json);

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @override
  @JsonKey(includeIfNull: false)
  final String? model;

  /// The name of the assistant. The maximum length is 256 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The description of the assistant. The maximum length is 512 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? description;

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  final List<AssistantTools> _tools;

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  @override
  @JsonKey()
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  final List<String> _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_ModifyAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final ModifyAssistantRequestResponseFormat? responseFormat;

  @override
  String toString() {
    return 'ModifyAssistantRequest(model: $model, name: $name, description: $description, instructions: $instructions, tools: $tools, fileIds: $fileIds, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, responseFormat: $responseFormat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyAssistantRequestImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      model,
      name,
      description,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_fileIds),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      responseFormat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyAssistantRequestImplCopyWith<_$ModifyAssistantRequestImpl>
      get copyWith => __$$ModifyAssistantRequestImplCopyWithImpl<
          _$ModifyAssistantRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyAssistantRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyAssistantRequest extends ModifyAssistantRequest {
  const factory _ModifyAssistantRequest(
          {@JsonKey(includeIfNull: false) final String? model,
          @JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? description,
          @JsonKey(includeIfNull: false) final String? instructions,
          final List<AssistantTools> tools,
          @JsonKey(name: 'file_ids') final List<String> fileIds,
          @JsonKey(name: 'tool_resources', includeIfNull: false)
          final ToolResources? toolResources,
          @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
          @JsonKey(includeIfNull: false) final double? temperature,
          @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
          @_ModifyAssistantRequestResponseFormatConverter()
          @JsonKey(name: 'response_format', includeIfNull: false)
          final ModifyAssistantRequestResponseFormat? responseFormat}) =
      _$ModifyAssistantRequestImpl;
  const _ModifyAssistantRequest._() : super._();

  factory _ModifyAssistantRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyAssistantRequestImpl.fromJson;

  @override

  /// ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models/overview) for descriptions of them.
  @JsonKey(includeIfNull: false)
  String? get model;
  @override

  /// The name of the assistant. The maximum length is 256 characters.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The description of the assistant. The maximum length is 512 characters.
  @JsonKey(includeIfNull: false)
  String? get description;
  @override

  /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
  List<AssistantTools> get tools;
  @override

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previosuly attached to the list but does not show up in the list, it will be deleted from the assistant.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_ModifyAssistantRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  ModifyAssistantRequestResponseFormat? get responseFormat;
  @override
  @JsonKey(ignore: true)
  _$$ModifyAssistantRequestImplCopyWith<_$ModifyAssistantRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModifyAssistantRequestResponseFormat
    _$ModifyAssistantRequestResponseFormatFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return ModifyAssistantRequestResponseFormatEnumeration.fromJson(json);
    case 'format':
      return ModifyAssistantRequestResponseFormatAssistantsResponseFormat
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ModifyAssistantRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ModifyAssistantRequestResponseFormat {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModifyAssistantResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ModifyAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyAssistantRequestResponseFormatCopyWith<$Res> {
  factory $ModifyAssistantRequestResponseFormatCopyWith(
          ModifyAssistantRequestResponseFormat value,
          $Res Function(ModifyAssistantRequestResponseFormat) then) =
      _$ModifyAssistantRequestResponseFormatCopyWithImpl<$Res,
          ModifyAssistantRequestResponseFormat>;
}

/// @nodoc
class _$ModifyAssistantRequestResponseFormatCopyWithImpl<$Res,
        $Val extends ModifyAssistantRequestResponseFormat>
    implements $ModifyAssistantRequestResponseFormatCopyWith<$Res> {
  _$ModifyAssistantRequestResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWith<
    $Res> {
  factory _$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWith(
          _$ModifyAssistantRequestResponseFormatEnumerationImpl value,
          $Res Function(_$ModifyAssistantRequestResponseFormatEnumerationImpl)
              then) =
      __$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ModifyAssistantResponseFormatMode value});
}

/// @nodoc
class __$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWithImpl<$Res>
    extends _$ModifyAssistantRequestResponseFormatCopyWithImpl<$Res,
        _$ModifyAssistantRequestResponseFormatEnumerationImpl>
    implements
        _$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWith<$Res> {
  __$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWithImpl(
      _$ModifyAssistantRequestResponseFormatEnumerationImpl _value,
      $Res Function(_$ModifyAssistantRequestResponseFormatEnumerationImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ModifyAssistantRequestResponseFormatEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ModifyAssistantResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyAssistantRequestResponseFormatEnumerationImpl
    extends ModifyAssistantRequestResponseFormatEnumeration {
  const _$ModifyAssistantRequestResponseFormatEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$ModifyAssistantRequestResponseFormatEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModifyAssistantRequestResponseFormatEnumerationImplFromJson(json);

  @override
  final ModifyAssistantResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModifyAssistantRequestResponseFormat.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyAssistantRequestResponseFormatEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWith<
          _$ModifyAssistantRequestResponseFormatEnumerationImpl>
      get copyWith =>
          __$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWithImpl<
                  _$ModifyAssistantRequestResponseFormatEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModifyAssistantResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ModifyAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyAssistantRequestResponseFormatEnumerationImplToJson(
      this,
    );
  }
}

abstract class ModifyAssistantRequestResponseFormatEnumeration
    extends ModifyAssistantRequestResponseFormat {
  const factory ModifyAssistantRequestResponseFormatEnumeration(
          final ModifyAssistantResponseFormatMode value) =
      _$ModifyAssistantRequestResponseFormatEnumerationImpl;
  const ModifyAssistantRequestResponseFormatEnumeration._() : super._();

  factory ModifyAssistantRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$ModifyAssistantRequestResponseFormatEnumerationImpl.fromJson;

  @override
  ModifyAssistantResponseFormatMode get value;
  @JsonKey(ignore: true)
  _$$ModifyAssistantRequestResponseFormatEnumerationImplCopyWith<
          _$ModifyAssistantRequestResponseFormatEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
    $Res> {
  factory _$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith(
          _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl value,
          $Res Function(
                  _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl)
              then) =
      __$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({AssistantsResponseFormat value});

  $AssistantsResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class __$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
        $Res>
    extends _$ModifyAssistantRequestResponseFormatCopyWithImpl<$Res,
        _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl>
    implements
        _$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
            $Res> {
  __$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl(
      _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl _value,
      $Res Function(
              _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormat,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsResponseFormatCopyWith<$Res> get value {
    return $AssistantsResponseFormatCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl
    extends ModifyAssistantRequestResponseFormatAssistantsResponseFormat {
  const _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'format',
        super._();

  factory _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplFromJson(
          json);

  @override
  final AssistantsResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ModifyAssistantRequestResponseFormat.format(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith =>
          __$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
                  _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ModifyAssistantResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return format(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return format?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ModifyAssistantResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            ModifyAssistantRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return format(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return format?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ModifyAssistantRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            ModifyAssistantRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplToJson(
      this,
    );
  }
}

abstract class ModifyAssistantRequestResponseFormatAssistantsResponseFormat
    extends ModifyAssistantRequestResponseFormat {
  const factory ModifyAssistantRequestResponseFormatAssistantsResponseFormat(
          final AssistantsResponseFormat value) =
      _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl;
  const ModifyAssistantRequestResponseFormatAssistantsResponseFormat._()
      : super._();

  factory ModifyAssistantRequestResponseFormatAssistantsResponseFormat.fromJson(
          Map<String, dynamic> json) =
      _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl
      .fromJson;

  @override
  AssistantsResponseFormat get value;
  @JsonKey(ignore: true)
  _$$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$ModifyAssistantRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteAssistantResponse _$DeleteAssistantResponseFromJson(
    Map<String, dynamic> json) {
  return _DeleteAssistantResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteAssistantResponse {
  /// The assistant identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the assistant was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `assistant.deleted`.
  DeleteAssistantResponseObject get object =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteAssistantResponseCopyWith<DeleteAssistantResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteAssistantResponseCopyWith<$Res> {
  factory $DeleteAssistantResponseCopyWith(DeleteAssistantResponse value,
          $Res Function(DeleteAssistantResponse) then) =
      _$DeleteAssistantResponseCopyWithImpl<$Res, DeleteAssistantResponse>;
  @useResult
  $Res call({String id, bool deleted, DeleteAssistantResponseObject object});
}

/// @nodoc
class _$DeleteAssistantResponseCopyWithImpl<$Res,
        $Val extends DeleteAssistantResponse>
    implements $DeleteAssistantResponseCopyWith<$Res> {
  _$DeleteAssistantResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteAssistantResponseImplCopyWith<$Res>
    implements $DeleteAssistantResponseCopyWith<$Res> {
  factory _$$DeleteAssistantResponseImplCopyWith(
          _$DeleteAssistantResponseImpl value,
          $Res Function(_$DeleteAssistantResponseImpl) then) =
      __$$DeleteAssistantResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteAssistantResponseObject object});
}

/// @nodoc
class __$$DeleteAssistantResponseImplCopyWithImpl<$Res>
    extends _$DeleteAssistantResponseCopyWithImpl<$Res,
        _$DeleteAssistantResponseImpl>
    implements _$$DeleteAssistantResponseImplCopyWith<$Res> {
  __$$DeleteAssistantResponseImplCopyWithImpl(
      _$DeleteAssistantResponseImpl _value,
      $Res Function(_$DeleteAssistantResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteAssistantResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteAssistantResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteAssistantResponseImpl extends _DeleteAssistantResponse {
  const _$DeleteAssistantResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteAssistantResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteAssistantResponseImplFromJson(json);

  /// The assistant identifier.
  @override
  final String id;

  /// Whether the assistant was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `assistant.deleted`.
  @override
  final DeleteAssistantResponseObject object;

  @override
  String toString() {
    return 'DeleteAssistantResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteAssistantResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteAssistantResponseImplCopyWith<_$DeleteAssistantResponseImpl>
      get copyWith => __$$DeleteAssistantResponseImplCopyWithImpl<
          _$DeleteAssistantResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteAssistantResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteAssistantResponse extends DeleteAssistantResponse {
  const factory _DeleteAssistantResponse(
          {required final String id,
          required final bool deleted,
          required final DeleteAssistantResponseObject object}) =
      _$DeleteAssistantResponseImpl;
  const _DeleteAssistantResponse._() : super._();

  factory _DeleteAssistantResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteAssistantResponseImpl.fromJson;

  @override

  /// The assistant identifier.
  String get id;
  @override

  /// Whether the assistant was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `assistant.deleted`.
  DeleteAssistantResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteAssistantResponseImplCopyWith<_$DeleteAssistantResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListAssistantsResponse _$ListAssistantsResponseFromJson(
    Map<String, dynamic> json) {
  return _ListAssistantsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListAssistantsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of assistants.
  List<AssistantObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first assistant in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last assistant in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more assistants to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListAssistantsResponseCopyWith<ListAssistantsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListAssistantsResponseCopyWith<$Res> {
  factory $ListAssistantsResponseCopyWith(ListAssistantsResponse value,
          $Res Function(ListAssistantsResponse) then) =
      _$ListAssistantsResponseCopyWithImpl<$Res, ListAssistantsResponse>;
  @useResult
  $Res call(
      {String object,
      List<AssistantObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListAssistantsResponseCopyWithImpl<$Res,
        $Val extends ListAssistantsResponse>
    implements $ListAssistantsResponseCopyWith<$Res> {
  _$ListAssistantsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListAssistantsResponseImplCopyWith<$Res>
    implements $ListAssistantsResponseCopyWith<$Res> {
  factory _$$ListAssistantsResponseImplCopyWith(
          _$ListAssistantsResponseImpl value,
          $Res Function(_$ListAssistantsResponseImpl) then) =
      __$$ListAssistantsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<AssistantObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListAssistantsResponseImplCopyWithImpl<$Res>
    extends _$ListAssistantsResponseCopyWithImpl<$Res,
        _$ListAssistantsResponseImpl>
    implements _$$ListAssistantsResponseImplCopyWith<$Res> {
  __$$ListAssistantsResponseImplCopyWithImpl(
      _$ListAssistantsResponseImpl _value,
      $Res Function(_$ListAssistantsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListAssistantsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<AssistantObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListAssistantsResponseImpl extends _ListAssistantsResponse {
  const _$ListAssistantsResponseImpl(
      {required this.object,
      required final List<AssistantObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListAssistantsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListAssistantsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of assistants.
  final List<AssistantObject> _data;

  /// The list of assistants.
  @override
  List<AssistantObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first assistant in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last assistant in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more assistants to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListAssistantsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListAssistantsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListAssistantsResponseImplCopyWith<_$ListAssistantsResponseImpl>
      get copyWith => __$$ListAssistantsResponseImplCopyWithImpl<
          _$ListAssistantsResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListAssistantsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListAssistantsResponse extends ListAssistantsResponse {
  const factory _ListAssistantsResponse(
          {required final String object,
          required final List<AssistantObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListAssistantsResponseImpl;
  const _ListAssistantsResponse._() : super._();

  factory _ListAssistantsResponse.fromJson(Map<String, dynamic> json) =
      _$ListAssistantsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of assistants.
  List<AssistantObject> get data;
  @override

  /// The ID of the first assistant in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last assistant in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more assistants to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListAssistantsResponseImplCopyWith<_$ListAssistantsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantsNamedToolChoice _$AssistantsNamedToolChoiceFromJson(
    Map<String, dynamic> json) {
  return _AssistantsNamedToolChoice.fromJson(json);
}

/// @nodoc
mixin _$AssistantsNamedToolChoice {
  /// The type of the tool. If type is `function`, the function name must be set
  AssistantsToolType get type => throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(includeIfNull: false)
  AssistantsFunctionCallOption? get function =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantsNamedToolChoiceCopyWith<AssistantsNamedToolChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantsNamedToolChoiceCopyWith<$Res> {
  factory $AssistantsNamedToolChoiceCopyWith(AssistantsNamedToolChoice value,
          $Res Function(AssistantsNamedToolChoice) then) =
      _$AssistantsNamedToolChoiceCopyWithImpl<$Res, AssistantsNamedToolChoice>;
  @useResult
  $Res call(
      {AssistantsToolType type,
      @JsonKey(includeIfNull: false) AssistantsFunctionCallOption? function});

  $AssistantsFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class _$AssistantsNamedToolChoiceCopyWithImpl<$Res,
        $Val extends AssistantsNamedToolChoice>
    implements $AssistantsNamedToolChoiceCopyWith<$Res> {
  _$AssistantsNamedToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = freezed,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AssistantsToolType,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as AssistantsFunctionCallOption?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsFunctionCallOptionCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $AssistantsFunctionCallOptionCopyWith<$Res>(_value.function!,
        (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AssistantsNamedToolChoiceImplCopyWith<$Res>
    implements $AssistantsNamedToolChoiceCopyWith<$Res> {
  factory _$$AssistantsNamedToolChoiceImplCopyWith(
          _$AssistantsNamedToolChoiceImpl value,
          $Res Function(_$AssistantsNamedToolChoiceImpl) then) =
      __$$AssistantsNamedToolChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {AssistantsToolType type,
      @JsonKey(includeIfNull: false) AssistantsFunctionCallOption? function});

  @override
  $AssistantsFunctionCallOptionCopyWith<$Res>? get function;
}

/// @nodoc
class __$$AssistantsNamedToolChoiceImplCopyWithImpl<$Res>
    extends _$AssistantsNamedToolChoiceCopyWithImpl<$Res,
        _$AssistantsNamedToolChoiceImpl>
    implements _$$AssistantsNamedToolChoiceImplCopyWith<$Res> {
  __$$AssistantsNamedToolChoiceImplCopyWithImpl(
      _$AssistantsNamedToolChoiceImpl _value,
      $Res Function(_$AssistantsNamedToolChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = freezed,
  }) {
    return _then(_$AssistantsNamedToolChoiceImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AssistantsToolType,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as AssistantsFunctionCallOption?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantsNamedToolChoiceImpl extends _AssistantsNamedToolChoice {
  const _$AssistantsNamedToolChoiceImpl(
      {required this.type, @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$AssistantsNamedToolChoiceImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantsNamedToolChoiceImplFromJson(json);

  /// The type of the tool. If type is `function`, the function name must be set
  @override
  final AssistantsToolType type;

  /// No Description
  @override
  @JsonKey(includeIfNull: false)
  final AssistantsFunctionCallOption? function;

  @override
  String toString() {
    return 'AssistantsNamedToolChoice(type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantsNamedToolChoiceImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantsNamedToolChoiceImplCopyWith<_$AssistantsNamedToolChoiceImpl>
      get copyWith => __$$AssistantsNamedToolChoiceImplCopyWithImpl<
          _$AssistantsNamedToolChoiceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantsNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class _AssistantsNamedToolChoice extends AssistantsNamedToolChoice {
  const factory _AssistantsNamedToolChoice(
          {required final AssistantsToolType type,
          @JsonKey(includeIfNull: false)
          final AssistantsFunctionCallOption? function}) =
      _$AssistantsNamedToolChoiceImpl;
  const _AssistantsNamedToolChoice._() : super._();

  factory _AssistantsNamedToolChoice.fromJson(Map<String, dynamic> json) =
      _$AssistantsNamedToolChoiceImpl.fromJson;

  @override

  /// The type of the tool. If type is `function`, the function name must be set
  AssistantsToolType get type;
  @override

  /// No Description
  @JsonKey(includeIfNull: false)
  AssistantsFunctionCallOption? get function;
  @override
  @JsonKey(ignore: true)
  _$$AssistantsNamedToolChoiceImplCopyWith<_$AssistantsNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantsFunctionCallOption _$AssistantsFunctionCallOptionFromJson(
    Map<String, dynamic> json) {
  return _AssistantsFunctionCallOption.fromJson(json);
}

/// @nodoc
mixin _$AssistantsFunctionCallOption {
  /// The name of the function to call.
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantsFunctionCallOptionCopyWith<AssistantsFunctionCallOption>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantsFunctionCallOptionCopyWith<$Res> {
  factory $AssistantsFunctionCallOptionCopyWith(
          AssistantsFunctionCallOption value,
          $Res Function(AssistantsFunctionCallOption) then) =
      _$AssistantsFunctionCallOptionCopyWithImpl<$Res,
          AssistantsFunctionCallOption>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$AssistantsFunctionCallOptionCopyWithImpl<$Res,
        $Val extends AssistantsFunctionCallOption>
    implements $AssistantsFunctionCallOptionCopyWith<$Res> {
  _$AssistantsFunctionCallOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssistantsFunctionCallOptionImplCopyWith<$Res>
    implements $AssistantsFunctionCallOptionCopyWith<$Res> {
  factory _$$AssistantsFunctionCallOptionImplCopyWith(
          _$AssistantsFunctionCallOptionImpl value,
          $Res Function(_$AssistantsFunctionCallOptionImpl) then) =
      __$$AssistantsFunctionCallOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$AssistantsFunctionCallOptionImplCopyWithImpl<$Res>
    extends _$AssistantsFunctionCallOptionCopyWithImpl<$Res,
        _$AssistantsFunctionCallOptionImpl>
    implements _$$AssistantsFunctionCallOptionImplCopyWith<$Res> {
  __$$AssistantsFunctionCallOptionImplCopyWithImpl(
      _$AssistantsFunctionCallOptionImpl _value,
      $Res Function(_$AssistantsFunctionCallOptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$AssistantsFunctionCallOptionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantsFunctionCallOptionImpl extends _AssistantsFunctionCallOption {
  const _$AssistantsFunctionCallOptionImpl({required this.name}) : super._();

  factory _$AssistantsFunctionCallOptionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$AssistantsFunctionCallOptionImplFromJson(json);

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'AssistantsFunctionCallOption(name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantsFunctionCallOptionImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantsFunctionCallOptionImplCopyWith<
          _$AssistantsFunctionCallOptionImpl>
      get copyWith => __$$AssistantsFunctionCallOptionImplCopyWithImpl<
          _$AssistantsFunctionCallOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantsFunctionCallOptionImplToJson(
      this,
    );
  }
}

abstract class _AssistantsFunctionCallOption
    extends AssistantsFunctionCallOption {
  const factory _AssistantsFunctionCallOption({required final String name}) =
      _$AssistantsFunctionCallOptionImpl;
  const _AssistantsFunctionCallOption._() : super._();

  factory _AssistantsFunctionCallOption.fromJson(Map<String, dynamic> json) =
      _$AssistantsFunctionCallOptionImpl.fromJson;

  @override

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$AssistantsFunctionCallOptionImplCopyWith<
          _$AssistantsFunctionCallOptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantsResponseFormat _$AssistantsResponseFormatFromJson(
    Map<String, dynamic> json) {
  return _AssistantsResponseFormat.fromJson(json);
}

/// @nodoc
mixin _$AssistantsResponseFormat {
  /// Must be one of `text` or `json_object`.
  AssistantsResponseFormatType get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantsResponseFormatCopyWith<AssistantsResponseFormat> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantsResponseFormatCopyWith<$Res> {
  factory $AssistantsResponseFormatCopyWith(AssistantsResponseFormat value,
          $Res Function(AssistantsResponseFormat) then) =
      _$AssistantsResponseFormatCopyWithImpl<$Res, AssistantsResponseFormat>;
  @useResult
  $Res call({AssistantsResponseFormatType type});
}

/// @nodoc
class _$AssistantsResponseFormatCopyWithImpl<$Res,
        $Val extends AssistantsResponseFormat>
    implements $AssistantsResponseFormatCopyWith<$Res> {
  _$AssistantsResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormatType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssistantsResponseFormatImplCopyWith<$Res>
    implements $AssistantsResponseFormatCopyWith<$Res> {
  factory _$$AssistantsResponseFormatImplCopyWith(
          _$AssistantsResponseFormatImpl value,
          $Res Function(_$AssistantsResponseFormatImpl) then) =
      __$$AssistantsResponseFormatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({AssistantsResponseFormatType type});
}

/// @nodoc
class __$$AssistantsResponseFormatImplCopyWithImpl<$Res>
    extends _$AssistantsResponseFormatCopyWithImpl<$Res,
        _$AssistantsResponseFormatImpl>
    implements _$$AssistantsResponseFormatImplCopyWith<$Res> {
  __$$AssistantsResponseFormatImplCopyWithImpl(
      _$AssistantsResponseFormatImpl _value,
      $Res Function(_$AssistantsResponseFormatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$AssistantsResponseFormatImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormatType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantsResponseFormatImpl extends _AssistantsResponseFormat {
  const _$AssistantsResponseFormatImpl(
      {this.type = AssistantsResponseFormatType.text})
      : super._();

  factory _$AssistantsResponseFormatImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantsResponseFormatImplFromJson(json);

  /// Must be one of `text` or `json_object`.
  @override
  @JsonKey()
  final AssistantsResponseFormatType type;

  @override
  String toString() {
    return 'AssistantsResponseFormat(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantsResponseFormatImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantsResponseFormatImplCopyWith<_$AssistantsResponseFormatImpl>
      get copyWith => __$$AssistantsResponseFormatImplCopyWithImpl<
          _$AssistantsResponseFormatImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantsResponseFormatImplToJson(
      this,
    );
  }
}

abstract class _AssistantsResponseFormat extends AssistantsResponseFormat {
  const factory _AssistantsResponseFormat(
          {final AssistantsResponseFormatType type}) =
      _$AssistantsResponseFormatImpl;
  const _AssistantsResponseFormat._() : super._();

  factory _AssistantsResponseFormat.fromJson(Map<String, dynamic> json) =
      _$AssistantsResponseFormatImpl.fromJson;

  @override

  /// Must be one of `text` or `json_object`.
  AssistantsResponseFormatType get type;
  @override
  @JsonKey(ignore: true)
  _$$AssistantsResponseFormatImplCopyWith<_$AssistantsResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TruncationObject _$TruncationObjectFromJson(Map<String, dynamic> json) {
  return _TruncationObject.fromJson(json);
}

/// @nodoc
mixin _$TruncationObject {
  /// The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
  TruncationObjectType get type => throw _privateConstructorUsedError;

  /// The number of most recent messages from the thread when constructing the context for the run.
  @JsonKey(name: 'last_messages', includeIfNull: false)
  int? get lastMessages => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TruncationObjectCopyWith<TruncationObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TruncationObjectCopyWith<$Res> {
  factory $TruncationObjectCopyWith(
          TruncationObject value, $Res Function(TruncationObject) then) =
      _$TruncationObjectCopyWithImpl<$Res, TruncationObject>;
  @useResult
  $Res call(
      {TruncationObjectType type,
      @JsonKey(name: 'last_messages', includeIfNull: false) int? lastMessages});
}

/// @nodoc
class _$TruncationObjectCopyWithImpl<$Res, $Val extends TruncationObject>
    implements $TruncationObjectCopyWith<$Res> {
  _$TruncationObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? lastMessages = freezed,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as TruncationObjectType,
      lastMessages: freezed == lastMessages
          ? _value.lastMessages
          : lastMessages // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TruncationObjectImplCopyWith<$Res>
    implements $TruncationObjectCopyWith<$Res> {
  factory _$$TruncationObjectImplCopyWith(_$TruncationObjectImpl value,
          $Res Function(_$TruncationObjectImpl) then) =
      __$$TruncationObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {TruncationObjectType type,
      @JsonKey(name: 'last_messages', includeIfNull: false) int? lastMessages});
}

/// @nodoc
class __$$TruncationObjectImplCopyWithImpl<$Res>
    extends _$TruncationObjectCopyWithImpl<$Res, _$TruncationObjectImpl>
    implements _$$TruncationObjectImplCopyWith<$Res> {
  __$$TruncationObjectImplCopyWithImpl(_$TruncationObjectImpl _value,
      $Res Function(_$TruncationObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? lastMessages = freezed,
  }) {
    return _then(_$TruncationObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as TruncationObjectType,
      lastMessages: freezed == lastMessages
          ? _value.lastMessages
          : lastMessages // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TruncationObjectImpl extends _TruncationObject {
  const _$TruncationObjectImpl(
      {required this.type,
      @JsonKey(name: 'last_messages', includeIfNull: false) this.lastMessages})
      : super._();

  factory _$TruncationObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$TruncationObjectImplFromJson(json);

  /// The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
  @override
  final TruncationObjectType type;

  /// The number of most recent messages from the thread when constructing the context for the run.
  @override
  @JsonKey(name: 'last_messages', includeIfNull: false)
  final int? lastMessages;

  @override
  String toString() {
    return 'TruncationObject(type: $type, lastMessages: $lastMessages)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TruncationObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.lastMessages, lastMessages) ||
                other.lastMessages == lastMessages));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, lastMessages);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TruncationObjectImplCopyWith<_$TruncationObjectImpl> get copyWith =>
      __$$TruncationObjectImplCopyWithImpl<_$TruncationObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TruncationObjectImplToJson(
      this,
    );
  }
}

abstract class _TruncationObject extends TruncationObject {
  const factory _TruncationObject(
      {required final TruncationObjectType type,
      @JsonKey(name: 'last_messages', includeIfNull: false)
      final int? lastMessages}) = _$TruncationObjectImpl;
  const _TruncationObject._() : super._();

  factory _TruncationObject.fromJson(Map<String, dynamic> json) =
      _$TruncationObjectImpl.fromJson;

  @override

  /// The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
  TruncationObjectType get type;
  @override

  /// The number of most recent messages from the thread when constructing the context for the run.
  @JsonKey(name: 'last_messages', includeIfNull: false)
  int? get lastMessages;
  @override
  @JsonKey(ignore: true)
  _$$TruncationObjectImplCopyWith<_$TruncationObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunObject _$RunObjectFromJson(Map<String, dynamic> json) {
  return _RunObject.fromJson(json);
}

/// @nodoc
mixin _$RunObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.run`.
  RunObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @JsonKey(name: 'thread_id')
  String get threadId => throw _privateConstructorUsedError;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
  RunStatus get status => throw _privateConstructorUsedError;

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @JsonKey(name: 'required_action')
  RunRequiredAction? get requiredAction => throw _privateConstructorUsedError;

  /// The last error associated with this run. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunLastError? get lastError => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run will expire.
  @JsonKey(name: 'expires_at')
  int? get expiresAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was started.
  @JsonKey(name: 'started_at')
  int? get startedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt => throw _privateConstructorUsedError;

  /// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
  @JsonKey(name: 'incomplete_details')
  RunObjectIncompleteDetails? get incompleteDetails =>
      throw _privateConstructorUsedError;

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get model => throw _privateConstructorUsedError;

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get instructions => throw _privateConstructorUsedError;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  List<AssistantTools> get tools => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  RunCompletionUsage? get usage => throw _privateConstructorUsedError;

  /// The sampling temperature used for this run. If not set, defaults to 1.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// The nucleus sampling value used for this run. If not set, defaults to 1.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// The maximum number of prompt tokens specified to have been used over the course of the run.
  @JsonKey(name: 'max_prompt_tokens')
  int? get maxPromptTokens => throw _privateConstructorUsedError;

  /// The maximum number of completion tokens specified to have been used over the course of the run.
  @JsonKey(name: 'max_completion_tokens')
  int? get maxCompletionTokens => throw _privateConstructorUsedError;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @JsonKey(name: 'truncation_strategy')
  TruncationObject? get truncationStrategy =>
      throw _privateConstructorUsedError;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_RunObjectToolChoiceConverter()
  @JsonKey(name: 'tool_choice')
  RunObjectToolChoice? get toolChoice => throw _privateConstructorUsedError;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls')
  bool? get parallelToolCalls => throw _privateConstructorUsedError;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_RunObjectResponseFormatConverter()
  @JsonKey(name: 'response_format')
  RunObjectResponseFormat get responseFormat =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunObjectCopyWith<RunObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunObjectCopyWith<$Res> {
  factory $RunObjectCopyWith(RunObject value, $Res Function(RunObject) then) =
      _$RunObjectCopyWithImpl<$Res, RunObject>;
  @useResult
  $Res call(
      {String id,
      RunObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'assistant_id') String assistantId,
      RunStatus status,
      @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') RunLastError? lastError,
      @JsonKey(name: 'expires_at') int? expiresAt,
      @JsonKey(name: 'started_at') int? startedAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_details')
      RunObjectIncompleteDetails? incompleteDetails,
      String model,
      String instructions,
      List<AssistantTools> tools,
      Map<String, dynamic>? metadata,
      RunCompletionUsage? usage,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens') int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens') int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy')
      TruncationObject? truncationStrategy,
      @_RunObjectToolChoiceConverter()
      @JsonKey(name: 'tool_choice')
      RunObjectToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls') bool? parallelToolCalls,
      @_RunObjectResponseFormatConverter()
      @JsonKey(name: 'response_format')
      RunObjectResponseFormat responseFormat});

  $RunRequiredActionCopyWith<$Res>? get requiredAction;
  $RunLastErrorCopyWith<$Res>? get lastError;
  $RunObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
  $RunCompletionUsageCopyWith<$Res>? get usage;
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  $RunObjectToolChoiceCopyWith<$Res>? get toolChoice;
  $RunObjectResponseFormatCopyWith<$Res> get responseFormat;
}

/// @nodoc
class _$RunObjectCopyWithImpl<$Res, $Val extends RunObject>
    implements $RunObjectCopyWith<$Res> {
  _$RunObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? assistantId = null,
    Object? status = null,
    Object? requiredAction = freezed,
    Object? lastError = freezed,
    Object? expiresAt = freezed,
    Object? startedAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? incompleteDetails = freezed,
    Object? model = null,
    Object? instructions = null,
    Object? tools = null,
    Object? metadata = freezed,
    Object? usage = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStatus,
      requiredAction: freezed == requiredAction
          ? _value.requiredAction
          : requiredAction // ignore: cast_nullable_to_non_nullable
              as RunRequiredAction?,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunLastError?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      startedAt: freezed == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteDetails: freezed == incompleteDetails
          ? _value.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetails?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: null == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String,
      tools: null == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunCompletionUsage?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _value.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _value.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _value.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as RunObjectToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: null == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as RunObjectResponseFormat,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunRequiredActionCopyWith<$Res>? get requiredAction {
    if (_value.requiredAction == null) {
      return null;
    }

    return $RunRequiredActionCopyWith<$Res>(_value.requiredAction!, (value) {
      return _then(_value.copyWith(requiredAction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunLastErrorCopyWith<$Res>? get lastError {
    if (_value.lastError == null) {
      return null;
    }

    return $RunLastErrorCopyWith<$Res>(_value.lastError!, (value) {
      return _then(_value.copyWith(lastError: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails {
    if (_value.incompleteDetails == null) {
      return null;
    }

    return $RunObjectIncompleteDetailsCopyWith<$Res>(_value.incompleteDetails!,
        (value) {
      return _then(_value.copyWith(incompleteDetails: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunCompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $RunCompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_value.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_value.truncationStrategy!, (value) {
      return _then(_value.copyWith(truncationStrategy: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunObjectToolChoiceCopyWith<$Res>? get toolChoice {
    if (_value.toolChoice == null) {
      return null;
    }

    return $RunObjectToolChoiceCopyWith<$Res>(_value.toolChoice!, (value) {
      return _then(_value.copyWith(toolChoice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunObjectResponseFormatCopyWith<$Res> get responseFormat {
    return $RunObjectResponseFormatCopyWith<$Res>(_value.responseFormat,
        (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunObjectImplCopyWith<$Res>
    implements $RunObjectCopyWith<$Res> {
  factory _$$RunObjectImplCopyWith(
          _$RunObjectImpl value, $Res Function(_$RunObjectImpl) then) =
      __$$RunObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      RunObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'assistant_id') String assistantId,
      RunStatus status,
      @JsonKey(name: 'required_action') RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') RunLastError? lastError,
      @JsonKey(name: 'expires_at') int? expiresAt,
      @JsonKey(name: 'started_at') int? startedAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_details')
      RunObjectIncompleteDetails? incompleteDetails,
      String model,
      String instructions,
      List<AssistantTools> tools,
      Map<String, dynamic>? metadata,
      RunCompletionUsage? usage,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens') int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens') int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy')
      TruncationObject? truncationStrategy,
      @_RunObjectToolChoiceConverter()
      @JsonKey(name: 'tool_choice')
      RunObjectToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls') bool? parallelToolCalls,
      @_RunObjectResponseFormatConverter()
      @JsonKey(name: 'response_format')
      RunObjectResponseFormat responseFormat});

  @override
  $RunRequiredActionCopyWith<$Res>? get requiredAction;
  @override
  $RunLastErrorCopyWith<$Res>? get lastError;
  @override
  $RunObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
  @override
  $RunCompletionUsageCopyWith<$Res>? get usage;
  @override
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  @override
  $RunObjectToolChoiceCopyWith<$Res>? get toolChoice;
  @override
  $RunObjectResponseFormatCopyWith<$Res> get responseFormat;
}

/// @nodoc
class __$$RunObjectImplCopyWithImpl<$Res>
    extends _$RunObjectCopyWithImpl<$Res, _$RunObjectImpl>
    implements _$$RunObjectImplCopyWith<$Res> {
  __$$RunObjectImplCopyWithImpl(
      _$RunObjectImpl _value, $Res Function(_$RunObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? assistantId = null,
    Object? status = null,
    Object? requiredAction = freezed,
    Object? lastError = freezed,
    Object? expiresAt = freezed,
    Object? startedAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? incompleteDetails = freezed,
    Object? model = null,
    Object? instructions = null,
    Object? tools = null,
    Object? metadata = freezed,
    Object? usage = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = null,
  }) {
    return _then(_$RunObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStatus,
      requiredAction: freezed == requiredAction
          ? _value.requiredAction
          : requiredAction // ignore: cast_nullable_to_non_nullable
              as RunRequiredAction?,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunLastError?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      startedAt: freezed == startedAt
          ? _value.startedAt
          : startedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteDetails: freezed == incompleteDetails
          ? _value.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetails?,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
      instructions: null == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String,
      tools: null == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunCompletionUsage?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _value.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _value.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _value.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as RunObjectToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: null == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as RunObjectResponseFormat,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunObjectImpl extends _RunObject {
  const _$RunObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      required this.status,
      @JsonKey(name: 'required_action') required this.requiredAction,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'expires_at') required this.expiresAt,
      @JsonKey(name: 'started_at') required this.startedAt,
      @JsonKey(name: 'cancelled_at') required this.cancelledAt,
      @JsonKey(name: 'failed_at') required this.failedAt,
      @JsonKey(name: 'completed_at') required this.completedAt,
      @JsonKey(name: 'incomplete_details') required this.incompleteDetails,
      required this.model,
      required this.instructions,
      required final List<AssistantTools> tools,
      required final Map<String, dynamic>? metadata,
      required this.usage,
      @JsonKey(includeIfNull: false) this.temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP,
      @JsonKey(name: 'max_prompt_tokens') required this.maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens') required this.maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy') required this.truncationStrategy,
      @_RunObjectToolChoiceConverter()
      @JsonKey(name: 'tool_choice')
      required this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls') required this.parallelToolCalls,
      @_RunObjectResponseFormatConverter()
      @JsonKey(name: 'response_format')
      required this.responseFormat})
      : _tools = tools,
        _metadata = metadata,
        super._();

  factory _$RunObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run`.
  @override
  final RunObjectObject object;

  /// The Unix timestamp (in seconds) for when the run was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
  @override
  final RunStatus status;

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @override
  @JsonKey(name: 'required_action')
  final RunRequiredAction? requiredAction;

  /// The last error associated with this run. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final RunLastError? lastError;

  /// The Unix timestamp (in seconds) for when the run will expire.
  @override
  @JsonKey(name: 'expires_at')
  final int? expiresAt;

  /// The Unix timestamp (in seconds) for when the run was started.
  @override
  @JsonKey(name: 'started_at')
  final int? startedAt;

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @override
  @JsonKey(name: 'cancelled_at')
  final int? cancelledAt;

  /// The Unix timestamp (in seconds) for when the run failed.
  @override
  @JsonKey(name: 'failed_at')
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the run was completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
  @override
  @JsonKey(name: 'incomplete_details')
  final RunObjectIncompleteDetails? incompleteDetails;

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  final String model;

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  final String instructions;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  final List<AssistantTools> _tools;

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  @override
  List<AssistantTools> get tools {
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tools);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  @override
  final RunCompletionUsage? usage;

  /// The sampling temperature used for this run. If not set, defaults to 1.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// The nucleus sampling value used for this run. If not set, defaults to 1.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// The maximum number of prompt tokens specified to have been used over the course of the run.
  @override
  @JsonKey(name: 'max_prompt_tokens')
  final int? maxPromptTokens;

  /// The maximum number of completion tokens specified to have been used over the course of the run.
  @override
  @JsonKey(name: 'max_completion_tokens')
  final int? maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @override
  @JsonKey(name: 'truncation_strategy')
  final TruncationObject? truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @override
  @_RunObjectToolChoiceConverter()
  @JsonKey(name: 'tool_choice')
  final RunObjectToolChoice? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls')
  final bool? parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_RunObjectResponseFormatConverter()
  @JsonKey(name: 'response_format')
  final RunObjectResponseFormat responseFormat;

  @override
  String toString() {
    return 'RunObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, assistantId: $assistantId, status: $status, requiredAction: $requiredAction, lastError: $lastError, expiresAt: $expiresAt, startedAt: $startedAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, incompleteDetails: $incompleteDetails, model: $model, instructions: $instructions, tools: $tools, metadata: $metadata, usage: $usage, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.requiredAction, requiredAction) ||
                other.requiredAction == requiredAction) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.startedAt, startedAt) ||
                other.startedAt == startedAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.incompleteDetails, incompleteDetails) ||
                other.incompleteDetails == incompleteDetails) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.usage, usage) || other.usage == usage) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        createdAt,
        threadId,
        assistantId,
        status,
        requiredAction,
        lastError,
        expiresAt,
        startedAt,
        cancelledAt,
        failedAt,
        completedAt,
        incompleteDetails,
        model,
        instructions,
        const DeepCollectionEquality().hash(_tools),
        const DeepCollectionEquality().hash(_metadata),
        usage,
        temperature,
        topP,
        maxPromptTokens,
        maxCompletionTokens,
        truncationStrategy,
        toolChoice,
        parallelToolCalls,
        responseFormat
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunObjectImplCopyWith<_$RunObjectImpl> get copyWith =>
      __$$RunObjectImplCopyWithImpl<_$RunObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunObjectImplToJson(
      this,
    );
  }
}

abstract class _RunObject extends RunObject {
  const factory _RunObject(
      {required final String id,
      required final RunObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'thread_id') required final String threadId,
      @JsonKey(name: 'assistant_id') required final String assistantId,
      required final RunStatus status,
      @JsonKey(name: 'required_action')
      required final RunRequiredAction? requiredAction,
      @JsonKey(name: 'last_error') required final RunLastError? lastError,
      @JsonKey(name: 'expires_at') required final int? expiresAt,
      @JsonKey(name: 'started_at') required final int? startedAt,
      @JsonKey(name: 'cancelled_at') required final int? cancelledAt,
      @JsonKey(name: 'failed_at') required final int? failedAt,
      @JsonKey(name: 'completed_at') required final int? completedAt,
      @JsonKey(name: 'incomplete_details')
      required final RunObjectIncompleteDetails? incompleteDetails,
      required final String model,
      required final String instructions,
      required final List<AssistantTools> tools,
      required final Map<String, dynamic>? metadata,
      required final RunCompletionUsage? usage,
      @JsonKey(includeIfNull: false) final double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
      @JsonKey(name: 'max_prompt_tokens') required final int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens')
      required final int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy')
      required final TruncationObject? truncationStrategy,
      @_RunObjectToolChoiceConverter()
      @JsonKey(name: 'tool_choice')
      required final RunObjectToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls')
      required final bool? parallelToolCalls,
      @_RunObjectResponseFormatConverter()
      @JsonKey(name: 'response_format')
      required final RunObjectResponseFormat responseFormat}) = _$RunObjectImpl;
  const _RunObject._() : super._();

  factory _RunObject.fromJson(Map<String, dynamic> json) =
      _$RunObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.run`.
  RunObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the run was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run.
  @JsonKey(name: 'thread_id')
  String get threadId;
  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
  RunStatus get status;
  @override

  /// Details on the action required to continue the run. Will be `null` if no action is required.
  @JsonKey(name: 'required_action')
  RunRequiredAction? get requiredAction;
  @override

  /// The last error associated with this run. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunLastError? get lastError;
  @override

  /// The Unix timestamp (in seconds) for when the run will expire.
  @JsonKey(name: 'expires_at')
  int? get expiresAt;
  @override

  /// The Unix timestamp (in seconds) for when the run was started.
  @JsonKey(name: 'started_at')
  int? get startedAt;
  @override

  /// The Unix timestamp (in seconds) for when the run was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt;
  @override

  /// The Unix timestamp (in seconds) for when the run failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt;
  @override

  /// The Unix timestamp (in seconds) for when the run was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;
  @override

  /// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
  @JsonKey(name: 'incomplete_details')
  RunObjectIncompleteDetails? get incompleteDetails;
  @override

  /// The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get model;
  @override

  /// The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  String get instructions;
  @override

  /// The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.
  List<AssistantTools> get tools;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override

  /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
  RunCompletionUsage? get usage;
  @override

  /// The sampling temperature used for this run. If not set, defaults to 1.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// The nucleus sampling value used for this run. If not set, defaults to 1.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// The maximum number of prompt tokens specified to have been used over the course of the run.
  @JsonKey(name: 'max_prompt_tokens')
  int? get maxPromptTokens;
  @override

  /// The maximum number of completion tokens specified to have been used over the course of the run.
  @JsonKey(name: 'max_completion_tokens')
  int? get maxCompletionTokens;
  @override

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @JsonKey(name: 'truncation_strategy')
  TruncationObject? get truncationStrategy;
  @override

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_RunObjectToolChoiceConverter()
  @JsonKey(name: 'tool_choice')
  RunObjectToolChoice? get toolChoice;
  @override

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls')
  bool? get parallelToolCalls;
  @override

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_RunObjectResponseFormatConverter()
  @JsonKey(name: 'response_format')
  RunObjectResponseFormat get responseFormat;
  @override
  @JsonKey(ignore: true)
  _$$RunObjectImplCopyWith<_$RunObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunRequiredAction _$RunRequiredActionFromJson(Map<String, dynamic> json) {
  return _RunRequiredAction.fromJson(json);
}

/// @nodoc
mixin _$RunRequiredAction {
  /// For now, this is always `submit_tool_outputs`.
  RunRequiredActionType get type => throw _privateConstructorUsedError;

  /// Details on the tool outputs needed for this run to continue.
  @JsonKey(name: 'submit_tool_outputs')
  RunSubmitToolOutputs get submitToolOutputs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunRequiredActionCopyWith<RunRequiredAction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunRequiredActionCopyWith<$Res> {
  factory $RunRequiredActionCopyWith(
          RunRequiredAction value, $Res Function(RunRequiredAction) then) =
      _$RunRequiredActionCopyWithImpl<$Res, RunRequiredAction>;
  @useResult
  $Res call(
      {RunRequiredActionType type,
      @JsonKey(name: 'submit_tool_outputs')
      RunSubmitToolOutputs submitToolOutputs});

  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs;
}

/// @nodoc
class _$RunRequiredActionCopyWithImpl<$Res, $Val extends RunRequiredAction>
    implements $RunRequiredActionCopyWith<$Res> {
  _$RunRequiredActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? submitToolOutputs = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunRequiredActionType,
      submitToolOutputs: null == submitToolOutputs
          ? _value.submitToolOutputs
          : submitToolOutputs // ignore: cast_nullable_to_non_nullable
              as RunSubmitToolOutputs,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs {
    return $RunSubmitToolOutputsCopyWith<$Res>(_value.submitToolOutputs,
        (value) {
      return _then(_value.copyWith(submitToolOutputs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunRequiredActionImplCopyWith<$Res>
    implements $RunRequiredActionCopyWith<$Res> {
  factory _$$RunRequiredActionImplCopyWith(_$RunRequiredActionImpl value,
          $Res Function(_$RunRequiredActionImpl) then) =
      __$$RunRequiredActionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RunRequiredActionType type,
      @JsonKey(name: 'submit_tool_outputs')
      RunSubmitToolOutputs submitToolOutputs});

  @override
  $RunSubmitToolOutputsCopyWith<$Res> get submitToolOutputs;
}

/// @nodoc
class __$$RunRequiredActionImplCopyWithImpl<$Res>
    extends _$RunRequiredActionCopyWithImpl<$Res, _$RunRequiredActionImpl>
    implements _$$RunRequiredActionImplCopyWith<$Res> {
  __$$RunRequiredActionImplCopyWithImpl(_$RunRequiredActionImpl _value,
      $Res Function(_$RunRequiredActionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? submitToolOutputs = null,
  }) {
    return _then(_$RunRequiredActionImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunRequiredActionType,
      submitToolOutputs: null == submitToolOutputs
          ? _value.submitToolOutputs
          : submitToolOutputs // ignore: cast_nullable_to_non_nullable
              as RunSubmitToolOutputs,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunRequiredActionImpl extends _RunRequiredAction {
  const _$RunRequiredActionImpl(
      {required this.type,
      @JsonKey(name: 'submit_tool_outputs') required this.submitToolOutputs})
      : super._();

  factory _$RunRequiredActionImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunRequiredActionImplFromJson(json);

  /// For now, this is always `submit_tool_outputs`.
  @override
  final RunRequiredActionType type;

  /// Details on the tool outputs needed for this run to continue.
  @override
  @JsonKey(name: 'submit_tool_outputs')
  final RunSubmitToolOutputs submitToolOutputs;

  @override
  String toString() {
    return 'RunRequiredAction(type: $type, submitToolOutputs: $submitToolOutputs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunRequiredActionImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.submitToolOutputs, submitToolOutputs) ||
                other.submitToolOutputs == submitToolOutputs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, submitToolOutputs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunRequiredActionImplCopyWith<_$RunRequiredActionImpl> get copyWith =>
      __$$RunRequiredActionImplCopyWithImpl<_$RunRequiredActionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunRequiredActionImplToJson(
      this,
    );
  }
}

abstract class _RunRequiredAction extends RunRequiredAction {
  const factory _RunRequiredAction(
          {required final RunRequiredActionType type,
          @JsonKey(name: 'submit_tool_outputs')
          required final RunSubmitToolOutputs submitToolOutputs}) =
      _$RunRequiredActionImpl;
  const _RunRequiredAction._() : super._();

  factory _RunRequiredAction.fromJson(Map<String, dynamic> json) =
      _$RunRequiredActionImpl.fromJson;

  @override

  /// For now, this is always `submit_tool_outputs`.
  RunRequiredActionType get type;
  @override

  /// Details on the tool outputs needed for this run to continue.
  @JsonKey(name: 'submit_tool_outputs')
  RunSubmitToolOutputs get submitToolOutputs;
  @override
  @JsonKey(ignore: true)
  _$$RunRequiredActionImplCopyWith<_$RunRequiredActionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunLastError _$RunLastErrorFromJson(Map<String, dynamic> json) {
  return _RunLastError.fromJson(json);
}

/// @nodoc
mixin _$RunLastError {
  /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
  RunLastErrorCode get code => throw _privateConstructorUsedError;

  /// A human-readable description of the error.
  String get message => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunLastErrorCopyWith<RunLastError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunLastErrorCopyWith<$Res> {
  factory $RunLastErrorCopyWith(
          RunLastError value, $Res Function(RunLastError) then) =
      _$RunLastErrorCopyWithImpl<$Res, RunLastError>;
  @useResult
  $Res call({RunLastErrorCode code, String message});
}

/// @nodoc
class _$RunLastErrorCopyWithImpl<$Res, $Val extends RunLastError>
    implements $RunLastErrorCopyWith<$Res> {
  _$RunLastErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunLastErrorImplCopyWith<$Res>
    implements $RunLastErrorCopyWith<$Res> {
  factory _$$RunLastErrorImplCopyWith(
          _$RunLastErrorImpl value, $Res Function(_$RunLastErrorImpl) then) =
      __$$RunLastErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({RunLastErrorCode code, String message});
}

/// @nodoc
class __$$RunLastErrorImplCopyWithImpl<$Res>
    extends _$RunLastErrorCopyWithImpl<$Res, _$RunLastErrorImpl>
    implements _$$RunLastErrorImplCopyWith<$Res> {
  __$$RunLastErrorImplCopyWithImpl(
      _$RunLastErrorImpl _value, $Res Function(_$RunLastErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_$RunLastErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunLastErrorImpl extends _RunLastError {
  const _$RunLastErrorImpl({required this.code, required this.message})
      : super._();

  factory _$RunLastErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunLastErrorImplFromJson(json);

  /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
  @override
  final RunLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  @override
  String toString() {
    return 'RunLastError(code: $code, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunLastErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunLastErrorImplCopyWith<_$RunLastErrorImpl> get copyWith =>
      __$$RunLastErrorImplCopyWithImpl<_$RunLastErrorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunLastErrorImplToJson(
      this,
    );
  }
}

abstract class _RunLastError extends RunLastError {
  const factory _RunLastError(
      {required final RunLastErrorCode code,
      required final String message}) = _$RunLastErrorImpl;
  const _RunLastError._() : super._();

  factory _RunLastError.fromJson(Map<String, dynamic> json) =
      _$RunLastErrorImpl.fromJson;

  @override

  /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
  RunLastErrorCode get code;
  @override

  /// A human-readable description of the error.
  String get message;
  @override
  @JsonKey(ignore: true)
  _$$RunLastErrorImplCopyWith<_$RunLastErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunObjectIncompleteDetails _$RunObjectIncompleteDetailsFromJson(
    Map<String, dynamic> json) {
  return _RunObjectIncompleteDetails.fromJson(json);
}

/// @nodoc
mixin _$RunObjectIncompleteDetails {
  /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  RunObjectIncompleteDetailsReason? get reason =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunObjectIncompleteDetailsCopyWith<RunObjectIncompleteDetails>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunObjectIncompleteDetailsCopyWith<$Res> {
  factory $RunObjectIncompleteDetailsCopyWith(RunObjectIncompleteDetails value,
          $Res Function(RunObjectIncompleteDetails) then) =
      _$RunObjectIncompleteDetailsCopyWithImpl<$Res,
          RunObjectIncompleteDetails>;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      RunObjectIncompleteDetailsReason? reason});
}

/// @nodoc
class _$RunObjectIncompleteDetailsCopyWithImpl<$Res,
        $Val extends RunObjectIncompleteDetails>
    implements $RunObjectIncompleteDetailsCopyWith<$Res> {
  _$RunObjectIncompleteDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = freezed,
  }) {
    return _then(_value.copyWith(
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetailsReason?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunObjectIncompleteDetailsImplCopyWith<$Res>
    implements $RunObjectIncompleteDetailsCopyWith<$Res> {
  factory _$$RunObjectIncompleteDetailsImplCopyWith(
          _$RunObjectIncompleteDetailsImpl value,
          $Res Function(_$RunObjectIncompleteDetailsImpl) then) =
      __$$RunObjectIncompleteDetailsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      RunObjectIncompleteDetailsReason? reason});
}

/// @nodoc
class __$$RunObjectIncompleteDetailsImplCopyWithImpl<$Res>
    extends _$RunObjectIncompleteDetailsCopyWithImpl<$Res,
        _$RunObjectIncompleteDetailsImpl>
    implements _$$RunObjectIncompleteDetailsImplCopyWith<$Res> {
  __$$RunObjectIncompleteDetailsImplCopyWithImpl(
      _$RunObjectIncompleteDetailsImpl _value,
      $Res Function(_$RunObjectIncompleteDetailsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = freezed,
  }) {
    return _then(_$RunObjectIncompleteDetailsImpl(
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as RunObjectIncompleteDetailsReason?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunObjectIncompleteDetailsImpl extends _RunObjectIncompleteDetails {
  const _$RunObjectIncompleteDetailsImpl(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.reason})
      : super._();

  factory _$RunObjectIncompleteDetailsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunObjectIncompleteDetailsImplFromJson(json);

  /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final RunObjectIncompleteDetailsReason? reason;

  @override
  String toString() {
    return 'RunObjectIncompleteDetails(reason: $reason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunObjectIncompleteDetailsImpl &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunObjectIncompleteDetailsImplCopyWith<_$RunObjectIncompleteDetailsImpl>
      get copyWith => __$$RunObjectIncompleteDetailsImplCopyWithImpl<
          _$RunObjectIncompleteDetailsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunObjectIncompleteDetailsImplToJson(
      this,
    );
  }
}

abstract class _RunObjectIncompleteDetails extends RunObjectIncompleteDetails {
  const factory _RunObjectIncompleteDetails(
          {@JsonKey(
              includeIfNull: false,
              unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
          final RunObjectIncompleteDetailsReason? reason}) =
      _$RunObjectIncompleteDetailsImpl;
  const _RunObjectIncompleteDetails._() : super._();

  factory _RunObjectIncompleteDetails.fromJson(Map<String, dynamic> json) =
      _$RunObjectIncompleteDetailsImpl.fromJson;

  @override

  /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  RunObjectIncompleteDetailsReason? get reason;
  @override
  @JsonKey(ignore: true)
  _$$RunObjectIncompleteDetailsImplCopyWith<_$RunObjectIncompleteDetailsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunObjectToolChoice _$RunObjectToolChoiceFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return RunObjectToolChoiceEnumeration.fromJson(json);
    case 'tool':
      return RunObjectToolChoiceAssistantsNamedToolChoice.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'RunObjectToolChoice',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$RunObjectToolChoice {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceEnumeration value) mode,
    required TResult Function(
            RunObjectToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult? Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunObjectToolChoiceCopyWith<$Res> {
  factory $RunObjectToolChoiceCopyWith(
          RunObjectToolChoice value, $Res Function(RunObjectToolChoice) then) =
      _$RunObjectToolChoiceCopyWithImpl<$Res, RunObjectToolChoice>;
}

/// @nodoc
class _$RunObjectToolChoiceCopyWithImpl<$Res, $Val extends RunObjectToolChoice>
    implements $RunObjectToolChoiceCopyWith<$Res> {
  _$RunObjectToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RunObjectToolChoiceEnumerationImplCopyWith<$Res> {
  factory _$$RunObjectToolChoiceEnumerationImplCopyWith(
          _$RunObjectToolChoiceEnumerationImpl value,
          $Res Function(_$RunObjectToolChoiceEnumerationImpl) then) =
      __$$RunObjectToolChoiceEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RunObjectToolChoiceMode value});
}

/// @nodoc
class __$$RunObjectToolChoiceEnumerationImplCopyWithImpl<$Res>
    extends _$RunObjectToolChoiceCopyWithImpl<$Res,
        _$RunObjectToolChoiceEnumerationImpl>
    implements _$$RunObjectToolChoiceEnumerationImplCopyWith<$Res> {
  __$$RunObjectToolChoiceEnumerationImplCopyWithImpl(
      _$RunObjectToolChoiceEnumerationImpl _value,
      $Res Function(_$RunObjectToolChoiceEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$RunObjectToolChoiceEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as RunObjectToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunObjectToolChoiceEnumerationImpl
    extends RunObjectToolChoiceEnumeration {
  const _$RunObjectToolChoiceEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$RunObjectToolChoiceEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunObjectToolChoiceEnumerationImplFromJson(json);

  @override
  final RunObjectToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'RunObjectToolChoice.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunObjectToolChoiceEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunObjectToolChoiceEnumerationImplCopyWith<
          _$RunObjectToolChoiceEnumerationImpl>
      get copyWith => __$$RunObjectToolChoiceEnumerationImplCopyWithImpl<
          _$RunObjectToolChoiceEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceEnumeration value) mode,
    required TResult Function(
            RunObjectToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult? Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunObjectToolChoiceEnumerationImplToJson(
      this,
    );
  }
}

abstract class RunObjectToolChoiceEnumeration extends RunObjectToolChoice {
  const factory RunObjectToolChoiceEnumeration(
          final RunObjectToolChoiceMode value) =
      _$RunObjectToolChoiceEnumerationImpl;
  const RunObjectToolChoiceEnumeration._() : super._();

  factory RunObjectToolChoiceEnumeration.fromJson(Map<String, dynamic> json) =
      _$RunObjectToolChoiceEnumerationImpl.fromJson;

  @override
  RunObjectToolChoiceMode get value;
  @JsonKey(ignore: true)
  _$$RunObjectToolChoiceEnumerationImplCopyWith<
          _$RunObjectToolChoiceEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWith<
    $Res> {
  factory _$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWith(
          _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl value,
          $Res Function(_$RunObjectToolChoiceAssistantsNamedToolChoiceImpl)
              then) =
      __$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AssistantsNamedToolChoice value});

  $AssistantsNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class __$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<$Res>
    extends _$RunObjectToolChoiceCopyWithImpl<$Res,
        _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl>
    implements
        _$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWith<$Res> {
  __$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl(
      _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl _value,
      $Res Function(_$RunObjectToolChoiceAssistantsNamedToolChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$RunObjectToolChoiceAssistantsNamedToolChoiceImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsNamedToolChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsNamedToolChoiceCopyWith<$Res> get value {
    return $AssistantsNamedToolChoiceCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl
    extends RunObjectToolChoiceAssistantsNamedToolChoice {
  const _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();

  factory _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunObjectToolChoiceAssistantsNamedToolChoiceImplFromJson(json);

  @override
  final AssistantsNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'RunObjectToolChoice.tool(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWith<
          _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl>
      get copyWith =>
          __$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<
                  _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    return tool(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    return tool?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectToolChoiceEnumeration value) mode,
    required TResult Function(
            RunObjectToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult? Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectToolChoiceEnumeration value)? mode,
    TResult Function(RunObjectToolChoiceAssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunObjectToolChoiceAssistantsNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class RunObjectToolChoiceAssistantsNamedToolChoice
    extends RunObjectToolChoice {
  const factory RunObjectToolChoiceAssistantsNamedToolChoice(
          final AssistantsNamedToolChoice value) =
      _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl;
  const RunObjectToolChoiceAssistantsNamedToolChoice._() : super._();

  factory RunObjectToolChoiceAssistantsNamedToolChoice.fromJson(
          Map<String, dynamic> json) =
      _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl.fromJson;

  @override
  AssistantsNamedToolChoice get value;
  @JsonKey(ignore: true)
  _$$RunObjectToolChoiceAssistantsNamedToolChoiceImplCopyWith<
          _$RunObjectToolChoiceAssistantsNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunObjectResponseFormat _$RunObjectResponseFormatFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return RunObjectResponseFormatEnumeration.fromJson(json);
    case 'format':
      return RunObjectResponseFormatAssistantsResponseFormat.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'RunObjectResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$RunObjectResponseFormat {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatEnumeration value) mode,
    required TResult Function(
            RunObjectResponseFormatAssistantsResponseFormat value)
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult? Function(RunObjectResponseFormatAssistantsResponseFormat value)?
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult Function(RunObjectResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunObjectResponseFormatCopyWith<$Res> {
  factory $RunObjectResponseFormatCopyWith(RunObjectResponseFormat value,
          $Res Function(RunObjectResponseFormat) then) =
      _$RunObjectResponseFormatCopyWithImpl<$Res, RunObjectResponseFormat>;
}

/// @nodoc
class _$RunObjectResponseFormatCopyWithImpl<$Res,
        $Val extends RunObjectResponseFormat>
    implements $RunObjectResponseFormatCopyWith<$Res> {
  _$RunObjectResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RunObjectResponseFormatEnumerationImplCopyWith<$Res> {
  factory _$$RunObjectResponseFormatEnumerationImplCopyWith(
          _$RunObjectResponseFormatEnumerationImpl value,
          $Res Function(_$RunObjectResponseFormatEnumerationImpl) then) =
      __$$RunObjectResponseFormatEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RunObjectResponseFormatMode value});
}

/// @nodoc
class __$$RunObjectResponseFormatEnumerationImplCopyWithImpl<$Res>
    extends _$RunObjectResponseFormatCopyWithImpl<$Res,
        _$RunObjectResponseFormatEnumerationImpl>
    implements _$$RunObjectResponseFormatEnumerationImplCopyWith<$Res> {
  __$$RunObjectResponseFormatEnumerationImplCopyWithImpl(
      _$RunObjectResponseFormatEnumerationImpl _value,
      $Res Function(_$RunObjectResponseFormatEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$RunObjectResponseFormatEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as RunObjectResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunObjectResponseFormatEnumerationImpl
    extends RunObjectResponseFormatEnumeration {
  const _$RunObjectResponseFormatEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$RunObjectResponseFormatEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunObjectResponseFormatEnumerationImplFromJson(json);

  @override
  final RunObjectResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'RunObjectResponseFormat.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunObjectResponseFormatEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunObjectResponseFormatEnumerationImplCopyWith<
          _$RunObjectResponseFormatEnumerationImpl>
      get copyWith => __$$RunObjectResponseFormatEnumerationImplCopyWithImpl<
          _$RunObjectResponseFormatEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatEnumeration value) mode,
    required TResult Function(
            RunObjectResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult? Function(RunObjectResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult Function(RunObjectResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunObjectResponseFormatEnumerationImplToJson(
      this,
    );
  }
}

abstract class RunObjectResponseFormatEnumeration
    extends RunObjectResponseFormat {
  const factory RunObjectResponseFormatEnumeration(
          final RunObjectResponseFormatMode value) =
      _$RunObjectResponseFormatEnumerationImpl;
  const RunObjectResponseFormatEnumeration._() : super._();

  factory RunObjectResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$RunObjectResponseFormatEnumerationImpl.fromJson;

  @override
  RunObjectResponseFormatMode get value;
  @JsonKey(ignore: true)
  _$$RunObjectResponseFormatEnumerationImplCopyWith<
          _$RunObjectResponseFormatEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWith<
    $Res> {
  factory _$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWith(
          _$RunObjectResponseFormatAssistantsResponseFormatImpl value,
          $Res Function(_$RunObjectResponseFormatAssistantsResponseFormatImpl)
              then) =
      __$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AssistantsResponseFormat value});

  $AssistantsResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class __$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl<$Res>
    extends _$RunObjectResponseFormatCopyWithImpl<$Res,
        _$RunObjectResponseFormatAssistantsResponseFormatImpl>
    implements
        _$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWith<$Res> {
  __$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl(
      _$RunObjectResponseFormatAssistantsResponseFormatImpl _value,
      $Res Function(_$RunObjectResponseFormatAssistantsResponseFormatImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$RunObjectResponseFormatAssistantsResponseFormatImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormat,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsResponseFormatCopyWith<$Res> get value {
    return $AssistantsResponseFormatCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunObjectResponseFormatAssistantsResponseFormatImpl
    extends RunObjectResponseFormatAssistantsResponseFormat {
  const _$RunObjectResponseFormatAssistantsResponseFormatImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'format',
        super._();

  factory _$RunObjectResponseFormatAssistantsResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunObjectResponseFormatAssistantsResponseFormatImplFromJson(json);

  @override
  final AssistantsResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'RunObjectResponseFormat.format(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunObjectResponseFormatAssistantsResponseFormatImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWith<
          _$RunObjectResponseFormatAssistantsResponseFormatImpl>
      get copyWith =>
          __$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWithImpl<
                  _$RunObjectResponseFormatAssistantsResponseFormatImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return format(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return format?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunObjectResponseFormatEnumeration value) mode,
    required TResult Function(
            RunObjectResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return format(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult? Function(RunObjectResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return format?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunObjectResponseFormatEnumeration value)? mode,
    TResult Function(RunObjectResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunObjectResponseFormatAssistantsResponseFormatImplToJson(
      this,
    );
  }
}

abstract class RunObjectResponseFormatAssistantsResponseFormat
    extends RunObjectResponseFormat {
  const factory RunObjectResponseFormatAssistantsResponseFormat(
          final AssistantsResponseFormat value) =
      _$RunObjectResponseFormatAssistantsResponseFormatImpl;
  const RunObjectResponseFormatAssistantsResponseFormat._() : super._();

  factory RunObjectResponseFormatAssistantsResponseFormat.fromJson(
          Map<String, dynamic> json) =
      _$RunObjectResponseFormatAssistantsResponseFormatImpl.fromJson;

  @override
  AssistantsResponseFormat get value;
  @JsonKey(ignore: true)
  _$$RunObjectResponseFormatAssistantsResponseFormatImplCopyWith<
          _$RunObjectResponseFormatAssistantsResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunSubmitToolOutputs _$RunSubmitToolOutputsFromJson(Map<String, dynamic> json) {
  return _RunSubmitToolOutputs.fromJson(json);
}

/// @nodoc
mixin _$RunSubmitToolOutputs {
  /// A list of the relevant tool calls.
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunSubmitToolOutputsCopyWith<RunSubmitToolOutputs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunSubmitToolOutputsCopyWith<$Res> {
  factory $RunSubmitToolOutputsCopyWith(RunSubmitToolOutputs value,
          $Res Function(RunSubmitToolOutputs) then) =
      _$RunSubmitToolOutputsCopyWithImpl<$Res, RunSubmitToolOutputs>;
  @useResult
  $Res call({@JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls});
}

/// @nodoc
class _$RunSubmitToolOutputsCopyWithImpl<$Res,
        $Val extends RunSubmitToolOutputs>
    implements $RunSubmitToolOutputsCopyWith<$Res> {
  _$RunSubmitToolOutputsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCalls = null,
  }) {
    return _then(_value.copyWith(
      toolCalls: null == toolCalls
          ? _value.toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunToolCallObject>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunSubmitToolOutputsImplCopyWith<$Res>
    implements $RunSubmitToolOutputsCopyWith<$Res> {
  factory _$$RunSubmitToolOutputsImplCopyWith(_$RunSubmitToolOutputsImpl value,
          $Res Function(_$RunSubmitToolOutputsImpl) then) =
      __$$RunSubmitToolOutputsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'tool_calls') List<RunToolCallObject> toolCalls});
}

/// @nodoc
class __$$RunSubmitToolOutputsImplCopyWithImpl<$Res>
    extends _$RunSubmitToolOutputsCopyWithImpl<$Res, _$RunSubmitToolOutputsImpl>
    implements _$$RunSubmitToolOutputsImplCopyWith<$Res> {
  __$$RunSubmitToolOutputsImplCopyWithImpl(_$RunSubmitToolOutputsImpl _value,
      $Res Function(_$RunSubmitToolOutputsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCalls = null,
  }) {
    return _then(_$RunSubmitToolOutputsImpl(
      toolCalls: null == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunToolCallObject>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunSubmitToolOutputsImpl extends _RunSubmitToolOutputs {
  const _$RunSubmitToolOutputsImpl(
      {@JsonKey(name: 'tool_calls')
      required final List<RunToolCallObject> toolCalls})
      : _toolCalls = toolCalls,
        super._();

  factory _$RunSubmitToolOutputsImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunSubmitToolOutputsImplFromJson(json);

  /// A list of the relevant tool calls.
  final List<RunToolCallObject> _toolCalls;

  /// A list of the relevant tool calls.
  @override
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls {
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolCalls);
  }

  @override
  String toString() {
    return 'RunSubmitToolOutputs(toolCalls: $toolCalls)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunSubmitToolOutputsImpl &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_toolCalls));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunSubmitToolOutputsImplCopyWith<_$RunSubmitToolOutputsImpl>
      get copyWith =>
          __$$RunSubmitToolOutputsImplCopyWithImpl<_$RunSubmitToolOutputsImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunSubmitToolOutputsImplToJson(
      this,
    );
  }
}

abstract class _RunSubmitToolOutputs extends RunSubmitToolOutputs {
  const factory _RunSubmitToolOutputs(
          {@JsonKey(name: 'tool_calls')
          required final List<RunToolCallObject> toolCalls}) =
      _$RunSubmitToolOutputsImpl;
  const _RunSubmitToolOutputs._() : super._();

  factory _RunSubmitToolOutputs.fromJson(Map<String, dynamic> json) =
      _$RunSubmitToolOutputsImpl.fromJson;

  @override

  /// A list of the relevant tool calls.
  @JsonKey(name: 'tool_calls')
  List<RunToolCallObject> get toolCalls;
  @override
  @JsonKey(ignore: true)
  _$$RunSubmitToolOutputsImplCopyWith<_$RunSubmitToolOutputsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunCompletionUsage _$RunCompletionUsageFromJson(Map<String, dynamic> json) {
  return _RunCompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$RunCompletionUsage {
  /// Number of completion tokens used over the course of the run.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens => throw _privateConstructorUsedError;

  /// Number of prompt tokens used over the course of the run.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunCompletionUsageCopyWith<RunCompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunCompletionUsageCopyWith<$Res> {
  factory $RunCompletionUsageCopyWith(
          RunCompletionUsage value, $Res Function(RunCompletionUsage) then) =
      _$RunCompletionUsageCopyWithImpl<$Res, RunCompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$RunCompletionUsageCopyWithImpl<$Res, $Val extends RunCompletionUsage>
    implements $RunCompletionUsageCopyWith<$Res> {
  _$RunCompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunCompletionUsageImplCopyWith<$Res>
    implements $RunCompletionUsageCopyWith<$Res> {
  factory _$$RunCompletionUsageImplCopyWith(_$RunCompletionUsageImpl value,
          $Res Function(_$RunCompletionUsageImpl) then) =
      __$$RunCompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$RunCompletionUsageImplCopyWithImpl<$Res>
    extends _$RunCompletionUsageCopyWithImpl<$Res, _$RunCompletionUsageImpl>
    implements _$$RunCompletionUsageImplCopyWith<$Res> {
  __$$RunCompletionUsageImplCopyWithImpl(_$RunCompletionUsageImpl _value,
      $Res Function(_$RunCompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$RunCompletionUsageImpl(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunCompletionUsageImpl extends _RunCompletionUsage {
  const _$RunCompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$RunCompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunCompletionUsageImplFromJson(json);

  /// Number of completion tokens used over the course of the run.
  @override
  @JsonKey(name: 'completion_tokens')
  final int completionTokens;

  /// Number of prompt tokens used over the course of the run.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'RunCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunCompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunCompletionUsageImplCopyWith<_$RunCompletionUsageImpl> get copyWith =>
      __$$RunCompletionUsageImplCopyWithImpl<_$RunCompletionUsageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunCompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _RunCompletionUsage extends RunCompletionUsage {
  const factory _RunCompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$RunCompletionUsageImpl;
  const _RunCompletionUsage._() : super._();

  factory _RunCompletionUsage.fromJson(Map<String, dynamic> json) =
      _$RunCompletionUsageImpl.fromJson;

  @override

  /// Number of completion tokens used over the course of the run.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens;
  @override

  /// Number of prompt tokens used over the course of the run.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$RunCompletionUsageImplCopyWith<_$RunCompletionUsageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateRunRequest _$CreateRunRequestFromJson(Map<String, dynamic> json) {
  return _CreateRunRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateRunRequest {
  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @_CreateRunRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateRunRequestModel? get model => throw _privateConstructorUsedError;

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  String? get additionalInstructions => throw _privateConstructorUsedError;

  /// Adds additional messages to the thread before creating the run.
  @JsonKey(name: 'additional_messages', includeIfNull: false)
  List<CreateMessageRequest>? get additionalMessages =>
      throw _privateConstructorUsedError;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  int? get maxPromptTokens => throw _privateConstructorUsedError;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  int? get maxCompletionTokens => throw _privateConstructorUsedError;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  TruncationObject? get truncationStrategy =>
      throw _privateConstructorUsedError;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_CreateRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  CreateRunRequestToolChoice? get toolChoice =>
      throw _privateConstructorUsedError;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls => throw _privateConstructorUsedError;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateRunRequestResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateRunRequestCopyWith<CreateRunRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateRunRequestCopyWith<$Res> {
  factory $CreateRunRequestCopyWith(
          CreateRunRequest value, $Res Function(CreateRunRequest) then) =
      _$CreateRunRequestCopyWithImpl<$Res, CreateRunRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @_CreateRunRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateRunRequestModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      String? additionalInstructions,
      @JsonKey(name: 'additional_messages', includeIfNull: false)
      List<CreateMessageRequest>? additionalMessages,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  $CreateRunRequestModelCopyWith<$Res>? get model;
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  $CreateRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  $CreateRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$CreateRunRequestCopyWithImpl<$Res, $Val extends CreateRunRequest>
    implements $CreateRunRequestCopyWith<$Res> {
  _$CreateRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? additionalInstructions = freezed,
    Object? additionalMessages = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_value.copyWith(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestModel?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInstructions: freezed == additionalInstructions
          ? _value.additionalInstructions
          : additionalInstructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalMessages: freezed == additionalMessages
          ? _value.additionalMessages
          : additionalMessages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _value.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _value.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _value.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestResponseFormat?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $CreateRunRequestModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_value.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_value.truncationStrategy!, (value) {
      return _then(_value.copyWith(truncationStrategy: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestToolChoiceCopyWith<$Res>? get toolChoice {
    if (_value.toolChoice == null) {
      return null;
    }

    return $CreateRunRequestToolChoiceCopyWith<$Res>(_value.toolChoice!,
        (value) {
      return _then(_value.copyWith(toolChoice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateRunRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $CreateRunRequestResponseFormatCopyWith<$Res>(_value.responseFormat!,
        (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateRunRequestImplCopyWith<$Res>
    implements $CreateRunRequestCopyWith<$Res> {
  factory _$$CreateRunRequestImplCopyWith(_$CreateRunRequestImpl value,
          $Res Function(_$CreateRunRequestImpl) then) =
      __$$CreateRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @_CreateRunRequestModelConverter()
      @JsonKey(includeIfNull: false)
      CreateRunRequestModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      String? additionalInstructions,
      @JsonKey(name: 'additional_messages', includeIfNull: false)
      List<CreateMessageRequest>? additionalMessages,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  @override
  $CreateRunRequestModelCopyWith<$Res>? get model;
  @override
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  @override
  $CreateRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  @override
  $CreateRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$$CreateRunRequestImplCopyWithImpl<$Res>
    extends _$CreateRunRequestCopyWithImpl<$Res, _$CreateRunRequestImpl>
    implements _$$CreateRunRequestImplCopyWith<$Res> {
  __$$CreateRunRequestImplCopyWithImpl(_$CreateRunRequestImpl _value,
      $Res Function(_$CreateRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? additionalInstructions = freezed,
    Object? additionalMessages = freezed,
    Object? tools = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_$CreateRunRequestImpl(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestModel?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalInstructions: freezed == additionalInstructions
          ? _value.additionalInstructions
          : additionalInstructions // ignore: cast_nullable_to_non_nullable
              as String?,
      additionalMessages: freezed == additionalMessages
          ? _value._additionalMessages
          : additionalMessages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _value.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _value.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _value.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestResponseFormat?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestImpl extends _CreateRunRequest {
  const _$CreateRunRequestImpl(
      {@JsonKey(name: 'assistant_id') required this.assistantId,
      @_CreateRunRequestModelConverter()
      @JsonKey(includeIfNull: false)
      this.model,
      @JsonKey(includeIfNull: false) this.instructions,
      @JsonKey(name: 'additional_instructions', includeIfNull: false)
      this.additionalInstructions,
      @JsonKey(name: 'additional_messages', includeIfNull: false)
      final List<CreateMessageRequest>? additionalMessages,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      this.maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      this.maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      this.truncationStrategy,
      @_CreateRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      this.parallelToolCalls = true,
      @_CreateRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.stream})
      : _additionalMessages = additionalMessages,
        _tools = tools,
        _metadata = metadata,
        super._();

  factory _$CreateRunRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateRunRequestImplFromJson(json);

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @override
  @_CreateRunRequestModelConverter()
  @JsonKey(includeIfNull: false)
  final CreateRunRequestModel? model;

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @override
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  final String? additionalInstructions;

  /// Adds additional messages to the thread before creating the run.
  final List<CreateMessageRequest>? _additionalMessages;

  /// Adds additional messages to the thread before creating the run.
  @override
  @JsonKey(name: 'additional_messages', includeIfNull: false)
  List<CreateMessageRequest>? get additionalMessages {
    final value = _additionalMessages;
    if (value == null) return null;
    if (_additionalMessages is EqualUnmodifiableListView)
      return _additionalMessages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  final List<AssistantTools>? _tools;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  final int? maxPromptTokens;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  final int? maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @override
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  final TruncationObject? truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @override
  @_CreateRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final CreateRunRequestToolChoice? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  final bool? parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_CreateRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final CreateRunRequestResponseFormat? responseFormat;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  @override
  String toString() {
    return 'CreateRunRequest(assistantId: $assistantId, model: $model, instructions: $instructions, additionalInstructions: $additionalInstructions, additionalMessages: $additionalMessages, tools: $tools, metadata: $metadata, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat, stream: $stream)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateRunRequestImpl &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            (identical(other.additionalInstructions, additionalInstructions) ||
                other.additionalInstructions == additionalInstructions) &&
            const DeepCollectionEquality()
                .equals(other._additionalMessages, _additionalMessages) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      model,
      instructions,
      additionalInstructions,
      const DeepCollectionEquality().hash(_additionalMessages),
      const DeepCollectionEquality().hash(_tools),
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      maxPromptTokens,
      maxCompletionTokens,
      truncationStrategy,
      toolChoice,
      parallelToolCalls,
      responseFormat,
      stream);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestImplCopyWith<_$CreateRunRequestImpl> get copyWith =>
      __$$CreateRunRequestImplCopyWithImpl<_$CreateRunRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateRunRequest extends CreateRunRequest {
  const factory _CreateRunRequest(
          {@JsonKey(name: 'assistant_id') required final String assistantId,
          @_CreateRunRequestModelConverter()
          @JsonKey(includeIfNull: false)
          final CreateRunRequestModel? model,
          @JsonKey(includeIfNull: false) final String? instructions,
          @JsonKey(name: 'additional_instructions', includeIfNull: false)
          final String? additionalInstructions,
          @JsonKey(name: 'additional_messages', includeIfNull: false)
          final List<CreateMessageRequest>? additionalMessages,
          @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
          @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
          @JsonKey(includeIfNull: false) final double? temperature,
          @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
          @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
          final int? maxPromptTokens,
          @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
          final int? maxCompletionTokens,
          @JsonKey(name: 'truncation_strategy', includeIfNull: false)
          final TruncationObject? truncationStrategy,
          @_CreateRunRequestToolChoiceConverter()
          @JsonKey(name: 'tool_choice', includeIfNull: false)
          final CreateRunRequestToolChoice? toolChoice,
          @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
          final bool? parallelToolCalls,
          @_CreateRunRequestResponseFormatConverter()
          @JsonKey(name: 'response_format', includeIfNull: false)
          final CreateRunRequestResponseFormat? responseFormat,
          @JsonKey(includeIfNull: false) final bool? stream}) =
      _$CreateRunRequestImpl;
  const _CreateRunRequest._() : super._();

  factory _CreateRunRequest.fromJson(Map<String, dynamic> json) =
      _$CreateRunRequestImpl.fromJson;

  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @_CreateRunRequestModelConverter()
  @JsonKey(includeIfNull: false)
  CreateRunRequestModel? get model;
  @override

  /// Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  @JsonKey(name: 'additional_instructions', includeIfNull: false)
  String? get additionalInstructions;
  @override

  /// Adds additional messages to the thread before creating the run.
  @JsonKey(name: 'additional_messages', includeIfNull: false)
  List<CreateMessageRequest>? get additionalMessages;
  @override

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  int? get maxPromptTokens;
  @override

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  int? get maxCompletionTokens;
  @override

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  TruncationObject? get truncationStrategy;
  @override

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_CreateRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  CreateRunRequestToolChoice? get toolChoice;
  @override

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls;
  @override

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateRunRequestResponseFormat? get responseFormat;
  @override

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override
  @JsonKey(ignore: true)
  _$$CreateRunRequestImplCopyWith<_$CreateRunRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateRunRequestModel _$CreateRunRequestModelFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return CreateRunRequestModelEnumeration.fromJson(json);
    case 'modelId':
      return CreateRunRequestModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateRunRequestModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateRunRequestModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestModelEnumeration value) model,
    required TResult Function(CreateRunRequestModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestModelEnumeration value)? model,
    TResult? Function(CreateRunRequestModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestModelEnumeration value)? model,
    TResult Function(CreateRunRequestModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateRunRequestModelCopyWith<$Res> {
  factory $CreateRunRequestModelCopyWith(CreateRunRequestModel value,
          $Res Function(CreateRunRequestModel) then) =
      _$CreateRunRequestModelCopyWithImpl<$Res, CreateRunRequestModel>;
}

/// @nodoc
class _$CreateRunRequestModelCopyWithImpl<$Res,
        $Val extends CreateRunRequestModel>
    implements $CreateRunRequestModelCopyWith<$Res> {
  _$CreateRunRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateRunRequestModelEnumerationImplCopyWith<$Res> {
  factory _$$CreateRunRequestModelEnumerationImplCopyWith(
          _$CreateRunRequestModelEnumerationImpl value,
          $Res Function(_$CreateRunRequestModelEnumerationImpl) then) =
      __$$CreateRunRequestModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RunModels value});
}

/// @nodoc
class __$$CreateRunRequestModelEnumerationImplCopyWithImpl<$Res>
    extends _$CreateRunRequestModelCopyWithImpl<$Res,
        _$CreateRunRequestModelEnumerationImpl>
    implements _$$CreateRunRequestModelEnumerationImplCopyWith<$Res> {
  __$$CreateRunRequestModelEnumerationImplCopyWithImpl(
      _$CreateRunRequestModelEnumerationImpl _value,
      $Res Function(_$CreateRunRequestModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateRunRequestModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as RunModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestModelEnumerationImpl
    extends CreateRunRequestModelEnumeration {
  const _$CreateRunRequestModelEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$CreateRunRequestModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateRunRequestModelEnumerationImplFromJson(json);

  @override
  final RunModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateRunRequestModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateRunRequestModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestModelEnumerationImplCopyWith<
          _$CreateRunRequestModelEnumerationImpl>
      get copyWith => __$$CreateRunRequestModelEnumerationImplCopyWithImpl<
          _$CreateRunRequestModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestModelEnumeration value) model,
    required TResult Function(CreateRunRequestModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestModelEnumeration value)? model,
    TResult? Function(CreateRunRequestModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestModelEnumeration value)? model,
    TResult Function(CreateRunRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateRunRequestModelEnumeration extends CreateRunRequestModel {
  const factory CreateRunRequestModelEnumeration(final RunModels value) =
      _$CreateRunRequestModelEnumerationImpl;
  const CreateRunRequestModelEnumeration._() : super._();

  factory CreateRunRequestModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$CreateRunRequestModelEnumerationImpl.fromJson;

  @override
  RunModels get value;
  @JsonKey(ignore: true)
  _$$CreateRunRequestModelEnumerationImplCopyWith<
          _$CreateRunRequestModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateRunRequestModelStringImplCopyWith<$Res> {
  factory _$$CreateRunRequestModelStringImplCopyWith(
          _$CreateRunRequestModelStringImpl value,
          $Res Function(_$CreateRunRequestModelStringImpl) then) =
      __$$CreateRunRequestModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CreateRunRequestModelStringImplCopyWithImpl<$Res>
    extends _$CreateRunRequestModelCopyWithImpl<$Res,
        _$CreateRunRequestModelStringImpl>
    implements _$$CreateRunRequestModelStringImplCopyWith<$Res> {
  __$$CreateRunRequestModelStringImplCopyWithImpl(
      _$CreateRunRequestModelStringImpl _value,
      $Res Function(_$CreateRunRequestModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateRunRequestModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestModelStringImpl extends CreateRunRequestModelString {
  const _$CreateRunRequestModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$CreateRunRequestModelStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateRunRequestModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateRunRequestModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateRunRequestModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestModelStringImplCopyWith<_$CreateRunRequestModelStringImpl>
      get copyWith => __$$CreateRunRequestModelStringImplCopyWithImpl<
          _$CreateRunRequestModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RunModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RunModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestModelEnumeration value) model,
    required TResult Function(CreateRunRequestModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestModelEnumeration value)? model,
    TResult? Function(CreateRunRequestModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestModelEnumeration value)? model,
    TResult Function(CreateRunRequestModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestModelStringImplToJson(
      this,
    );
  }
}

abstract class CreateRunRequestModelString extends CreateRunRequestModel {
  const factory CreateRunRequestModelString(final String value) =
      _$CreateRunRequestModelStringImpl;
  const CreateRunRequestModelString._() : super._();

  factory CreateRunRequestModelString.fromJson(Map<String, dynamic> json) =
      _$CreateRunRequestModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CreateRunRequestModelStringImplCopyWith<_$CreateRunRequestModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateRunRequestToolChoice _$CreateRunRequestToolChoiceFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateRunRequestToolChoiceEnumeration.fromJson(json);
    case 'tool':
      return CreateRunRequestToolChoiceAssistantsNamedToolChoice.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateRunRequestToolChoice',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateRunRequestToolChoice {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceEnumeration value) mode,
    required TResult Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult? Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult Function(CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateRunRequestToolChoiceCopyWith<$Res> {
  factory $CreateRunRequestToolChoiceCopyWith(CreateRunRequestToolChoice value,
          $Res Function(CreateRunRequestToolChoice) then) =
      _$CreateRunRequestToolChoiceCopyWithImpl<$Res,
          CreateRunRequestToolChoice>;
}

/// @nodoc
class _$CreateRunRequestToolChoiceCopyWithImpl<$Res,
        $Val extends CreateRunRequestToolChoice>
    implements $CreateRunRequestToolChoiceCopyWith<$Res> {
  _$CreateRunRequestToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateRunRequestToolChoiceEnumerationImplCopyWith<$Res> {
  factory _$$CreateRunRequestToolChoiceEnumerationImplCopyWith(
          _$CreateRunRequestToolChoiceEnumerationImpl value,
          $Res Function(_$CreateRunRequestToolChoiceEnumerationImpl) then) =
      __$$CreateRunRequestToolChoiceEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CreateRunRequestToolChoiceMode value});
}

/// @nodoc
class __$$CreateRunRequestToolChoiceEnumerationImplCopyWithImpl<$Res>
    extends _$CreateRunRequestToolChoiceCopyWithImpl<$Res,
        _$CreateRunRequestToolChoiceEnumerationImpl>
    implements _$$CreateRunRequestToolChoiceEnumerationImplCopyWith<$Res> {
  __$$CreateRunRequestToolChoiceEnumerationImplCopyWithImpl(
      _$CreateRunRequestToolChoiceEnumerationImpl _value,
      $Res Function(_$CreateRunRequestToolChoiceEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateRunRequestToolChoiceEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestToolChoiceEnumerationImpl
    extends CreateRunRequestToolChoiceEnumeration {
  const _$CreateRunRequestToolChoiceEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$CreateRunRequestToolChoiceEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateRunRequestToolChoiceEnumerationImplFromJson(json);

  @override
  final CreateRunRequestToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateRunRequestToolChoice.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateRunRequestToolChoiceEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestToolChoiceEnumerationImplCopyWith<
          _$CreateRunRequestToolChoiceEnumerationImpl>
      get copyWith => __$$CreateRunRequestToolChoiceEnumerationImplCopyWithImpl<
          _$CreateRunRequestToolChoiceEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceEnumeration value) mode,
    required TResult Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult? Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult Function(CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestToolChoiceEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateRunRequestToolChoiceEnumeration
    extends CreateRunRequestToolChoice {
  const factory CreateRunRequestToolChoiceEnumeration(
          final CreateRunRequestToolChoiceMode value) =
      _$CreateRunRequestToolChoiceEnumerationImpl;
  const CreateRunRequestToolChoiceEnumeration._() : super._();

  factory CreateRunRequestToolChoiceEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateRunRequestToolChoiceEnumerationImpl.fromJson;

  @override
  CreateRunRequestToolChoiceMode get value;
  @JsonKey(ignore: true)
  _$$CreateRunRequestToolChoiceEnumerationImplCopyWith<
          _$CreateRunRequestToolChoiceEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
    $Res> {
  factory _$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith(
          _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl value,
          $Res Function(
                  _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl)
              then) =
      __$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({AssistantsNamedToolChoice value});

  $AssistantsNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class __$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<
        $Res>
    extends _$CreateRunRequestToolChoiceCopyWithImpl<$Res,
        _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl>
    implements
        _$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
            $Res> {
  __$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl(
      _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl _value,
      $Res Function(_$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsNamedToolChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsNamedToolChoiceCopyWith<$Res> get value {
    return $AssistantsNamedToolChoiceCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl
    extends CreateRunRequestToolChoiceAssistantsNamedToolChoice {
  const _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();

  factory _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplFromJson(json);

  @override
  final AssistantsNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateRunRequestToolChoice.tool(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
          _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl>
      get copyWith =>
          __$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<
                  _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceMode value) mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    return tool(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    return tool?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestToolChoiceEnumeration value) mode,
    required TResult Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult? Function(
            CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestToolChoiceEnumeration value)? mode,
    TResult Function(CreateRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class CreateRunRequestToolChoiceAssistantsNamedToolChoice
    extends CreateRunRequestToolChoice {
  const factory CreateRunRequestToolChoiceAssistantsNamedToolChoice(
          final AssistantsNamedToolChoice value) =
      _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl;
  const CreateRunRequestToolChoiceAssistantsNamedToolChoice._() : super._();

  factory CreateRunRequestToolChoiceAssistantsNamedToolChoice.fromJson(
          Map<String, dynamic> json) =
      _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl.fromJson;

  @override
  AssistantsNamedToolChoice get value;
  @JsonKey(ignore: true)
  _$$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
          _$CreateRunRequestToolChoiceAssistantsNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateRunRequestResponseFormat _$CreateRunRequestResponseFormatFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateRunRequestResponseFormatEnumeration.fromJson(json);
    case 'format':
      return CreateRunRequestResponseFormatAssistantsResponseFormat.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateRunRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateRunRequestResponseFormat {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult? Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateRunRequestResponseFormatCopyWith<$Res> {
  factory $CreateRunRequestResponseFormatCopyWith(
          CreateRunRequestResponseFormat value,
          $Res Function(CreateRunRequestResponseFormat) then) =
      _$CreateRunRequestResponseFormatCopyWithImpl<$Res,
          CreateRunRequestResponseFormat>;
}

/// @nodoc
class _$CreateRunRequestResponseFormatCopyWithImpl<$Res,
        $Val extends CreateRunRequestResponseFormat>
    implements $CreateRunRequestResponseFormatCopyWith<$Res> {
  _$CreateRunRequestResponseFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateRunRequestResponseFormatEnumerationImplCopyWith<$Res> {
  factory _$$CreateRunRequestResponseFormatEnumerationImplCopyWith(
          _$CreateRunRequestResponseFormatEnumerationImpl value,
          $Res Function(_$CreateRunRequestResponseFormatEnumerationImpl) then) =
      __$$CreateRunRequestResponseFormatEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CreateRunRequestResponseFormatMode value});
}

/// @nodoc
class __$$CreateRunRequestResponseFormatEnumerationImplCopyWithImpl<$Res>
    extends _$CreateRunRequestResponseFormatCopyWithImpl<$Res,
        _$CreateRunRequestResponseFormatEnumerationImpl>
    implements _$$CreateRunRequestResponseFormatEnumerationImplCopyWith<$Res> {
  __$$CreateRunRequestResponseFormatEnumerationImplCopyWithImpl(
      _$CreateRunRequestResponseFormatEnumerationImpl _value,
      $Res Function(_$CreateRunRequestResponseFormatEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateRunRequestResponseFormatEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateRunRequestResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestResponseFormatEnumerationImpl
    extends CreateRunRequestResponseFormatEnumeration {
  const _$CreateRunRequestResponseFormatEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$CreateRunRequestResponseFormatEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateRunRequestResponseFormatEnumerationImplFromJson(json);

  @override
  final CreateRunRequestResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateRunRequestResponseFormat.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateRunRequestResponseFormatEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestResponseFormatEnumerationImplCopyWith<
          _$CreateRunRequestResponseFormatEnumerationImpl>
      get copyWith =>
          __$$CreateRunRequestResponseFormatEnumerationImplCopyWithImpl<
                  _$CreateRunRequestResponseFormatEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult? Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestResponseFormatEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateRunRequestResponseFormatEnumeration
    extends CreateRunRequestResponseFormat {
  const factory CreateRunRequestResponseFormatEnumeration(
          final CreateRunRequestResponseFormatMode value) =
      _$CreateRunRequestResponseFormatEnumerationImpl;
  const CreateRunRequestResponseFormatEnumeration._() : super._();

  factory CreateRunRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateRunRequestResponseFormatEnumerationImpl.fromJson;

  @override
  CreateRunRequestResponseFormatMode get value;
  @JsonKey(ignore: true)
  _$$CreateRunRequestResponseFormatEnumerationImplCopyWith<
          _$CreateRunRequestResponseFormatEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
    $Res> {
  factory _$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWith(
          _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl value,
          $Res Function(
                  _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl)
              then) =
      __$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({AssistantsResponseFormat value});

  $AssistantsResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class __$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
        $Res>
    extends _$CreateRunRequestResponseFormatCopyWithImpl<$Res,
        _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl>
    implements
        _$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
            $Res> {
  __$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl(
      _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl _value,
      $Res Function(
              _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateRunRequestResponseFormatAssistantsResponseFormatImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormat,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsResponseFormatCopyWith<$Res> get value {
    return $AssistantsResponseFormatCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl
    extends CreateRunRequestResponseFormatAssistantsResponseFormat {
  const _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'format',
        super._();

  factory _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateRunRequestResponseFormatAssistantsResponseFormatImplFromJson(
          json);

  @override
  final AssistantsResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateRunRequestResponseFormat.format(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith =>
          __$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
                  _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatMode value) mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return format(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return format?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CreateRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)
        format,
  }) {
    return format(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult? Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)?
        format,
  }) {
    return format?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateRunRequestResponseFormatEnumeration value)? mode,
    TResult Function(
            CreateRunRequestResponseFormatAssistantsResponseFormat value)?
        format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateRunRequestResponseFormatAssistantsResponseFormatImplToJson(
      this,
    );
  }
}

abstract class CreateRunRequestResponseFormatAssistantsResponseFormat
    extends CreateRunRequestResponseFormat {
  const factory CreateRunRequestResponseFormatAssistantsResponseFormat(
          final AssistantsResponseFormat value) =
      _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl;
  const CreateRunRequestResponseFormatAssistantsResponseFormat._() : super._();

  factory CreateRunRequestResponseFormatAssistantsResponseFormat.fromJson(
          Map<String, dynamic> json) =
      _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl.fromJson;

  @override
  AssistantsResponseFormat get value;
  @JsonKey(ignore: true)
  _$$CreateRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$CreateRunRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListRunsResponse _$ListRunsResponseFromJson(Map<String, dynamic> json) {
  return _ListRunsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListRunsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of runs.
  List<RunObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first run in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last run in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more runs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListRunsResponseCopyWith<ListRunsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListRunsResponseCopyWith<$Res> {
  factory $ListRunsResponseCopyWith(
          ListRunsResponse value, $Res Function(ListRunsResponse) then) =
      _$ListRunsResponseCopyWithImpl<$Res, ListRunsResponse>;
  @useResult
  $Res call(
      {String object,
      List<RunObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListRunsResponseCopyWithImpl<$Res, $Val extends ListRunsResponse>
    implements $ListRunsResponseCopyWith<$Res> {
  _$ListRunsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListRunsResponseImplCopyWith<$Res>
    implements $ListRunsResponseCopyWith<$Res> {
  factory _$$ListRunsResponseImplCopyWith(_$ListRunsResponseImpl value,
          $Res Function(_$ListRunsResponseImpl) then) =
      __$$ListRunsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<RunObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListRunsResponseImplCopyWithImpl<$Res>
    extends _$ListRunsResponseCopyWithImpl<$Res, _$ListRunsResponseImpl>
    implements _$$ListRunsResponseImplCopyWith<$Res> {
  __$$ListRunsResponseImplCopyWithImpl(_$ListRunsResponseImpl _value,
      $Res Function(_$ListRunsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListRunsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListRunsResponseImpl extends _ListRunsResponse {
  const _$ListRunsResponseImpl(
      {required this.object,
      required final List<RunObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListRunsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListRunsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of runs.
  final List<RunObject> _data;

  /// The list of runs.
  @override
  List<RunObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first run in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last run in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more runs to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListRunsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListRunsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListRunsResponseImplCopyWith<_$ListRunsResponseImpl> get copyWith =>
      __$$ListRunsResponseImplCopyWithImpl<_$ListRunsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListRunsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListRunsResponse extends ListRunsResponse {
  const factory _ListRunsResponse(
          {required final String object,
          required final List<RunObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListRunsResponseImpl;
  const _ListRunsResponse._() : super._();

  factory _ListRunsResponse.fromJson(Map<String, dynamic> json) =
      _$ListRunsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of runs.
  List<RunObject> get data;
  @override

  /// The ID of the first run in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last run in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more runs to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListRunsResponseImplCopyWith<_$ListRunsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModifyRunRequest _$ModifyRunRequestFromJson(Map<String, dynamic> json) {
  return _ModifyRunRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyRunRequest {
  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyRunRequestCopyWith<ModifyRunRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyRunRequestCopyWith<$Res> {
  factory $ModifyRunRequestCopyWith(
          ModifyRunRequest value, $Res Function(ModifyRunRequest) then) =
      _$ModifyRunRequestCopyWithImpl<$Res, ModifyRunRequest>;
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyRunRequestCopyWithImpl<$Res, $Val extends ModifyRunRequest>
    implements $ModifyRunRequestCopyWith<$Res> {
  _$ModifyRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModifyRunRequestImplCopyWith<$Res>
    implements $ModifyRunRequestCopyWith<$Res> {
  factory _$$ModifyRunRequestImplCopyWith(_$ModifyRunRequestImpl value,
          $Res Function(_$ModifyRunRequestImpl) then) =
      __$$ModifyRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ModifyRunRequestImplCopyWithImpl<$Res>
    extends _$ModifyRunRequestCopyWithImpl<$Res, _$ModifyRunRequestImpl>
    implements _$$ModifyRunRequestImplCopyWith<$Res> {
  __$$ModifyRunRequestImplCopyWithImpl(_$ModifyRunRequestImpl _value,
      $Res Function(_$ModifyRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_$ModifyRunRequestImpl(
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyRunRequestImpl extends _ModifyRunRequest {
  const _$ModifyRunRequestImpl(
      {@JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ModifyRunRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyRunRequestImplFromJson(json);

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ModifyRunRequest(metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyRunRequestImpl &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyRunRequestImplCopyWith<_$ModifyRunRequestImpl> get copyWith =>
      __$$ModifyRunRequestImplCopyWithImpl<_$ModifyRunRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyRunRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyRunRequest extends ModifyRunRequest {
  const factory _ModifyRunRequest(
      {@JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$ModifyRunRequestImpl;
  const _ModifyRunRequest._() : super._();

  factory _ModifyRunRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyRunRequestImpl.fromJson;

  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ModifyRunRequestImplCopyWith<_$ModifyRunRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SubmitToolOutputsRunRequest _$SubmitToolOutputsRunRequestFromJson(
    Map<String, dynamic> json) {
  return _SubmitToolOutputsRunRequest.fromJson(json);
}

/// @nodoc
mixin _$SubmitToolOutputsRunRequest {
  /// A list of tools for which the outputs are being submitted.
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs =>
      throw _privateConstructorUsedError;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubmitToolOutputsRunRequestCopyWith<SubmitToolOutputsRunRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubmitToolOutputsRunRequestCopyWith<$Res> {
  factory $SubmitToolOutputsRunRequestCopyWith(
          SubmitToolOutputsRunRequest value,
          $Res Function(SubmitToolOutputsRunRequest) then) =
      _$SubmitToolOutputsRunRequestCopyWithImpl<$Res,
          SubmitToolOutputsRunRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_outputs') List<RunSubmitToolOutput> toolOutputs,
      @JsonKey(includeIfNull: false) bool? stream});
}

/// @nodoc
class _$SubmitToolOutputsRunRequestCopyWithImpl<$Res,
        $Val extends SubmitToolOutputsRunRequest>
    implements $SubmitToolOutputsRunRequestCopyWith<$Res> {
  _$SubmitToolOutputsRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolOutputs = null,
    Object? stream = freezed,
  }) {
    return _then(_value.copyWith(
      toolOutputs: null == toolOutputs
          ? _value.toolOutputs
          : toolOutputs // ignore: cast_nullable_to_non_nullable
              as List<RunSubmitToolOutput>,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubmitToolOutputsRunRequestImplCopyWith<$Res>
    implements $SubmitToolOutputsRunRequestCopyWith<$Res> {
  factory _$$SubmitToolOutputsRunRequestImplCopyWith(
          _$SubmitToolOutputsRunRequestImpl value,
          $Res Function(_$SubmitToolOutputsRunRequestImpl) then) =
      __$$SubmitToolOutputsRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_outputs') List<RunSubmitToolOutput> toolOutputs,
      @JsonKey(includeIfNull: false) bool? stream});
}

/// @nodoc
class __$$SubmitToolOutputsRunRequestImplCopyWithImpl<$Res>
    extends _$SubmitToolOutputsRunRequestCopyWithImpl<$Res,
        _$SubmitToolOutputsRunRequestImpl>
    implements _$$SubmitToolOutputsRunRequestImplCopyWith<$Res> {
  __$$SubmitToolOutputsRunRequestImplCopyWithImpl(
      _$SubmitToolOutputsRunRequestImpl _value,
      $Res Function(_$SubmitToolOutputsRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolOutputs = null,
    Object? stream = freezed,
  }) {
    return _then(_$SubmitToolOutputsRunRequestImpl(
      toolOutputs: null == toolOutputs
          ? _value._toolOutputs
          : toolOutputs // ignore: cast_nullable_to_non_nullable
              as List<RunSubmitToolOutput>,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubmitToolOutputsRunRequestImpl extends _SubmitToolOutputsRunRequest {
  const _$SubmitToolOutputsRunRequestImpl(
      {@JsonKey(name: 'tool_outputs')
      required final List<RunSubmitToolOutput> toolOutputs,
      @JsonKey(includeIfNull: false) this.stream})
      : _toolOutputs = toolOutputs,
        super._();

  factory _$SubmitToolOutputsRunRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$SubmitToolOutputsRunRequestImplFromJson(json);

  /// A list of tools for which the outputs are being submitted.
  final List<RunSubmitToolOutput> _toolOutputs;

  /// A list of tools for which the outputs are being submitted.
  @override
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs {
    if (_toolOutputs is EqualUnmodifiableListView) return _toolOutputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolOutputs);
  }

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  @override
  String toString() {
    return 'SubmitToolOutputsRunRequest(toolOutputs: $toolOutputs, stream: $stream)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubmitToolOutputsRunRequestImpl &&
            const DeepCollectionEquality()
                .equals(other._toolOutputs, _toolOutputs) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_toolOutputs), stream);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SubmitToolOutputsRunRequestImplCopyWith<_$SubmitToolOutputsRunRequestImpl>
      get copyWith => __$$SubmitToolOutputsRunRequestImplCopyWithImpl<
          _$SubmitToolOutputsRunRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SubmitToolOutputsRunRequestImplToJson(
      this,
    );
  }
}

abstract class _SubmitToolOutputsRunRequest
    extends SubmitToolOutputsRunRequest {
  const factory _SubmitToolOutputsRunRequest(
          {@JsonKey(name: 'tool_outputs')
          required final List<RunSubmitToolOutput> toolOutputs,
          @JsonKey(includeIfNull: false) final bool? stream}) =
      _$SubmitToolOutputsRunRequestImpl;
  const _SubmitToolOutputsRunRequest._() : super._();

  factory _SubmitToolOutputsRunRequest.fromJson(Map<String, dynamic> json) =
      _$SubmitToolOutputsRunRequestImpl.fromJson;

  @override

  /// A list of tools for which the outputs are being submitted.
  @JsonKey(name: 'tool_outputs')
  List<RunSubmitToolOutput> get toolOutputs;
  @override

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override
  @JsonKey(ignore: true)
  _$$SubmitToolOutputsRunRequestImplCopyWith<_$SubmitToolOutputsRunRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunSubmitToolOutput _$RunSubmitToolOutputFromJson(Map<String, dynamic> json) {
  return _RunSubmitToolOutput.fromJson(json);
}

/// @nodoc
mixin _$RunSubmitToolOutput {
  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  String? get toolCallId => throw _privateConstructorUsedError;

  /// The output of the tool call to be submitted to continue the run.
  @JsonKey(includeIfNull: false)
  String? get output => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunSubmitToolOutputCopyWith<RunSubmitToolOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunSubmitToolOutputCopyWith<$Res> {
  factory $RunSubmitToolOutputCopyWith(
          RunSubmitToolOutput value, $Res Function(RunSubmitToolOutput) then) =
      _$RunSubmitToolOutputCopyWithImpl<$Res, RunSubmitToolOutput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class _$RunSubmitToolOutputCopyWithImpl<$Res, $Val extends RunSubmitToolOutput>
    implements $RunSubmitToolOutputCopyWith<$Res> {
  _$RunSubmitToolOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCallId = freezed,
    Object? output = freezed,
  }) {
    return _then(_value.copyWith(
      toolCallId: freezed == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunSubmitToolOutputImplCopyWith<$Res>
    implements $RunSubmitToolOutputCopyWith<$Res> {
  factory _$$RunSubmitToolOutputImplCopyWith(_$RunSubmitToolOutputImpl value,
          $Res Function(_$RunSubmitToolOutputImpl) then) =
      __$$RunSubmitToolOutputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) String? toolCallId,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class __$$RunSubmitToolOutputImplCopyWithImpl<$Res>
    extends _$RunSubmitToolOutputCopyWithImpl<$Res, _$RunSubmitToolOutputImpl>
    implements _$$RunSubmitToolOutputImplCopyWith<$Res> {
  __$$RunSubmitToolOutputImplCopyWithImpl(_$RunSubmitToolOutputImpl _value,
      $Res Function(_$RunSubmitToolOutputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolCallId = freezed,
    Object? output = freezed,
  }) {
    return _then(_$RunSubmitToolOutputImpl(
      toolCallId: freezed == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunSubmitToolOutputImpl extends _RunSubmitToolOutput {
  const _$RunSubmitToolOutputImpl(
      {@JsonKey(name: 'tool_call_id', includeIfNull: false) this.toolCallId,
      @JsonKey(includeIfNull: false) this.output})
      : super._();

  factory _$RunSubmitToolOutputImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunSubmitToolOutputImplFromJson(json);

  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @override
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  final String? toolCallId;

  /// The output of the tool call to be submitted to continue the run.
  @override
  @JsonKey(includeIfNull: false)
  final String? output;

  @override
  String toString() {
    return 'RunSubmitToolOutput(toolCallId: $toolCallId, output: $output)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunSubmitToolOutputImpl &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, toolCallId, output);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunSubmitToolOutputImplCopyWith<_$RunSubmitToolOutputImpl> get copyWith =>
      __$$RunSubmitToolOutputImplCopyWithImpl<_$RunSubmitToolOutputImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunSubmitToolOutputImplToJson(
      this,
    );
  }
}

abstract class _RunSubmitToolOutput extends RunSubmitToolOutput {
  const factory _RunSubmitToolOutput(
          {@JsonKey(name: 'tool_call_id', includeIfNull: false)
          final String? toolCallId,
          @JsonKey(includeIfNull: false) final String? output}) =
      _$RunSubmitToolOutputImpl;
  const _RunSubmitToolOutput._() : super._();

  factory _RunSubmitToolOutput.fromJson(Map<String, dynamic> json) =
      _$RunSubmitToolOutputImpl.fromJson;

  @override

  /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
  @JsonKey(name: 'tool_call_id', includeIfNull: false)
  String? get toolCallId;
  @override

  /// The output of the tool call to be submitted to continue the run.
  @JsonKey(includeIfNull: false)
  String? get output;
  @override
  @JsonKey(ignore: true)
  _$$RunSubmitToolOutputImplCopyWith<_$RunSubmitToolOutputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunToolCallObject _$RunToolCallObjectFromJson(Map<String, dynamic> json) {
  return _RunToolCallObject.fromJson(json);
}

/// @nodoc
mixin _$RunToolCallObject {
  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  String get id => throw _privateConstructorUsedError;

  /// The type of tool call the output is required for. For now, this is always `function`.
  RunToolCallObjectType get type => throw _privateConstructorUsedError;

  /// The function definition.
  RunToolCallFunction get function => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunToolCallObjectCopyWith<RunToolCallObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunToolCallObjectCopyWith<$Res> {
  factory $RunToolCallObjectCopyWith(
          RunToolCallObject value, $Res Function(RunToolCallObject) then) =
      _$RunToolCallObjectCopyWithImpl<$Res, RunToolCallObject>;
  @useResult
  $Res call(
      {String id, RunToolCallObjectType type, RunToolCallFunction function});

  $RunToolCallFunctionCopyWith<$Res> get function;
}

/// @nodoc
class _$RunToolCallObjectCopyWithImpl<$Res, $Val extends RunToolCallObject>
    implements $RunToolCallObjectCopyWith<$Res> {
  _$RunToolCallObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunToolCallObjectType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunToolCallFunction,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunToolCallFunctionCopyWith<$Res> get function {
    return $RunToolCallFunctionCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunToolCallObjectImplCopyWith<$Res>
    implements $RunToolCallObjectCopyWith<$Res> {
  factory _$$RunToolCallObjectImplCopyWith(_$RunToolCallObjectImpl value,
          $Res Function(_$RunToolCallObjectImpl) then) =
      __$$RunToolCallObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id, RunToolCallObjectType type, RunToolCallFunction function});

  @override
  $RunToolCallFunctionCopyWith<$Res> get function;
}

/// @nodoc
class __$$RunToolCallObjectImplCopyWithImpl<$Res>
    extends _$RunToolCallObjectCopyWithImpl<$Res, _$RunToolCallObjectImpl>
    implements _$$RunToolCallObjectImplCopyWith<$Res> {
  __$$RunToolCallObjectImplCopyWithImpl(_$RunToolCallObjectImpl _value,
      $Res Function(_$RunToolCallObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$RunToolCallObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunToolCallObjectType,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunToolCallFunction,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunToolCallObjectImpl extends _RunToolCallObject {
  const _$RunToolCallObjectImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$RunToolCallObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunToolCallObjectImplFromJson(json);

  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  @override
  final String id;

  /// The type of tool call the output is required for. For now, this is always `function`.
  @override
  final RunToolCallObjectType type;

  /// The function definition.
  @override
  final RunToolCallFunction function;

  @override
  String toString() {
    return 'RunToolCallObject(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunToolCallObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunToolCallObjectImplCopyWith<_$RunToolCallObjectImpl> get copyWith =>
      __$$RunToolCallObjectImplCopyWithImpl<_$RunToolCallObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunToolCallObjectImplToJson(
      this,
    );
  }
}

abstract class _RunToolCallObject extends RunToolCallObject {
  const factory _RunToolCallObject(
      {required final String id,
      required final RunToolCallObjectType type,
      required final RunToolCallFunction function}) = _$RunToolCallObjectImpl;
  const _RunToolCallObject._() : super._();

  factory _RunToolCallObject.fromJson(Map<String, dynamic> json) =
      _$RunToolCallObjectImpl.fromJson;

  @override

  /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint.
  String get id;
  @override

  /// The type of tool call the output is required for. For now, this is always `function`.
  RunToolCallObjectType get type;
  @override

  /// The function definition.
  RunToolCallFunction get function;
  @override
  @JsonKey(ignore: true)
  _$$RunToolCallObjectImplCopyWith<_$RunToolCallObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunToolCallFunction _$RunToolCallFunctionFromJson(Map<String, dynamic> json) {
  return _RunToolCallFunction.fromJson(json);
}

/// @nodoc
mixin _$RunToolCallFunction {
  /// The name of the function.
  String get name => throw _privateConstructorUsedError;

  /// The arguments that the model expects you to pass to the function.
  String get arguments => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunToolCallFunctionCopyWith<RunToolCallFunction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunToolCallFunctionCopyWith<$Res> {
  factory $RunToolCallFunctionCopyWith(
          RunToolCallFunction value, $Res Function(RunToolCallFunction) then) =
      _$RunToolCallFunctionCopyWithImpl<$Res, RunToolCallFunction>;
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class _$RunToolCallFunctionCopyWithImpl<$Res, $Val extends RunToolCallFunction>
    implements $RunToolCallFunctionCopyWith<$Res> {
  _$RunToolCallFunctionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunToolCallFunctionImplCopyWith<$Res>
    implements $RunToolCallFunctionCopyWith<$Res> {
  factory _$$RunToolCallFunctionImplCopyWith(_$RunToolCallFunctionImpl value,
          $Res Function(_$RunToolCallFunctionImpl) then) =
      __$$RunToolCallFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments});
}

/// @nodoc
class __$$RunToolCallFunctionImplCopyWithImpl<$Res>
    extends _$RunToolCallFunctionCopyWithImpl<$Res, _$RunToolCallFunctionImpl>
    implements _$$RunToolCallFunctionImplCopyWith<$Res> {
  __$$RunToolCallFunctionImplCopyWithImpl(_$RunToolCallFunctionImpl _value,
      $Res Function(_$RunToolCallFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
  }) {
    return _then(_$RunToolCallFunctionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunToolCallFunctionImpl extends _RunToolCallFunction {
  const _$RunToolCallFunctionImpl({required this.name, required this.arguments})
      : super._();

  factory _$RunToolCallFunctionImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunToolCallFunctionImplFromJson(json);

  /// The name of the function.
  @override
  final String name;

  /// The arguments that the model expects you to pass to the function.
  @override
  final String arguments;

  @override
  String toString() {
    return 'RunToolCallFunction(name: $name, arguments: $arguments)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunToolCallFunctionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunToolCallFunctionImplCopyWith<_$RunToolCallFunctionImpl> get copyWith =>
      __$$RunToolCallFunctionImplCopyWithImpl<_$RunToolCallFunctionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunToolCallFunctionImplToJson(
      this,
    );
  }
}

abstract class _RunToolCallFunction extends RunToolCallFunction {
  const factory _RunToolCallFunction(
      {required final String name,
      required final String arguments}) = _$RunToolCallFunctionImpl;
  const _RunToolCallFunction._() : super._();

  factory _RunToolCallFunction.fromJson(Map<String, dynamic> json) =
      _$RunToolCallFunctionImpl.fromJson;

  @override

  /// The name of the function.
  String get name;
  @override

  /// The arguments that the model expects you to pass to the function.
  String get arguments;
  @override
  @JsonKey(ignore: true)
  _$$RunToolCallFunctionImplCopyWith<_$RunToolCallFunctionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateThreadAndRunRequest _$CreateThreadAndRunRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateThreadAndRunRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateThreadAndRunRequest {
  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// If no thread is provided, an empty thread will be created.
  @JsonKey(includeIfNull: false)
  CreateThreadRequest? get thread => throw _privateConstructorUsedError;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @_ThreadAndRunModelConverter()
  @JsonKey(includeIfNull: false)
  ThreadAndRunModel? get model => throw _privateConstructorUsedError;

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions => throw _privateConstructorUsedError;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools => throw _privateConstructorUsedError;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature => throw _privateConstructorUsedError;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP => throw _privateConstructorUsedError;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  int? get maxPromptTokens => throw _privateConstructorUsedError;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  int? get maxCompletionTokens => throw _privateConstructorUsedError;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  TruncationObject? get truncationStrategy =>
      throw _privateConstructorUsedError;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_CreateThreadAndRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  CreateThreadAndRunRequestToolChoice? get toolChoice =>
      throw _privateConstructorUsedError;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls => throw _privateConstructorUsedError;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateThreadAndRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateThreadAndRunRequestResponseFormat? get responseFormat =>
      throw _privateConstructorUsedError;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateThreadAndRunRequestCopyWith<CreateThreadAndRunRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateThreadAndRunRequestCopyWith<$Res> {
  factory $CreateThreadAndRunRequestCopyWith(CreateThreadAndRunRequest value,
          $Res Function(CreateThreadAndRunRequest) then) =
      _$CreateThreadAndRunRequestCopyWithImpl<$Res, CreateThreadAndRunRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
      @_ThreadAndRunModelConverter()
      @JsonKey(includeIfNull: false)
      ThreadAndRunModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateThreadAndRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateThreadAndRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateThreadAndRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateThreadAndRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  $CreateThreadRequestCopyWith<$Res>? get thread;
  $ThreadAndRunModelCopyWith<$Res>? get model;
  $ToolResourcesCopyWith<$Res>? get toolResources;
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class _$CreateThreadAndRunRequestCopyWithImpl<$Res,
        $Val extends CreateThreadAndRunRequest>
    implements $CreateThreadAndRunRequestCopyWith<$Res> {
  _$CreateThreadAndRunRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? thread = freezed,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? tools = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_value.copyWith(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      thread: freezed == thread
          ? _value.thread
          : thread // ignore: cast_nullable_to_non_nullable
              as CreateThreadRequest?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ThreadAndRunModel?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _value.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _value.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _value.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestResponseFormat?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateThreadRequestCopyWith<$Res>? get thread {
    if (_value.thread == null) {
      return null;
    }

    return $CreateThreadRequestCopyWith<$Res>(_value.thread!, (value) {
      return _then(_value.copyWith(thread: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ThreadAndRunModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $ThreadAndRunModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_value.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_value.toolResources!, (value) {
      return _then(_value.copyWith(toolResources: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TruncationObjectCopyWith<$Res>? get truncationStrategy {
    if (_value.truncationStrategy == null) {
      return null;
    }

    return $TruncationObjectCopyWith<$Res>(_value.truncationStrategy!, (value) {
      return _then(_value.copyWith(truncationStrategy: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>? get toolChoice {
    if (_value.toolChoice == null) {
      return null;
    }

    return $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>(
        _value.toolChoice!, (value) {
      return _then(_value.copyWith(toolChoice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>? get responseFormat {
    if (_value.responseFormat == null) {
      return null;
    }

    return $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>(
        _value.responseFormat!, (value) {
      return _then(_value.copyWith(responseFormat: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateThreadAndRunRequestImplCopyWith<$Res>
    implements $CreateThreadAndRunRequestCopyWith<$Res> {
  factory _$$CreateThreadAndRunRequestImplCopyWith(
          _$CreateThreadAndRunRequestImpl value,
          $Res Function(_$CreateThreadAndRunRequestImpl) then) =
      __$$CreateThreadAndRunRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(includeIfNull: false) CreateThreadRequest? thread,
      @_ThreadAndRunModelConverter()
      @JsonKey(includeIfNull: false)
      ThreadAndRunModel? model,
      @JsonKey(includeIfNull: false) String? instructions,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) double? temperature,
      @JsonKey(name: 'top_p', includeIfNull: false) double? topP,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      int? maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      int? maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      TruncationObject? truncationStrategy,
      @_CreateThreadAndRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      CreateThreadAndRunRequestToolChoice? toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      bool? parallelToolCalls,
      @_CreateThreadAndRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      CreateThreadAndRunRequestResponseFormat? responseFormat,
      @JsonKey(includeIfNull: false) bool? stream});

  @override
  $CreateThreadRequestCopyWith<$Res>? get thread;
  @override
  $ThreadAndRunModelCopyWith<$Res>? get model;
  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
  @override
  $TruncationObjectCopyWith<$Res>? get truncationStrategy;
  @override
  $CreateThreadAndRunRequestToolChoiceCopyWith<$Res>? get toolChoice;
  @override
  $CreateThreadAndRunRequestResponseFormatCopyWith<$Res>? get responseFormat;
}

/// @nodoc
class __$$CreateThreadAndRunRequestImplCopyWithImpl<$Res>
    extends _$CreateThreadAndRunRequestCopyWithImpl<$Res,
        _$CreateThreadAndRunRequestImpl>
    implements _$$CreateThreadAndRunRequestImplCopyWith<$Res> {
  __$$CreateThreadAndRunRequestImplCopyWithImpl(
      _$CreateThreadAndRunRequestImpl _value,
      $Res Function(_$CreateThreadAndRunRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assistantId = null,
    Object? thread = freezed,
    Object? model = freezed,
    Object? instructions = freezed,
    Object? tools = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
    Object? temperature = freezed,
    Object? topP = freezed,
    Object? maxPromptTokens = freezed,
    Object? maxCompletionTokens = freezed,
    Object? truncationStrategy = freezed,
    Object? toolChoice = freezed,
    Object? parallelToolCalls = freezed,
    Object? responseFormat = freezed,
    Object? stream = freezed,
  }) {
    return _then(_$CreateThreadAndRunRequestImpl(
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      thread: freezed == thread
          ? _value.thread
          : thread // ignore: cast_nullable_to_non_nullable
              as CreateThreadRequest?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as ThreadAndRunModel?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      temperature: freezed == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      topP: freezed == topP
          ? _value.topP
          : topP // ignore: cast_nullable_to_non_nullable
              as double?,
      maxPromptTokens: freezed == maxPromptTokens
          ? _value.maxPromptTokens
          : maxPromptTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      maxCompletionTokens: freezed == maxCompletionTokens
          ? _value.maxCompletionTokens
          : maxCompletionTokens // ignore: cast_nullable_to_non_nullable
              as int?,
      truncationStrategy: freezed == truncationStrategy
          ? _value.truncationStrategy
          : truncationStrategy // ignore: cast_nullable_to_non_nullable
              as TruncationObject?,
      toolChoice: freezed == toolChoice
          ? _value.toolChoice
          : toolChoice // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestToolChoice?,
      parallelToolCalls: freezed == parallelToolCalls
          ? _value.parallelToolCalls
          : parallelToolCalls // ignore: cast_nullable_to_non_nullable
              as bool?,
      responseFormat: freezed == responseFormat
          ? _value.responseFormat
          : responseFormat // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestResponseFormat?,
      stream: freezed == stream
          ? _value.stream
          : stream // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadAndRunRequestImpl extends _CreateThreadAndRunRequest {
  const _$CreateThreadAndRunRequestImpl(
      {@JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(includeIfNull: false) this.thread,
      @_ThreadAndRunModelConverter() @JsonKey(includeIfNull: false) this.model,
      @JsonKey(includeIfNull: false) this.instructions,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
      @JsonKey(includeIfNull: false) this.temperature = 1.0,
      @JsonKey(name: 'top_p', includeIfNull: false) this.topP = 1.0,
      @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
      this.maxPromptTokens,
      @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
      this.maxCompletionTokens,
      @JsonKey(name: 'truncation_strategy', includeIfNull: false)
      this.truncationStrategy,
      @_CreateThreadAndRunRequestToolChoiceConverter()
      @JsonKey(name: 'tool_choice', includeIfNull: false)
      this.toolChoice,
      @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
      this.parallelToolCalls = true,
      @_CreateThreadAndRunRequestResponseFormatConverter()
      @JsonKey(name: 'response_format', includeIfNull: false)
      this.responseFormat,
      @JsonKey(includeIfNull: false) this.stream})
      : _tools = tools,
        _metadata = metadata,
        super._();

  factory _$CreateThreadAndRunRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateThreadAndRunRequestImplFromJson(json);

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// If no thread is provided, an empty thread will be created.
  @override
  @JsonKey(includeIfNull: false)
  final CreateThreadRequest? thread;

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @override
  @_ThreadAndRunModelConverter()
  @JsonKey(includeIfNull: false)
  final ThreadAndRunModel? model;

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  final String? instructions;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  final List<AssistantTools>? _tools;

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @override
  @JsonKey(includeIfNull: false)
  final double? temperature;

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @override
  @JsonKey(name: 'top_p', includeIfNull: false)
  final double? topP;

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  final int? maxPromptTokens;

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @override
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  final int? maxCompletionTokens;

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @override
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  final TruncationObject? truncationStrategy;

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @override
  @_CreateThreadAndRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  final CreateThreadAndRunRequestToolChoice? toolChoice;

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @override
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  final bool? parallelToolCalls;

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @override
  @_CreateThreadAndRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  final CreateThreadAndRunRequestResponseFormat? responseFormat;

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @override
  @JsonKey(includeIfNull: false)
  final bool? stream;

  @override
  String toString() {
    return 'CreateThreadAndRunRequest(assistantId: $assistantId, thread: $thread, model: $model, instructions: $instructions, tools: $tools, toolResources: $toolResources, metadata: $metadata, temperature: $temperature, topP: $topP, maxPromptTokens: $maxPromptTokens, maxCompletionTokens: $maxCompletionTokens, truncationStrategy: $truncationStrategy, toolChoice: $toolChoice, parallelToolCalls: $parallelToolCalls, responseFormat: $responseFormat, stream: $stream)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateThreadAndRunRequestImpl &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.thread, thread) || other.thread == thread) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality().equals(other._tools, _tools) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.topP, topP) || other.topP == topP) &&
            (identical(other.maxPromptTokens, maxPromptTokens) ||
                other.maxPromptTokens == maxPromptTokens) &&
            (identical(other.maxCompletionTokens, maxCompletionTokens) ||
                other.maxCompletionTokens == maxCompletionTokens) &&
            (identical(other.truncationStrategy, truncationStrategy) ||
                other.truncationStrategy == truncationStrategy) &&
            (identical(other.toolChoice, toolChoice) ||
                other.toolChoice == toolChoice) &&
            (identical(other.parallelToolCalls, parallelToolCalls) ||
                other.parallelToolCalls == parallelToolCalls) &&
            (identical(other.responseFormat, responseFormat) ||
                other.responseFormat == responseFormat) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      assistantId,
      thread,
      model,
      instructions,
      const DeepCollectionEquality().hash(_tools),
      toolResources,
      const DeepCollectionEquality().hash(_metadata),
      temperature,
      topP,
      maxPromptTokens,
      maxCompletionTokens,
      truncationStrategy,
      toolChoice,
      parallelToolCalls,
      responseFormat,
      stream);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadAndRunRequestImplCopyWith<_$CreateThreadAndRunRequestImpl>
      get copyWith => __$$CreateThreadAndRunRequestImplCopyWithImpl<
          _$CreateThreadAndRunRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadAndRunRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateThreadAndRunRequest extends CreateThreadAndRunRequest {
  const factory _CreateThreadAndRunRequest(
          {@JsonKey(name: 'assistant_id') required final String assistantId,
          @JsonKey(includeIfNull: false) final CreateThreadRequest? thread,
          @_ThreadAndRunModelConverter()
          @JsonKey(includeIfNull: false)
          final ThreadAndRunModel? model,
          @JsonKey(includeIfNull: false) final String? instructions,
          @JsonKey(includeIfNull: false) final List<AssistantTools>? tools,
          @JsonKey(name: 'tool_resources', includeIfNull: false)
          final ToolResources? toolResources,
          @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata,
          @JsonKey(includeIfNull: false) final double? temperature,
          @JsonKey(name: 'top_p', includeIfNull: false) final double? topP,
          @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
          final int? maxPromptTokens,
          @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
          final int? maxCompletionTokens,
          @JsonKey(name: 'truncation_strategy', includeIfNull: false)
          final TruncationObject? truncationStrategy,
          @_CreateThreadAndRunRequestToolChoiceConverter()
          @JsonKey(name: 'tool_choice', includeIfNull: false)
          final CreateThreadAndRunRequestToolChoice? toolChoice,
          @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
          final bool? parallelToolCalls,
          @_CreateThreadAndRunRequestResponseFormatConverter()
          @JsonKey(name: 'response_format', includeIfNull: false)
          final CreateThreadAndRunRequestResponseFormat? responseFormat,
          @JsonKey(includeIfNull: false) final bool? stream}) =
      _$CreateThreadAndRunRequestImpl;
  const _CreateThreadAndRunRequest._() : super._();

  factory _CreateThreadAndRunRequest.fromJson(Map<String, dynamic> json) =
      _$CreateThreadAndRunRequestImpl.fromJson;

  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// If no thread is provided, an empty thread will be created.
  @JsonKey(includeIfNull: false)
  CreateThreadRequest? get thread;
  @override

  /// The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  @_ThreadAndRunModelConverter()
  @JsonKey(includeIfNull: false)
  ThreadAndRunModel? get model;
  @override

  /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  String? get instructions;
  @override

  /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;
  @override

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override

  /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  @JsonKey(includeIfNull: false)
  double? get temperature;
  @override

  /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
  ///
  /// We generally recommend altering this or temperature but not both.
  @JsonKey(name: 'top_p', includeIfNull: false)
  double? get topP;
  @override

  /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_prompt_tokens', includeIfNull: false)
  int? get maxPromptTokens;
  @override

  /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
  @JsonKey(name: 'max_completion_tokens', includeIfNull: false)
  int? get maxCompletionTokens;
  @override

  /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
  @JsonKey(name: 'truncation_strategy', includeIfNull: false)
  TruncationObject? get truncationStrategy;
  @override

  /// Controls which (if any) tool is called by the model.
  /// `none` means the model will not call any tools and instead generates a message.
  /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
  /// `required` means the model must call one or more tools before responding to the user.
  /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
  @_CreateThreadAndRunRequestToolChoiceConverter()
  @JsonKey(name: 'tool_choice', includeIfNull: false)
  CreateThreadAndRunRequestToolChoice? get toolChoice;
  @override

  /// Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  /// during tool use.
  @JsonKey(name: 'parallel_tool_calls', includeIfNull: false)
  bool? get parallelToolCalls;
  @override

  /// Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models/gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
  ///
  /// Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is valid JSON.
  ///
  /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
  @_CreateThreadAndRunRequestResponseFormatConverter()
  @JsonKey(name: 'response_format', includeIfNull: false)
  CreateThreadAndRunRequestResponseFormat? get responseFormat;
  @override

  /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
  @JsonKey(includeIfNull: false)
  bool? get stream;
  @override
  @JsonKey(ignore: true)
  _$$CreateThreadAndRunRequestImplCopyWith<_$CreateThreadAndRunRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ThreadAndRunModel _$ThreadAndRunModelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'model':
      return ThreadAndRunModelEnumeration.fromJson(json);
    case 'modelId':
      return ThreadAndRunModelString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ThreadAndRunModel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ThreadAndRunModel {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ThreadAndRunModels value) model,
    required TResult Function(String value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModels value)? model,
    TResult? Function(String value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ThreadAndRunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadAndRunModelEnumeration value) model,
    required TResult Function(ThreadAndRunModelString value) modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModelEnumeration value)? model,
    TResult? Function(ThreadAndRunModelString value)? modelId,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadAndRunModelEnumeration value)? model,
    TResult Function(ThreadAndRunModelString value)? modelId,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThreadAndRunModelCopyWith<$Res> {
  factory $ThreadAndRunModelCopyWith(
          ThreadAndRunModel value, $Res Function(ThreadAndRunModel) then) =
      _$ThreadAndRunModelCopyWithImpl<$Res, ThreadAndRunModel>;
}

/// @nodoc
class _$ThreadAndRunModelCopyWithImpl<$Res, $Val extends ThreadAndRunModel>
    implements $ThreadAndRunModelCopyWith<$Res> {
  _$ThreadAndRunModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ThreadAndRunModelEnumerationImplCopyWith<$Res> {
  factory _$$ThreadAndRunModelEnumerationImplCopyWith(
          _$ThreadAndRunModelEnumerationImpl value,
          $Res Function(_$ThreadAndRunModelEnumerationImpl) then) =
      __$$ThreadAndRunModelEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ThreadAndRunModels value});
}

/// @nodoc
class __$$ThreadAndRunModelEnumerationImplCopyWithImpl<$Res>
    extends _$ThreadAndRunModelCopyWithImpl<$Res,
        _$ThreadAndRunModelEnumerationImpl>
    implements _$$ThreadAndRunModelEnumerationImplCopyWith<$Res> {
  __$$ThreadAndRunModelEnumerationImplCopyWithImpl(
      _$ThreadAndRunModelEnumerationImpl _value,
      $Res Function(_$ThreadAndRunModelEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ThreadAndRunModelEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ThreadAndRunModels,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ThreadAndRunModelEnumerationImpl extends ThreadAndRunModelEnumeration {
  const _$ThreadAndRunModelEnumerationImpl(this.value, {final String? $type})
      : $type = $type ?? 'model',
        super._();

  factory _$ThreadAndRunModelEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ThreadAndRunModelEnumerationImplFromJson(json);

  @override
  final ThreadAndRunModels value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ThreadAndRunModel.model(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThreadAndRunModelEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ThreadAndRunModelEnumerationImplCopyWith<
          _$ThreadAndRunModelEnumerationImpl>
      get copyWith => __$$ThreadAndRunModelEnumerationImplCopyWithImpl<
          _$ThreadAndRunModelEnumerationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ThreadAndRunModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return model(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return model?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ThreadAndRunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadAndRunModelEnumeration value) model,
    required TResult Function(ThreadAndRunModelString value) modelId,
  }) {
    return model(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModelEnumeration value)? model,
    TResult? Function(ThreadAndRunModelString value)? modelId,
  }) {
    return model?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadAndRunModelEnumeration value)? model,
    TResult Function(ThreadAndRunModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (model != null) {
      return model(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ThreadAndRunModelEnumerationImplToJson(
      this,
    );
  }
}

abstract class ThreadAndRunModelEnumeration extends ThreadAndRunModel {
  const factory ThreadAndRunModelEnumeration(final ThreadAndRunModels value) =
      _$ThreadAndRunModelEnumerationImpl;
  const ThreadAndRunModelEnumeration._() : super._();

  factory ThreadAndRunModelEnumeration.fromJson(Map<String, dynamic> json) =
      _$ThreadAndRunModelEnumerationImpl.fromJson;

  @override
  ThreadAndRunModels get value;
  @JsonKey(ignore: true)
  _$$ThreadAndRunModelEnumerationImplCopyWith<
          _$ThreadAndRunModelEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ThreadAndRunModelStringImplCopyWith<$Res> {
  factory _$$ThreadAndRunModelStringImplCopyWith(
          _$ThreadAndRunModelStringImpl value,
          $Res Function(_$ThreadAndRunModelStringImpl) then) =
      __$$ThreadAndRunModelStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ThreadAndRunModelStringImplCopyWithImpl<$Res>
    extends _$ThreadAndRunModelCopyWithImpl<$Res, _$ThreadAndRunModelStringImpl>
    implements _$$ThreadAndRunModelStringImplCopyWith<$Res> {
  __$$ThreadAndRunModelStringImplCopyWithImpl(
      _$ThreadAndRunModelStringImpl _value,
      $Res Function(_$ThreadAndRunModelStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ThreadAndRunModelStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ThreadAndRunModelStringImpl extends ThreadAndRunModelString {
  const _$ThreadAndRunModelStringImpl(this.value, {final String? $type})
      : $type = $type ?? 'modelId',
        super._();

  factory _$ThreadAndRunModelStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ThreadAndRunModelStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ThreadAndRunModel.modelId(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThreadAndRunModelStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ThreadAndRunModelStringImplCopyWith<_$ThreadAndRunModelStringImpl>
      get copyWith => __$$ThreadAndRunModelStringImplCopyWithImpl<
          _$ThreadAndRunModelStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ThreadAndRunModels value) model,
    required TResult Function(String value) modelId,
  }) {
    return modelId(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModels value)? model,
    TResult? Function(String value)? modelId,
  }) {
    return modelId?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ThreadAndRunModels value)? model,
    TResult Function(String value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadAndRunModelEnumeration value) model,
    required TResult Function(ThreadAndRunModelString value) modelId,
  }) {
    return modelId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadAndRunModelEnumeration value)? model,
    TResult? Function(ThreadAndRunModelString value)? modelId,
  }) {
    return modelId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadAndRunModelEnumeration value)? model,
    TResult Function(ThreadAndRunModelString value)? modelId,
    required TResult orElse(),
  }) {
    if (modelId != null) {
      return modelId(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ThreadAndRunModelStringImplToJson(
      this,
    );
  }
}

abstract class ThreadAndRunModelString extends ThreadAndRunModel {
  const factory ThreadAndRunModelString(final String value) =
      _$ThreadAndRunModelStringImpl;
  const ThreadAndRunModelString._() : super._();

  factory ThreadAndRunModelString.fromJson(Map<String, dynamic> json) =
      _$ThreadAndRunModelStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ThreadAndRunModelStringImplCopyWith<_$ThreadAndRunModelStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateThreadAndRunRequestToolChoice
    _$CreateThreadAndRunRequestToolChoiceFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateThreadAndRunRequestToolChoiceEnumeration.fromJson(json);
    case 'tool':
      return CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateThreadAndRunRequestToolChoice',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateThreadAndRunRequestToolChoice {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestToolChoiceMode value)
        mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateThreadAndRunRequestToolChoiceCopyWith<$Res> {
  factory $CreateThreadAndRunRequestToolChoiceCopyWith(
          CreateThreadAndRunRequestToolChoice value,
          $Res Function(CreateThreadAndRunRequestToolChoice) then) =
      _$CreateThreadAndRunRequestToolChoiceCopyWithImpl<$Res,
          CreateThreadAndRunRequestToolChoice>;
}

/// @nodoc
class _$CreateThreadAndRunRequestToolChoiceCopyWithImpl<$Res,
        $Val extends CreateThreadAndRunRequestToolChoice>
    implements $CreateThreadAndRunRequestToolChoiceCopyWith<$Res> {
  _$CreateThreadAndRunRequestToolChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWith<
    $Res> {
  factory _$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWith(
          _$CreateThreadAndRunRequestToolChoiceEnumerationImpl value,
          $Res Function(_$CreateThreadAndRunRequestToolChoiceEnumerationImpl)
              then) =
      __$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CreateThreadAndRunRequestToolChoiceMode value});
}

/// @nodoc
class __$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWithImpl<$Res>
    extends _$CreateThreadAndRunRequestToolChoiceCopyWithImpl<$Res,
        _$CreateThreadAndRunRequestToolChoiceEnumerationImpl>
    implements
        _$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWith<$Res> {
  __$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWithImpl(
      _$CreateThreadAndRunRequestToolChoiceEnumerationImpl _value,
      $Res Function(_$CreateThreadAndRunRequestToolChoiceEnumerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateThreadAndRunRequestToolChoiceEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestToolChoiceMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadAndRunRequestToolChoiceEnumerationImpl
    extends CreateThreadAndRunRequestToolChoiceEnumeration {
  const _$CreateThreadAndRunRequestToolChoiceEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$CreateThreadAndRunRequestToolChoiceEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateThreadAndRunRequestToolChoiceEnumerationImplFromJson(json);

  @override
  final CreateThreadAndRunRequestToolChoiceMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateThreadAndRunRequestToolChoice.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateThreadAndRunRequestToolChoiceEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWith<
          _$CreateThreadAndRunRequestToolChoiceEnumerationImpl>
      get copyWith =>
          __$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWithImpl<
                  _$CreateThreadAndRunRequestToolChoiceEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestToolChoiceMode value)
        mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadAndRunRequestToolChoiceEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateThreadAndRunRequestToolChoiceEnumeration
    extends CreateThreadAndRunRequestToolChoice {
  const factory CreateThreadAndRunRequestToolChoiceEnumeration(
          final CreateThreadAndRunRequestToolChoiceMode value) =
      _$CreateThreadAndRunRequestToolChoiceEnumerationImpl;
  const CreateThreadAndRunRequestToolChoiceEnumeration._() : super._();

  factory CreateThreadAndRunRequestToolChoiceEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateThreadAndRunRequestToolChoiceEnumerationImpl.fromJson;

  @override
  CreateThreadAndRunRequestToolChoiceMode get value;
  @JsonKey(ignore: true)
  _$$CreateThreadAndRunRequestToolChoiceEnumerationImplCopyWith<
          _$CreateThreadAndRunRequestToolChoiceEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
    $Res> {
  factory _$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith(
          _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl value,
          $Res Function(
                  _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl)
              then) =
      __$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({AssistantsNamedToolChoice value});

  $AssistantsNamedToolChoiceCopyWith<$Res> get value;
}

/// @nodoc
class __$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<
        $Res>
    extends _$CreateThreadAndRunRequestToolChoiceCopyWithImpl<$Res,
        _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl>
    implements
        _$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
            $Res> {
  __$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl(
      _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl _value,
      $Res Function(
              _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsNamedToolChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsNamedToolChoiceCopyWith<$Res> get value {
    return $AssistantsNamedToolChoiceCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl
    extends CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice {
  const _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'tool',
        super._();

  factory _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplFromJson(
          json);

  @override
  final AssistantsNamedToolChoice value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateThreadAndRunRequestToolChoice.tool(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
          _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl>
      get copyWith =>
          __$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWithImpl<
                  _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestToolChoiceMode value)
        mode,
    required TResult Function(AssistantsNamedToolChoice value) tool,
  }) {
    return tool(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult? Function(AssistantsNamedToolChoice value)? tool,
  }) {
    return tool?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceMode value)? mode,
    TResult Function(AssistantsNamedToolChoice value)? tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)
        tool,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestToolChoiceEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice value)?
        tool,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplToJson(
      this,
    );
  }
}

abstract class CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice
    extends CreateThreadAndRunRequestToolChoice {
  const factory CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice(
          final AssistantsNamedToolChoice value) =
      _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl;
  const CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice._()
      : super._();

  factory CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoice.fromJson(
          Map<String, dynamic> json) =
      _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl
      .fromJson;

  @override
  AssistantsNamedToolChoice get value;
  @JsonKey(ignore: true)
  _$$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImplCopyWith<
          _$CreateThreadAndRunRequestToolChoiceAssistantsNamedToolChoiceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateThreadAndRunRequestResponseFormat
    _$CreateThreadAndRunRequestResponseFormatFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'mode':
      return CreateThreadAndRunRequestResponseFormatEnumeration.fromJson(json);
    case 'format':
      return CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateThreadAndRunRequestResponseFormat',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateThreadAndRunRequestResponseFormat {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestResponseFormatMode value)
        mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)?
        format,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)?
        format,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateThreadAndRunRequestResponseFormatCopyWith<$Res> {
  factory $CreateThreadAndRunRequestResponseFormatCopyWith(
          CreateThreadAndRunRequestResponseFormat value,
          $Res Function(CreateThreadAndRunRequestResponseFormat) then) =
      _$CreateThreadAndRunRequestResponseFormatCopyWithImpl<$Res,
          CreateThreadAndRunRequestResponseFormat>;
}

/// @nodoc
class _$CreateThreadAndRunRequestResponseFormatCopyWithImpl<$Res,
        $Val extends CreateThreadAndRunRequestResponseFormat>
    implements $CreateThreadAndRunRequestResponseFormatCopyWith<$Res> {
  _$CreateThreadAndRunRequestResponseFormatCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWith<
    $Res> {
  factory _$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWith(
          _$CreateThreadAndRunRequestResponseFormatEnumerationImpl value,
          $Res Function(
                  _$CreateThreadAndRunRequestResponseFormatEnumerationImpl)
              then) =
      __$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({CreateThreadAndRunRequestResponseFormatMode value});
}

/// @nodoc
class __$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWithImpl<
        $Res>
    extends _$CreateThreadAndRunRequestResponseFormatCopyWithImpl<$Res,
        _$CreateThreadAndRunRequestResponseFormatEnumerationImpl>
    implements
        _$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWith<
            $Res> {
  __$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWithImpl(
      _$CreateThreadAndRunRequestResponseFormatEnumerationImpl _value,
      $Res Function(_$CreateThreadAndRunRequestResponseFormatEnumerationImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateThreadAndRunRequestResponseFormatEnumerationImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as CreateThreadAndRunRequestResponseFormatMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadAndRunRequestResponseFormatEnumerationImpl
    extends CreateThreadAndRunRequestResponseFormatEnumeration {
  const _$CreateThreadAndRunRequestResponseFormatEnumerationImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'mode',
        super._();

  factory _$CreateThreadAndRunRequestResponseFormatEnumerationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateThreadAndRunRequestResponseFormatEnumerationImplFromJson(json);

  @override
  final CreateThreadAndRunRequestResponseFormatMode value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateThreadAndRunRequestResponseFormat.mode(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateThreadAndRunRequestResponseFormatEnumerationImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWith<
          _$CreateThreadAndRunRequestResponseFormatEnumerationImpl>
      get copyWith =>
          __$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWithImpl<
                  _$CreateThreadAndRunRequestResponseFormatEnumerationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestResponseFormatMode value)
        mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return mode(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return mode?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)
        format,
  }) {
    return mode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)?
        format,
  }) {
    return mode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)?
        format,
    required TResult orElse(),
  }) {
    if (mode != null) {
      return mode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadAndRunRequestResponseFormatEnumerationImplToJson(
      this,
    );
  }
}

abstract class CreateThreadAndRunRequestResponseFormatEnumeration
    extends CreateThreadAndRunRequestResponseFormat {
  const factory CreateThreadAndRunRequestResponseFormatEnumeration(
          final CreateThreadAndRunRequestResponseFormatMode value) =
      _$CreateThreadAndRunRequestResponseFormatEnumerationImpl;
  const CreateThreadAndRunRequestResponseFormatEnumeration._() : super._();

  factory CreateThreadAndRunRequestResponseFormatEnumeration.fromJson(
          Map<String, dynamic> json) =
      _$CreateThreadAndRunRequestResponseFormatEnumerationImpl.fromJson;

  @override
  CreateThreadAndRunRequestResponseFormatMode get value;
  @JsonKey(ignore: true)
  _$$CreateThreadAndRunRequestResponseFormatEnumerationImplCopyWith<
          _$CreateThreadAndRunRequestResponseFormatEnumerationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
    $Res> {
  factory _$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWith(
          _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl
              value,
          $Res Function(
                  _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl)
              then) =
      __$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({AssistantsResponseFormat value});

  $AssistantsResponseFormatCopyWith<$Res> get value;
}

/// @nodoc
class __$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
        $Res>
    extends _$CreateThreadAndRunRequestResponseFormatCopyWithImpl<$Res,
        _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl>
    implements
        _$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
            $Res> {
  __$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl(
      _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl
          _value,
      $Res Function(
              _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as AssistantsResponseFormat,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantsResponseFormatCopyWith<$Res> get value {
    return $AssistantsResponseFormatCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl
    extends CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat {
  const _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl(
      this.value,
      {final String? $type})
      : $type = $type ?? 'format',
        super._();

  factory _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplFromJson(
          json);

  @override
  final AssistantsResponseFormat value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateThreadAndRunRequestResponseFormat.format(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith =>
          __$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWithImpl<
                  _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(CreateThreadAndRunRequestResponseFormatMode value)
        mode,
    required TResult Function(AssistantsResponseFormat value) format,
  }) {
    return format(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult? Function(AssistantsResponseFormat value)? format,
  }) {
    return format?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatMode value)? mode,
    TResult Function(AssistantsResponseFormat value)? format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatEnumeration value)
        mode,
    required TResult Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)
        format,
  }) {
    return format(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult? Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)?
        format,
  }) {
    return format?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateThreadAndRunRequestResponseFormatEnumeration value)?
        mode,
    TResult Function(
            CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
                value)?
        format,
    required TResult orElse(),
  }) {
    if (format != null) {
      return format(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplToJson(
      this,
    );
  }
}

abstract class CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat
    extends CreateThreadAndRunRequestResponseFormat {
  const factory CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat(
          final AssistantsResponseFormat value) =
      _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl;
  const CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat._()
      : super._();

  factory CreateThreadAndRunRequestResponseFormatAssistantsResponseFormat.fromJson(
          Map<String, dynamic> json) =
      _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl
      .fromJson;

  @override
  AssistantsResponseFormat get value;
  @JsonKey(ignore: true)
  _$$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImplCopyWith<
          _$CreateThreadAndRunRequestResponseFormatAssistantsResponseFormatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ThreadObject _$ThreadObjectFromJson(Map<String, dynamic> json) {
  return _ThreadObject.fromJson(json);
}

/// @nodoc
mixin _$ThreadObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread`.
  ThreadObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the thread was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources')
  ToolResources? get toolResources => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ThreadObjectCopyWith<ThreadObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThreadObjectCopyWith<$Res> {
  factory $ThreadObjectCopyWith(
          ThreadObject value, $Res Function(ThreadObject) then) =
      _$ThreadObjectCopyWithImpl<$Res, ThreadObject>;
  @useResult
  $Res call(
      {String id,
      ThreadObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'tool_resources') ToolResources? toolResources,
      Map<String, dynamic>? metadata});

  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class _$ThreadObjectCopyWithImpl<$Res, $Val extends ThreadObject>
    implements $ThreadObjectCopyWith<$Res> {
  _$ThreadObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ThreadObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_value.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_value.toolResources!, (value) {
      return _then(_value.copyWith(toolResources: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ThreadObjectImplCopyWith<$Res>
    implements $ThreadObjectCopyWith<$Res> {
  factory _$$ThreadObjectImplCopyWith(
          _$ThreadObjectImpl value, $Res Function(_$ThreadObjectImpl) then) =
      __$$ThreadObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      ThreadObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'tool_resources') ToolResources? toolResources,
      Map<String, dynamic>? metadata});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class __$$ThreadObjectImplCopyWithImpl<$Res>
    extends _$ThreadObjectCopyWithImpl<$Res, _$ThreadObjectImpl>
    implements _$$ThreadObjectImplCopyWith<$Res> {
  __$$ThreadObjectImplCopyWithImpl(
      _$ThreadObjectImpl _value, $Res Function(_$ThreadObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$ThreadObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ThreadObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ThreadObjectImpl extends _ThreadObject {
  const _$ThreadObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'tool_resources') required this.toolResources,
      required final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ThreadObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$ThreadObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread`.
  @override
  final ThreadObjectObject object;

  /// The Unix timestamp (in seconds) for when the thread was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources')
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ThreadObject(id: $id, object: $object, createdAt: $createdAt, toolResources: $toolResources, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThreadObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, createdAt,
      toolResources, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ThreadObjectImplCopyWith<_$ThreadObjectImpl> get copyWith =>
      __$$ThreadObjectImplCopyWithImpl<_$ThreadObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ThreadObjectImplToJson(
      this,
    );
  }
}

abstract class _ThreadObject extends ThreadObject {
  const factory _ThreadObject(
      {required final String id,
      required final ThreadObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'tool_resources')
      required final ToolResources? toolResources,
      required final Map<String, dynamic>? metadata}) = _$ThreadObjectImpl;
  const _ThreadObject._() : super._();

  factory _ThreadObject.fromJson(Map<String, dynamic> json) =
      _$ThreadObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread`.
  ThreadObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the thread was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources')
  ToolResources? get toolResources;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ThreadObjectImplCopyWith<_$ThreadObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateThreadRequest _$CreateThreadRequestFromJson(Map<String, dynamic> json) {
  return _CreateThreadRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateThreadRequest {
  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages =>
      throw _privateConstructorUsedError;

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateThreadRequestCopyWith<CreateThreadRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateThreadRequestCopyWith<$Res> {
  factory $CreateThreadRequestCopyWith(
          CreateThreadRequest value, $Res Function(CreateThreadRequest) then) =
      _$CreateThreadRequestCopyWithImpl<$Res, CreateThreadRequest>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class _$CreateThreadRequestCopyWithImpl<$Res, $Val extends CreateThreadRequest>
    implements $CreateThreadRequestCopyWith<$Res> {
  _$CreateThreadRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messages = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      messages: freezed == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_value.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_value.toolResources!, (value) {
      return _then(_value.copyWith(toolResources: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateThreadRequestImplCopyWith<$Res>
    implements $CreateThreadRequestCopyWith<$Res> {
  factory _$$CreateThreadRequestImplCopyWith(_$CreateThreadRequestImpl value,
          $Res Function(_$CreateThreadRequestImpl) then) =
      __$$CreateThreadRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) List<CreateMessageRequest>? messages,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class __$$CreateThreadRequestImplCopyWithImpl<$Res>
    extends _$CreateThreadRequestCopyWithImpl<$Res, _$CreateThreadRequestImpl>
    implements _$$CreateThreadRequestImplCopyWith<$Res> {
  __$$CreateThreadRequestImplCopyWithImpl(_$CreateThreadRequestImpl _value,
      $Res Function(_$CreateThreadRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messages = freezed,
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateThreadRequestImpl(
      messages: freezed == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as List<CreateMessageRequest>?,
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateThreadRequestImpl extends _CreateThreadRequest {
  const _$CreateThreadRequestImpl(
      {@JsonKey(includeIfNull: false)
      final List<CreateMessageRequest>? messages,
      @JsonKey(name: 'tool_resources', includeIfNull: false) this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _messages = messages,
        _metadata = metadata,
        super._();

  factory _$CreateThreadRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateThreadRequestImplFromJson(json);

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  final List<CreateMessageRequest>? _messages;

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @override
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages {
    final value = _messages;
    if (value == null) return null;
    if (_messages is EqualUnmodifiableListView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateThreadRequest(messages: $messages, toolResources: $toolResources, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateThreadRequestImpl &&
            const DeepCollectionEquality().equals(other._messages, _messages) &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_messages),
      toolResources,
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateThreadRequestImplCopyWith<_$CreateThreadRequestImpl> get copyWith =>
      __$$CreateThreadRequestImplCopyWithImpl<_$CreateThreadRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateThreadRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateThreadRequest extends CreateThreadRequest {
  const factory _CreateThreadRequest(
      {@JsonKey(includeIfNull: false)
      final List<CreateMessageRequest>? messages,
      @JsonKey(name: 'tool_resources', includeIfNull: false)
      final ToolResources? toolResources,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$CreateThreadRequestImpl;
  const _CreateThreadRequest._() : super._();

  factory _CreateThreadRequest.fromJson(Map<String, dynamic> json) =
      _$CreateThreadRequestImpl.fromJson;

  @override

  /// A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with.
  @JsonKey(includeIfNull: false)
  List<CreateMessageRequest>? get messages;
  @override

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateThreadRequestImplCopyWith<_$CreateThreadRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ModifyThreadRequest _$ModifyThreadRequestFromJson(Map<String, dynamic> json) {
  return _ModifyThreadRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyThreadRequest {
  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyThreadRequestCopyWith<ModifyThreadRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyThreadRequestCopyWith<$Res> {
  factory $ModifyThreadRequestCopyWith(
          ModifyThreadRequest value, $Res Function(ModifyThreadRequest) then) =
      _$ModifyThreadRequestCopyWithImpl<$Res, ModifyThreadRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class _$ModifyThreadRequestCopyWithImpl<$Res, $Val extends ModifyThreadRequest>
    implements $ModifyThreadRequestCopyWith<$Res> {
  _$ModifyThreadRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCopyWith<$Res>? get toolResources {
    if (_value.toolResources == null) {
      return null;
    }

    return $ToolResourcesCopyWith<$Res>(_value.toolResources!, (value) {
      return _then(_value.copyWith(toolResources: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModifyThreadRequestImplCopyWith<$Res>
    implements $ModifyThreadRequestCopyWith<$Res> {
  factory _$$ModifyThreadRequestImplCopyWith(_$ModifyThreadRequestImpl value,
          $Res Function(_$ModifyThreadRequestImpl) then) =
      __$$ModifyThreadRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tool_resources', includeIfNull: false)
      ToolResources? toolResources,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $ToolResourcesCopyWith<$Res>? get toolResources;
}

/// @nodoc
class __$$ModifyThreadRequestImplCopyWithImpl<$Res>
    extends _$ModifyThreadRequestCopyWithImpl<$Res, _$ModifyThreadRequestImpl>
    implements _$$ModifyThreadRequestImplCopyWith<$Res> {
  __$$ModifyThreadRequestImplCopyWithImpl(_$ModifyThreadRequestImpl _value,
      $Res Function(_$ModifyThreadRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? toolResources = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$ModifyThreadRequestImpl(
      toolResources: freezed == toolResources
          ? _value.toolResources
          : toolResources // ignore: cast_nullable_to_non_nullable
              as ToolResources?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyThreadRequestImpl extends _ModifyThreadRequest {
  const _$ModifyThreadRequestImpl(
      {@JsonKey(name: 'tool_resources', includeIfNull: false)
      this.toolResources,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ModifyThreadRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyThreadRequestImplFromJson(json);

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @override
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  final ToolResources? toolResources;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ModifyThreadRequest(toolResources: $toolResources, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyThreadRequestImpl &&
            (identical(other.toolResources, toolResources) ||
                other.toolResources == toolResources) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, toolResources,
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyThreadRequestImplCopyWith<_$ModifyThreadRequestImpl> get copyWith =>
      __$$ModifyThreadRequestImplCopyWithImpl<_$ModifyThreadRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyThreadRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyThreadRequest extends ModifyThreadRequest {
  const factory _ModifyThreadRequest(
      {@JsonKey(name: 'tool_resources', includeIfNull: false)
      final ToolResources? toolResources,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$ModifyThreadRequestImpl;
  const _ModifyThreadRequest._() : super._();

  factory _ModifyThreadRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyThreadRequestImpl.fromJson;

  @override

  /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
  @JsonKey(name: 'tool_resources', includeIfNull: false)
  ToolResources? get toolResources;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ModifyThreadRequestImplCopyWith<_$ModifyThreadRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ToolResources _$ToolResourcesFromJson(Map<String, dynamic> json) {
  return _ToolResources.fromJson(json);
}

/// @nodoc
mixin _$ToolResources {
  /// No Description
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  ToolResourcesCodeInterpreter? get codeInterpreter =>
      throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(name: 'file_search', includeIfNull: false)
  ToolResourcesFileSearch? get fileSearch => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ToolResourcesCopyWith<ToolResources> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ToolResourcesCopyWith<$Res> {
  factory $ToolResourcesCopyWith(
          ToolResources value, $Res Function(ToolResources) then) =
      _$ToolResourcesCopyWithImpl<$Res, ToolResources>;
  @useResult
  $Res call(
      {@JsonKey(name: 'code_interpreter', includeIfNull: false)
      ToolResourcesCodeInterpreter? codeInterpreter,
      @JsonKey(name: 'file_search', includeIfNull: false)
      ToolResourcesFileSearch? fileSearch});

  $ToolResourcesCodeInterpreterCopyWith<$Res>? get codeInterpreter;
  $ToolResourcesFileSearchCopyWith<$Res>? get fileSearch;
}

/// @nodoc
class _$ToolResourcesCopyWithImpl<$Res, $Val extends ToolResources>
    implements $ToolResourcesCopyWith<$Res> {
  _$ToolResourcesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? codeInterpreter = freezed,
    Object? fileSearch = freezed,
  }) {
    return _then(_value.copyWith(
      codeInterpreter: freezed == codeInterpreter
          ? _value.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as ToolResourcesCodeInterpreter?,
      fileSearch: freezed == fileSearch
          ? _value.fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as ToolResourcesFileSearch?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesCodeInterpreterCopyWith<$Res>? get codeInterpreter {
    if (_value.codeInterpreter == null) {
      return null;
    }

    return $ToolResourcesCodeInterpreterCopyWith<$Res>(_value.codeInterpreter!,
        (value) {
      return _then(_value.copyWith(codeInterpreter: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ToolResourcesFileSearchCopyWith<$Res>? get fileSearch {
    if (_value.fileSearch == null) {
      return null;
    }

    return $ToolResourcesFileSearchCopyWith<$Res>(_value.fileSearch!, (value) {
      return _then(_value.copyWith(fileSearch: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ToolResourcesImplCopyWith<$Res>
    implements $ToolResourcesCopyWith<$Res> {
  factory _$$ToolResourcesImplCopyWith(
          _$ToolResourcesImpl value, $Res Function(_$ToolResourcesImpl) then) =
      __$$ToolResourcesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'code_interpreter', includeIfNull: false)
      ToolResourcesCodeInterpreter? codeInterpreter,
      @JsonKey(name: 'file_search', includeIfNull: false)
      ToolResourcesFileSearch? fileSearch});

  @override
  $ToolResourcesCodeInterpreterCopyWith<$Res>? get codeInterpreter;
  @override
  $ToolResourcesFileSearchCopyWith<$Res>? get fileSearch;
}

/// @nodoc
class __$$ToolResourcesImplCopyWithImpl<$Res>
    extends _$ToolResourcesCopyWithImpl<$Res, _$ToolResourcesImpl>
    implements _$$ToolResourcesImplCopyWith<$Res> {
  __$$ToolResourcesImplCopyWithImpl(
      _$ToolResourcesImpl _value, $Res Function(_$ToolResourcesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? codeInterpreter = freezed,
    Object? fileSearch = freezed,
  }) {
    return _then(_$ToolResourcesImpl(
      codeInterpreter: freezed == codeInterpreter
          ? _value.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as ToolResourcesCodeInterpreter?,
      fileSearch: freezed == fileSearch
          ? _value.fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as ToolResourcesFileSearch?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ToolResourcesImpl extends _ToolResources {
  const _$ToolResourcesImpl(
      {@JsonKey(name: 'code_interpreter', includeIfNull: false)
      this.codeInterpreter,
      @JsonKey(name: 'file_search', includeIfNull: false) this.fileSearch})
      : super._();

  factory _$ToolResourcesImpl.fromJson(Map<String, dynamic> json) =>
      _$$ToolResourcesImplFromJson(json);

  /// No Description
  @override
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  final ToolResourcesCodeInterpreter? codeInterpreter;

  /// No Description
  @override
  @JsonKey(name: 'file_search', includeIfNull: false)
  final ToolResourcesFileSearch? fileSearch;

  @override
  String toString() {
    return 'ToolResources(codeInterpreter: $codeInterpreter, fileSearch: $fileSearch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToolResourcesImpl &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter) &&
            (identical(other.fileSearch, fileSearch) ||
                other.fileSearch == fileSearch));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, codeInterpreter, fileSearch);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ToolResourcesImplCopyWith<_$ToolResourcesImpl> get copyWith =>
      __$$ToolResourcesImplCopyWithImpl<_$ToolResourcesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ToolResourcesImplToJson(
      this,
    );
  }
}

abstract class _ToolResources extends ToolResources {
  const factory _ToolResources(
      {@JsonKey(name: 'code_interpreter', includeIfNull: false)
      final ToolResourcesCodeInterpreter? codeInterpreter,
      @JsonKey(name: 'file_search', includeIfNull: false)
      final ToolResourcesFileSearch? fileSearch}) = _$ToolResourcesImpl;
  const _ToolResources._() : super._();

  factory _ToolResources.fromJson(Map<String, dynamic> json) =
      _$ToolResourcesImpl.fromJson;

  @override

  /// No Description
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  ToolResourcesCodeInterpreter? get codeInterpreter;
  @override

  /// No Description
  @JsonKey(name: 'file_search', includeIfNull: false)
  ToolResourcesFileSearch? get fileSearch;
  @override
  @JsonKey(ignore: true)
  _$$ToolResourcesImplCopyWith<_$ToolResourcesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ToolResourcesCodeInterpreter _$ToolResourcesCodeInterpreterFromJson(
    Map<String, dynamic> json) {
  return _ToolResourcesCodeInterpreter.fromJson(json);
}

/// @nodoc
mixin _$ToolResourcesCodeInterpreter {
  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ToolResourcesCodeInterpreterCopyWith<ToolResourcesCodeInterpreter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ToolResourcesCodeInterpreterCopyWith<$Res> {
  factory $ToolResourcesCodeInterpreterCopyWith(
          ToolResourcesCodeInterpreter value,
          $Res Function(ToolResourcesCodeInterpreter) then) =
      _$ToolResourcesCodeInterpreterCopyWithImpl<$Res,
          ToolResourcesCodeInterpreter>;
  @useResult
  $Res call({@JsonKey(name: 'file_ids') List<String> fileIds});
}

/// @nodoc
class _$ToolResourcesCodeInterpreterCopyWithImpl<$Res,
        $Val extends ToolResourcesCodeInterpreter>
    implements $ToolResourcesCodeInterpreterCopyWith<$Res> {
  _$ToolResourcesCodeInterpreterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = null,
  }) {
    return _then(_value.copyWith(
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ToolResourcesCodeInterpreterImplCopyWith<$Res>
    implements $ToolResourcesCodeInterpreterCopyWith<$Res> {
  factory _$$ToolResourcesCodeInterpreterImplCopyWith(
          _$ToolResourcesCodeInterpreterImpl value,
          $Res Function(_$ToolResourcesCodeInterpreterImpl) then) =
      __$$ToolResourcesCodeInterpreterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_ids') List<String> fileIds});
}

/// @nodoc
class __$$ToolResourcesCodeInterpreterImplCopyWithImpl<$Res>
    extends _$ToolResourcesCodeInterpreterCopyWithImpl<$Res,
        _$ToolResourcesCodeInterpreterImpl>
    implements _$$ToolResourcesCodeInterpreterImplCopyWith<$Res> {
  __$$ToolResourcesCodeInterpreterImplCopyWithImpl(
      _$ToolResourcesCodeInterpreterImpl _value,
      $Res Function(_$ToolResourcesCodeInterpreterImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = null,
  }) {
    return _then(_$ToolResourcesCodeInterpreterImpl(
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ToolResourcesCodeInterpreterImpl extends _ToolResourcesCodeInterpreter {
  const _$ToolResourcesCodeInterpreterImpl(
      {@JsonKey(name: 'file_ids') final List<String> fileIds = const []})
      : _fileIds = fileIds,
        super._();

  factory _$ToolResourcesCodeInterpreterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ToolResourcesCodeInterpreterImplFromJson(json);

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
  final List<String> _fileIds;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  @override
  String toString() {
    return 'ToolResourcesCodeInterpreter(fileIds: $fileIds)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToolResourcesCodeInterpreterImpl &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_fileIds));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ToolResourcesCodeInterpreterImplCopyWith<
          _$ToolResourcesCodeInterpreterImpl>
      get copyWith => __$$ToolResourcesCodeInterpreterImplCopyWithImpl<
          _$ToolResourcesCodeInterpreterImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ToolResourcesCodeInterpreterImplToJson(
      this,
    );
  }
}

abstract class _ToolResourcesCodeInterpreter
    extends ToolResourcesCodeInterpreter {
  const factory _ToolResourcesCodeInterpreter(
          {@JsonKey(name: 'file_ids') final List<String> fileIds}) =
      _$ToolResourcesCodeInterpreterImpl;
  const _ToolResourcesCodeInterpreter._() : super._();

  factory _ToolResourcesCodeInterpreter.fromJson(Map<String, dynamic> json) =
      _$ToolResourcesCodeInterpreterImpl.fromJson;

  @override

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override
  @JsonKey(ignore: true)
  _$$ToolResourcesCodeInterpreterImplCopyWith<
          _$ToolResourcesCodeInterpreterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ToolResourcesFileSearch _$ToolResourcesFileSearchFromJson(
    Map<String, dynamic> json) {
  return _ToolResourcesFileSearch.fromJson(json);
}

/// @nodoc
mixin _$ToolResourcesFileSearch {
  /// The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.
  @JsonKey(name: 'vector_store_ids', includeIfNull: false)
  List<String>? get vectorStoreIds => throw _privateConstructorUsedError;

  /// A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.
  @JsonKey(name: 'vector_stores', includeIfNull: false)
  List<ToolResourcesFileSearchVectorStore>? get vectorStores =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ToolResourcesFileSearchCopyWith<ToolResourcesFileSearch> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ToolResourcesFileSearchCopyWith<$Res> {
  factory $ToolResourcesFileSearchCopyWith(ToolResourcesFileSearch value,
          $Res Function(ToolResourcesFileSearch) then) =
      _$ToolResourcesFileSearchCopyWithImpl<$Res, ToolResourcesFileSearch>;
  @useResult
  $Res call(
      {@JsonKey(name: 'vector_store_ids', includeIfNull: false)
      List<String>? vectorStoreIds,
      @JsonKey(name: 'vector_stores', includeIfNull: false)
      List<ToolResourcesFileSearchVectorStore>? vectorStores});
}

/// @nodoc
class _$ToolResourcesFileSearchCopyWithImpl<$Res,
        $Val extends ToolResourcesFileSearch>
    implements $ToolResourcesFileSearchCopyWith<$Res> {
  _$ToolResourcesFileSearchCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vectorStoreIds = freezed,
    Object? vectorStores = freezed,
  }) {
    return _then(_value.copyWith(
      vectorStoreIds: freezed == vectorStoreIds
          ? _value.vectorStoreIds
          : vectorStoreIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      vectorStores: freezed == vectorStores
          ? _value.vectorStores
          : vectorStores // ignore: cast_nullable_to_non_nullable
              as List<ToolResourcesFileSearchVectorStore>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ToolResourcesFileSearchImplCopyWith<$Res>
    implements $ToolResourcesFileSearchCopyWith<$Res> {
  factory _$$ToolResourcesFileSearchImplCopyWith(
          _$ToolResourcesFileSearchImpl value,
          $Res Function(_$ToolResourcesFileSearchImpl) then) =
      __$$ToolResourcesFileSearchImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'vector_store_ids', includeIfNull: false)
      List<String>? vectorStoreIds,
      @JsonKey(name: 'vector_stores', includeIfNull: false)
      List<ToolResourcesFileSearchVectorStore>? vectorStores});
}

/// @nodoc
class __$$ToolResourcesFileSearchImplCopyWithImpl<$Res>
    extends _$ToolResourcesFileSearchCopyWithImpl<$Res,
        _$ToolResourcesFileSearchImpl>
    implements _$$ToolResourcesFileSearchImplCopyWith<$Res> {
  __$$ToolResourcesFileSearchImplCopyWithImpl(
      _$ToolResourcesFileSearchImpl _value,
      $Res Function(_$ToolResourcesFileSearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vectorStoreIds = freezed,
    Object? vectorStores = freezed,
  }) {
    return _then(_$ToolResourcesFileSearchImpl(
      vectorStoreIds: freezed == vectorStoreIds
          ? _value._vectorStoreIds
          : vectorStoreIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      vectorStores: freezed == vectorStores
          ? _value._vectorStores
          : vectorStores // ignore: cast_nullable_to_non_nullable
              as List<ToolResourcesFileSearchVectorStore>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ToolResourcesFileSearchImpl extends _ToolResourcesFileSearch {
  const _$ToolResourcesFileSearchImpl(
      {@JsonKey(name: 'vector_store_ids', includeIfNull: false)
      final List<String>? vectorStoreIds,
      @JsonKey(name: 'vector_stores', includeIfNull: false)
      final List<ToolResourcesFileSearchVectorStore>? vectorStores})
      : _vectorStoreIds = vectorStoreIds,
        _vectorStores = vectorStores,
        super._();

  factory _$ToolResourcesFileSearchImpl.fromJson(Map<String, dynamic> json) =>
      _$$ToolResourcesFileSearchImplFromJson(json);

  /// The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.
  final List<String>? _vectorStoreIds;

  /// The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.
  @override
  @JsonKey(name: 'vector_store_ids', includeIfNull: false)
  List<String>? get vectorStoreIds {
    final value = _vectorStoreIds;
    if (value == null) return null;
    if (_vectorStoreIds is EqualUnmodifiableListView) return _vectorStoreIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.
  final List<ToolResourcesFileSearchVectorStore>? _vectorStores;

  /// A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.
  @override
  @JsonKey(name: 'vector_stores', includeIfNull: false)
  List<ToolResourcesFileSearchVectorStore>? get vectorStores {
    final value = _vectorStores;
    if (value == null) return null;
    if (_vectorStores is EqualUnmodifiableListView) return _vectorStores;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ToolResourcesFileSearch(vectorStoreIds: $vectorStoreIds, vectorStores: $vectorStores)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToolResourcesFileSearchImpl &&
            const DeepCollectionEquality()
                .equals(other._vectorStoreIds, _vectorStoreIds) &&
            const DeepCollectionEquality()
                .equals(other._vectorStores, _vectorStores));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_vectorStoreIds),
      const DeepCollectionEquality().hash(_vectorStores));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ToolResourcesFileSearchImplCopyWith<_$ToolResourcesFileSearchImpl>
      get copyWith => __$$ToolResourcesFileSearchImplCopyWithImpl<
          _$ToolResourcesFileSearchImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ToolResourcesFileSearchImplToJson(
      this,
    );
  }
}

abstract class _ToolResourcesFileSearch extends ToolResourcesFileSearch {
  const factory _ToolResourcesFileSearch(
          {@JsonKey(name: 'vector_store_ids', includeIfNull: false)
          final List<String>? vectorStoreIds,
          @JsonKey(name: 'vector_stores', includeIfNull: false)
          final List<ToolResourcesFileSearchVectorStore>? vectorStores}) =
      _$ToolResourcesFileSearchImpl;
  const _ToolResourcesFileSearch._() : super._();

  factory _ToolResourcesFileSearch.fromJson(Map<String, dynamic> json) =
      _$ToolResourcesFileSearchImpl.fromJson;

  @override

  /// The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.
  @JsonKey(name: 'vector_store_ids', includeIfNull: false)
  List<String>? get vectorStoreIds;
  @override

  /// A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.
  @JsonKey(name: 'vector_stores', includeIfNull: false)
  List<ToolResourcesFileSearchVectorStore>? get vectorStores;
  @override
  @JsonKey(ignore: true)
  _$$ToolResourcesFileSearchImplCopyWith<_$ToolResourcesFileSearchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ToolResourcesFileSearchVectorStore _$ToolResourcesFileSearchVectorStoreFromJson(
    Map<String, dynamic> json) {
  return _ToolResourcesFileSearchVectorStore.fromJson(json);
}

/// @nodoc
mixin _$ToolResourcesFileSearchVectorStore {
  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds => throw _privateConstructorUsedError;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy =>
      throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ToolResourcesFileSearchVectorStoreCopyWith<
          ToolResourcesFileSearchVectorStore>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ToolResourcesFileSearchVectorStoreCopyWith<$Res> {
  factory $ToolResourcesFileSearchVectorStoreCopyWith(
          ToolResourcesFileSearchVectorStore value,
          $Res Function(ToolResourcesFileSearchVectorStore) then) =
      _$ToolResourcesFileSearchVectorStoreCopyWithImpl<$Res,
          ToolResourcesFileSearchVectorStore>;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$ToolResourcesFileSearchVectorStoreCopyWithImpl<$Res,
        $Val extends ToolResourcesFileSearchVectorStore>
    implements $ToolResourcesFileSearchVectorStoreCopyWith<$Res> {
  _$ToolResourcesFileSearchVectorStoreCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      fileIds: freezed == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_value.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_value.chunkingStrategy!,
        (value) {
      return _then(_value.copyWith(chunkingStrategy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ToolResourcesFileSearchVectorStoreImplCopyWith<$Res>
    implements $ToolResourcesFileSearchVectorStoreCopyWith<$Res> {
  factory _$$ToolResourcesFileSearchVectorStoreImplCopyWith(
          _$ToolResourcesFileSearchVectorStoreImpl value,
          $Res Function(_$ToolResourcesFileSearchVectorStoreImpl) then) =
      __$$ToolResourcesFileSearchVectorStoreImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$$ToolResourcesFileSearchVectorStoreImplCopyWithImpl<$Res>
    extends _$ToolResourcesFileSearchVectorStoreCopyWithImpl<$Res,
        _$ToolResourcesFileSearchVectorStoreImpl>
    implements _$$ToolResourcesFileSearchVectorStoreImplCopyWith<$Res> {
  __$$ToolResourcesFileSearchVectorStoreImplCopyWithImpl(
      _$ToolResourcesFileSearchVectorStoreImpl _value,
      $Res Function(_$ToolResourcesFileSearchVectorStoreImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$ToolResourcesFileSearchVectorStoreImpl(
      fileIds: freezed == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ToolResourcesFileSearchVectorStoreImpl
    extends _ToolResourcesFileSearchVectorStore {
  const _$ToolResourcesFileSearchVectorStoreImpl(
      {@JsonKey(name: 'file_ids', includeIfNull: false)
      final List<String>? fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy,
      @JsonKey(includeIfNull: false) this.metadata})
      : _fileIds = fileIds,
        super._();

  factory _$ToolResourcesFileSearchVectorStoreImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ToolResourcesFileSearchVectorStoreImplFromJson(json);

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.
  final List<String>? _fileIds;

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.
  @override
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds {
    final value = _fileIds;
    if (value == null) return null;
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  /// Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  @override
  String toString() {
    return 'ToolResourcesFileSearchVectorStore(fileIds: $fileIds, chunkingStrategy: $chunkingStrategy, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToolResourcesFileSearchVectorStoreImpl &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_fileIds),
      chunkingStrategy,
      const DeepCollectionEquality().hash(metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ToolResourcesFileSearchVectorStoreImplCopyWith<
          _$ToolResourcesFileSearchVectorStoreImpl>
      get copyWith => __$$ToolResourcesFileSearchVectorStoreImplCopyWithImpl<
          _$ToolResourcesFileSearchVectorStoreImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ToolResourcesFileSearchVectorStoreImplToJson(
      this,
    );
  }
}

abstract class _ToolResourcesFileSearchVectorStore
    extends ToolResourcesFileSearchVectorStore {
  const factory _ToolResourcesFileSearchVectorStore(
          {@JsonKey(name: 'file_ids', includeIfNull: false)
          final List<String>? fileIds,
          @JsonKey(name: 'chunking_strategy', includeIfNull: false)
          final ChunkingStrategyRequestParam? chunkingStrategy,
          @JsonKey(includeIfNull: false) final dynamic metadata}) =
      _$ToolResourcesFileSearchVectorStoreImpl;
  const _ToolResourcesFileSearchVectorStore._() : super._();

  factory _ToolResourcesFileSearchVectorStore.fromJson(
          Map<String, dynamic> json) =
      _$ToolResourcesFileSearchVectorStoreImpl.fromJson;

  @override

  /// A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds;
  @override

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;
  @override

  /// Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ToolResourcesFileSearchVectorStoreImplCopyWith<
          _$ToolResourcesFileSearchVectorStoreImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteThreadResponse _$DeleteThreadResponseFromJson(Map<String, dynamic> json) {
  return _DeleteThreadResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteThreadResponse {
  /// The thread identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the thread was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.deleted`.
  DeleteThreadResponseObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteThreadResponseCopyWith<DeleteThreadResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteThreadResponseCopyWith<$Res> {
  factory $DeleteThreadResponseCopyWith(DeleteThreadResponse value,
          $Res Function(DeleteThreadResponse) then) =
      _$DeleteThreadResponseCopyWithImpl<$Res, DeleteThreadResponse>;
  @useResult
  $Res call({String id, bool deleted, DeleteThreadResponseObject object});
}

/// @nodoc
class _$DeleteThreadResponseCopyWithImpl<$Res,
        $Val extends DeleteThreadResponse>
    implements $DeleteThreadResponseCopyWith<$Res> {
  _$DeleteThreadResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteThreadResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteThreadResponseImplCopyWith<$Res>
    implements $DeleteThreadResponseCopyWith<$Res> {
  factory _$$DeleteThreadResponseImplCopyWith(_$DeleteThreadResponseImpl value,
          $Res Function(_$DeleteThreadResponseImpl) then) =
      __$$DeleteThreadResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteThreadResponseObject object});
}

/// @nodoc
class __$$DeleteThreadResponseImplCopyWithImpl<$Res>
    extends _$DeleteThreadResponseCopyWithImpl<$Res, _$DeleteThreadResponseImpl>
    implements _$$DeleteThreadResponseImplCopyWith<$Res> {
  __$$DeleteThreadResponseImplCopyWithImpl(_$DeleteThreadResponseImpl _value,
      $Res Function(_$DeleteThreadResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteThreadResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteThreadResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteThreadResponseImpl extends _DeleteThreadResponse {
  const _$DeleteThreadResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteThreadResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteThreadResponseImplFromJson(json);

  /// The thread identifier.
  @override
  final String id;

  /// Whether the thread was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `thread.deleted`.
  @override
  final DeleteThreadResponseObject object;

  @override
  String toString() {
    return 'DeleteThreadResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteThreadResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteThreadResponseImplCopyWith<_$DeleteThreadResponseImpl>
      get copyWith =>
          __$$DeleteThreadResponseImplCopyWithImpl<_$DeleteThreadResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteThreadResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteThreadResponse extends DeleteThreadResponse {
  const factory _DeleteThreadResponse(
          {required final String id,
          required final bool deleted,
          required final DeleteThreadResponseObject object}) =
      _$DeleteThreadResponseImpl;
  const _DeleteThreadResponse._() : super._();

  factory _DeleteThreadResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteThreadResponseImpl.fromJson;

  @override

  /// The thread identifier.
  String get id;
  @override

  /// Whether the thread was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `thread.deleted`.
  DeleteThreadResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteThreadResponseImplCopyWith<_$DeleteThreadResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListThreadsResponse _$ListThreadsResponseFromJson(Map<String, dynamic> json) {
  return _ListThreadsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListThreadsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of threads.
  List<ThreadObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first thread in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last thread in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more threads to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListThreadsResponseCopyWith<ListThreadsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListThreadsResponseCopyWith<$Res> {
  factory $ListThreadsResponseCopyWith(
          ListThreadsResponse value, $Res Function(ListThreadsResponse) then) =
      _$ListThreadsResponseCopyWithImpl<$Res, ListThreadsResponse>;
  @useResult
  $Res call(
      {String object,
      List<ThreadObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListThreadsResponseCopyWithImpl<$Res, $Val extends ListThreadsResponse>
    implements $ListThreadsResponseCopyWith<$Res> {
  _$ListThreadsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ThreadObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListThreadsResponseImplCopyWith<$Res>
    implements $ListThreadsResponseCopyWith<$Res> {
  factory _$$ListThreadsResponseImplCopyWith(_$ListThreadsResponseImpl value,
          $Res Function(_$ListThreadsResponseImpl) then) =
      __$$ListThreadsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<ThreadObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListThreadsResponseImplCopyWithImpl<$Res>
    extends _$ListThreadsResponseCopyWithImpl<$Res, _$ListThreadsResponseImpl>
    implements _$$ListThreadsResponseImplCopyWith<$Res> {
  __$$ListThreadsResponseImplCopyWithImpl(_$ListThreadsResponseImpl _value,
      $Res Function(_$ListThreadsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListThreadsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ThreadObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListThreadsResponseImpl extends _ListThreadsResponse {
  const _$ListThreadsResponseImpl(
      {required this.object,
      required final List<ThreadObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListThreadsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListThreadsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of threads.
  final List<ThreadObject> _data;

  /// The list of threads.
  @override
  List<ThreadObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first thread in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last thread in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more threads to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListThreadsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListThreadsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListThreadsResponseImplCopyWith<_$ListThreadsResponseImpl> get copyWith =>
      __$$ListThreadsResponseImplCopyWithImpl<_$ListThreadsResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListThreadsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListThreadsResponse extends ListThreadsResponse {
  const factory _ListThreadsResponse(
          {required final String object,
          required final List<ThreadObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListThreadsResponseImpl;
  const _ListThreadsResponse._() : super._();

  factory _ListThreadsResponse.fromJson(Map<String, dynamic> json) =
      _$ListThreadsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of threads.
  List<ThreadObject> get data;
  @override

  /// The ID of the first thread in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last thread in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more threads to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListThreadsResponseImplCopyWith<_$ListThreadsResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageObject _$MessageObjectFromJson(Map<String, dynamic> json) {
  return _MessageObject.fromJson(json);
}

/// @nodoc
mixin _$MessageObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.message`.
  MessageObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the message was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @JsonKey(name: 'thread_id')
  String get threadId => throw _privateConstructorUsedError;

  /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
  @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  MessageObjectStatus? get status => throw _privateConstructorUsedError;

  /// On an incomplete message, details about why the message is incomplete.
  @JsonKey(name: 'incomplete_details')
  MessageObjectIncompleteDetails? get incompleteDetails =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the message was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the message was marked as incomplete.
  @JsonKey(name: 'incomplete_at')
  int? get incompleteAt => throw _privateConstructorUsedError;

  /// The entity that produced the message. One of `user` or `assistant`.
  MessageRole get role => throw _privateConstructorUsedError;

  /// The content of the message in array of text and/or images.
  List<MessageContent> get content => throw _privateConstructorUsedError;

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @JsonKey(name: 'assistant_id')
  String? get assistantId => throw _privateConstructorUsedError;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
  @JsonKey(name: 'run_id')
  String? get runId => throw _privateConstructorUsedError;

  /// A list of files attached to the message, and the tools they were added to.
  List<MessageAttachment>? get attachments =>
      throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageObjectCopyWith<MessageObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageObjectCopyWith<$Res> {
  factory $MessageObjectCopyWith(
          MessageObject value, $Res Function(MessageObject) then) =
      _$MessageObjectCopyWithImpl<$Res, MessageObject>;
  @useResult
  $Res call(
      {String id,
      MessageObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageObjectStatus? status,
      @JsonKey(name: 'incomplete_details')
      MessageObjectIncompleteDetails? incompleteDetails,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_at') int? incompleteAt,
      MessageRole role,
      List<MessageContent> content,
      @JsonKey(name: 'assistant_id') String? assistantId,
      @JsonKey(name: 'run_id') String? runId,
      List<MessageAttachment>? attachments,
      Map<String, dynamic>? metadata});

  $MessageObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
}

/// @nodoc
class _$MessageObjectCopyWithImpl<$Res, $Val extends MessageObject>
    implements $MessageObjectCopyWith<$Res> {
  _$MessageObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? status = freezed,
    Object? incompleteDetails = freezed,
    Object? completedAt = freezed,
    Object? incompleteAt = freezed,
    Object? role = null,
    Object? content = null,
    Object? assistantId = freezed,
    Object? runId = freezed,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as MessageObjectStatus?,
      incompleteDetails: freezed == incompleteDetails
          ? _value.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetails?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteAt: freezed == incompleteAt
          ? _value.incompleteAt
          : incompleteAt // ignore: cast_nullable_to_non_nullable
              as int?,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
      assistantId: freezed == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String?,
      runId: freezed == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String?,
      attachments: freezed == attachments
          ? _value.attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails {
    if (_value.incompleteDetails == null) {
      return null;
    }

    return $MessageObjectIncompleteDetailsCopyWith<$Res>(
        _value.incompleteDetails!, (value) {
      return _then(_value.copyWith(incompleteDetails: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MessageObjectImplCopyWith<$Res>
    implements $MessageObjectCopyWith<$Res> {
  factory _$$MessageObjectImplCopyWith(
          _$MessageObjectImpl value, $Res Function(_$MessageObjectImpl) then) =
      __$$MessageObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      MessageObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageObjectStatus? status,
      @JsonKey(name: 'incomplete_details')
      MessageObjectIncompleteDetails? incompleteDetails,
      @JsonKey(name: 'completed_at') int? completedAt,
      @JsonKey(name: 'incomplete_at') int? incompleteAt,
      MessageRole role,
      List<MessageContent> content,
      @JsonKey(name: 'assistant_id') String? assistantId,
      @JsonKey(name: 'run_id') String? runId,
      List<MessageAttachment>? attachments,
      Map<String, dynamic>? metadata});

  @override
  $MessageObjectIncompleteDetailsCopyWith<$Res>? get incompleteDetails;
}

/// @nodoc
class __$$MessageObjectImplCopyWithImpl<$Res>
    extends _$MessageObjectCopyWithImpl<$Res, _$MessageObjectImpl>
    implements _$$MessageObjectImplCopyWith<$Res> {
  __$$MessageObjectImplCopyWithImpl(
      _$MessageObjectImpl _value, $Res Function(_$MessageObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? threadId = null,
    Object? status = freezed,
    Object? incompleteDetails = freezed,
    Object? completedAt = freezed,
    Object? incompleteAt = freezed,
    Object? role = null,
    Object? content = null,
    Object? assistantId = freezed,
    Object? runId = freezed,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$MessageObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as MessageObjectStatus?,
      incompleteDetails: freezed == incompleteDetails
          ? _value.incompleteDetails
          : incompleteDetails // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetails?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      incompleteAt: freezed == incompleteAt
          ? _value.incompleteAt
          : incompleteAt // ignore: cast_nullable_to_non_nullable
              as int?,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
      assistantId: freezed == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String?,
      runId: freezed == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String?,
      attachments: freezed == attachments
          ? _value._attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageObjectImpl extends _MessageObject {
  const _$MessageObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required this.status,
      @JsonKey(name: 'incomplete_details') required this.incompleteDetails,
      @JsonKey(name: 'completed_at') required this.completedAt,
      @JsonKey(name: 'incomplete_at') required this.incompleteAt,
      required this.role,
      required final List<MessageContent> content,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(name: 'run_id') required this.runId,
      required final List<MessageAttachment>? attachments,
      required final Map<String, dynamic>? metadata})
      : _content = content,
        _attachments = attachments,
        _metadata = metadata,
        super._();

  factory _$MessageObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.message`.
  @override
  final MessageObjectObject object;

  /// The Unix timestamp (in seconds) for when the message was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
  @override
  @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final MessageObjectStatus? status;

  /// On an incomplete message, details about why the message is incomplete.
  @override
  @JsonKey(name: 'incomplete_details')
  final MessageObjectIncompleteDetails? incompleteDetails;

  /// The Unix timestamp (in seconds) for when the message was completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// The Unix timestamp (in seconds) for when the message was marked as incomplete.
  @override
  @JsonKey(name: 'incomplete_at')
  final int? incompleteAt;

  /// The entity that produced the message. One of `user` or `assistant`.
  @override
  final MessageRole role;

  /// The content of the message in array of text and/or images.
  final List<MessageContent> _content;

  /// The content of the message in array of text and/or images.
  @override
  List<MessageContent> get content {
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_content);
  }

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @override
  @JsonKey(name: 'assistant_id')
  final String? assistantId;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
  @override
  @JsonKey(name: 'run_id')
  final String? runId;

  /// A list of files attached to the message, and the tools they were added to.
  final List<MessageAttachment>? _attachments;

  /// A list of files attached to the message, and the tools they were added to.
  @override
  List<MessageAttachment>? get attachments {
    final value = _attachments;
    if (value == null) return null;
    if (_attachments is EqualUnmodifiableListView) return _attachments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'MessageObject(id: $id, object: $object, createdAt: $createdAt, threadId: $threadId, status: $status, incompleteDetails: $incompleteDetails, completedAt: $completedAt, incompleteAt: $incompleteAt, role: $role, content: $content, assistantId: $assistantId, runId: $runId, attachments: $attachments, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.incompleteDetails, incompleteDetails) ||
                other.incompleteDetails == incompleteDetails) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.incompleteAt, incompleteAt) ||
                other.incompleteAt == incompleteAt) &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            const DeepCollectionEquality()
                .equals(other._attachments, _attachments) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      threadId,
      status,
      incompleteDetails,
      completedAt,
      incompleteAt,
      role,
      const DeepCollectionEquality().hash(_content),
      assistantId,
      runId,
      const DeepCollectionEquality().hash(_attachments),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageObjectImplCopyWith<_$MessageObjectImpl> get copyWith =>
      __$$MessageObjectImplCopyWithImpl<_$MessageObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageObjectImplToJson(
      this,
    );
  }
}

abstract class _MessageObject extends MessageObject {
  const factory _MessageObject(
      {required final String id,
      required final MessageObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'thread_id') required final String threadId,
      @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      required final MessageObjectStatus? status,
      @JsonKey(name: 'incomplete_details')
      required final MessageObjectIncompleteDetails? incompleteDetails,
      @JsonKey(name: 'completed_at') required final int? completedAt,
      @JsonKey(name: 'incomplete_at') required final int? incompleteAt,
      required final MessageRole role,
      required final List<MessageContent> content,
      @JsonKey(name: 'assistant_id') required final String? assistantId,
      @JsonKey(name: 'run_id') required final String? runId,
      required final List<MessageAttachment>? attachments,
      required final Map<String, dynamic>? metadata}) = _$MessageObjectImpl;
  const _MessageObject._() : super._();

  factory _MessageObject.fromJson(Map<String, dynamic> json) =
      _$MessageObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.message`.
  MessageObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the message was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to.
  @JsonKey(name: 'thread_id')
  String get threadId;
  @override

  /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
  @JsonKey(unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  MessageObjectStatus? get status;
  @override

  /// On an incomplete message, details about why the message is incomplete.
  @JsonKey(name: 'incomplete_details')
  MessageObjectIncompleteDetails? get incompleteDetails;
  @override

  /// The Unix timestamp (in seconds) for when the message was completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;
  @override

  /// The Unix timestamp (in seconds) for when the message was marked as incomplete.
  @JsonKey(name: 'incomplete_at')
  int? get incompleteAt;
  @override

  /// The entity that produced the message. One of `user` or `assistant`.
  MessageRole get role;
  @override

  /// The content of the message in array of text and/or images.
  List<MessageContent> get content;
  @override

  /// If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message.
  @JsonKey(name: 'assistant_id')
  String? get assistantId;
  @override

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
  @JsonKey(name: 'run_id')
  String? get runId;
  @override

  /// A list of files attached to the message, and the tools they were added to.
  List<MessageAttachment>? get attachments;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$MessageObjectImplCopyWith<_$MessageObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageObjectIncompleteDetails _$MessageObjectIncompleteDetailsFromJson(
    Map<String, dynamic> json) {
  return _MessageObjectIncompleteDetails.fromJson(json);
}

/// @nodoc
mixin _$MessageObjectIncompleteDetails {
  /// The reason the message is incomplete.
  MessageObjectIncompleteDetailsReason get reason =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageObjectIncompleteDetailsCopyWith<MessageObjectIncompleteDetails>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageObjectIncompleteDetailsCopyWith<$Res> {
  factory $MessageObjectIncompleteDetailsCopyWith(
          MessageObjectIncompleteDetails value,
          $Res Function(MessageObjectIncompleteDetails) then) =
      _$MessageObjectIncompleteDetailsCopyWithImpl<$Res,
          MessageObjectIncompleteDetails>;
  @useResult
  $Res call({MessageObjectIncompleteDetailsReason reason});
}

/// @nodoc
class _$MessageObjectIncompleteDetailsCopyWithImpl<$Res,
        $Val extends MessageObjectIncompleteDetails>
    implements $MessageObjectIncompleteDetailsCopyWith<$Res> {
  _$MessageObjectIncompleteDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = null,
  }) {
    return _then(_value.copyWith(
      reason: null == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetailsReason,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageObjectIncompleteDetailsImplCopyWith<$Res>
    implements $MessageObjectIncompleteDetailsCopyWith<$Res> {
  factory _$$MessageObjectIncompleteDetailsImplCopyWith(
          _$MessageObjectIncompleteDetailsImpl value,
          $Res Function(_$MessageObjectIncompleteDetailsImpl) then) =
      __$$MessageObjectIncompleteDetailsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({MessageObjectIncompleteDetailsReason reason});
}

/// @nodoc
class __$$MessageObjectIncompleteDetailsImplCopyWithImpl<$Res>
    extends _$MessageObjectIncompleteDetailsCopyWithImpl<$Res,
        _$MessageObjectIncompleteDetailsImpl>
    implements _$$MessageObjectIncompleteDetailsImplCopyWith<$Res> {
  __$$MessageObjectIncompleteDetailsImplCopyWithImpl(
      _$MessageObjectIncompleteDetailsImpl _value,
      $Res Function(_$MessageObjectIncompleteDetailsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = null,
  }) {
    return _then(_$MessageObjectIncompleteDetailsImpl(
      reason: null == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as MessageObjectIncompleteDetailsReason,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageObjectIncompleteDetailsImpl
    extends _MessageObjectIncompleteDetails {
  const _$MessageObjectIncompleteDetailsImpl({required this.reason})
      : super._();

  factory _$MessageObjectIncompleteDetailsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageObjectIncompleteDetailsImplFromJson(json);

  /// The reason the message is incomplete.
  @override
  final MessageObjectIncompleteDetailsReason reason;

  @override
  String toString() {
    return 'MessageObjectIncompleteDetails(reason: $reason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageObjectIncompleteDetailsImpl &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageObjectIncompleteDetailsImplCopyWith<
          _$MessageObjectIncompleteDetailsImpl>
      get copyWith => __$$MessageObjectIncompleteDetailsImplCopyWithImpl<
          _$MessageObjectIncompleteDetailsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageObjectIncompleteDetailsImplToJson(
      this,
    );
  }
}

abstract class _MessageObjectIncompleteDetails
    extends MessageObjectIncompleteDetails {
  const factory _MessageObjectIncompleteDetails(
          {required final MessageObjectIncompleteDetailsReason reason}) =
      _$MessageObjectIncompleteDetailsImpl;
  const _MessageObjectIncompleteDetails._() : super._();

  factory _MessageObjectIncompleteDetails.fromJson(Map<String, dynamic> json) =
      _$MessageObjectIncompleteDetailsImpl.fromJson;

  @override

  /// The reason the message is incomplete.
  MessageObjectIncompleteDetailsReason get reason;
  @override
  @JsonKey(ignore: true)
  _$$MessageObjectIncompleteDetailsImplCopyWith<
          _$MessageObjectIncompleteDetailsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageAttachment _$MessageAttachmentFromJson(Map<String, dynamic> json) {
  return _MessageAttachment.fromJson(json);
}

/// @nodoc
mixin _$MessageAttachment {
  /// The ID of the file to attach to the message.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId => throw _privateConstructorUsedError;

  /// The tools to add this file to.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageAttachmentCopyWith<MessageAttachment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageAttachmentCopyWith<$Res> {
  factory $MessageAttachmentCopyWith(
          MessageAttachment value, $Res Function(MessageAttachment) then) =
      _$MessageAttachmentCopyWithImpl<$Res, MessageAttachment>;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools});
}

/// @nodoc
class _$MessageAttachmentCopyWithImpl<$Res, $Val extends MessageAttachment>
    implements $MessageAttachmentCopyWith<$Res> {
  _$MessageAttachmentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
    Object? tools = freezed,
  }) {
    return _then(_value.copyWith(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageAttachmentImplCopyWith<$Res>
    implements $MessageAttachmentCopyWith<$Res> {
  factory _$$MessageAttachmentImplCopyWith(_$MessageAttachmentImpl value,
          $Res Function(_$MessageAttachmentImpl) then) =
      __$$MessageAttachmentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) List<AssistantTools>? tools});
}

/// @nodoc
class __$$MessageAttachmentImplCopyWithImpl<$Res>
    extends _$MessageAttachmentCopyWithImpl<$Res, _$MessageAttachmentImpl>
    implements _$$MessageAttachmentImplCopyWith<$Res> {
  __$$MessageAttachmentImplCopyWithImpl(_$MessageAttachmentImpl _value,
      $Res Function(_$MessageAttachmentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
    Object? tools = freezed,
  }) {
    return _then(_$MessageAttachmentImpl(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      tools: freezed == tools
          ? _value._tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<AssistantTools>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageAttachmentImpl extends _MessageAttachment {
  const _$MessageAttachmentImpl(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId,
      @JsonKey(includeIfNull: false) final List<AssistantTools>? tools})
      : _tools = tools,
        super._();

  factory _$MessageAttachmentImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageAttachmentImplFromJson(json);

  /// The ID of the file to attach to the message.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  /// The tools to add this file to.
  final List<AssistantTools>? _tools;

  /// The tools to add this file to.
  @override
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools {
    final value = _tools;
    if (value == null) return null;
    if (_tools is EqualUnmodifiableListView) return _tools;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MessageAttachment(fileId: $fileId, tools: $tools)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageAttachmentImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            const DeepCollectionEquality().equals(other._tools, _tools));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, fileId, const DeepCollectionEquality().hash(_tools));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageAttachmentImplCopyWith<_$MessageAttachmentImpl> get copyWith =>
      __$$MessageAttachmentImplCopyWithImpl<_$MessageAttachmentImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageAttachmentImplToJson(
      this,
    );
  }
}

abstract class _MessageAttachment extends MessageAttachment {
  const factory _MessageAttachment(
          {@JsonKey(name: 'file_id', includeIfNull: false) final String? fileId,
          @JsonKey(includeIfNull: false) final List<AssistantTools>? tools}) =
      _$MessageAttachmentImpl;
  const _MessageAttachment._() : super._();

  factory _MessageAttachment.fromJson(Map<String, dynamic> json) =
      _$MessageAttachmentImpl.fromJson;

  @override

  /// The ID of the file to attach to the message.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;
  @override

  /// The tools to add this file to.
  @JsonKey(includeIfNull: false)
  List<AssistantTools>? get tools;
  @override
  @JsonKey(ignore: true)
  _$$MessageAttachmentImplCopyWith<_$MessageAttachmentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageDeltaObject _$MessageDeltaObjectFromJson(Map<String, dynamic> json) {
  return _MessageDeltaObject.fromJson(json);
}

/// @nodoc
mixin _$MessageDeltaObject {
  /// The identifier of the message, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.message.delta`.
  MessageDeltaObjectObject get object => throw _privateConstructorUsedError;

  /// The delta containing the fields that have changed on the Message.
  MessageDelta get delta => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaObjectCopyWith<MessageDeltaObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaObjectCopyWith<$Res> {
  factory $MessageDeltaObjectCopyWith(
          MessageDeltaObject value, $Res Function(MessageDeltaObject) then) =
      _$MessageDeltaObjectCopyWithImpl<$Res, MessageDeltaObject>;
  @useResult
  $Res call({String id, MessageDeltaObjectObject object, MessageDelta delta});

  $MessageDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class _$MessageDeltaObjectCopyWithImpl<$Res, $Val extends MessageDeltaObject>
    implements $MessageDeltaObjectCopyWith<$Res> {
  _$MessageDeltaObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageDeltaObjectObject,
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as MessageDelta,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaCopyWith<$Res> get delta {
    return $MessageDeltaCopyWith<$Res>(_value.delta, (value) {
      return _then(_value.copyWith(delta: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MessageDeltaObjectImplCopyWith<$Res>
    implements $MessageDeltaObjectCopyWith<$Res> {
  factory _$$MessageDeltaObjectImplCopyWith(_$MessageDeltaObjectImpl value,
          $Res Function(_$MessageDeltaObjectImpl) then) =
      __$$MessageDeltaObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, MessageDeltaObjectObject object, MessageDelta delta});

  @override
  $MessageDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class __$$MessageDeltaObjectImplCopyWithImpl<$Res>
    extends _$MessageDeltaObjectCopyWithImpl<$Res, _$MessageDeltaObjectImpl>
    implements _$$MessageDeltaObjectImplCopyWith<$Res> {
  __$$MessageDeltaObjectImplCopyWithImpl(_$MessageDeltaObjectImpl _value,
      $Res Function(_$MessageDeltaObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_$MessageDeltaObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as MessageDeltaObjectObject,
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as MessageDelta,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaObjectImpl extends _MessageDeltaObject {
  const _$MessageDeltaObjectImpl(
      {required this.id, required this.object, required this.delta})
      : super._();

  factory _$MessageDeltaObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageDeltaObjectImplFromJson(json);

  /// The identifier of the message, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.message.delta`.
  @override
  final MessageDeltaObjectObject object;

  /// The delta containing the fields that have changed on the Message.
  @override
  final MessageDelta delta;

  @override
  String toString() {
    return 'MessageDeltaObject(id: $id, object: $object, delta: $delta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, delta);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaObjectImplCopyWith<_$MessageDeltaObjectImpl> get copyWith =>
      __$$MessageDeltaObjectImplCopyWithImpl<_$MessageDeltaObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaObjectImplToJson(
      this,
    );
  }
}

abstract class _MessageDeltaObject extends MessageDeltaObject {
  const factory _MessageDeltaObject(
      {required final String id,
      required final MessageDeltaObjectObject object,
      required final MessageDelta delta}) = _$MessageDeltaObjectImpl;
  const _MessageDeltaObject._() : super._();

  factory _MessageDeltaObject.fromJson(Map<String, dynamic> json) =
      _$MessageDeltaObjectImpl.fromJson;

  @override

  /// The identifier of the message, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.message.delta`.
  MessageDeltaObjectObject get object;
  @override

  /// The delta containing the fields that have changed on the Message.
  MessageDelta get delta;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaObjectImplCopyWith<_$MessageDeltaObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageDelta _$MessageDeltaFromJson(Map<String, dynamic> json) {
  return _MessageDelta.fromJson(json);
}

/// @nodoc
mixin _$MessageDelta {
  /// The entity that produced the message. One of `user` or `assistant`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  MessageRole? get role => throw _privateConstructorUsedError;

  /// The content of the message in array of text and/or images.
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContent>? get content => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaCopyWith<MessageDelta> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaCopyWith<$Res> {
  factory $MessageDeltaCopyWith(
          MessageDelta value, $Res Function(MessageDelta) then) =
      _$MessageDeltaCopyWithImpl<$Res, MessageDelta>;
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageRole? role,
      @JsonKey(includeIfNull: false) List<MessageDeltaContent>? content});
}

/// @nodoc
class _$MessageDeltaCopyWithImpl<$Res, $Val extends MessageDelta>
    implements $MessageDeltaCopyWith<$Res> {
  _$MessageDeltaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = freezed,
    Object? content = freezed,
  }) {
    return _then(_value.copyWith(
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole?,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContent>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageDeltaImplCopyWith<$Res>
    implements $MessageDeltaCopyWith<$Res> {
  factory _$$MessageDeltaImplCopyWith(
          _$MessageDeltaImpl value, $Res Function(_$MessageDeltaImpl) then) =
      __$$MessageDeltaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      MessageRole? role,
      @JsonKey(includeIfNull: false) List<MessageDeltaContent>? content});
}

/// @nodoc
class __$$MessageDeltaImplCopyWithImpl<$Res>
    extends _$MessageDeltaCopyWithImpl<$Res, _$MessageDeltaImpl>
    implements _$$MessageDeltaImplCopyWith<$Res> {
  __$$MessageDeltaImplCopyWithImpl(
      _$MessageDeltaImpl _value, $Res Function(_$MessageDeltaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = freezed,
    Object? content = freezed,
  }) {
    return _then(_$MessageDeltaImpl(
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole?,
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContent>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaImpl extends _MessageDelta {
  const _$MessageDeltaImpl(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      this.role,
      @JsonKey(includeIfNull: false) final List<MessageDeltaContent>? content})
      : _content = content,
        super._();

  factory _$MessageDeltaImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageDeltaImplFromJson(json);

  /// The entity that produced the message. One of `user` or `assistant`.
  @override
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  final MessageRole? role;

  /// The content of the message in array of text and/or images.
  final List<MessageDeltaContent>? _content;

  /// The content of the message in array of text and/or images.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContent>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MessageDelta(role: $role, content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaImpl &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other._content, _content));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, role, const DeepCollectionEquality().hash(_content));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaImplCopyWith<_$MessageDeltaImpl> get copyWith =>
      __$$MessageDeltaImplCopyWithImpl<_$MessageDeltaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaImplToJson(
      this,
    );
  }
}

abstract class _MessageDelta extends MessageDelta {
  const factory _MessageDelta(
      {@JsonKey(
          includeIfNull: false,
          unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
      final MessageRole? role,
      @JsonKey(includeIfNull: false)
      final List<MessageDeltaContent>? content}) = _$MessageDeltaImpl;
  const _MessageDelta._() : super._();

  factory _MessageDelta.fromJson(Map<String, dynamic> json) =
      _$MessageDeltaImpl.fromJson;

  @override

  /// The entity that produced the message. One of `user` or `assistant`.
  @JsonKey(
      includeIfNull: false, unknownEnumValue: JsonKey.nullForUndefinedEnumValue)
  MessageRole? get role;
  @override

  /// The content of the message in array of text and/or images.
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContent>? get content;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaImplCopyWith<_$MessageDeltaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateMessageRequest _$CreateMessageRequestFromJson(Map<String, dynamic> json) {
  return _CreateMessageRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateMessageRequest {
  /// The entity that produced the message. One of `user` or `assistant`.
  MessageRole get role => throw _privateConstructorUsedError;

  /// The content of the message.
  @_CreateMessageRequestContentConverter()
  CreateMessageRequestContent get content => throw _privateConstructorUsedError;

  /// A list of files attached to the message, and the tools they were added to.
  @JsonKey(includeIfNull: false)
  List<MessageAttachment>? get attachments =>
      throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateMessageRequestCopyWith<CreateMessageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateMessageRequestCopyWith<$Res> {
  factory $CreateMessageRequestCopyWith(CreateMessageRequest value,
          $Res Function(CreateMessageRequest) then) =
      _$CreateMessageRequestCopyWithImpl<$Res, CreateMessageRequest>;
  @useResult
  $Res call(
      {MessageRole role,
      @_CreateMessageRequestContentConverter()
      CreateMessageRequestContent content,
      @JsonKey(includeIfNull: false) List<MessageAttachment>? attachments,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  $CreateMessageRequestContentCopyWith<$Res> get content;
}

/// @nodoc
class _$CreateMessageRequestCopyWithImpl<$Res,
        $Val extends CreateMessageRequest>
    implements $CreateMessageRequestCopyWith<$Res> {
  _$CreateMessageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as CreateMessageRequestContent,
      attachments: freezed == attachments
          ? _value.attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateMessageRequestContentCopyWith<$Res> get content {
    return $CreateMessageRequestContentCopyWith<$Res>(_value.content, (value) {
      return _then(_value.copyWith(content: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateMessageRequestImplCopyWith<$Res>
    implements $CreateMessageRequestCopyWith<$Res> {
  factory _$$CreateMessageRequestImplCopyWith(_$CreateMessageRequestImpl value,
          $Res Function(_$CreateMessageRequestImpl) then) =
      __$$CreateMessageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {MessageRole role,
      @_CreateMessageRequestContentConverter()
      CreateMessageRequestContent content,
      @JsonKey(includeIfNull: false) List<MessageAttachment>? attachments,
      @JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});

  @override
  $CreateMessageRequestContentCopyWith<$Res> get content;
}

/// @nodoc
class __$$CreateMessageRequestImplCopyWithImpl<$Res>
    extends _$CreateMessageRequestCopyWithImpl<$Res, _$CreateMessageRequestImpl>
    implements _$$CreateMessageRequestImplCopyWith<$Res> {
  __$$CreateMessageRequestImplCopyWithImpl(_$CreateMessageRequestImpl _value,
      $Res Function(_$CreateMessageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? attachments = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateMessageRequestImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as MessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as CreateMessageRequestContent,
      attachments: freezed == attachments
          ? _value._attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<MessageAttachment>?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateMessageRequestImpl extends _CreateMessageRequest {
  const _$CreateMessageRequestImpl(
      {required this.role,
      @_CreateMessageRequestContentConverter() required this.content,
      @JsonKey(includeIfNull: false) final List<MessageAttachment>? attachments,
      @JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _attachments = attachments,
        _metadata = metadata,
        super._();

  factory _$CreateMessageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateMessageRequestImplFromJson(json);

  /// The entity that produced the message. One of `user` or `assistant`.
  @override
  final MessageRole role;

  /// The content of the message.
  @override
  @_CreateMessageRequestContentConverter()
  final CreateMessageRequestContent content;

  /// A list of files attached to the message, and the tools they were added to.
  final List<MessageAttachment>? _attachments;

  /// A list of files attached to the message, and the tools they were added to.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageAttachment>? get attachments {
    final value = _attachments;
    if (value == null) return null;
    if (_attachments is EqualUnmodifiableListView) return _attachments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateMessageRequest(role: $role, content: $content, attachments: $attachments, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateMessageRequestImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            const DeepCollectionEquality()
                .equals(other._attachments, _attachments) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      role,
      content,
      const DeepCollectionEquality().hash(_attachments),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateMessageRequestImplCopyWith<_$CreateMessageRequestImpl>
      get copyWith =>
          __$$CreateMessageRequestImplCopyWithImpl<_$CreateMessageRequestImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateMessageRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateMessageRequest extends CreateMessageRequest {
  const factory _CreateMessageRequest(
      {required final MessageRole role,
      @_CreateMessageRequestContentConverter()
      required final CreateMessageRequestContent content,
      @JsonKey(includeIfNull: false) final List<MessageAttachment>? attachments,
      @JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$CreateMessageRequestImpl;
  const _CreateMessageRequest._() : super._();

  factory _CreateMessageRequest.fromJson(Map<String, dynamic> json) =
      _$CreateMessageRequestImpl.fromJson;

  @override

  /// The entity that produced the message. One of `user` or `assistant`.
  MessageRole get role;
  @override

  /// The content of the message.
  @_CreateMessageRequestContentConverter()
  CreateMessageRequestContent get content;
  @override

  /// A list of files attached to the message, and the tools they were added to.
  @JsonKey(includeIfNull: false)
  List<MessageAttachment>? get attachments;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateMessageRequestImplCopyWith<_$CreateMessageRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateMessageRequestContent _$CreateMessageRequestContentFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'parts':
      return CreateMessageRequestContentListMessageContent.fromJson(json);
    case 'text':
      return CreateMessageRequestContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'CreateMessageRequestContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateMessageRequestContent {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<MessageContent> value) parts,
    required TResult Function(String value) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<MessageContent> value)? parts,
    TResult? Function(String value)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<MessageContent> value)? parts,
    TResult Function(String value)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateMessageRequestContentListMessageContent value)
        parts,
    required TResult Function(CreateMessageRequestContentString value) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult? Function(CreateMessageRequestContentString value)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult Function(CreateMessageRequestContentString value)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateMessageRequestContentCopyWith<$Res> {
  factory $CreateMessageRequestContentCopyWith(
          CreateMessageRequestContent value,
          $Res Function(CreateMessageRequestContent) then) =
      _$CreateMessageRequestContentCopyWithImpl<$Res,
          CreateMessageRequestContent>;
}

/// @nodoc
class _$CreateMessageRequestContentCopyWithImpl<$Res,
        $Val extends CreateMessageRequestContent>
    implements $CreateMessageRequestContentCopyWith<$Res> {
  _$CreateMessageRequestContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateMessageRequestContentListMessageContentImplCopyWith<
    $Res> {
  factory _$$CreateMessageRequestContentListMessageContentImplCopyWith(
          _$CreateMessageRequestContentListMessageContentImpl value,
          $Res Function(_$CreateMessageRequestContentListMessageContentImpl)
              then) =
      __$$CreateMessageRequestContentListMessageContentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<MessageContent> value});
}

/// @nodoc
class __$$CreateMessageRequestContentListMessageContentImplCopyWithImpl<$Res>
    extends _$CreateMessageRequestContentCopyWithImpl<$Res,
        _$CreateMessageRequestContentListMessageContentImpl>
    implements
        _$$CreateMessageRequestContentListMessageContentImplCopyWith<$Res> {
  __$$CreateMessageRequestContentListMessageContentImplCopyWithImpl(
      _$CreateMessageRequestContentListMessageContentImpl _value,
      $Res Function(_$CreateMessageRequestContentListMessageContentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateMessageRequestContentListMessageContentImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<MessageContent>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateMessageRequestContentListMessageContentImpl
    extends CreateMessageRequestContentListMessageContent {
  const _$CreateMessageRequestContentListMessageContentImpl(
      final List<MessageContent> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'parts',
        super._();

  factory _$CreateMessageRequestContentListMessageContentImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateMessageRequestContentListMessageContentImplFromJson(json);

  final List<MessageContent> _value;
  @override
  List<MessageContent> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateMessageRequestContent.parts(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateMessageRequestContentListMessageContentImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateMessageRequestContentListMessageContentImplCopyWith<
          _$CreateMessageRequestContentListMessageContentImpl>
      get copyWith =>
          __$$CreateMessageRequestContentListMessageContentImplCopyWithImpl<
                  _$CreateMessageRequestContentListMessageContentImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<MessageContent> value) parts,
    required TResult Function(String value) text,
  }) {
    return parts(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<MessageContent> value)? parts,
    TResult? Function(String value)? text,
  }) {
    return parts?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<MessageContent> value)? parts,
    TResult Function(String value)? text,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateMessageRequestContentListMessageContent value)
        parts,
    required TResult Function(CreateMessageRequestContentString value) text,
  }) {
    return parts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult? Function(CreateMessageRequestContentString value)? text,
  }) {
    return parts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult Function(CreateMessageRequestContentString value)? text,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateMessageRequestContentListMessageContentImplToJson(
      this,
    );
  }
}

abstract class CreateMessageRequestContentListMessageContent
    extends CreateMessageRequestContent {
  const factory CreateMessageRequestContentListMessageContent(
          final List<MessageContent> value) =
      _$CreateMessageRequestContentListMessageContentImpl;
  const CreateMessageRequestContentListMessageContent._() : super._();

  factory CreateMessageRequestContentListMessageContent.fromJson(
          Map<String, dynamic> json) =
      _$CreateMessageRequestContentListMessageContentImpl.fromJson;

  @override
  List<MessageContent> get value;
  @JsonKey(ignore: true)
  _$$CreateMessageRequestContentListMessageContentImplCopyWith<
          _$CreateMessageRequestContentListMessageContentImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateMessageRequestContentStringImplCopyWith<$Res> {
  factory _$$CreateMessageRequestContentStringImplCopyWith(
          _$CreateMessageRequestContentStringImpl value,
          $Res Function(_$CreateMessageRequestContentStringImpl) then) =
      __$$CreateMessageRequestContentStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CreateMessageRequestContentStringImplCopyWithImpl<$Res>
    extends _$CreateMessageRequestContentCopyWithImpl<$Res,
        _$CreateMessageRequestContentStringImpl>
    implements _$$CreateMessageRequestContentStringImplCopyWith<$Res> {
  __$$CreateMessageRequestContentStringImplCopyWithImpl(
      _$CreateMessageRequestContentStringImpl _value,
      $Res Function(_$CreateMessageRequestContentStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CreateMessageRequestContentStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateMessageRequestContentStringImpl
    extends CreateMessageRequestContentString {
  const _$CreateMessageRequestContentStringImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'text',
        super._();

  factory _$CreateMessageRequestContentStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateMessageRequestContentStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateMessageRequestContent.text(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateMessageRequestContentStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateMessageRequestContentStringImplCopyWith<
          _$CreateMessageRequestContentStringImpl>
      get copyWith => __$$CreateMessageRequestContentStringImplCopyWithImpl<
          _$CreateMessageRequestContentStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<MessageContent> value) parts,
    required TResult Function(String value) text,
  }) {
    return text(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<MessageContent> value)? parts,
    TResult? Function(String value)? text,
  }) {
    return text?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<MessageContent> value)? parts,
    TResult Function(String value)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            CreateMessageRequestContentListMessageContent value)
        parts,
    required TResult Function(CreateMessageRequestContentString value) text,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult? Function(CreateMessageRequestContentString value)? text,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CreateMessageRequestContentListMessageContent value)?
        parts,
    TResult Function(CreateMessageRequestContentString value)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateMessageRequestContentStringImplToJson(
      this,
    );
  }
}

abstract class CreateMessageRequestContentString
    extends CreateMessageRequestContent {
  const factory CreateMessageRequestContentString(final String value) =
      _$CreateMessageRequestContentStringImpl;
  const CreateMessageRequestContentString._() : super._();

  factory CreateMessageRequestContentString.fromJson(
          Map<String, dynamic> json) =
      _$CreateMessageRequestContentStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CreateMessageRequestContentStringImplCopyWith<
          _$CreateMessageRequestContentStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ModifyMessageRequest _$ModifyMessageRequestFromJson(Map<String, dynamic> json) {
  return _ModifyMessageRequest.fromJson(json);
}

/// @nodoc
mixin _$ModifyMessageRequest {
  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModifyMessageRequestCopyWith<ModifyMessageRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModifyMessageRequestCopyWith<$Res> {
  factory $ModifyMessageRequestCopyWith(ModifyMessageRequest value,
          $Res Function(ModifyMessageRequest) then) =
      _$ModifyMessageRequestCopyWithImpl<$Res, ModifyMessageRequest>;
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class _$ModifyMessageRequestCopyWithImpl<$Res,
        $Val extends ModifyMessageRequest>
    implements $ModifyMessageRequestCopyWith<$Res> {
  _$ModifyMessageRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ModifyMessageRequestImplCopyWith<$Res>
    implements $ModifyMessageRequestCopyWith<$Res> {
  factory _$$ModifyMessageRequestImplCopyWith(_$ModifyMessageRequestImpl value,
          $Res Function(_$ModifyMessageRequestImpl) then) =
      __$$ModifyMessageRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(includeIfNull: false) Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$ModifyMessageRequestImplCopyWithImpl<$Res>
    extends _$ModifyMessageRequestCopyWithImpl<$Res, _$ModifyMessageRequestImpl>
    implements _$$ModifyMessageRequestImplCopyWith<$Res> {
  __$$ModifyMessageRequestImplCopyWithImpl(_$ModifyMessageRequestImpl _value,
      $Res Function(_$ModifyMessageRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
  }) {
    return _then(_$ModifyMessageRequestImpl(
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ModifyMessageRequestImpl extends _ModifyMessageRequest {
  const _$ModifyMessageRequestImpl(
      {@JsonKey(includeIfNull: false) final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  factory _$ModifyMessageRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModifyMessageRequestImplFromJson(json);

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'ModifyMessageRequest(metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyMessageRequestImpl &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ModifyMessageRequestImplCopyWith<_$ModifyMessageRequestImpl>
      get copyWith =>
          __$$ModifyMessageRequestImplCopyWithImpl<_$ModifyMessageRequestImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModifyMessageRequestImplToJson(
      this,
    );
  }
}

abstract class _ModifyMessageRequest extends ModifyMessageRequest {
  const factory _ModifyMessageRequest(
      {@JsonKey(includeIfNull: false)
      final Map<String, dynamic>? metadata}) = _$ModifyMessageRequestImpl;
  const _ModifyMessageRequest._() : super._();

  factory _ModifyMessageRequest.fromJson(Map<String, dynamic> json) =
      _$ModifyMessageRequestImpl.fromJson;

  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$ModifyMessageRequestImplCopyWith<_$ModifyMessageRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteMessageResponse _$DeleteMessageResponseFromJson(
    Map<String, dynamic> json) {
  return _DeleteMessageResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteMessageResponse {
  /// The message identifier.
  String get id => throw _privateConstructorUsedError;

  /// Whether the message was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.message.deleted`.
  DeleteMessageResponseObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteMessageResponseCopyWith<DeleteMessageResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteMessageResponseCopyWith<$Res> {
  factory $DeleteMessageResponseCopyWith(DeleteMessageResponse value,
          $Res Function(DeleteMessageResponse) then) =
      _$DeleteMessageResponseCopyWithImpl<$Res, DeleteMessageResponse>;
  @useResult
  $Res call({String id, bool deleted, DeleteMessageResponseObject object});
}

/// @nodoc
class _$DeleteMessageResponseCopyWithImpl<$Res,
        $Val extends DeleteMessageResponse>
    implements $DeleteMessageResponseCopyWith<$Res> {
  _$DeleteMessageResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteMessageResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteMessageResponseImplCopyWith<$Res>
    implements $DeleteMessageResponseCopyWith<$Res> {
  factory _$$DeleteMessageResponseImplCopyWith(
          _$DeleteMessageResponseImpl value,
          $Res Function(_$DeleteMessageResponseImpl) then) =
      __$$DeleteMessageResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, DeleteMessageResponseObject object});
}

/// @nodoc
class __$$DeleteMessageResponseImplCopyWithImpl<$Res>
    extends _$DeleteMessageResponseCopyWithImpl<$Res,
        _$DeleteMessageResponseImpl>
    implements _$$DeleteMessageResponseImplCopyWith<$Res> {
  __$$DeleteMessageResponseImplCopyWithImpl(_$DeleteMessageResponseImpl _value,
      $Res Function(_$DeleteMessageResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteMessageResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as DeleteMessageResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteMessageResponseImpl extends _DeleteMessageResponse {
  const _$DeleteMessageResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteMessageResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteMessageResponseImplFromJson(json);

  /// The message identifier.
  @override
  final String id;

  /// Whether the message was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `thread.message.deleted`.
  @override
  final DeleteMessageResponseObject object;

  @override
  String toString() {
    return 'DeleteMessageResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteMessageResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteMessageResponseImplCopyWith<_$DeleteMessageResponseImpl>
      get copyWith => __$$DeleteMessageResponseImplCopyWithImpl<
          _$DeleteMessageResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteMessageResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteMessageResponse extends DeleteMessageResponse {
  const factory _DeleteMessageResponse(
          {required final String id,
          required final bool deleted,
          required final DeleteMessageResponseObject object}) =
      _$DeleteMessageResponseImpl;
  const _DeleteMessageResponse._() : super._();

  factory _DeleteMessageResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteMessageResponseImpl.fromJson;

  @override

  /// The message identifier.
  String get id;
  @override

  /// Whether the message was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `thread.message.deleted`.
  DeleteMessageResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteMessageResponseImplCopyWith<_$DeleteMessageResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListMessagesResponse _$ListMessagesResponseFromJson(Map<String, dynamic> json) {
  return _ListMessagesResponse.fromJson(json);
}

/// @nodoc
mixin _$ListMessagesResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of messages.
  List<MessageObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first message in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last message in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more messages to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListMessagesResponseCopyWith<ListMessagesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListMessagesResponseCopyWith<$Res> {
  factory $ListMessagesResponseCopyWith(ListMessagesResponse value,
          $Res Function(ListMessagesResponse) then) =
      _$ListMessagesResponseCopyWithImpl<$Res, ListMessagesResponse>;
  @useResult
  $Res call(
      {String object,
      List<MessageObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListMessagesResponseCopyWithImpl<$Res,
        $Val extends ListMessagesResponse>
    implements $ListMessagesResponseCopyWith<$Res> {
  _$ListMessagesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListMessagesResponseImplCopyWith<$Res>
    implements $ListMessagesResponseCopyWith<$Res> {
  factory _$$ListMessagesResponseImplCopyWith(_$ListMessagesResponseImpl value,
          $Res Function(_$ListMessagesResponseImpl) then) =
      __$$ListMessagesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<MessageObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListMessagesResponseImplCopyWithImpl<$Res>
    extends _$ListMessagesResponseCopyWithImpl<$Res, _$ListMessagesResponseImpl>
    implements _$$ListMessagesResponseImplCopyWith<$Res> {
  __$$ListMessagesResponseImplCopyWithImpl(_$ListMessagesResponseImpl _value,
      $Res Function(_$ListMessagesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListMessagesResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<MessageObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListMessagesResponseImpl extends _ListMessagesResponse {
  const _$ListMessagesResponseImpl(
      {required this.object,
      required final List<MessageObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListMessagesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListMessagesResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of messages.
  final List<MessageObject> _data;

  /// The list of messages.
  @override
  List<MessageObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first message in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last message in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more messages to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListMessagesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListMessagesResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListMessagesResponseImplCopyWith<_$ListMessagesResponseImpl>
      get copyWith =>
          __$$ListMessagesResponseImplCopyWithImpl<_$ListMessagesResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListMessagesResponseImplToJson(
      this,
    );
  }
}

abstract class _ListMessagesResponse extends ListMessagesResponse {
  const factory _ListMessagesResponse(
          {required final String object,
          required final List<MessageObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListMessagesResponseImpl;
  const _ListMessagesResponse._() : super._();

  factory _ListMessagesResponse.fromJson(Map<String, dynamic> json) =
      _$ListMessagesResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of messages.
  List<MessageObject> get data;
  @override

  /// The ID of the first message in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last message in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more messages to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListMessagesResponseImplCopyWith<_$ListMessagesResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentImageFile _$MessageContentImageFileFromJson(
    Map<String, dynamic> json) {
  return _MessageContentImageFile.fromJson(json);
}

/// @nodoc
mixin _$MessageContentImageFile {
  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose="vision"` when uploading the File if you need to later display the file content.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  MessageContentImageDetail get detail => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentImageFileCopyWith<MessageContentImageFile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentImageFileCopyWith<$Res> {
  factory $MessageContentImageFileCopyWith(MessageContentImageFile value,
          $Res Function(MessageContentImageFile) then) =
      _$MessageContentImageFileCopyWithImpl<$Res, MessageContentImageFile>;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      MessageContentImageDetail detail});
}

/// @nodoc
class _$MessageContentImageFileCopyWithImpl<$Res,
        $Val extends MessageContentImageFile>
    implements $MessageContentImageFileCopyWith<$Res> {
  _$MessageContentImageFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? detail = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentImageFileImplCopyWith<$Res>
    implements $MessageContentImageFileCopyWith<$Res> {
  factory _$$MessageContentImageFileImplCopyWith(
          _$MessageContentImageFileImpl value,
          $Res Function(_$MessageContentImageFileImpl) then) =
      __$$MessageContentImageFileImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      MessageContentImageDetail detail});
}

/// @nodoc
class __$$MessageContentImageFileImplCopyWithImpl<$Res>
    extends _$MessageContentImageFileCopyWithImpl<$Res,
        _$MessageContentImageFileImpl>
    implements _$$MessageContentImageFileImplCopyWith<$Res> {
  __$$MessageContentImageFileImplCopyWithImpl(
      _$MessageContentImageFileImpl _value,
      $Res Function(_$MessageContentImageFileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? detail = null,
  }) {
    return _then(_$MessageContentImageFileImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentImageFileImpl extends _MessageContentImageFile {
  const _$MessageContentImageFileImpl(
      {@JsonKey(name: 'file_id') required this.fileId,
      this.detail = MessageContentImageDetail.auto})
      : super._();

  factory _$MessageContentImageFileImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageContentImageFileImplFromJson(json);

  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose="vision"` when uploading the File if you need to later display the file content.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  @override
  @JsonKey()
  final MessageContentImageDetail detail;

  @override
  String toString() {
    return 'MessageContentImageFile(fileId: $fileId, detail: $detail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentImageFileImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, detail);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentImageFileImplCopyWith<_$MessageContentImageFileImpl>
      get copyWith => __$$MessageContentImageFileImplCopyWithImpl<
          _$MessageContentImageFileImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentImageFileImplToJson(
      this,
    );
  }
}

abstract class _MessageContentImageFile extends MessageContentImageFile {
  const factory _MessageContentImageFile(
      {@JsonKey(name: 'file_id') required final String fileId,
      final MessageContentImageDetail detail}) = _$MessageContentImageFileImpl;
  const _MessageContentImageFile._() : super._();

  factory _MessageContentImageFile.fromJson(Map<String, dynamic> json) =
      _$MessageContentImageFileImpl.fromJson;

  @override

  /// The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose="vision"` when uploading the File if you need to later display the file content.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  MessageContentImageDetail get detail;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentImageFileImplCopyWith<_$MessageContentImageFileImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentImageUrl _$MessageContentImageUrlFromJson(
    Map<String, dynamic> json) {
  return _MessageContentImageUrl.fromJson(json);
}

/// @nodoc
mixin _$MessageContentImageUrl {
  /// The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
  String get url => throw _privateConstructorUsedError;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  MessageContentImageDetail get detail => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentImageUrlCopyWith<MessageContentImageUrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentImageUrlCopyWith<$Res> {
  factory $MessageContentImageUrlCopyWith(MessageContentImageUrl value,
          $Res Function(MessageContentImageUrl) then) =
      _$MessageContentImageUrlCopyWithImpl<$Res, MessageContentImageUrl>;
  @useResult
  $Res call({String url, MessageContentImageDetail detail});
}

/// @nodoc
class _$MessageContentImageUrlCopyWithImpl<$Res,
        $Val extends MessageContentImageUrl>
    implements $MessageContentImageUrlCopyWith<$Res> {
  _$MessageContentImageUrlCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_value.copyWith(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentImageUrlImplCopyWith<$Res>
    implements $MessageContentImageUrlCopyWith<$Res> {
  factory _$$MessageContentImageUrlImplCopyWith(
          _$MessageContentImageUrlImpl value,
          $Res Function(_$MessageContentImageUrlImpl) then) =
      __$$MessageContentImageUrlImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url, MessageContentImageDetail detail});
}

/// @nodoc
class __$$MessageContentImageUrlImplCopyWithImpl<$Res>
    extends _$MessageContentImageUrlCopyWithImpl<$Res,
        _$MessageContentImageUrlImpl>
    implements _$$MessageContentImageUrlImplCopyWith<$Res> {
  __$$MessageContentImageUrlImplCopyWithImpl(
      _$MessageContentImageUrlImpl _value,
      $Res Function(_$MessageContentImageUrlImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_$MessageContentImageUrlImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as MessageContentImageDetail,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentImageUrlImpl extends _MessageContentImageUrl {
  const _$MessageContentImageUrlImpl(
      {required this.url, this.detail = MessageContentImageDetail.auto})
      : super._();

  factory _$MessageContentImageUrlImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageContentImageUrlImplFromJson(json);

  /// The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
  @override
  final String url;

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  @override
  @JsonKey()
  final MessageContentImageDetail detail;

  @override
  String toString() {
    return 'MessageContentImageUrl(url: $url, detail: $detail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentImageUrlImpl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentImageUrlImplCopyWith<_$MessageContentImageUrlImpl>
      get copyWith => __$$MessageContentImageUrlImplCopyWithImpl<
          _$MessageContentImageUrlImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentImageUrlImplToJson(
      this,
    );
  }
}

abstract class _MessageContentImageUrl extends MessageContentImageUrl {
  const factory _MessageContentImageUrl(
      {required final String url,
      final MessageContentImageDetail detail}) = _$MessageContentImageUrlImpl;
  const _MessageContentImageUrl._() : super._();

  factory _MessageContentImageUrl.fromJson(Map<String, dynamic> json) =
      _$MessageContentImageUrlImpl.fromJson;

  @override

  /// The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
  String get url;
  @override

  /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
  MessageContentImageDetail get detail;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentImageUrlImplCopyWith<_$MessageContentImageUrlImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageRequestContentTextObject _$MessageRequestContentTextObjectFromJson(
    Map<String, dynamic> json) {
  return _MessageRequestContentTextObject.fromJson(json);
}

/// @nodoc
mixin _$MessageRequestContentTextObject {
  /// Always `text`.
  String get type => throw _privateConstructorUsedError;

  /// Text content to be sent to the model
  String get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageRequestContentTextObjectCopyWith<MessageRequestContentTextObject>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageRequestContentTextObjectCopyWith<$Res> {
  factory $MessageRequestContentTextObjectCopyWith(
          MessageRequestContentTextObject value,
          $Res Function(MessageRequestContentTextObject) then) =
      _$MessageRequestContentTextObjectCopyWithImpl<$Res,
          MessageRequestContentTextObject>;
  @useResult
  $Res call({String type, String text});
}

/// @nodoc
class _$MessageRequestContentTextObjectCopyWithImpl<$Res,
        $Val extends MessageRequestContentTextObject>
    implements $MessageRequestContentTextObjectCopyWith<$Res> {
  _$MessageRequestContentTextObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageRequestContentTextObjectImplCopyWith<$Res>
    implements $MessageRequestContentTextObjectCopyWith<$Res> {
  factory _$$MessageRequestContentTextObjectImplCopyWith(
          _$MessageRequestContentTextObjectImpl value,
          $Res Function(_$MessageRequestContentTextObjectImpl) then) =
      __$$MessageRequestContentTextObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, String text});
}

/// @nodoc
class __$$MessageRequestContentTextObjectImplCopyWithImpl<$Res>
    extends _$MessageRequestContentTextObjectCopyWithImpl<$Res,
        _$MessageRequestContentTextObjectImpl>
    implements _$$MessageRequestContentTextObjectImplCopyWith<$Res> {
  __$$MessageRequestContentTextObjectImplCopyWithImpl(
      _$MessageRequestContentTextObjectImpl _value,
      $Res Function(_$MessageRequestContentTextObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_$MessageRequestContentTextObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageRequestContentTextObjectImpl
    extends _MessageRequestContentTextObject {
  const _$MessageRequestContentTextObjectImpl(
      {required this.type, required this.text})
      : super._();

  factory _$MessageRequestContentTextObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageRequestContentTextObjectImplFromJson(json);

  /// Always `text`.
  @override
  final String type;

  /// Text content to be sent to the model
  @override
  final String text;

  @override
  String toString() {
    return 'MessageRequestContentTextObject(type: $type, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageRequestContentTextObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageRequestContentTextObjectImplCopyWith<
          _$MessageRequestContentTextObjectImpl>
      get copyWith => __$$MessageRequestContentTextObjectImplCopyWithImpl<
          _$MessageRequestContentTextObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageRequestContentTextObjectImplToJson(
      this,
    );
  }
}

abstract class _MessageRequestContentTextObject
    extends MessageRequestContentTextObject {
  const factory _MessageRequestContentTextObject(
      {required final String type,
      required final String text}) = _$MessageRequestContentTextObjectImpl;
  const _MessageRequestContentTextObject._() : super._();

  factory _MessageRequestContentTextObject.fromJson(Map<String, dynamic> json) =
      _$MessageRequestContentTextObjectImpl.fromJson;

  @override

  /// Always `text`.
  String get type;
  @override

  /// Text content to be sent to the model
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$MessageRequestContentTextObjectImplCopyWith<
          _$MessageRequestContentTextObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentText _$MessageContentTextFromJson(Map<String, dynamic> json) {
  return _MessageContentText.fromJson(json);
}

/// @nodoc
mixin _$MessageContentText {
  /// The data that makes up the text.
  String get value => throw _privateConstructorUsedError;

  /// A list of annotations that point to specific quotes from specific files.
  @JsonKey(includeIfNull: false)
  List<MessageContentTextAnnotations>? get annotations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextCopyWith<MessageContentText> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextCopyWith<$Res> {
  factory $MessageContentTextCopyWith(
          MessageContentText value, $Res Function(MessageContentText) then) =
      _$MessageContentTextCopyWithImpl<$Res, MessageContentText>;
  @useResult
  $Res call(
      {String value,
      @JsonKey(includeIfNull: false)
      List<MessageContentTextAnnotations>? annotations});
}

/// @nodoc
class _$MessageContentTextCopyWithImpl<$Res, $Val extends MessageContentText>
    implements $MessageContentTextCopyWith<$Res> {
  _$MessageContentTextCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? annotations = freezed,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      annotations: freezed == annotations
          ? _value.annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageContentTextAnnotations>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextImplCopyWith<$Res>
    implements $MessageContentTextCopyWith<$Res> {
  factory _$$MessageContentTextImplCopyWith(_$MessageContentTextImpl value,
          $Res Function(_$MessageContentTextImpl) then) =
      __$$MessageContentTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String value,
      @JsonKey(includeIfNull: false)
      List<MessageContentTextAnnotations>? annotations});
}

/// @nodoc
class __$$MessageContentTextImplCopyWithImpl<$Res>
    extends _$MessageContentTextCopyWithImpl<$Res, _$MessageContentTextImpl>
    implements _$$MessageContentTextImplCopyWith<$Res> {
  __$$MessageContentTextImplCopyWithImpl(_$MessageContentTextImpl _value,
      $Res Function(_$MessageContentTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? annotations = freezed,
  }) {
    return _then(_$MessageContentTextImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      annotations: freezed == annotations
          ? _value._annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageContentTextAnnotations>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextImpl extends _MessageContentText {
  const _$MessageContentTextImpl(
      {required this.value,
      @JsonKey(includeIfNull: false)
      final List<MessageContentTextAnnotations>? annotations})
      : _annotations = annotations,
        super._();

  factory _$MessageContentTextImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageContentTextImplFromJson(json);

  /// The data that makes up the text.
  @override
  final String value;

  /// A list of annotations that point to specific quotes from specific files.
  final List<MessageContentTextAnnotations>? _annotations;

  /// A list of annotations that point to specific quotes from specific files.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageContentTextAnnotations>? get annotations {
    final value = _annotations;
    if (value == null) return null;
    if (_annotations is EqualUnmodifiableListView) return _annotations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MessageContentText(value: $value, annotations: $annotations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextImpl &&
            (identical(other.value, value) || other.value == value) &&
            const DeepCollectionEquality()
                .equals(other._annotations, _annotations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, value, const DeepCollectionEquality().hash(_annotations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextImplCopyWith<_$MessageContentTextImpl> get copyWith =>
      __$$MessageContentTextImplCopyWithImpl<_$MessageContentTextImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextImplToJson(
      this,
    );
  }
}

abstract class _MessageContentText extends MessageContentText {
  const factory _MessageContentText(
          {required final String value,
          @JsonKey(includeIfNull: false)
          final List<MessageContentTextAnnotations>? annotations}) =
      _$MessageContentTextImpl;
  const _MessageContentText._() : super._();

  factory _MessageContentText.fromJson(Map<String, dynamic> json) =
      _$MessageContentTextImpl.fromJson;

  @override

  /// The data that makes up the text.
  String get value;
  @override

  /// A list of annotations that point to specific quotes from specific files.
  @JsonKey(includeIfNull: false)
  List<MessageContentTextAnnotations>? get annotations;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextImplCopyWith<_$MessageContentTextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MessageContentTextAnnotationsFileCitation
    _$MessageContentTextAnnotationsFileCitationFromJson(
        Map<String, dynamic> json) {
  return _MessageContentTextAnnotationsFileCitation.fromJson(json);
}

/// @nodoc
mixin _$MessageContentTextAnnotationsFileCitation {
  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextAnnotationsFileCitationCopyWith<
          MessageContentTextAnnotationsFileCitation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFileCitationCopyWith(
          MessageContentTextAnnotationsFileCitation value,
          $Res Function(MessageContentTextAnnotationsFileCitation) then) =
      _$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res,
          MessageContentTextAnnotationsFileCitation>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res,
        $Val extends MessageContentTextAnnotationsFileCitation>
    implements $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  _$MessageContentTextAnnotationsFileCitationCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFileCitationImplCopyWith<$Res>
    implements $MessageContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFileCitationImplCopyWith(
          _$MessageContentTextAnnotationsFileCitationImpl value,
          $Res Function(_$MessageContentTextAnnotationsFileCitationImpl) then) =
      __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsFileCitationCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFileCitationImpl>
    implements _$$MessageContentTextAnnotationsFileCitationImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl(
      _$MessageContentTextAnnotationsFileCitationImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFileCitationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFileCitationImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFileCitationImpl
    extends _MessageContentTextAnnotationsFileCitation {
  const _$MessageContentTextAnnotationsFileCitationImpl(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();

  factory _$MessageContentTextAnnotationsFileCitationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFileCitationImplFromJson(json);

  /// The ID of the specific File the citation is from.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFileCitation(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFileCitationImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFileCitationImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationImpl>
      get copyWith =>
          __$$MessageContentTextAnnotationsFileCitationImplCopyWithImpl<
                  _$MessageContentTextAnnotationsFileCitationImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFileCitationImplToJson(
      this,
    );
  }
}

abstract class _MessageContentTextAnnotationsFileCitation
    extends MessageContentTextAnnotationsFileCitation {
  const factory _MessageContentTextAnnotationsFileCitation(
          {@JsonKey(name: 'file_id') required final String fileId}) =
      _$MessageContentTextAnnotationsFileCitationImpl;
  const _MessageContentTextAnnotationsFileCitation._() : super._();

  factory _MessageContentTextAnnotationsFileCitation.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFileCitationImpl.fromJson;

  @override

  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFileCitationImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageDeltaContentImageUrlObject _$MessageDeltaContentImageUrlObjectFromJson(
    Map<String, dynamic> json) {
  return _MessageDeltaContentImageUrlObject.fromJson(json);
}

/// @nodoc
mixin _$MessageDeltaContentImageUrlObject {
  /// The index of the content part in the message.
  @JsonKey(includeIfNull: false)
  int? get index => throw _privateConstructorUsedError;

  /// Always `image_url`.
  @JsonKey(includeIfNull: false)
  String? get type => throw _privateConstructorUsedError;

  /// The image URL part of a message.
  @JsonKey(name: 'image_url', includeIfNull: false)
  MessageContentImageUrl? get imageUrl => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaContentImageUrlObjectCopyWith<MessageDeltaContentImageUrlObject>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaContentImageUrlObjectCopyWith<$Res> {
  factory $MessageDeltaContentImageUrlObjectCopyWith(
          MessageDeltaContentImageUrlObject value,
          $Res Function(MessageDeltaContentImageUrlObject) then) =
      _$MessageDeltaContentImageUrlObjectCopyWithImpl<$Res,
          MessageDeltaContentImageUrlObject>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) int? index,
      @JsonKey(includeIfNull: false) String? type,
      @JsonKey(name: 'image_url', includeIfNull: false)
      MessageContentImageUrl? imageUrl});

  $MessageContentImageUrlCopyWith<$Res>? get imageUrl;
}

/// @nodoc
class _$MessageDeltaContentImageUrlObjectCopyWithImpl<$Res,
        $Val extends MessageDeltaContentImageUrlObject>
    implements $MessageDeltaContentImageUrlObjectCopyWith<$Res> {
  _$MessageDeltaContentImageUrlObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = freezed,
    Object? type = freezed,
    Object? imageUrl = freezed,
  }) {
    return _then(_value.copyWith(
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as MessageContentImageUrl?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageUrlCopyWith<$Res>? get imageUrl {
    if (_value.imageUrl == null) {
      return null;
    }

    return $MessageContentImageUrlCopyWith<$Res>(_value.imageUrl!, (value) {
      return _then(_value.copyWith(imageUrl: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MessageDeltaContentImageUrlObjectImplCopyWith<$Res>
    implements $MessageDeltaContentImageUrlObjectCopyWith<$Res> {
  factory _$$MessageDeltaContentImageUrlObjectImplCopyWith(
          _$MessageDeltaContentImageUrlObjectImpl value,
          $Res Function(_$MessageDeltaContentImageUrlObjectImpl) then) =
      __$$MessageDeltaContentImageUrlObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) int? index,
      @JsonKey(includeIfNull: false) String? type,
      @JsonKey(name: 'image_url', includeIfNull: false)
      MessageContentImageUrl? imageUrl});

  @override
  $MessageContentImageUrlCopyWith<$Res>? get imageUrl;
}

/// @nodoc
class __$$MessageDeltaContentImageUrlObjectImplCopyWithImpl<$Res>
    extends _$MessageDeltaContentImageUrlObjectCopyWithImpl<$Res,
        _$MessageDeltaContentImageUrlObjectImpl>
    implements _$$MessageDeltaContentImageUrlObjectImplCopyWith<$Res> {
  __$$MessageDeltaContentImageUrlObjectImplCopyWithImpl(
      _$MessageDeltaContentImageUrlObjectImpl _value,
      $Res Function(_$MessageDeltaContentImageUrlObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = freezed,
    Object? type = freezed,
    Object? imageUrl = freezed,
  }) {
    return _then(_$MessageDeltaContentImageUrlObjectImpl(
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as MessageContentImageUrl?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentImageUrlObjectImpl
    extends _MessageDeltaContentImageUrlObject {
  const _$MessageDeltaContentImageUrlObjectImpl(
      {@JsonKey(includeIfNull: false) this.index,
      @JsonKey(includeIfNull: false) this.type,
      @JsonKey(name: 'image_url', includeIfNull: false) this.imageUrl})
      : super._();

  factory _$MessageDeltaContentImageUrlObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageDeltaContentImageUrlObjectImplFromJson(json);

  /// The index of the content part in the message.
  @override
  @JsonKey(includeIfNull: false)
  final int? index;

  /// Always `image_url`.
  @override
  @JsonKey(includeIfNull: false)
  final String? type;

  /// The image URL part of a message.
  @override
  @JsonKey(name: 'image_url', includeIfNull: false)
  final MessageContentImageUrl? imageUrl;

  @override
  String toString() {
    return 'MessageDeltaContentImageUrlObject(index: $index, type: $type, imageUrl: $imageUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaContentImageUrlObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, imageUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentImageUrlObjectImplCopyWith<
          _$MessageDeltaContentImageUrlObjectImpl>
      get copyWith => __$$MessageDeltaContentImageUrlObjectImplCopyWithImpl<
          _$MessageDeltaContentImageUrlObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentImageUrlObjectImplToJson(
      this,
    );
  }
}

abstract class _MessageDeltaContentImageUrlObject
    extends MessageDeltaContentImageUrlObject {
  const factory _MessageDeltaContentImageUrlObject(
          {@JsonKey(includeIfNull: false) final int? index,
          @JsonKey(includeIfNull: false) final String? type,
          @JsonKey(name: 'image_url', includeIfNull: false)
          final MessageContentImageUrl? imageUrl}) =
      _$MessageDeltaContentImageUrlObjectImpl;
  const _MessageDeltaContentImageUrlObject._() : super._();

  factory _MessageDeltaContentImageUrlObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageDeltaContentImageUrlObjectImpl.fromJson;

  @override

  /// The index of the content part in the message.
  @JsonKey(includeIfNull: false)
  int? get index;
  @override

  /// Always `image_url`.
  @JsonKey(includeIfNull: false)
  String? get type;
  @override

  /// The image URL part of a message.
  @JsonKey(name: 'image_url', includeIfNull: false)
  MessageContentImageUrl? get imageUrl;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentImageUrlObjectImplCopyWith<
          _$MessageDeltaContentImageUrlObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageDeltaContentText _$MessageDeltaContentTextFromJson(
    Map<String, dynamic> json) {
  return _MessageDeltaContentText.fromJson(json);
}

/// @nodoc
mixin _$MessageDeltaContentText {
  /// The data that makes up the text.
  @JsonKey(includeIfNull: false)
  String? get value => throw _privateConstructorUsedError;

  /// A list of annotations that point to specific quotes from specific files.
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContentTextAnnotations>? get annotations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaContentTextCopyWith<MessageDeltaContentText> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaContentTextCopyWith<$Res> {
  factory $MessageDeltaContentTextCopyWith(MessageDeltaContentText value,
          $Res Function(MessageDeltaContentText) then) =
      _$MessageDeltaContentTextCopyWithImpl<$Res, MessageDeltaContentText>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? value,
      @JsonKey(includeIfNull: false)
      List<MessageDeltaContentTextAnnotations>? annotations});
}

/// @nodoc
class _$MessageDeltaContentTextCopyWithImpl<$Res,
        $Val extends MessageDeltaContentText>
    implements $MessageDeltaContentTextCopyWith<$Res> {
  _$MessageDeltaContentTextCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? annotations = freezed,
  }) {
    return _then(_value.copyWith(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      annotations: freezed == annotations
          ? _value.annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContentTextAnnotations>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageDeltaContentTextImplCopyWith<$Res>
    implements $MessageDeltaContentTextCopyWith<$Res> {
  factory _$$MessageDeltaContentTextImplCopyWith(
          _$MessageDeltaContentTextImpl value,
          $Res Function(_$MessageDeltaContentTextImpl) then) =
      __$$MessageDeltaContentTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? value,
      @JsonKey(includeIfNull: false)
      List<MessageDeltaContentTextAnnotations>? annotations});
}

/// @nodoc
class __$$MessageDeltaContentTextImplCopyWithImpl<$Res>
    extends _$MessageDeltaContentTextCopyWithImpl<$Res,
        _$MessageDeltaContentTextImpl>
    implements _$$MessageDeltaContentTextImplCopyWith<$Res> {
  __$$MessageDeltaContentTextImplCopyWithImpl(
      _$MessageDeltaContentTextImpl _value,
      $Res Function(_$MessageDeltaContentTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? annotations = freezed,
  }) {
    return _then(_$MessageDeltaContentTextImpl(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      annotations: freezed == annotations
          ? _value._annotations
          : annotations // ignore: cast_nullable_to_non_nullable
              as List<MessageDeltaContentTextAnnotations>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentTextImpl extends _MessageDeltaContentText {
  const _$MessageDeltaContentTextImpl(
      {@JsonKey(includeIfNull: false) this.value,
      @JsonKey(includeIfNull: false)
      final List<MessageDeltaContentTextAnnotations>? annotations})
      : _annotations = annotations,
        super._();

  factory _$MessageDeltaContentTextImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageDeltaContentTextImplFromJson(json);

  /// The data that makes up the text.
  @override
  @JsonKey(includeIfNull: false)
  final String? value;

  /// A list of annotations that point to specific quotes from specific files.
  final List<MessageDeltaContentTextAnnotations>? _annotations;

  /// A list of annotations that point to specific quotes from specific files.
  @override
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContentTextAnnotations>? get annotations {
    final value = _annotations;
    if (value == null) return null;
    if (_annotations is EqualUnmodifiableListView) return _annotations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MessageDeltaContentText(value: $value, annotations: $annotations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaContentTextImpl &&
            (identical(other.value, value) || other.value == value) &&
            const DeepCollectionEquality()
                .equals(other._annotations, _annotations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, value, const DeepCollectionEquality().hash(_annotations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentTextImplCopyWith<_$MessageDeltaContentTextImpl>
      get copyWith => __$$MessageDeltaContentTextImplCopyWithImpl<
          _$MessageDeltaContentTextImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentTextImplToJson(
      this,
    );
  }
}

abstract class _MessageDeltaContentText extends MessageDeltaContentText {
  const factory _MessageDeltaContentText(
          {@JsonKey(includeIfNull: false) final String? value,
          @JsonKey(includeIfNull: false)
          final List<MessageDeltaContentTextAnnotations>? annotations}) =
      _$MessageDeltaContentTextImpl;
  const _MessageDeltaContentText._() : super._();

  factory _MessageDeltaContentText.fromJson(Map<String, dynamic> json) =
      _$MessageDeltaContentTextImpl.fromJson;

  @override

  /// The data that makes up the text.
  @JsonKey(includeIfNull: false)
  String? get value;
  @override

  /// A list of annotations that point to specific quotes from specific files.
  @JsonKey(includeIfNull: false)
  List<MessageDeltaContentTextAnnotations>? get annotations;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentTextImplCopyWith<_$MessageDeltaContentTextImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageDeltaContentTextAnnotationsFileCitation
    _$MessageDeltaContentTextAnnotationsFileCitationFromJson(
        Map<String, dynamic> json) {
  return _MessageDeltaContentTextAnnotationsFileCitation.fromJson(json);
}

/// @nodoc
mixin _$MessageDeltaContentTextAnnotationsFileCitation {
  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId => throw _privateConstructorUsedError;

  /// The specific quote in the file.
  @JsonKey(includeIfNull: false)
  String? get quote => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaContentTextAnnotationsFileCitationCopyWith<
          MessageDeltaContentTextAnnotationsFileCitation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory $MessageDeltaContentTextAnnotationsFileCitationCopyWith(
          MessageDeltaContentTextAnnotationsFileCitation value,
          $Res Function(MessageDeltaContentTextAnnotationsFileCitation) then) =
      _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl<$Res,
          MessageDeltaContentTextAnnotationsFileCitation>;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) String? quote});
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl<$Res,
        $Val extends MessageDeltaContentTextAnnotationsFileCitation>
    implements $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res> {
  _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
    Object? quote = freezed,
  }) {
    return _then(_value.copyWith(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      quote: freezed == quote
          ? _value.quote
          : quote // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWith<
        $Res>
    implements $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res> {
  factory _$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWith(
          _$MessageDeltaContentTextAnnotationsFileCitationImpl value,
          $Res Function(_$MessageDeltaContentTextAnnotationsFileCitationImpl)
              then) =
      __$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id', includeIfNull: false) String? fileId,
      @JsonKey(includeIfNull: false) String? quote});
}

/// @nodoc
class __$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWithImpl<$Res>
    extends _$MessageDeltaContentTextAnnotationsFileCitationCopyWithImpl<$Res,
        _$MessageDeltaContentTextAnnotationsFileCitationImpl>
    implements
        _$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWith<$Res> {
  __$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWithImpl(
      _$MessageDeltaContentTextAnnotationsFileCitationImpl _value,
      $Res Function(_$MessageDeltaContentTextAnnotationsFileCitationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
    Object? quote = freezed,
  }) {
    return _then(_$MessageDeltaContentTextAnnotationsFileCitationImpl(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      quote: freezed == quote
          ? _value.quote
          : quote // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentTextAnnotationsFileCitationImpl
    extends _MessageDeltaContentTextAnnotationsFileCitation {
  const _$MessageDeltaContentTextAnnotationsFileCitationImpl(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId,
      @JsonKey(includeIfNull: false) this.quote})
      : super._();

  factory _$MessageDeltaContentTextAnnotationsFileCitationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageDeltaContentTextAnnotationsFileCitationImplFromJson(json);

  /// The ID of the specific File the citation is from.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  /// The specific quote in the file.
  @override
  @JsonKey(includeIfNull: false)
  final String? quote;

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotationsFileCitation(fileId: $fileId, quote: $quote)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaContentTextAnnotationsFileCitationImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.quote, quote) || other.quote == quote));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, quote);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFileCitationImpl>
      get copyWith =>
          __$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWithImpl<
                  _$MessageDeltaContentTextAnnotationsFileCitationImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentTextAnnotationsFileCitationImplToJson(
      this,
    );
  }
}

abstract class _MessageDeltaContentTextAnnotationsFileCitation
    extends MessageDeltaContentTextAnnotationsFileCitation {
  const factory _MessageDeltaContentTextAnnotationsFileCitation(
          {@JsonKey(name: 'file_id', includeIfNull: false) final String? fileId,
          @JsonKey(includeIfNull: false) final String? quote}) =
      _$MessageDeltaContentTextAnnotationsFileCitationImpl;
  const _MessageDeltaContentTextAnnotationsFileCitation._() : super._();

  factory _MessageDeltaContentTextAnnotationsFileCitation.fromJson(
          Map<String, dynamic> json) =
      _$MessageDeltaContentTextAnnotationsFileCitationImpl.fromJson;

  @override

  /// The ID of the specific File the citation is from.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;
  @override

  /// The specific quote in the file.
  @JsonKey(includeIfNull: false)
  String? get quote;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentTextAnnotationsFileCitationImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFileCitationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepObject _$RunStepObjectFromJson(Map<String, dynamic> json) {
  return _RunStepObject.fromJson(json);
}

/// @nodoc
mixin _$RunStepObject {
  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.run.step`.
  RunStepObjectObject get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @JsonKey(name: 'assistant_id')
  String get assistantId => throw _privateConstructorUsedError;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @JsonKey(name: 'thread_id')
  String get threadId => throw _privateConstructorUsedError;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @JsonKey(name: 'run_id')
  String get runId => throw _privateConstructorUsedError;

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  RunStepType get type => throw _privateConstructorUsedError;

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  RunStepStatus get status => throw _privateConstructorUsedError;

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details')
  RunStepDetails get stepDetails => throw _privateConstructorUsedError;

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunStepLastError? get lastError => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @JsonKey(name: 'expired_at')
  int? get expiredAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the run step completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  RunStepCompletionUsage? get usage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepObjectCopyWith<RunStepObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepObjectCopyWith<$Res> {
  factory $RunStepObjectCopyWith(
          RunStepObject value, $Res Function(RunStepObject) then) =
      _$RunStepObjectCopyWithImpl<$Res, RunStepObject>;
  @useResult
  $Res call(
      {String id,
      RunStepObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'run_id') String runId,
      RunStepType type,
      RunStepStatus status,
      @JsonKey(name: 'step_details') RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') int? expiredAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      Map<String, dynamic>? metadata,
      RunStepCompletionUsage? usage});

  $RunStepDetailsCopyWith<$Res> get stepDetails;
  $RunStepLastErrorCopyWith<$Res>? get lastError;
  $RunStepCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class _$RunStepObjectCopyWithImpl<$Res, $Val extends RunStepObject>
    implements $RunStepObjectCopyWith<$Res> {
  _$RunStepObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
    Object? threadId = null,
    Object? runId = null,
    Object? type = null,
    Object? status = null,
    Object? stepDetails = null,
    Object? lastError = freezed,
    Object? expiredAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      runId: null == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepType,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStepStatus,
      stepDetails: null == stepDetails
          ? _value.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDetails,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunStepLastError?,
      expiredAt: freezed == expiredAt
          ? _value.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunStepCompletionUsage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsCopyWith<$Res> get stepDetails {
    return $RunStepDetailsCopyWith<$Res>(_value.stepDetails, (value) {
      return _then(_value.copyWith(stepDetails: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepLastErrorCopyWith<$Res>? get lastError {
    if (_value.lastError == null) {
      return null;
    }

    return $RunStepLastErrorCopyWith<$Res>(_value.lastError!, (value) {
      return _then(_value.copyWith(lastError: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepCompletionUsageCopyWith<$Res>? get usage {
    if (_value.usage == null) {
      return null;
    }

    return $RunStepCompletionUsageCopyWith<$Res>(_value.usage!, (value) {
      return _then(_value.copyWith(usage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunStepObjectImplCopyWith<$Res>
    implements $RunStepObjectCopyWith<$Res> {
  factory _$$RunStepObjectImplCopyWith(
          _$RunStepObjectImpl value, $Res Function(_$RunStepObjectImpl) then) =
      __$$RunStepObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      RunStepObjectObject object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'assistant_id') String assistantId,
      @JsonKey(name: 'thread_id') String threadId,
      @JsonKey(name: 'run_id') String runId,
      RunStepType type,
      RunStepStatus status,
      @JsonKey(name: 'step_details') RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') int? expiredAt,
      @JsonKey(name: 'cancelled_at') int? cancelledAt,
      @JsonKey(name: 'failed_at') int? failedAt,
      @JsonKey(name: 'completed_at') int? completedAt,
      Map<String, dynamic>? metadata,
      RunStepCompletionUsage? usage});

  @override
  $RunStepDetailsCopyWith<$Res> get stepDetails;
  @override
  $RunStepLastErrorCopyWith<$Res>? get lastError;
  @override
  $RunStepCompletionUsageCopyWith<$Res>? get usage;
}

/// @nodoc
class __$$RunStepObjectImplCopyWithImpl<$Res>
    extends _$RunStepObjectCopyWithImpl<$Res, _$RunStepObjectImpl>
    implements _$$RunStepObjectImplCopyWith<$Res> {
  __$$RunStepObjectImplCopyWithImpl(
      _$RunStepObjectImpl _value, $Res Function(_$RunStepObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? assistantId = null,
    Object? threadId = null,
    Object? runId = null,
    Object? type = null,
    Object? status = null,
    Object? stepDetails = null,
    Object? lastError = freezed,
    Object? expiredAt = freezed,
    Object? cancelledAt = freezed,
    Object? failedAt = freezed,
    Object? completedAt = freezed,
    Object? metadata = freezed,
    Object? usage = freezed,
  }) {
    return _then(_$RunStepObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepObjectObject,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      assistantId: null == assistantId
          ? _value.assistantId
          : assistantId // ignore: cast_nullable_to_non_nullable
              as String,
      threadId: null == threadId
          ? _value.threadId
          : threadId // ignore: cast_nullable_to_non_nullable
              as String,
      runId: null == runId
          ? _value.runId
          : runId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RunStepType,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RunStepStatus,
      stepDetails: null == stepDetails
          ? _value.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDetails,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as RunStepLastError?,
      expiredAt: freezed == expiredAt
          ? _value.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as RunStepCompletionUsage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepObjectImpl extends _RunStepObject {
  const _$RunStepObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'assistant_id') required this.assistantId,
      @JsonKey(name: 'thread_id') required this.threadId,
      @JsonKey(name: 'run_id') required this.runId,
      required this.type,
      required this.status,
      @JsonKey(name: 'step_details') required this.stepDetails,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'expired_at') required this.expiredAt,
      @JsonKey(name: 'cancelled_at') required this.cancelledAt,
      @JsonKey(name: 'failed_at') required this.failedAt,
      @JsonKey(name: 'completed_at') required this.completedAt,
      required final Map<String, dynamic>? metadata,
      required this.usage})
      : _metadata = metadata,
        super._();

  factory _$RunStepObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepObjectImplFromJson(json);

  /// The identifier of the run step, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run.step`.
  @override
  final RunStepObjectObject object;

  /// The Unix timestamp (in seconds) for when the run step was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @override
  @JsonKey(name: 'assistant_id')
  final String assistantId;

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @override
  @JsonKey(name: 'thread_id')
  final String threadId;

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @override
  @JsonKey(name: 'run_id')
  final String runId;

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  @override
  final RunStepType type;

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  @override
  final RunStepStatus status;

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @override
  @JsonKey(name: 'step_details')
  final RunStepDetails stepDetails;

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final RunStepLastError? lastError;

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @override
  @JsonKey(name: 'expired_at')
  final int? expiredAt;

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @override
  @JsonKey(name: 'cancelled_at')
  final int? cancelledAt;

  /// The Unix timestamp (in seconds) for when the run step failed.
  @override
  @JsonKey(name: 'failed_at')
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the run step completed.
  @override
  @JsonKey(name: 'completed_at')
  final int? completedAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  final Map<String, dynamic>? _metadata;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  @override
  final RunStepCompletionUsage? usage;

  @override
  String toString() {
    return 'RunStepObject(id: $id, object: $object, createdAt: $createdAt, assistantId: $assistantId, threadId: $threadId, runId: $runId, type: $type, status: $status, stepDetails: $stepDetails, lastError: $lastError, expiredAt: $expiredAt, cancelledAt: $cancelledAt, failedAt: $failedAt, completedAt: $completedAt, metadata: $metadata, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.assistantId, assistantId) ||
                other.assistantId == assistantId) &&
            (identical(other.threadId, threadId) ||
                other.threadId == threadId) &&
            (identical(other.runId, runId) || other.runId == runId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.stepDetails, stepDetails) ||
                other.stepDetails == stepDetails) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.expiredAt, expiredAt) ||
                other.expiredAt == expiredAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.usage, usage) || other.usage == usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      assistantId,
      threadId,
      runId,
      type,
      status,
      stepDetails,
      lastError,
      expiredAt,
      cancelledAt,
      failedAt,
      completedAt,
      const DeepCollectionEquality().hash(_metadata),
      usage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepObjectImplCopyWith<_$RunStepObjectImpl> get copyWith =>
      __$$RunStepObjectImplCopyWithImpl<_$RunStepObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepObjectImplToJson(
      this,
    );
  }
}

abstract class _RunStepObject extends RunStepObject {
  const factory _RunStepObject(
      {required final String id,
      required final RunStepObjectObject object,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'assistant_id') required final String assistantId,
      @JsonKey(name: 'thread_id') required final String threadId,
      @JsonKey(name: 'run_id') required final String runId,
      required final RunStepType type,
      required final RunStepStatus status,
      @JsonKey(name: 'step_details') required final RunStepDetails stepDetails,
      @JsonKey(name: 'last_error') required final RunStepLastError? lastError,
      @JsonKey(name: 'expired_at') required final int? expiredAt,
      @JsonKey(name: 'cancelled_at') required final int? cancelledAt,
      @JsonKey(name: 'failed_at') required final int? failedAt,
      @JsonKey(name: 'completed_at') required final int? completedAt,
      required final Map<String, dynamic>? metadata,
      required final RunStepCompletionUsage? usage}) = _$RunStepObjectImpl;
  const _RunStepObject._() : super._();

  factory _RunStepObject.fromJson(Map<String, dynamic> json) =
      _$RunStepObjectImpl.fromJson;

  @override

  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.run.step`.
  RunStepObjectObject get object;
  @override

  /// The Unix timestamp (in seconds) for when the run step was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step.
  @JsonKey(name: 'assistant_id')
  String get assistantId;
  @override

  /// The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run.
  @JsonKey(name: 'thread_id')
  String get threadId;
  @override

  /// The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of.
  @JsonKey(name: 'run_id')
  String get runId;
  @override

  /// The type of run step, which can be either `message_creation` or `tool_calls`.
  RunStepType get type;
  @override

  /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  RunStepStatus get status;
  @override

  /// The details of the run step.
  /// Any of: [RunStepDetailsMessageCreationObject], [RunStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details')
  RunStepDetails get stepDetails;
  @override

  /// The last error associated with this run step. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  RunStepLastError? get lastError;
  @override

  /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  @JsonKey(name: 'expired_at')
  int? get expiredAt;
  @override

  /// The Unix timestamp (in seconds) for when the run step was cancelled.
  @JsonKey(name: 'cancelled_at')
  int? get cancelledAt;
  @override

  /// The Unix timestamp (in seconds) for when the run step failed.
  @JsonKey(name: 'failed_at')
  int? get failedAt;
  @override

  /// The Unix timestamp (in seconds) for when the run step completed.
  @JsonKey(name: 'completed_at')
  int? get completedAt;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  Map<String, dynamic>? get metadata;
  @override

  /// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
  RunStepCompletionUsage? get usage;
  @override
  @JsonKey(ignore: true)
  _$$RunStepObjectImplCopyWith<_$RunStepObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunStepLastError _$RunStepLastErrorFromJson(Map<String, dynamic> json) {
  return _RunStepLastError.fromJson(json);
}

/// @nodoc
mixin _$RunStepLastError {
  /// One of `server_error` or `rate_limit_exceeded`.
  RunStepLastErrorCode get code => throw _privateConstructorUsedError;

  /// A human-readable description of the error.
  String get message => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepLastErrorCopyWith<RunStepLastError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepLastErrorCopyWith<$Res> {
  factory $RunStepLastErrorCopyWith(
          RunStepLastError value, $Res Function(RunStepLastError) then) =
      _$RunStepLastErrorCopyWithImpl<$Res, RunStepLastError>;
  @useResult
  $Res call({RunStepLastErrorCode code, String message});
}

/// @nodoc
class _$RunStepLastErrorCopyWithImpl<$Res, $Val extends RunStepLastError>
    implements $RunStepLastErrorCopyWith<$Res> {
  _$RunStepLastErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunStepLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepLastErrorImplCopyWith<$Res>
    implements $RunStepLastErrorCopyWith<$Res> {
  factory _$$RunStepLastErrorImplCopyWith(_$RunStepLastErrorImpl value,
          $Res Function(_$RunStepLastErrorImpl) then) =
      __$$RunStepLastErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({RunStepLastErrorCode code, String message});
}

/// @nodoc
class __$$RunStepLastErrorImplCopyWithImpl<$Res>
    extends _$RunStepLastErrorCopyWithImpl<$Res, _$RunStepLastErrorImpl>
    implements _$$RunStepLastErrorImplCopyWith<$Res> {
  __$$RunStepLastErrorImplCopyWithImpl(_$RunStepLastErrorImpl _value,
      $Res Function(_$RunStepLastErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_$RunStepLastErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as RunStepLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepLastErrorImpl extends _RunStepLastError {
  const _$RunStepLastErrorImpl({required this.code, required this.message})
      : super._();

  factory _$RunStepLastErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepLastErrorImplFromJson(json);

  /// One of `server_error` or `rate_limit_exceeded`.
  @override
  final RunStepLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  @override
  String toString() {
    return 'RunStepLastError(code: $code, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepLastErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepLastErrorImplCopyWith<_$RunStepLastErrorImpl> get copyWith =>
      __$$RunStepLastErrorImplCopyWithImpl<_$RunStepLastErrorImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepLastErrorImplToJson(
      this,
    );
  }
}

abstract class _RunStepLastError extends RunStepLastError {
  const factory _RunStepLastError(
      {required final RunStepLastErrorCode code,
      required final String message}) = _$RunStepLastErrorImpl;
  const _RunStepLastError._() : super._();

  factory _RunStepLastError.fromJson(Map<String, dynamic> json) =
      _$RunStepLastErrorImpl.fromJson;

  @override

  /// One of `server_error` or `rate_limit_exceeded`.
  RunStepLastErrorCode get code;
  @override

  /// A human-readable description of the error.
  String get message;
  @override
  @JsonKey(ignore: true)
  _$$RunStepLastErrorImplCopyWith<_$RunStepLastErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunStepDeltaObject _$RunStepDeltaObjectFromJson(Map<String, dynamic> json) {
  return _RunStepDeltaObject.fromJson(json);
}

/// @nodoc
mixin _$RunStepDeltaObject {
  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `thread.run.step.delta`.
  RunStepDeltaObjectObject get object => throw _privateConstructorUsedError;

  /// The delta containing the fields that have changed on the run step.
  RunStepDelta get delta => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaObjectCopyWith<RunStepDeltaObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaObjectCopyWith<$Res> {
  factory $RunStepDeltaObjectCopyWith(
          RunStepDeltaObject value, $Res Function(RunStepDeltaObject) then) =
      _$RunStepDeltaObjectCopyWithImpl<$Res, RunStepDeltaObject>;
  @useResult
  $Res call({String id, RunStepDeltaObjectObject object, RunStepDelta delta});

  $RunStepDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class _$RunStepDeltaObjectCopyWithImpl<$Res, $Val extends RunStepDeltaObject>
    implements $RunStepDeltaObjectCopyWith<$Res> {
  _$RunStepDeltaObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaObjectObject,
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as RunStepDelta,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaCopyWith<$Res> get delta {
    return $RunStepDeltaCopyWith<$Res>(_value.delta, (value) {
      return _then(_value.copyWith(delta: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunStepDeltaObjectImplCopyWith<$Res>
    implements $RunStepDeltaObjectCopyWith<$Res> {
  factory _$$RunStepDeltaObjectImplCopyWith(_$RunStepDeltaObjectImpl value,
          $Res Function(_$RunStepDeltaObjectImpl) then) =
      __$$RunStepDeltaObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, RunStepDeltaObjectObject object, RunStepDelta delta});

  @override
  $RunStepDeltaCopyWith<$Res> get delta;
}

/// @nodoc
class __$$RunStepDeltaObjectImplCopyWithImpl<$Res>
    extends _$RunStepDeltaObjectCopyWithImpl<$Res, _$RunStepDeltaObjectImpl>
    implements _$$RunStepDeltaObjectImplCopyWith<$Res> {
  __$$RunStepDeltaObjectImplCopyWithImpl(_$RunStepDeltaObjectImpl _value,
      $Res Function(_$RunStepDeltaObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? delta = null,
  }) {
    return _then(_$RunStepDeltaObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaObjectObject,
      delta: null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as RunStepDelta,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaObjectImpl extends _RunStepDeltaObject {
  const _$RunStepDeltaObjectImpl(
      {required this.id, required this.object, required this.delta})
      : super._();

  factory _$RunStepDeltaObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepDeltaObjectImplFromJson(json);

  /// The identifier of the run step, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `thread.run.step.delta`.
  @override
  final RunStepDeltaObjectObject object;

  /// The delta containing the fields that have changed on the run step.
  @override
  final RunStepDelta delta;

  @override
  String toString() {
    return 'RunStepDeltaObject(id: $id, object: $object, delta: $delta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, delta);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaObjectImplCopyWith<_$RunStepDeltaObjectImpl> get copyWith =>
      __$$RunStepDeltaObjectImplCopyWithImpl<_$RunStepDeltaObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaObjectImplToJson(
      this,
    );
  }
}

abstract class _RunStepDeltaObject extends RunStepDeltaObject {
  const factory _RunStepDeltaObject(
      {required final String id,
      required final RunStepDeltaObjectObject object,
      required final RunStepDelta delta}) = _$RunStepDeltaObjectImpl;
  const _RunStepDeltaObject._() : super._();

  factory _RunStepDeltaObject.fromJson(Map<String, dynamic> json) =
      _$RunStepDeltaObjectImpl.fromJson;

  @override

  /// The identifier of the run step, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `thread.run.step.delta`.
  RunStepDeltaObjectObject get object;
  @override

  /// The delta containing the fields that have changed on the run step.
  RunStepDelta get delta;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaObjectImplCopyWith<_$RunStepDeltaObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RunStepDelta _$RunStepDeltaFromJson(Map<String, dynamic> json) {
  return _RunStepDelta.fromJson(json);
}

/// @nodoc
mixin _$RunStepDelta {
  /// The details of the run step
  /// Any of: [RunStepDeltaStepDetailsMessageCreationObject], [RunStepDeltaStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details', includeIfNull: false)
  RunStepDeltaDetails? get stepDetails => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaCopyWith<RunStepDelta> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaCopyWith<$Res> {
  factory $RunStepDeltaCopyWith(
          RunStepDelta value, $Res Function(RunStepDelta) then) =
      _$RunStepDeltaCopyWithImpl<$Res, RunStepDelta>;
  @useResult
  $Res call(
      {@JsonKey(name: 'step_details', includeIfNull: false)
      RunStepDeltaDetails? stepDetails});

  $RunStepDeltaDetailsCopyWith<$Res>? get stepDetails;
}

/// @nodoc
class _$RunStepDeltaCopyWithImpl<$Res, $Val extends RunStepDelta>
    implements $RunStepDeltaCopyWith<$Res> {
  _$RunStepDeltaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stepDetails = freezed,
  }) {
    return _then(_value.copyWith(
      stepDetails: freezed == stepDetails
          ? _value.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaDetails?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaDetailsCopyWith<$Res>? get stepDetails {
    if (_value.stepDetails == null) {
      return null;
    }

    return $RunStepDeltaDetailsCopyWith<$Res>(_value.stepDetails!, (value) {
      return _then(_value.copyWith(stepDetails: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RunStepDeltaImplCopyWith<$Res>
    implements $RunStepDeltaCopyWith<$Res> {
  factory _$$RunStepDeltaImplCopyWith(
          _$RunStepDeltaImpl value, $Res Function(_$RunStepDeltaImpl) then) =
      __$$RunStepDeltaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'step_details', includeIfNull: false)
      RunStepDeltaDetails? stepDetails});

  @override
  $RunStepDeltaDetailsCopyWith<$Res>? get stepDetails;
}

/// @nodoc
class __$$RunStepDeltaImplCopyWithImpl<$Res>
    extends _$RunStepDeltaCopyWithImpl<$Res, _$RunStepDeltaImpl>
    implements _$$RunStepDeltaImplCopyWith<$Res> {
  __$$RunStepDeltaImplCopyWithImpl(
      _$RunStepDeltaImpl _value, $Res Function(_$RunStepDeltaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stepDetails = freezed,
  }) {
    return _then(_$RunStepDeltaImpl(
      stepDetails: freezed == stepDetails
          ? _value.stepDetails
          : stepDetails // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaDetails?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaImpl extends _RunStepDelta {
  const _$RunStepDeltaImpl(
      {@JsonKey(name: 'step_details', includeIfNull: false) this.stepDetails})
      : super._();

  factory _$RunStepDeltaImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepDeltaImplFromJson(json);

  /// The details of the run step
  /// Any of: [RunStepDeltaStepDetailsMessageCreationObject], [RunStepDeltaStepDetailsToolCallsObject]
  @override
  @JsonKey(name: 'step_details', includeIfNull: false)
  final RunStepDeltaDetails? stepDetails;

  @override
  String toString() {
    return 'RunStepDelta(stepDetails: $stepDetails)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaImpl &&
            (identical(other.stepDetails, stepDetails) ||
                other.stepDetails == stepDetails));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, stepDetails);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaImplCopyWith<_$RunStepDeltaImpl> get copyWith =>
      __$$RunStepDeltaImplCopyWithImpl<_$RunStepDeltaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaImplToJson(
      this,
    );
  }
}

abstract class _RunStepDelta extends RunStepDelta {
  const factory _RunStepDelta(
      {@JsonKey(name: 'step_details', includeIfNull: false)
      final RunStepDeltaDetails? stepDetails}) = _$RunStepDeltaImpl;
  const _RunStepDelta._() : super._();

  factory _RunStepDelta.fromJson(Map<String, dynamic> json) =
      _$RunStepDeltaImpl.fromJson;

  @override

  /// The details of the run step
  /// Any of: [RunStepDeltaStepDetailsMessageCreationObject], [RunStepDeltaStepDetailsToolCallsObject]
  @JsonKey(name: 'step_details', includeIfNull: false)
  RunStepDeltaDetails? get stepDetails;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaImplCopyWith<_$RunStepDeltaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ListRunStepsResponse _$ListRunStepsResponseFromJson(Map<String, dynamic> json) {
  return _ListRunStepsResponse.fromJson(json);
}

/// @nodoc
mixin _$ListRunStepsResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// The list of run steps.
  List<RunStepObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first run step in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last run step in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more run steps to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListRunStepsResponseCopyWith<ListRunStepsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListRunStepsResponseCopyWith<$Res> {
  factory $ListRunStepsResponseCopyWith(ListRunStepsResponse value,
          $Res Function(ListRunStepsResponse) then) =
      _$ListRunStepsResponseCopyWithImpl<$Res, ListRunStepsResponse>;
  @useResult
  $Res call(
      {String object,
      List<RunStepObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListRunStepsResponseCopyWithImpl<$Res,
        $Val extends ListRunStepsResponse>
    implements $ListRunStepsResponseCopyWith<$Res> {
  _$ListRunStepsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunStepObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListRunStepsResponseImplCopyWith<$Res>
    implements $ListRunStepsResponseCopyWith<$Res> {
  factory _$$ListRunStepsResponseImplCopyWith(_$ListRunStepsResponseImpl value,
          $Res Function(_$ListRunStepsResponseImpl) then) =
      __$$ListRunStepsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<RunStepObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListRunStepsResponseImplCopyWithImpl<$Res>
    extends _$ListRunStepsResponseCopyWithImpl<$Res, _$ListRunStepsResponseImpl>
    implements _$$ListRunStepsResponseImplCopyWith<$Res> {
  __$$ListRunStepsResponseImplCopyWithImpl(_$ListRunStepsResponseImpl _value,
      $Res Function(_$ListRunStepsResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListRunStepsResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<RunStepObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListRunStepsResponseImpl extends _ListRunStepsResponse {
  const _$ListRunStepsResponseImpl(
      {required this.object,
      required final List<RunStepObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListRunStepsResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListRunStepsResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// The list of run steps.
  final List<RunStepObject> _data;

  /// The list of run steps.
  @override
  List<RunStepObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first run step in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last run step in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more run steps to retrieve.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListRunStepsResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListRunStepsResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListRunStepsResponseImplCopyWith<_$ListRunStepsResponseImpl>
      get copyWith =>
          __$$ListRunStepsResponseImplCopyWithImpl<_$ListRunStepsResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListRunStepsResponseImplToJson(
      this,
    );
  }
}

abstract class _ListRunStepsResponse extends ListRunStepsResponse {
  const factory _ListRunStepsResponse(
          {required final String object,
          required final List<RunStepObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListRunStepsResponseImpl;
  const _ListRunStepsResponse._() : super._();

  factory _ListRunStepsResponse.fromJson(Map<String, dynamic> json) =
      _$ListRunStepsResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// The list of run steps.
  List<RunStepObject> get data;
  @override

  /// The ID of the first run step in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last run step in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more run steps to retrieve.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListRunStepsResponseImplCopyWith<_$ListRunStepsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsMessageCreation _$RunStepDetailsMessageCreationFromJson(
    Map<String, dynamic> json) {
  return _RunStepDetailsMessageCreation.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsMessageCreation {
  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id')
  String get messageId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsMessageCreationCopyWith<RunStepDetailsMessageCreation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsMessageCreationCopyWith<$Res> {
  factory $RunStepDetailsMessageCreationCopyWith(
          RunStepDetailsMessageCreation value,
          $Res Function(RunStepDetailsMessageCreation) then) =
      _$RunStepDetailsMessageCreationCopyWithImpl<$Res,
          RunStepDetailsMessageCreation>;
  @useResult
  $Res call({@JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class _$RunStepDetailsMessageCreationCopyWithImpl<$Res,
        $Val extends RunStepDetailsMessageCreation>
    implements $RunStepDetailsMessageCreationCopyWith<$Res> {
  _$RunStepDetailsMessageCreationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = null,
  }) {
    return _then(_value.copyWith(
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsMessageCreationImplCopyWith<$Res>
    implements $RunStepDetailsMessageCreationCopyWith<$Res> {
  factory _$$RunStepDetailsMessageCreationImplCopyWith(
          _$RunStepDetailsMessageCreationImpl value,
          $Res Function(_$RunStepDetailsMessageCreationImpl) then) =
      __$$RunStepDetailsMessageCreationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'message_id') String messageId});
}

/// @nodoc
class __$$RunStepDetailsMessageCreationImplCopyWithImpl<$Res>
    extends _$RunStepDetailsMessageCreationCopyWithImpl<$Res,
        _$RunStepDetailsMessageCreationImpl>
    implements _$$RunStepDetailsMessageCreationImplCopyWith<$Res> {
  __$$RunStepDetailsMessageCreationImplCopyWithImpl(
      _$RunStepDetailsMessageCreationImpl _value,
      $Res Function(_$RunStepDetailsMessageCreationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = null,
  }) {
    return _then(_$RunStepDetailsMessageCreationImpl(
      messageId: null == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsMessageCreationImpl
    extends _RunStepDetailsMessageCreation {
  const _$RunStepDetailsMessageCreationImpl(
      {@JsonKey(name: 'message_id') required this.messageId})
      : super._();

  factory _$RunStepDetailsMessageCreationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsMessageCreationImplFromJson(json);

  /// The ID of the message that was created by this run step.
  @override
  @JsonKey(name: 'message_id')
  final String messageId;

  @override
  String toString() {
    return 'RunStepDetailsMessageCreation(messageId: $messageId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsMessageCreationImpl &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, messageId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsMessageCreationImplCopyWith<
          _$RunStepDetailsMessageCreationImpl>
      get copyWith => __$$RunStepDetailsMessageCreationImplCopyWithImpl<
          _$RunStepDetailsMessageCreationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsMessageCreationImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsMessageCreation
    extends RunStepDetailsMessageCreation {
  const factory _RunStepDetailsMessageCreation(
          {@JsonKey(name: 'message_id') required final String messageId}) =
      _$RunStepDetailsMessageCreationImpl;
  const _RunStepDetailsMessageCreation._() : super._();

  factory _RunStepDetailsMessageCreation.fromJson(Map<String, dynamic> json) =
      _$RunStepDetailsMessageCreationImpl.fromJson;

  @override

  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id')
  String get messageId;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsMessageCreationImplCopyWith<
          _$RunStepDetailsMessageCreationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDeltaStepDetailsMessageCreation
    _$RunStepDeltaStepDetailsMessageCreationFromJson(
        Map<String, dynamic> json) {
  return _RunStepDeltaStepDetailsMessageCreation.fromJson(json);
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsMessageCreation {
  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id', includeIfNull: false)
  String? get messageId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaStepDetailsMessageCreationCopyWith<
          RunStepDeltaStepDetailsMessageCreation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsMessageCreationCopyWith(
          RunStepDeltaStepDetailsMessageCreation value,
          $Res Function(RunStepDeltaStepDetailsMessageCreation) then) =
      _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl<$Res,
          RunStepDeltaStepDetailsMessageCreation>;
  @useResult
  $Res call(
      {@JsonKey(name: 'message_id', includeIfNull: false) String? messageId});
}

/// @nodoc
class _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl<$Res,
        $Val extends RunStepDeltaStepDetailsMessageCreation>
    implements $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res> {
  _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = freezed,
  }) {
    return _then(_value.copyWith(
      messageId: freezed == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsMessageCreationImplCopyWith<$Res>
    implements $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsMessageCreationImplCopyWith(
          _$RunStepDeltaStepDetailsMessageCreationImpl value,
          $Res Function(_$RunStepDeltaStepDetailsMessageCreationImpl) then) =
      __$$RunStepDeltaStepDetailsMessageCreationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'message_id', includeIfNull: false) String? messageId});
}

/// @nodoc
class __$$RunStepDeltaStepDetailsMessageCreationImplCopyWithImpl<$Res>
    extends _$RunStepDeltaStepDetailsMessageCreationCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsMessageCreationImpl>
    implements _$$RunStepDeltaStepDetailsMessageCreationImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsMessageCreationImplCopyWithImpl(
      _$RunStepDeltaStepDetailsMessageCreationImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsMessageCreationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageId = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsMessageCreationImpl(
      messageId: freezed == messageId
          ? _value.messageId
          : messageId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsMessageCreationImpl
    extends _RunStepDeltaStepDetailsMessageCreation {
  const _$RunStepDeltaStepDetailsMessageCreationImpl(
      {@JsonKey(name: 'message_id', includeIfNull: false) this.messageId})
      : super._();

  factory _$RunStepDeltaStepDetailsMessageCreationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsMessageCreationImplFromJson(json);

  /// The ID of the message that was created by this run step.
  @override
  @JsonKey(name: 'message_id', includeIfNull: false)
  final String? messageId;

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsMessageCreation(messageId: $messageId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsMessageCreationImpl &&
            (identical(other.messageId, messageId) ||
                other.messageId == messageId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, messageId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsMessageCreationImplCopyWith<
          _$RunStepDeltaStepDetailsMessageCreationImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsMessageCreationImplCopyWithImpl<
              _$RunStepDeltaStepDetailsMessageCreationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsMessageCreationImplToJson(
      this,
    );
  }
}

abstract class _RunStepDeltaStepDetailsMessageCreation
    extends RunStepDeltaStepDetailsMessageCreation {
  const factory _RunStepDeltaStepDetailsMessageCreation(
      {@JsonKey(name: 'message_id', includeIfNull: false)
      final String? messageId}) = _$RunStepDeltaStepDetailsMessageCreationImpl;
  const _RunStepDeltaStepDetailsMessageCreation._() : super._();

  factory _RunStepDeltaStepDetailsMessageCreation.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsMessageCreationImpl.fromJson;

  @override

  /// The ID of the message that was created by this run step.
  @JsonKey(name: 'message_id', includeIfNull: false)
  String? get messageId;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsMessageCreationImplCopyWith<
          _$RunStepDeltaStepDetailsMessageCreationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsCodeObjectCodeInterpreter
    _$RunStepDetailsToolCallsCodeObjectCodeInterpreterFromJson(
        Map<String, dynamic> json) {
  return _RunStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  /// The input to the Code Interpreter tool call.
  String get input => throw _privateConstructorUsedError;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  List<RunStepDetailsToolCallsCodeOutput> get outputs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
          RunStepDetailsToolCallsCodeObjectCodeInterpreter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith(
          RunStepDetailsToolCallsCodeObjectCodeInterpreter value,
          $Res Function(RunStepDetailsToolCallsCodeObjectCodeInterpreter)
              then) =
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res,
          RunStepDetailsToolCallsCodeObjectCodeInterpreter>;
  @useResult
  $Res call({String input, List<RunStepDetailsToolCallsCodeOutput> outputs});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsCodeObjectCodeInterpreter>
    implements $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? outputs = null,
  }) {
    return _then(_value.copyWith(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
      outputs: null == outputs
          ? _value.outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsCodeOutput>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
        $Res>
    implements $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith(
          _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl)
              then) =
      __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String input, List<RunStepDetailsToolCallsCodeOutput> outputs});
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
    implements
        _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? outputs = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
      outputs: null == outputs
          ? _value._outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCallsCodeOutput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl
    extends _RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  const _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl(
      {required this.input,
      required final List<RunStepDetailsToolCallsCodeOutput> outputs})
      : _outputs = outputs,
        super._();

  factory _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplFromJson(json);

  /// The input to the Code Interpreter tool call.
  @override
  final String input;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  final List<RunStepDetailsToolCallsCodeOutput> _outputs;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @override
  List<RunStepDetailsToolCallsCodeOutput> get outputs {
    if (_outputs is EqualUnmodifiableListView) return _outputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_outputs);
  }

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeObjectCodeInterpreter(input: $input, outputs: $outputs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other._outputs, _outputs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(_outputs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<
                  _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsToolCallsCodeObjectCodeInterpreter
    extends RunStepDetailsToolCallsCodeObjectCodeInterpreter {
  const factory _RunStepDetailsToolCallsCodeObjectCodeInterpreter(
          {required final String input,
          required final List<RunStepDetailsToolCallsCodeOutput> outputs}) =
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl;
  const _RunStepDetailsToolCallsCodeObjectCodeInterpreter._() : super._();

  factory _RunStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl.fromJson;

  @override

  /// The input to the Code Interpreter tool call.
  String get input;
  @override

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  List<RunStepDetailsToolCallsCodeOutput> get outputs;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
    _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterFromJson(
        Map<String, dynamic> json) {
  return _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(
      json);
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
  /// The input to the Code Interpreter tool call.
  @JsonKey(includeIfNull: false)
  String? get input => throw _privateConstructorUsedError;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @JsonKey(includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCallsCodeOutput>? get outputs =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
    $Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value,
          $Res Function(
                  RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter)
              then) =
      _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
          $Res, RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? input,
      @JsonKey(includeIfNull: false)
      List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
        $Res,
        $Val extends RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>
    implements
        $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
            $Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = freezed,
    Object? outputs = freezed,
  }) {
    return _then(_value.copyWith(
      input: freezed == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String?,
      outputs: freezed == outputs
          ? _value.outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDeltaStepDetailsToolCallsCodeOutput>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
        $Res>
    implements
        $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
            $Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl value,
          $Res Function(
                  _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl)
              then) =
      __$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? input,
      @JsonKey(includeIfNull: false)
      List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs});
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<
        $Res>
    extends _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWithImpl<
        $Res, _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
    implements
        _$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
            $Res> {
  __$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl _value,
      $Res Function(
              _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = freezed,
    Object? outputs = freezed,
  }) {
    return _then(
        _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl(
      input: freezed == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String?,
      outputs: freezed == outputs
          ? _value._outputs
          : outputs // ignore: cast_nullable_to_non_nullable
              as List<RunStepDeltaStepDetailsToolCallsCodeOutput>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl
    extends _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
  const _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl(
      {@JsonKey(includeIfNull: false) this.input,
      @JsonKey(includeIfNull: false)
      final List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs})
      : _outputs = outputs,
        super._();

  factory _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplFromJson(
          json);

  /// The input to the Code Interpreter tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? input;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  final List<RunStepDeltaStepDetailsToolCallsCodeOutput>? _outputs;

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @override
  @JsonKey(includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCallsCodeOutput>? get outputs {
    final value = _outputs;
    if (value == null) return null;
    if (_outputs is EqualUnmodifiableListView) return _outputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter(input: $input, outputs: $outputs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other._outputs, _outputs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(_outputs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplToJson(
      this,
    );
  }
}

abstract class _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
    extends RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
  const factory _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter(
          {@JsonKey(includeIfNull: false) final String? input,
          @JsonKey(includeIfNull: false)
          final List<RunStepDeltaStepDetailsToolCallsCodeOutput>? outputs}) =
      _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl;
  const _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter._()
      : super._();

  factory _RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl.fromJson;

  @override

  /// The input to the Code Interpreter tool call.
  @JsonKey(includeIfNull: false)
  String? get input;
  @override

  /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  @JsonKey(includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCallsCodeOutput>? get outputs;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsCodeOutputImage
    _$RunStepDetailsToolCallsCodeOutputImageFromJson(
        Map<String, dynamic> json) {
  return _RunStepDetailsToolCallsCodeOutputImage.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeOutputImage {
  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsCodeOutputImageCopyWith<
          RunStepDetailsToolCallsCodeOutputImage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputImageCopyWith(
          RunStepDetailsToolCallsCodeOutputImage value,
          $Res Function(RunStepDetailsToolCallsCodeOutputImage) then) =
      _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
          RunStepDetailsToolCallsCodeOutputImage>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsCodeOutputImage>
    implements $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith(
          _$RunStepDetailsToolCallsCodeOutputImageImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeOutputImageImpl) then) =
      __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeOutputImageImpl>
    implements _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeOutputImageImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeOutputImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeOutputImageImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeOutputImageImpl
    extends _RunStepDetailsToolCallsCodeOutputImage {
  const _$RunStepDetailsToolCallsCodeOutputImageImpl(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();

  factory _$RunStepDetailsToolCallsCodeOutputImageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeOutputImageImplFromJson(json);

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutputImage(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeOutputImageImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<
              _$RunStepDetailsToolCallsCodeOutputImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeOutputImageImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsToolCallsCodeOutputImage
    extends RunStepDetailsToolCallsCodeOutputImage {
  const factory _RunStepDetailsToolCallsCodeOutputImage(
          {@JsonKey(name: 'file_id') required final String fileId}) =
      _$RunStepDetailsToolCallsCodeOutputImageImpl;
  const _RunStepDetailsToolCallsCodeOutputImage._() : super._();

  factory _RunStepDetailsToolCallsCodeOutputImage.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeOutputImageImpl.fromJson;

  @override

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeOutputImageImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDeltaStepDetailsToolCallsCodeOutputImage
    _$RunStepDeltaStepDetailsToolCallsCodeOutputImageFromJson(
        Map<String, dynamic> json) {
  return _RunStepDeltaStepDetailsToolCallsCodeOutputImage.fromJson(json);
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsCodeOutputImage {
  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeOutputImage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeOutputImage value,
          $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutputImage) then) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
          RunStepDeltaStepDetailsToolCallsCodeOutputImage>;
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
        $Val extends RunStepDeltaStepDetailsToolCallsCodeOutputImage>
    implements $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_value.copyWith(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWith<
        $Res>
    implements $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl value,
          $Res Function(_$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl)
              then) =
      __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<$Res>
    extends _$RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl>
    implements
        _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl
    extends _RunStepDeltaStepDetailsToolCallsCodeOutputImage {
  const _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId})
      : super._();

  factory _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplFromJson(json);

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutputImage(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplToJson(
      this,
    );
  }
}

abstract class _RunStepDeltaStepDetailsToolCallsCodeOutputImage
    extends RunStepDeltaStepDetailsToolCallsCodeOutputImage {
  const factory _RunStepDeltaStepDetailsToolCallsCodeOutputImage(
          {@JsonKey(name: 'file_id', includeIfNull: false)
          final String? fileId}) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl;
  const _RunStepDeltaStepDetailsToolCallsCodeOutputImage._() : super._();

  factory _RunStepDeltaStepDetailsToolCallsCodeOutputImage.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl.fromJson;

  @override

  /// The [file](https://platform.openai.com/docs/api-reference/files) ID of the image.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeOutputImageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepCompletionUsage _$RunStepCompletionUsageFromJson(
    Map<String, dynamic> json) {
  return _RunStepCompletionUsage.fromJson(json);
}

/// @nodoc
mixin _$RunStepCompletionUsage {
  /// Number of completion tokens used over the course of the run step.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens => throw _privateConstructorUsedError;

  /// Number of prompt tokens used over the course of the run step.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens => throw _privateConstructorUsedError;

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepCompletionUsageCopyWith<RunStepCompletionUsage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepCompletionUsageCopyWith<$Res> {
  factory $RunStepCompletionUsageCopyWith(RunStepCompletionUsage value,
          $Res Function(RunStepCompletionUsage) then) =
      _$RunStepCompletionUsageCopyWithImpl<$Res, RunStepCompletionUsage>;
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class _$RunStepCompletionUsageCopyWithImpl<$Res,
        $Val extends RunStepCompletionUsage>
    implements $RunStepCompletionUsageCopyWith<$Res> {
  _$RunStepCompletionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_value.copyWith(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepCompletionUsageImplCopyWith<$Res>
    implements $RunStepCompletionUsageCopyWith<$Res> {
  factory _$$RunStepCompletionUsageImplCopyWith(
          _$RunStepCompletionUsageImpl value,
          $Res Function(_$RunStepCompletionUsageImpl) then) =
      __$$RunStepCompletionUsageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'completion_tokens') int completionTokens,
      @JsonKey(name: 'prompt_tokens') int promptTokens,
      @JsonKey(name: 'total_tokens') int totalTokens});
}

/// @nodoc
class __$$RunStepCompletionUsageImplCopyWithImpl<$Res>
    extends _$RunStepCompletionUsageCopyWithImpl<$Res,
        _$RunStepCompletionUsageImpl>
    implements _$$RunStepCompletionUsageImplCopyWith<$Res> {
  __$$RunStepCompletionUsageImplCopyWithImpl(
      _$RunStepCompletionUsageImpl _value,
      $Res Function(_$RunStepCompletionUsageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completionTokens = null,
    Object? promptTokens = null,
    Object? totalTokens = null,
  }) {
    return _then(_$RunStepCompletionUsageImpl(
      completionTokens: null == completionTokens
          ? _value.completionTokens
          : completionTokens // ignore: cast_nullable_to_non_nullable
              as int,
      promptTokens: null == promptTokens
          ? _value.promptTokens
          : promptTokens // ignore: cast_nullable_to_non_nullable
              as int,
      totalTokens: null == totalTokens
          ? _value.totalTokens
          : totalTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepCompletionUsageImpl extends _RunStepCompletionUsage {
  const _$RunStepCompletionUsageImpl(
      {@JsonKey(name: 'completion_tokens') required this.completionTokens,
      @JsonKey(name: 'prompt_tokens') required this.promptTokens,
      @JsonKey(name: 'total_tokens') required this.totalTokens})
      : super._();

  factory _$RunStepCompletionUsageImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepCompletionUsageImplFromJson(json);

  /// Number of completion tokens used over the course of the run step.
  @override
  @JsonKey(name: 'completion_tokens')
  final int completionTokens;

  /// Number of prompt tokens used over the course of the run step.
  @override
  @JsonKey(name: 'prompt_tokens')
  final int promptTokens;

  /// Total number of tokens used (prompt + completion).
  @override
  @JsonKey(name: 'total_tokens')
  final int totalTokens;

  @override
  String toString() {
    return 'RunStepCompletionUsage(completionTokens: $completionTokens, promptTokens: $promptTokens, totalTokens: $totalTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepCompletionUsageImpl &&
            (identical(other.completionTokens, completionTokens) ||
                other.completionTokens == completionTokens) &&
            (identical(other.promptTokens, promptTokens) ||
                other.promptTokens == promptTokens) &&
            (identical(other.totalTokens, totalTokens) ||
                other.totalTokens == totalTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, completionTokens, promptTokens, totalTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepCompletionUsageImplCopyWith<_$RunStepCompletionUsageImpl>
      get copyWith => __$$RunStepCompletionUsageImplCopyWithImpl<
          _$RunStepCompletionUsageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepCompletionUsageImplToJson(
      this,
    );
  }
}

abstract class _RunStepCompletionUsage extends RunStepCompletionUsage {
  const factory _RunStepCompletionUsage(
      {@JsonKey(name: 'completion_tokens') required final int completionTokens,
      @JsonKey(name: 'prompt_tokens') required final int promptTokens,
      @JsonKey(name: 'total_tokens')
      required final int totalTokens}) = _$RunStepCompletionUsageImpl;
  const _RunStepCompletionUsage._() : super._();

  factory _RunStepCompletionUsage.fromJson(Map<String, dynamic> json) =
      _$RunStepCompletionUsageImpl.fromJson;

  @override

  /// Number of completion tokens used over the course of the run step.
  @JsonKey(name: 'completion_tokens')
  int get completionTokens;
  @override

  /// Number of prompt tokens used over the course of the run step.
  @JsonKey(name: 'prompt_tokens')
  int get promptTokens;
  @override

  /// Total number of tokens used (prompt + completion).
  @JsonKey(name: 'total_tokens')
  int get totalTokens;
  @override
  @JsonKey(ignore: true)
  _$$RunStepCompletionUsageImplCopyWith<_$RunStepCompletionUsageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

VectorStoreExpirationAfter _$VectorStoreExpirationAfterFromJson(
    Map<String, dynamic> json) {
  return _VectorStoreExpirationAfter.fromJson(json);
}

/// @nodoc
mixin _$VectorStoreExpirationAfter {
  /// Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
  VectorStoreExpirationAfterAnchor get anchor =>
      throw _privateConstructorUsedError;

  /// The number of days after the anchor time that the vector store will expire.
  int get days => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VectorStoreExpirationAfterCopyWith<VectorStoreExpirationAfter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VectorStoreExpirationAfterCopyWith<$Res> {
  factory $VectorStoreExpirationAfterCopyWith(VectorStoreExpirationAfter value,
          $Res Function(VectorStoreExpirationAfter) then) =
      _$VectorStoreExpirationAfterCopyWithImpl<$Res,
          VectorStoreExpirationAfter>;
  @useResult
  $Res call({VectorStoreExpirationAfterAnchor anchor, int days});
}

/// @nodoc
class _$VectorStoreExpirationAfterCopyWithImpl<$Res,
        $Val extends VectorStoreExpirationAfter>
    implements $VectorStoreExpirationAfterCopyWith<$Res> {
  _$VectorStoreExpirationAfterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? anchor = null,
    Object? days = null,
  }) {
    return _then(_value.copyWith(
      anchor: null == anchor
          ? _value.anchor
          : anchor // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfterAnchor,
      days: null == days
          ? _value.days
          : days // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VectorStoreExpirationAfterImplCopyWith<$Res>
    implements $VectorStoreExpirationAfterCopyWith<$Res> {
  factory _$$VectorStoreExpirationAfterImplCopyWith(
          _$VectorStoreExpirationAfterImpl value,
          $Res Function(_$VectorStoreExpirationAfterImpl) then) =
      __$$VectorStoreExpirationAfterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({VectorStoreExpirationAfterAnchor anchor, int days});
}

/// @nodoc
class __$$VectorStoreExpirationAfterImplCopyWithImpl<$Res>
    extends _$VectorStoreExpirationAfterCopyWithImpl<$Res,
        _$VectorStoreExpirationAfterImpl>
    implements _$$VectorStoreExpirationAfterImplCopyWith<$Res> {
  __$$VectorStoreExpirationAfterImplCopyWithImpl(
      _$VectorStoreExpirationAfterImpl _value,
      $Res Function(_$VectorStoreExpirationAfterImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? anchor = null,
    Object? days = null,
  }) {
    return _then(_$VectorStoreExpirationAfterImpl(
      anchor: null == anchor
          ? _value.anchor
          : anchor // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfterAnchor,
      days: null == days
          ? _value.days
          : days // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VectorStoreExpirationAfterImpl extends _VectorStoreExpirationAfter {
  const _$VectorStoreExpirationAfterImpl(
      {required this.anchor, required this.days})
      : super._();

  factory _$VectorStoreExpirationAfterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$VectorStoreExpirationAfterImplFromJson(json);

  /// Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
  @override
  final VectorStoreExpirationAfterAnchor anchor;

  /// The number of days after the anchor time that the vector store will expire.
  @override
  final int days;

  @override
  String toString() {
    return 'VectorStoreExpirationAfter(anchor: $anchor, days: $days)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VectorStoreExpirationAfterImpl &&
            (identical(other.anchor, anchor) || other.anchor == anchor) &&
            (identical(other.days, days) || other.days == days));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, anchor, days);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VectorStoreExpirationAfterImplCopyWith<_$VectorStoreExpirationAfterImpl>
      get copyWith => __$$VectorStoreExpirationAfterImplCopyWithImpl<
          _$VectorStoreExpirationAfterImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VectorStoreExpirationAfterImplToJson(
      this,
    );
  }
}

abstract class _VectorStoreExpirationAfter extends VectorStoreExpirationAfter {
  const factory _VectorStoreExpirationAfter(
      {required final VectorStoreExpirationAfterAnchor anchor,
      required final int days}) = _$VectorStoreExpirationAfterImpl;
  const _VectorStoreExpirationAfter._() : super._();

  factory _VectorStoreExpirationAfter.fromJson(Map<String, dynamic> json) =
      _$VectorStoreExpirationAfterImpl.fromJson;

  @override

  /// Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
  VectorStoreExpirationAfterAnchor get anchor;
  @override

  /// The number of days after the anchor time that the vector store will expire.
  int get days;
  @override
  @JsonKey(ignore: true)
  _$$VectorStoreExpirationAfterImplCopyWith<_$VectorStoreExpirationAfterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

VectorStoreObject _$VectorStoreObjectFromJson(Map<String, dynamic> json) {
  return _VectorStoreObject.fromJson(json);
}

/// @nodoc
mixin _$VectorStoreObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `vector_store`.
  String get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the vector store was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The name of the vector store.
  String? get name => throw _privateConstructorUsedError;

  /// The total number of bytes used by the files in the vector store.
  @JsonKey(name: 'usage_bytes')
  int get usageBytes => throw _privateConstructorUsedError;

  /// The number of files in the vector store.
  @JsonKey(name: 'file_counts')
  VectorStoreObjectFileCounts get fileCounts =>
      throw _privateConstructorUsedError;

  /// The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
  VectorStoreObjectStatus get status => throw _privateConstructorUsedError;

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter =>
      throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the vector store will expire.
  @JsonKey(name: 'expires_at', includeIfNull: false)
  int? get expiresAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the vector store was last active.
  @JsonKey(name: 'last_active_at')
  int? get lastActiveAt => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  dynamic get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VectorStoreObjectCopyWith<VectorStoreObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VectorStoreObjectCopyWith<$Res> {
  factory $VectorStoreObjectCopyWith(
          VectorStoreObject value, $Res Function(VectorStoreObject) then) =
      _$VectorStoreObjectCopyWithImpl<$Res, VectorStoreObject>;
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'file_counts') VectorStoreObjectFileCounts fileCounts,
      VectorStoreObjectStatus status,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'last_active_at') int? lastActiveAt,
      dynamic metadata});

  $VectorStoreObjectFileCountsCopyWith<$Res> get fileCounts;
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class _$VectorStoreObjectCopyWithImpl<$Res, $Val extends VectorStoreObject>
    implements $VectorStoreObjectCopyWith<$Res> {
  _$VectorStoreObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? usageBytes = null,
    Object? fileCounts = null,
    Object? status = null,
    Object? expiresAfter = freezed,
    Object? expiresAt = freezed,
    Object? lastActiveAt = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      usageBytes: null == usageBytes
          ? _value.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      fileCounts: null == fileCounts
          ? _value.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectFileCounts,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectStatus,
      expiresAfter: freezed == expiresAfter
          ? _value.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      lastActiveAt: freezed == lastActiveAt
          ? _value.lastActiveAt
          : lastActiveAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VectorStoreObjectFileCountsCopyWith<$Res> get fileCounts {
    return $VectorStoreObjectFileCountsCopyWith<$Res>(_value.fileCounts,
        (value) {
      return _then(_value.copyWith(fileCounts: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_value.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_value.expiresAfter!,
        (value) {
      return _then(_value.copyWith(expiresAfter: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$VectorStoreObjectImplCopyWith<$Res>
    implements $VectorStoreObjectCopyWith<$Res> {
  factory _$$VectorStoreObjectImplCopyWith(_$VectorStoreObjectImpl value,
          $Res Function(_$VectorStoreObjectImpl) then) =
      __$$VectorStoreObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      String? name,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'file_counts') VectorStoreObjectFileCounts fileCounts,
      VectorStoreObjectStatus status,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'last_active_at') int? lastActiveAt,
      dynamic metadata});

  @override
  $VectorStoreObjectFileCountsCopyWith<$Res> get fileCounts;
  @override
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class __$$VectorStoreObjectImplCopyWithImpl<$Res>
    extends _$VectorStoreObjectCopyWithImpl<$Res, _$VectorStoreObjectImpl>
    implements _$$VectorStoreObjectImplCopyWith<$Res> {
  __$$VectorStoreObjectImplCopyWithImpl(_$VectorStoreObjectImpl _value,
      $Res Function(_$VectorStoreObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? name = freezed,
    Object? usageBytes = null,
    Object? fileCounts = null,
    Object? status = null,
    Object? expiresAfter = freezed,
    Object? expiresAt = freezed,
    Object? lastActiveAt = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$VectorStoreObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      usageBytes: null == usageBytes
          ? _value.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      fileCounts: null == fileCounts
          ? _value.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectFileCounts,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreObjectStatus,
      expiresAfter: freezed == expiresAfter
          ? _value.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      lastActiveAt: freezed == lastActiveAt
          ? _value.lastActiveAt
          : lastActiveAt // ignore: cast_nullable_to_non_nullable
              as int?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VectorStoreObjectImpl extends _VectorStoreObject {
  const _$VectorStoreObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      required this.name,
      @JsonKey(name: 'usage_bytes') required this.usageBytes,
      @JsonKey(name: 'file_counts') required this.fileCounts,
      required this.status,
      @JsonKey(name: 'expires_after', includeIfNull: false) this.expiresAfter,
      @JsonKey(name: 'expires_at', includeIfNull: false) this.expiresAt,
      @JsonKey(name: 'last_active_at') required this.lastActiveAt,
      required this.metadata})
      : super._();

  factory _$VectorStoreObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$VectorStoreObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `vector_store`.
  @override
  final String object;

  /// The Unix timestamp (in seconds) for when the vector store was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The name of the vector store.
  @override
  final String? name;

  /// The total number of bytes used by the files in the vector store.
  @override
  @JsonKey(name: 'usage_bytes')
  final int usageBytes;

  /// The number of files in the vector store.
  @override
  @JsonKey(name: 'file_counts')
  final VectorStoreObjectFileCounts fileCounts;

  /// The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
  @override
  final VectorStoreObjectStatus status;

  /// The expiration policy for a vector store.
  @override
  @JsonKey(name: 'expires_after', includeIfNull: false)
  final VectorStoreExpirationAfter? expiresAfter;

  /// The Unix timestamp (in seconds) for when the vector store will expire.
  @override
  @JsonKey(name: 'expires_at', includeIfNull: false)
  final int? expiresAt;

  /// The Unix timestamp (in seconds) for when the vector store was last active.
  @override
  @JsonKey(name: 'last_active_at')
  final int? lastActiveAt;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  final dynamic metadata;

  @override
  String toString() {
    return 'VectorStoreObject(id: $id, object: $object, createdAt: $createdAt, name: $name, usageBytes: $usageBytes, fileCounts: $fileCounts, status: $status, expiresAfter: $expiresAfter, expiresAt: $expiresAt, lastActiveAt: $lastActiveAt, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VectorStoreObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.usageBytes, usageBytes) ||
                other.usageBytes == usageBytes) &&
            (identical(other.fileCounts, fileCounts) ||
                other.fileCounts == fileCounts) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.lastActiveAt, lastActiveAt) ||
                other.lastActiveAt == lastActiveAt) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      object,
      createdAt,
      name,
      usageBytes,
      fileCounts,
      status,
      expiresAfter,
      expiresAt,
      lastActiveAt,
      const DeepCollectionEquality().hash(metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VectorStoreObjectImplCopyWith<_$VectorStoreObjectImpl> get copyWith =>
      __$$VectorStoreObjectImplCopyWithImpl<_$VectorStoreObjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VectorStoreObjectImplToJson(
      this,
    );
  }
}

abstract class _VectorStoreObject extends VectorStoreObject {
  const factory _VectorStoreObject(
      {required final String id,
      required final String object,
      @JsonKey(name: 'created_at') required final int createdAt,
      required final String? name,
      @JsonKey(name: 'usage_bytes') required final int usageBytes,
      @JsonKey(name: 'file_counts')
      required final VectorStoreObjectFileCounts fileCounts,
      required final VectorStoreObjectStatus status,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      final VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'expires_at', includeIfNull: false) final int? expiresAt,
      @JsonKey(name: 'last_active_at') required final int? lastActiveAt,
      required final dynamic metadata}) = _$VectorStoreObjectImpl;
  const _VectorStoreObject._() : super._();

  factory _VectorStoreObject.fromJson(Map<String, dynamic> json) =
      _$VectorStoreObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `vector_store`.
  String get object;
  @override

  /// The Unix timestamp (in seconds) for when the vector store was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The name of the vector store.
  String? get name;
  @override

  /// The total number of bytes used by the files in the vector store.
  @JsonKey(name: 'usage_bytes')
  int get usageBytes;
  @override

  /// The number of files in the vector store.
  @JsonKey(name: 'file_counts')
  VectorStoreObjectFileCounts get fileCounts;
  @override

  /// The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
  VectorStoreObjectStatus get status;
  @override

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter;
  @override

  /// The Unix timestamp (in seconds) for when the vector store will expire.
  @JsonKey(name: 'expires_at', includeIfNull: false)
  int? get expiresAt;
  @override

  /// The Unix timestamp (in seconds) for when the vector store was last active.
  @JsonKey(name: 'last_active_at')
  int? get lastActiveAt;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  dynamic get metadata;
  @override
  @JsonKey(ignore: true)
  _$$VectorStoreObjectImplCopyWith<_$VectorStoreObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

VectorStoreObjectFileCounts _$VectorStoreObjectFileCountsFromJson(
    Map<String, dynamic> json) {
  return _VectorStoreObjectFileCounts.fromJson(json);
}

/// @nodoc
mixin _$VectorStoreObjectFileCounts {
  /// The number of files that are currently being processed.
  @JsonKey(name: 'in_progress')
  int get inProgress => throw _privateConstructorUsedError;

  /// The number of files that have been successfully processed.
  int get completed => throw _privateConstructorUsedError;

  /// The number of files that have failed to process.
  int get failed => throw _privateConstructorUsedError;

  /// The number of files that were cancelled.
  int get cancelled => throw _privateConstructorUsedError;

  /// The total number of files.
  int get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VectorStoreObjectFileCountsCopyWith<VectorStoreObjectFileCounts>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VectorStoreObjectFileCountsCopyWith<$Res> {
  factory $VectorStoreObjectFileCountsCopyWith(
          VectorStoreObjectFileCounts value,
          $Res Function(VectorStoreObjectFileCounts) then) =
      _$VectorStoreObjectFileCountsCopyWithImpl<$Res,
          VectorStoreObjectFileCounts>;
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class _$VectorStoreObjectFileCountsCopyWithImpl<$Res,
        $Val extends VectorStoreObjectFileCounts>
    implements $VectorStoreObjectFileCountsCopyWith<$Res> {
  _$VectorStoreObjectFileCountsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_value.copyWith(
      inProgress: null == inProgress
          ? _value.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _value.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _value.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VectorStoreObjectFileCountsImplCopyWith<$Res>
    implements $VectorStoreObjectFileCountsCopyWith<$Res> {
  factory _$$VectorStoreObjectFileCountsImplCopyWith(
          _$VectorStoreObjectFileCountsImpl value,
          $Res Function(_$VectorStoreObjectFileCountsImpl) then) =
      __$$VectorStoreObjectFileCountsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class __$$VectorStoreObjectFileCountsImplCopyWithImpl<$Res>
    extends _$VectorStoreObjectFileCountsCopyWithImpl<$Res,
        _$VectorStoreObjectFileCountsImpl>
    implements _$$VectorStoreObjectFileCountsImplCopyWith<$Res> {
  __$$VectorStoreObjectFileCountsImplCopyWithImpl(
      _$VectorStoreObjectFileCountsImpl _value,
      $Res Function(_$VectorStoreObjectFileCountsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_$VectorStoreObjectFileCountsImpl(
      inProgress: null == inProgress
          ? _value.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _value.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _value.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VectorStoreObjectFileCountsImpl extends _VectorStoreObjectFileCounts {
  const _$VectorStoreObjectFileCountsImpl(
      {@JsonKey(name: 'in_progress') required this.inProgress,
      required this.completed,
      required this.failed,
      required this.cancelled,
      required this.total})
      : super._();

  factory _$VectorStoreObjectFileCountsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$VectorStoreObjectFileCountsImplFromJson(json);

  /// The number of files that are currently being processed.
  @override
  @JsonKey(name: 'in_progress')
  final int inProgress;

  /// The number of files that have been successfully processed.
  @override
  final int completed;

  /// The number of files that have failed to process.
  @override
  final int failed;

  /// The number of files that were cancelled.
  @override
  final int cancelled;

  /// The total number of files.
  @override
  final int total;

  @override
  String toString() {
    return 'VectorStoreObjectFileCounts(inProgress: $inProgress, completed: $completed, failed: $failed, cancelled: $cancelled, total: $total)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VectorStoreObjectFileCountsImpl &&
            (identical(other.inProgress, inProgress) ||
                other.inProgress == inProgress) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed) &&
            (identical(other.cancelled, cancelled) ||
                other.cancelled == cancelled) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, inProgress, completed, failed, cancelled, total);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VectorStoreObjectFileCountsImplCopyWith<_$VectorStoreObjectFileCountsImpl>
      get copyWith => __$$VectorStoreObjectFileCountsImplCopyWithImpl<
          _$VectorStoreObjectFileCountsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VectorStoreObjectFileCountsImplToJson(
      this,
    );
  }
}

abstract class _VectorStoreObjectFileCounts
    extends VectorStoreObjectFileCounts {
  const factory _VectorStoreObjectFileCounts(
      {@JsonKey(name: 'in_progress') required final int inProgress,
      required final int completed,
      required final int failed,
      required final int cancelled,
      required final int total}) = _$VectorStoreObjectFileCountsImpl;
  const _VectorStoreObjectFileCounts._() : super._();

  factory _VectorStoreObjectFileCounts.fromJson(Map<String, dynamic> json) =
      _$VectorStoreObjectFileCountsImpl.fromJson;

  @override

  /// The number of files that are currently being processed.
  @JsonKey(name: 'in_progress')
  int get inProgress;
  @override

  /// The number of files that have been successfully processed.
  int get completed;
  @override

  /// The number of files that have failed to process.
  int get failed;
  @override

  /// The number of files that were cancelled.
  int get cancelled;
  @override

  /// The total number of files.
  int get total;
  @override
  @JsonKey(ignore: true)
  _$$VectorStoreObjectFileCountsImplCopyWith<_$VectorStoreObjectFileCountsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateVectorStoreRequest _$CreateVectorStoreRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateVectorStoreRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateVectorStoreRequest {
  /// The name of the vector store.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds => throw _privateConstructorUsedError;

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter =>
      throw _privateConstructorUsedError;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy =>
      throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateVectorStoreRequestCopyWith<CreateVectorStoreRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateVectorStoreRequestCopyWith<$Res> {
  factory $CreateVectorStoreRequestCopyWith(CreateVectorStoreRequest value,
          $Res Function(CreateVectorStoreRequest) then) =
      _$CreateVectorStoreRequestCopyWithImpl<$Res, CreateVectorStoreRequest>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$CreateVectorStoreRequestCopyWithImpl<$Res,
        $Val extends CreateVectorStoreRequest>
    implements $CreateVectorStoreRequestCopyWith<$Res> {
  _$CreateVectorStoreRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? fileIds = freezed,
    Object? expiresAfter = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIds: freezed == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      expiresAfter: freezed == expiresAfter
          ? _value.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_value.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_value.expiresAfter!,
        (value) {
      return _then(_value.copyWith(expiresAfter: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_value.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_value.chunkingStrategy!,
        (value) {
      return _then(_value.copyWith(chunkingStrategy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateVectorStoreRequestImplCopyWith<$Res>
    implements $CreateVectorStoreRequestCopyWith<$Res> {
  factory _$$CreateVectorStoreRequestImplCopyWith(
          _$CreateVectorStoreRequestImpl value,
          $Res Function(_$CreateVectorStoreRequestImpl) then) =
      __$$CreateVectorStoreRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'file_ids', includeIfNull: false) List<String>? fileIds,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$$CreateVectorStoreRequestImplCopyWithImpl<$Res>
    extends _$CreateVectorStoreRequestCopyWithImpl<$Res,
        _$CreateVectorStoreRequestImpl>
    implements _$$CreateVectorStoreRequestImplCopyWith<$Res> {
  __$$CreateVectorStoreRequestImplCopyWithImpl(
      _$CreateVectorStoreRequestImpl _value,
      $Res Function(_$CreateVectorStoreRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? fileIds = freezed,
    Object? expiresAfter = freezed,
    Object? chunkingStrategy = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateVectorStoreRequestImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIds: freezed == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      expiresAfter: freezed == expiresAfter
          ? _value.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateVectorStoreRequestImpl extends _CreateVectorStoreRequest {
  const _$CreateVectorStoreRequestImpl(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(name: 'file_ids', includeIfNull: false)
      final List<String>? fileIds,
      @JsonKey(name: 'expires_after', includeIfNull: false) this.expiresAfter,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy,
      @JsonKey(includeIfNull: false) this.metadata})
      : _fileIds = fileIds,
        super._();

  factory _$CreateVectorStoreRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateVectorStoreRequestImplFromJson(json);

  /// The name of the vector store.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  final List<String>? _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @override
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds {
    final value = _fileIds;
    if (value == null) return null;
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The expiration policy for a vector store.
  @override
  @JsonKey(name: 'expires_after', includeIfNull: false)
  final VectorStoreExpirationAfter? expiresAfter;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  @override
  String toString() {
    return 'CreateVectorStoreRequest(name: $name, fileIds: $fileIds, expiresAfter: $expiresAfter, chunkingStrategy: $chunkingStrategy, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateVectorStoreRequestImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      const DeepCollectionEquality().hash(_fileIds),
      expiresAfter,
      chunkingStrategy,
      const DeepCollectionEquality().hash(metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateVectorStoreRequestImplCopyWith<_$CreateVectorStoreRequestImpl>
      get copyWith => __$$CreateVectorStoreRequestImplCopyWithImpl<
          _$CreateVectorStoreRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateVectorStoreRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateVectorStoreRequest extends CreateVectorStoreRequest {
  const factory _CreateVectorStoreRequest(
          {@JsonKey(includeIfNull: false) final String? name,
          @JsonKey(name: 'file_ids', includeIfNull: false)
          final List<String>? fileIds,
          @JsonKey(name: 'expires_after', includeIfNull: false)
          final VectorStoreExpirationAfter? expiresAfter,
          @JsonKey(name: 'chunking_strategy', includeIfNull: false)
          final ChunkingStrategyRequestParam? chunkingStrategy,
          @JsonKey(includeIfNull: false) final dynamic metadata}) =
      _$CreateVectorStoreRequestImpl;
  const _CreateVectorStoreRequest._() : super._();

  factory _CreateVectorStoreRequest.fromJson(Map<String, dynamic> json) =
      _$CreateVectorStoreRequestImpl.fromJson;

  @override

  /// The name of the vector store.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_ids', includeIfNull: false)
  List<String>? get fileIds;
  @override

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter;
  @override

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateVectorStoreRequestImplCopyWith<_$CreateVectorStoreRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

UpdateVectorStoreRequest _$UpdateVectorStoreRequestFromJson(
    Map<String, dynamic> json) {
  return _UpdateVectorStoreRequest.fromJson(json);
}

/// @nodoc
mixin _$UpdateVectorStoreRequest {
  /// The name of the vector store.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter =>
      throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UpdateVectorStoreRequestCopyWith<UpdateVectorStoreRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateVectorStoreRequestCopyWith<$Res> {
  factory $UpdateVectorStoreRequestCopyWith(UpdateVectorStoreRequest value,
          $Res Function(UpdateVectorStoreRequest) then) =
      _$UpdateVectorStoreRequestCopyWithImpl<$Res, UpdateVectorStoreRequest>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class _$UpdateVectorStoreRequestCopyWithImpl<$Res,
        $Val extends UpdateVectorStoreRequest>
    implements $UpdateVectorStoreRequestCopyWith<$Res> {
  _$UpdateVectorStoreRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? expiresAfter = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAfter: freezed == expiresAfter
          ? _value.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter {
    if (_value.expiresAfter == null) {
      return null;
    }

    return $VectorStoreExpirationAfterCopyWith<$Res>(_value.expiresAfter!,
        (value) {
      return _then(_value.copyWith(expiresAfter: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$UpdateVectorStoreRequestImplCopyWith<$Res>
    implements $UpdateVectorStoreRequestCopyWith<$Res> {
  factory _$$UpdateVectorStoreRequestImplCopyWith(
          _$UpdateVectorStoreRequestImpl value,
          $Res Function(_$UpdateVectorStoreRequestImpl) then) =
      __$$UpdateVectorStoreRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'expires_after', includeIfNull: false)
      VectorStoreExpirationAfter? expiresAfter,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $VectorStoreExpirationAfterCopyWith<$Res>? get expiresAfter;
}

/// @nodoc
class __$$UpdateVectorStoreRequestImplCopyWithImpl<$Res>
    extends _$UpdateVectorStoreRequestCopyWithImpl<$Res,
        _$UpdateVectorStoreRequestImpl>
    implements _$$UpdateVectorStoreRequestImplCopyWith<$Res> {
  __$$UpdateVectorStoreRequestImplCopyWithImpl(
      _$UpdateVectorStoreRequestImpl _value,
      $Res Function(_$UpdateVectorStoreRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? expiresAfter = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$UpdateVectorStoreRequestImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      expiresAfter: freezed == expiresAfter
          ? _value.expiresAfter
          : expiresAfter // ignore: cast_nullable_to_non_nullable
              as VectorStoreExpirationAfter?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UpdateVectorStoreRequestImpl extends _UpdateVectorStoreRequest {
  const _$UpdateVectorStoreRequestImpl(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(name: 'expires_after', includeIfNull: false) this.expiresAfter,
      @JsonKey(includeIfNull: false) this.metadata})
      : super._();

  factory _$UpdateVectorStoreRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$UpdateVectorStoreRequestImplFromJson(json);

  /// The name of the vector store.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The expiration policy for a vector store.
  @override
  @JsonKey(name: 'expires_after', includeIfNull: false)
  final VectorStoreExpirationAfter? expiresAfter;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  @override
  String toString() {
    return 'UpdateVectorStoreRequest(name: $name, expiresAfter: $expiresAfter, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateVectorStoreRequestImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.expiresAfter, expiresAfter) ||
                other.expiresAfter == expiresAfter) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, expiresAfter,
      const DeepCollectionEquality().hash(metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateVectorStoreRequestImplCopyWith<_$UpdateVectorStoreRequestImpl>
      get copyWith => __$$UpdateVectorStoreRequestImplCopyWithImpl<
          _$UpdateVectorStoreRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UpdateVectorStoreRequestImplToJson(
      this,
    );
  }
}

abstract class _UpdateVectorStoreRequest extends UpdateVectorStoreRequest {
  const factory _UpdateVectorStoreRequest(
          {@JsonKey(includeIfNull: false) final String? name,
          @JsonKey(name: 'expires_after', includeIfNull: false)
          final VectorStoreExpirationAfter? expiresAfter,
          @JsonKey(includeIfNull: false) final dynamic metadata}) =
      _$UpdateVectorStoreRequestImpl;
  const _UpdateVectorStoreRequest._() : super._();

  factory _UpdateVectorStoreRequest.fromJson(Map<String, dynamic> json) =
      _$UpdateVectorStoreRequestImpl.fromJson;

  @override

  /// The name of the vector store.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The expiration policy for a vector store.
  @JsonKey(name: 'expires_after', includeIfNull: false)
  VectorStoreExpirationAfter? get expiresAfter;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;
  @override
  @JsonKey(ignore: true)
  _$$UpdateVectorStoreRequestImplCopyWith<_$UpdateVectorStoreRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListVectorStoresResponse _$ListVectorStoresResponseFromJson(
    Map<String, dynamic> json) {
  return _ListVectorStoresResponse.fromJson(json);
}

/// @nodoc
mixin _$ListVectorStoresResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// A list of assistant files.
  List<VectorStoreObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first assistant file in the list.
  @JsonKey(name: 'first_id')
  String? get firstId => throw _privateConstructorUsedError;

  /// The ID of the last assistant file in the list.
  @JsonKey(name: 'last_id')
  String? get lastId => throw _privateConstructorUsedError;

  /// Whether there are more assistant files available.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListVectorStoresResponseCopyWith<ListVectorStoresResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListVectorStoresResponseCopyWith<$Res> {
  factory $ListVectorStoresResponseCopyWith(ListVectorStoresResponse value,
          $Res Function(ListVectorStoresResponse) then) =
      _$ListVectorStoresResponseCopyWithImpl<$Res, ListVectorStoresResponse>;
  @useResult
  $Res call(
      {String object,
      List<VectorStoreObject> data,
      @JsonKey(name: 'first_id') String? firstId,
      @JsonKey(name: 'last_id') String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListVectorStoresResponseCopyWithImpl<$Res,
        $Val extends ListVectorStoresResponse>
    implements $ListVectorStoresResponseCopyWith<$Res> {
  _$ListVectorStoresResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreObject>,
      firstId: freezed == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListVectorStoresResponseImplCopyWith<$Res>
    implements $ListVectorStoresResponseCopyWith<$Res> {
  factory _$$ListVectorStoresResponseImplCopyWith(
          _$ListVectorStoresResponseImpl value,
          $Res Function(_$ListVectorStoresResponseImpl) then) =
      __$$ListVectorStoresResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<VectorStoreObject> data,
      @JsonKey(name: 'first_id') String? firstId,
      @JsonKey(name: 'last_id') String? lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListVectorStoresResponseImplCopyWithImpl<$Res>
    extends _$ListVectorStoresResponseCopyWithImpl<$Res,
        _$ListVectorStoresResponseImpl>
    implements _$$ListVectorStoresResponseImplCopyWith<$Res> {
  __$$ListVectorStoresResponseImplCopyWithImpl(
      _$ListVectorStoresResponseImpl _value,
      $Res Function(_$ListVectorStoresResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
  }) {
    return _then(_$ListVectorStoresResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreObject>,
      firstId: freezed == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListVectorStoresResponseImpl extends _ListVectorStoresResponse {
  const _$ListVectorStoresResponseImpl(
      {required this.object,
      required final List<VectorStoreObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListVectorStoresResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListVectorStoresResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// A list of assistant files.
  final List<VectorStoreObject> _data;

  /// A list of assistant files.
  @override
  List<VectorStoreObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first assistant file in the list.
  @override
  @JsonKey(name: 'first_id')
  final String? firstId;

  /// The ID of the last assistant file in the list.
  @override
  @JsonKey(name: 'last_id')
  final String? lastId;

  /// Whether there are more assistant files available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListVectorStoresResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListVectorStoresResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListVectorStoresResponseImplCopyWith<_$ListVectorStoresResponseImpl>
      get copyWith => __$$ListVectorStoresResponseImplCopyWithImpl<
          _$ListVectorStoresResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListVectorStoresResponseImplToJson(
      this,
    );
  }
}

abstract class _ListVectorStoresResponse extends ListVectorStoresResponse {
  const factory _ListVectorStoresResponse(
          {required final String object,
          required final List<VectorStoreObject> data,
          @JsonKey(name: 'first_id') required final String? firstId,
          @JsonKey(name: 'last_id') required final String? lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListVectorStoresResponseImpl;
  const _ListVectorStoresResponse._() : super._();

  factory _ListVectorStoresResponse.fromJson(Map<String, dynamic> json) =
      _$ListVectorStoresResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// A list of assistant files.
  List<VectorStoreObject> get data;
  @override

  /// The ID of the first assistant file in the list.
  @JsonKey(name: 'first_id')
  String? get firstId;
  @override

  /// The ID of the last assistant file in the list.
  @JsonKey(name: 'last_id')
  String? get lastId;
  @override

  /// Whether there are more assistant files available.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListVectorStoresResponseImplCopyWith<_$ListVectorStoresResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteVectorStoreResponse _$DeleteVectorStoreResponseFromJson(
    Map<String, dynamic> json) {
  return _DeleteVectorStoreResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteVectorStoreResponse {
  /// The ID of the deleted vector store.
  String get id => throw _privateConstructorUsedError;

  /// Whether the vector store was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `vector_store.deleted`.
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteVectorStoreResponseCopyWith<DeleteVectorStoreResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteVectorStoreResponseCopyWith<$Res> {
  factory $DeleteVectorStoreResponseCopyWith(DeleteVectorStoreResponse value,
          $Res Function(DeleteVectorStoreResponse) then) =
      _$DeleteVectorStoreResponseCopyWithImpl<$Res, DeleteVectorStoreResponse>;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteVectorStoreResponseCopyWithImpl<$Res,
        $Val extends DeleteVectorStoreResponse>
    implements $DeleteVectorStoreResponseCopyWith<$Res> {
  _$DeleteVectorStoreResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteVectorStoreResponseImplCopyWith<$Res>
    implements $DeleteVectorStoreResponseCopyWith<$Res> {
  factory _$$DeleteVectorStoreResponseImplCopyWith(
          _$DeleteVectorStoreResponseImpl value,
          $Res Function(_$DeleteVectorStoreResponseImpl) then) =
      __$$DeleteVectorStoreResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$$DeleteVectorStoreResponseImplCopyWithImpl<$Res>
    extends _$DeleteVectorStoreResponseCopyWithImpl<$Res,
        _$DeleteVectorStoreResponseImpl>
    implements _$$DeleteVectorStoreResponseImplCopyWith<$Res> {
  __$$DeleteVectorStoreResponseImplCopyWithImpl(
      _$DeleteVectorStoreResponseImpl _value,
      $Res Function(_$DeleteVectorStoreResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteVectorStoreResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteVectorStoreResponseImpl extends _DeleteVectorStoreResponse {
  const _$DeleteVectorStoreResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteVectorStoreResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeleteVectorStoreResponseImplFromJson(json);

  /// The ID of the deleted vector store.
  @override
  final String id;

  /// Whether the vector store was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `vector_store.deleted`.
  @override
  final String object;

  @override
  String toString() {
    return 'DeleteVectorStoreResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteVectorStoreResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteVectorStoreResponseImplCopyWith<_$DeleteVectorStoreResponseImpl>
      get copyWith => __$$DeleteVectorStoreResponseImplCopyWithImpl<
          _$DeleteVectorStoreResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteVectorStoreResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteVectorStoreResponse extends DeleteVectorStoreResponse {
  const factory _DeleteVectorStoreResponse(
      {required final String id,
      required final bool deleted,
      required final String object}) = _$DeleteVectorStoreResponseImpl;
  const _DeleteVectorStoreResponse._() : super._();

  factory _DeleteVectorStoreResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteVectorStoreResponseImpl.fromJson;

  @override

  /// The ID of the deleted vector store.
  String get id;
  @override

  /// Whether the vector store was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `vector_store.deleted`.
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteVectorStoreResponseImplCopyWith<_$DeleteVectorStoreResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

VectorStoreFileObject _$VectorStoreFileObjectFromJson(
    Map<String, dynamic> json) {
  return _VectorStoreFileObject.fromJson(json);
}

/// @nodoc
mixin _$VectorStoreFileObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `vector_store.file`.
  String get object => throw _privateConstructorUsedError;

  /// The total vector store usage in bytes. Note that this may be different from the original file size.
  @JsonKey(name: 'usage_bytes')
  int get usageBytes => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the vector store file was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'vector_store_id')
  String get vectorStoreId => throw _privateConstructorUsedError;

  /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
  VectorStoreFileStatus get status => throw _privateConstructorUsedError;

  /// The last error associated with this vector store file. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  VectorStoreFileObjectLastError? get lastError =>
      throw _privateConstructorUsedError;

  /// The chunking strategy used to chunk the file(s).
  /// Any of: [StaticChunkingStrategyResponseParam], [OtherChunkingStrategyResponseParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyResponseParam? get chunkingStrategy =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VectorStoreFileObjectCopyWith<VectorStoreFileObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VectorStoreFileObjectCopyWith<$Res> {
  factory $VectorStoreFileObjectCopyWith(VectorStoreFileObject value,
          $Res Function(VectorStoreFileObject) then) =
      _$VectorStoreFileObjectCopyWithImpl<$Res, VectorStoreFileObject>;
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileStatus status,
      @JsonKey(name: 'last_error') VectorStoreFileObjectLastError? lastError,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyResponseParam? chunkingStrategy});

  $VectorStoreFileObjectLastErrorCopyWith<$Res>? get lastError;
  $ChunkingStrategyResponseParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$VectorStoreFileObjectCopyWithImpl<$Res,
        $Val extends VectorStoreFileObject>
    implements $VectorStoreFileObjectCopyWith<$Res> {
  _$VectorStoreFileObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? usageBytes = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? lastError = freezed,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usageBytes: null == usageBytes
          ? _value.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _value.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileStatus,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastError?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyResponseParam?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VectorStoreFileObjectLastErrorCopyWith<$Res>? get lastError {
    if (_value.lastError == null) {
      return null;
    }

    return $VectorStoreFileObjectLastErrorCopyWith<$Res>(_value.lastError!,
        (value) {
      return _then(_value.copyWith(lastError: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyResponseParamCopyWith<$Res>? get chunkingStrategy {
    if (_value.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyResponseParamCopyWith<$Res>(
        _value.chunkingStrategy!, (value) {
      return _then(_value.copyWith(chunkingStrategy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$VectorStoreFileObjectImplCopyWith<$Res>
    implements $VectorStoreFileObjectCopyWith<$Res> {
  factory _$$VectorStoreFileObjectImplCopyWith(
          _$VectorStoreFileObjectImpl value,
          $Res Function(_$VectorStoreFileObjectImpl) then) =
      __$$VectorStoreFileObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'usage_bytes') int usageBytes,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileStatus status,
      @JsonKey(name: 'last_error') VectorStoreFileObjectLastError? lastError,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyResponseParam? chunkingStrategy});

  @override
  $VectorStoreFileObjectLastErrorCopyWith<$Res>? get lastError;
  @override
  $ChunkingStrategyResponseParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$$VectorStoreFileObjectImplCopyWithImpl<$Res>
    extends _$VectorStoreFileObjectCopyWithImpl<$Res,
        _$VectorStoreFileObjectImpl>
    implements _$$VectorStoreFileObjectImplCopyWith<$Res> {
  __$$VectorStoreFileObjectImplCopyWithImpl(_$VectorStoreFileObjectImpl _value,
      $Res Function(_$VectorStoreFileObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? usageBytes = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? lastError = freezed,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_$VectorStoreFileObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      usageBytes: null == usageBytes
          ? _value.usageBytes
          : usageBytes // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _value.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileStatus,
      lastError: freezed == lastError
          ? _value.lastError
          : lastError // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastError?,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyResponseParam?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VectorStoreFileObjectImpl extends _VectorStoreFileObject {
  const _$VectorStoreFileObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'usage_bytes') required this.usageBytes,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'vector_store_id') required this.vectorStoreId,
      required this.status,
      @JsonKey(name: 'last_error') required this.lastError,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy})
      : super._();

  factory _$VectorStoreFileObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$VectorStoreFileObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `vector_store.file`.
  @override
  final String object;

  /// The total vector store usage in bytes. Note that this may be different from the original file size.
  @override
  @JsonKey(name: 'usage_bytes')
  final int usageBytes;

  /// The Unix timestamp (in seconds) for when the vector store file was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @override
  @JsonKey(name: 'vector_store_id')
  final String vectorStoreId;

  /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
  @override
  final VectorStoreFileStatus status;

  /// The last error associated with this vector store file. Will be `null` if there are no errors.
  @override
  @JsonKey(name: 'last_error')
  final VectorStoreFileObjectLastError? lastError;

  /// The chunking strategy used to chunk the file(s).
  /// Any of: [StaticChunkingStrategyResponseParam], [OtherChunkingStrategyResponseParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyResponseParam? chunkingStrategy;

  @override
  String toString() {
    return 'VectorStoreFileObject(id: $id, object: $object, usageBytes: $usageBytes, createdAt: $createdAt, vectorStoreId: $vectorStoreId, status: $status, lastError: $lastError, chunkingStrategy: $chunkingStrategy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VectorStoreFileObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.usageBytes, usageBytes) ||
                other.usageBytes == usageBytes) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.vectorStoreId, vectorStoreId) ||
                other.vectorStoreId == vectorStoreId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.lastError, lastError) ||
                other.lastError == lastError) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, object, usageBytes,
      createdAt, vectorStoreId, status, lastError, chunkingStrategy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VectorStoreFileObjectImplCopyWith<_$VectorStoreFileObjectImpl>
      get copyWith => __$$VectorStoreFileObjectImplCopyWithImpl<
          _$VectorStoreFileObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VectorStoreFileObjectImplToJson(
      this,
    );
  }
}

abstract class _VectorStoreFileObject extends VectorStoreFileObject {
  const factory _VectorStoreFileObject(
          {required final String id,
          required final String object,
          @JsonKey(name: 'usage_bytes') required final int usageBytes,
          @JsonKey(name: 'created_at') required final int createdAt,
          @JsonKey(name: 'vector_store_id') required final String vectorStoreId,
          required final VectorStoreFileStatus status,
          @JsonKey(name: 'last_error')
          required final VectorStoreFileObjectLastError? lastError,
          @JsonKey(name: 'chunking_strategy', includeIfNull: false)
          final ChunkingStrategyResponseParam? chunkingStrategy}) =
      _$VectorStoreFileObjectImpl;
  const _VectorStoreFileObject._() : super._();

  factory _VectorStoreFileObject.fromJson(Map<String, dynamic> json) =
      _$VectorStoreFileObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `vector_store.file`.
  String get object;
  @override

  /// The total vector store usage in bytes. Note that this may be different from the original file size.
  @JsonKey(name: 'usage_bytes')
  int get usageBytes;
  @override

  /// The Unix timestamp (in seconds) for when the vector store file was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'vector_store_id')
  String get vectorStoreId;
  @override

  /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
  VectorStoreFileStatus get status;
  @override

  /// The last error associated with this vector store file. Will be `null` if there are no errors.
  @JsonKey(name: 'last_error')
  VectorStoreFileObjectLastError? get lastError;
  @override

  /// The chunking strategy used to chunk the file(s).
  /// Any of: [StaticChunkingStrategyResponseParam], [OtherChunkingStrategyResponseParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyResponseParam? get chunkingStrategy;
  @override
  @JsonKey(ignore: true)
  _$$VectorStoreFileObjectImplCopyWith<_$VectorStoreFileObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

VectorStoreFileObjectLastError _$VectorStoreFileObjectLastErrorFromJson(
    Map<String, dynamic> json) {
  return _VectorStoreFileObjectLastError.fromJson(json);
}

/// @nodoc
mixin _$VectorStoreFileObjectLastError {
  /// One of `server_error` or `rate_limit_exceeded`.
  VectorStoreFileObjectLastErrorCode get code =>
      throw _privateConstructorUsedError;

  /// A human-readable description of the error.
  String get message => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VectorStoreFileObjectLastErrorCopyWith<VectorStoreFileObjectLastError>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VectorStoreFileObjectLastErrorCopyWith<$Res> {
  factory $VectorStoreFileObjectLastErrorCopyWith(
          VectorStoreFileObjectLastError value,
          $Res Function(VectorStoreFileObjectLastError) then) =
      _$VectorStoreFileObjectLastErrorCopyWithImpl<$Res,
          VectorStoreFileObjectLastError>;
  @useResult
  $Res call({VectorStoreFileObjectLastErrorCode code, String message});
}

/// @nodoc
class _$VectorStoreFileObjectLastErrorCopyWithImpl<$Res,
        $Val extends VectorStoreFileObjectLastError>
    implements $VectorStoreFileObjectLastErrorCopyWith<$Res> {
  _$VectorStoreFileObjectLastErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VectorStoreFileObjectLastErrorImplCopyWith<$Res>
    implements $VectorStoreFileObjectLastErrorCopyWith<$Res> {
  factory _$$VectorStoreFileObjectLastErrorImplCopyWith(
          _$VectorStoreFileObjectLastErrorImpl value,
          $Res Function(_$VectorStoreFileObjectLastErrorImpl) then) =
      __$$VectorStoreFileObjectLastErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({VectorStoreFileObjectLastErrorCode code, String message});
}

/// @nodoc
class __$$VectorStoreFileObjectLastErrorImplCopyWithImpl<$Res>
    extends _$VectorStoreFileObjectLastErrorCopyWithImpl<$Res,
        _$VectorStoreFileObjectLastErrorImpl>
    implements _$$VectorStoreFileObjectLastErrorImplCopyWith<$Res> {
  __$$VectorStoreFileObjectLastErrorImplCopyWithImpl(
      _$VectorStoreFileObjectLastErrorImpl _value,
      $Res Function(_$VectorStoreFileObjectLastErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? message = null,
  }) {
    return _then(_$VectorStoreFileObjectLastErrorImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileObjectLastErrorCode,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VectorStoreFileObjectLastErrorImpl
    extends _VectorStoreFileObjectLastError {
  const _$VectorStoreFileObjectLastErrorImpl(
      {required this.code, required this.message})
      : super._();

  factory _$VectorStoreFileObjectLastErrorImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$VectorStoreFileObjectLastErrorImplFromJson(json);

  /// One of `server_error` or `rate_limit_exceeded`.
  @override
  final VectorStoreFileObjectLastErrorCode code;

  /// A human-readable description of the error.
  @override
  final String message;

  @override
  String toString() {
    return 'VectorStoreFileObjectLastError(code: $code, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VectorStoreFileObjectLastErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VectorStoreFileObjectLastErrorImplCopyWith<
          _$VectorStoreFileObjectLastErrorImpl>
      get copyWith => __$$VectorStoreFileObjectLastErrorImplCopyWithImpl<
          _$VectorStoreFileObjectLastErrorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VectorStoreFileObjectLastErrorImplToJson(
      this,
    );
  }
}

abstract class _VectorStoreFileObjectLastError
    extends VectorStoreFileObjectLastError {
  const factory _VectorStoreFileObjectLastError(
      {required final VectorStoreFileObjectLastErrorCode code,
      required final String message}) = _$VectorStoreFileObjectLastErrorImpl;
  const _VectorStoreFileObjectLastError._() : super._();

  factory _VectorStoreFileObjectLastError.fromJson(Map<String, dynamic> json) =
      _$VectorStoreFileObjectLastErrorImpl.fromJson;

  @override

  /// One of `server_error` or `rate_limit_exceeded`.
  VectorStoreFileObjectLastErrorCode get code;
  @override

  /// A human-readable description of the error.
  String get message;
  @override
  @JsonKey(ignore: true)
  _$$VectorStoreFileObjectLastErrorImplCopyWith<
          _$VectorStoreFileObjectLastErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

StaticChunkingStrategy _$StaticChunkingStrategyFromJson(
    Map<String, dynamic> json) {
  return _StaticChunkingStrategy.fromJson(json);
}

/// @nodoc
mixin _$StaticChunkingStrategy {
  /// The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the
  /// maximum value is `4096`.
  @JsonKey(name: 'max_chunk_size_tokens')
  int get maxChunkSizeTokens => throw _privateConstructorUsedError;

  /// The number of tokens that overlap between chunks. The default value is `400`.
  ///
  /// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
  @JsonKey(name: 'chunk_overlap_tokens')
  int get chunkOverlapTokens => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StaticChunkingStrategyCopyWith<StaticChunkingStrategy> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StaticChunkingStrategyCopyWith<$Res> {
  factory $StaticChunkingStrategyCopyWith(StaticChunkingStrategy value,
          $Res Function(StaticChunkingStrategy) then) =
      _$StaticChunkingStrategyCopyWithImpl<$Res, StaticChunkingStrategy>;
  @useResult
  $Res call(
      {@JsonKey(name: 'max_chunk_size_tokens') int maxChunkSizeTokens,
      @JsonKey(name: 'chunk_overlap_tokens') int chunkOverlapTokens});
}

/// @nodoc
class _$StaticChunkingStrategyCopyWithImpl<$Res,
        $Val extends StaticChunkingStrategy>
    implements $StaticChunkingStrategyCopyWith<$Res> {
  _$StaticChunkingStrategyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? maxChunkSizeTokens = null,
    Object? chunkOverlapTokens = null,
  }) {
    return _then(_value.copyWith(
      maxChunkSizeTokens: null == maxChunkSizeTokens
          ? _value.maxChunkSizeTokens
          : maxChunkSizeTokens // ignore: cast_nullable_to_non_nullable
              as int,
      chunkOverlapTokens: null == chunkOverlapTokens
          ? _value.chunkOverlapTokens
          : chunkOverlapTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StaticChunkingStrategyImplCopyWith<$Res>
    implements $StaticChunkingStrategyCopyWith<$Res> {
  factory _$$StaticChunkingStrategyImplCopyWith(
          _$StaticChunkingStrategyImpl value,
          $Res Function(_$StaticChunkingStrategyImpl) then) =
      __$$StaticChunkingStrategyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'max_chunk_size_tokens') int maxChunkSizeTokens,
      @JsonKey(name: 'chunk_overlap_tokens') int chunkOverlapTokens});
}

/// @nodoc
class __$$StaticChunkingStrategyImplCopyWithImpl<$Res>
    extends _$StaticChunkingStrategyCopyWithImpl<$Res,
        _$StaticChunkingStrategyImpl>
    implements _$$StaticChunkingStrategyImplCopyWith<$Res> {
  __$$StaticChunkingStrategyImplCopyWithImpl(
      _$StaticChunkingStrategyImpl _value,
      $Res Function(_$StaticChunkingStrategyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? maxChunkSizeTokens = null,
    Object? chunkOverlapTokens = null,
  }) {
    return _then(_$StaticChunkingStrategyImpl(
      maxChunkSizeTokens: null == maxChunkSizeTokens
          ? _value.maxChunkSizeTokens
          : maxChunkSizeTokens // ignore: cast_nullable_to_non_nullable
              as int,
      chunkOverlapTokens: null == chunkOverlapTokens
          ? _value.chunkOverlapTokens
          : chunkOverlapTokens // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StaticChunkingStrategyImpl extends _StaticChunkingStrategy {
  const _$StaticChunkingStrategyImpl(
      {@JsonKey(name: 'max_chunk_size_tokens') required this.maxChunkSizeTokens,
      @JsonKey(name: 'chunk_overlap_tokens') required this.chunkOverlapTokens})
      : super._();

  factory _$StaticChunkingStrategyImpl.fromJson(Map<String, dynamic> json) =>
      _$$StaticChunkingStrategyImplFromJson(json);

  /// The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the
  /// maximum value is `4096`.
  @override
  @JsonKey(name: 'max_chunk_size_tokens')
  final int maxChunkSizeTokens;

  /// The number of tokens that overlap between chunks. The default value is `400`.
  ///
  /// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
  @override
  @JsonKey(name: 'chunk_overlap_tokens')
  final int chunkOverlapTokens;

  @override
  String toString() {
    return 'StaticChunkingStrategy(maxChunkSizeTokens: $maxChunkSizeTokens, chunkOverlapTokens: $chunkOverlapTokens)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StaticChunkingStrategyImpl &&
            (identical(other.maxChunkSizeTokens, maxChunkSizeTokens) ||
                other.maxChunkSizeTokens == maxChunkSizeTokens) &&
            (identical(other.chunkOverlapTokens, chunkOverlapTokens) ||
                other.chunkOverlapTokens == chunkOverlapTokens));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, maxChunkSizeTokens, chunkOverlapTokens);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StaticChunkingStrategyImplCopyWith<_$StaticChunkingStrategyImpl>
      get copyWith => __$$StaticChunkingStrategyImplCopyWithImpl<
          _$StaticChunkingStrategyImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StaticChunkingStrategyImplToJson(
      this,
    );
  }
}

abstract class _StaticChunkingStrategy extends StaticChunkingStrategy {
  const factory _StaticChunkingStrategy(
      {@JsonKey(name: 'max_chunk_size_tokens')
      required final int maxChunkSizeTokens,
      @JsonKey(name: 'chunk_overlap_tokens')
      required final int chunkOverlapTokens}) = _$StaticChunkingStrategyImpl;
  const _StaticChunkingStrategy._() : super._();

  factory _StaticChunkingStrategy.fromJson(Map<String, dynamic> json) =
      _$StaticChunkingStrategyImpl.fromJson;

  @override

  /// The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the
  /// maximum value is `4096`.
  @JsonKey(name: 'max_chunk_size_tokens')
  int get maxChunkSizeTokens;
  @override

  /// The number of tokens that overlap between chunks. The default value is `400`.
  ///
  /// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
  @JsonKey(name: 'chunk_overlap_tokens')
  int get chunkOverlapTokens;
  @override
  @JsonKey(ignore: true)
  _$$StaticChunkingStrategyImplCopyWith<_$StaticChunkingStrategyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateVectorStoreFileRequest _$CreateVectorStoreFileRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateVectorStoreFileRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateVectorStoreFileRequest {
  /// A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateVectorStoreFileRequestCopyWith<CreateVectorStoreFileRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateVectorStoreFileRequestCopyWith<$Res> {
  factory $CreateVectorStoreFileRequestCopyWith(
          CreateVectorStoreFileRequest value,
          $Res Function(CreateVectorStoreFileRequest) then) =
      _$CreateVectorStoreFileRequestCopyWithImpl<$Res,
          CreateVectorStoreFileRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$CreateVectorStoreFileRequestCopyWithImpl<$Res,
        $Val extends CreateVectorStoreFileRequest>
    implements $CreateVectorStoreFileRequestCopyWith<$Res> {
  _$CreateVectorStoreFileRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_value.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_value.chunkingStrategy!,
        (value) {
      return _then(_value.copyWith(chunkingStrategy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateVectorStoreFileRequestImplCopyWith<$Res>
    implements $CreateVectorStoreFileRequestCopyWith<$Res> {
  factory _$$CreateVectorStoreFileRequestImplCopyWith(
          _$CreateVectorStoreFileRequestImpl value,
          $Res Function(_$CreateVectorStoreFileRequestImpl) then) =
      __$$CreateVectorStoreFileRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_id') String fileId,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$$CreateVectorStoreFileRequestImplCopyWithImpl<$Res>
    extends _$CreateVectorStoreFileRequestCopyWithImpl<$Res,
        _$CreateVectorStoreFileRequestImpl>
    implements _$$CreateVectorStoreFileRequestImplCopyWith<$Res> {
  __$$CreateVectorStoreFileRequestImplCopyWithImpl(
      _$CreateVectorStoreFileRequestImpl _value,
      $Res Function(_$CreateVectorStoreFileRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_$CreateVectorStoreFileRequestImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateVectorStoreFileRequestImpl extends _CreateVectorStoreFileRequest {
  const _$CreateVectorStoreFileRequestImpl(
      {@JsonKey(name: 'file_id') required this.fileId,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy})
      : super._();

  factory _$CreateVectorStoreFileRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateVectorStoreFileRequestImplFromJson(json);

  /// A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  @override
  String toString() {
    return 'CreateVectorStoreFileRequest(fileId: $fileId, chunkingStrategy: $chunkingStrategy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateVectorStoreFileRequestImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId, chunkingStrategy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateVectorStoreFileRequestImplCopyWith<
          _$CreateVectorStoreFileRequestImpl>
      get copyWith => __$$CreateVectorStoreFileRequestImplCopyWithImpl<
          _$CreateVectorStoreFileRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateVectorStoreFileRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateVectorStoreFileRequest
    extends CreateVectorStoreFileRequest {
  const factory _CreateVectorStoreFileRequest(
          {@JsonKey(name: 'file_id') required final String fileId,
          @JsonKey(name: 'chunking_strategy', includeIfNull: false)
          final ChunkingStrategyRequestParam? chunkingStrategy}) =
      _$CreateVectorStoreFileRequestImpl;
  const _CreateVectorStoreFileRequest._() : super._();

  factory _CreateVectorStoreFileRequest.fromJson(Map<String, dynamic> json) =
      _$CreateVectorStoreFileRequestImpl.fromJson;

  @override

  /// A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;
  @override
  @JsonKey(ignore: true)
  _$$CreateVectorStoreFileRequestImplCopyWith<
          _$CreateVectorStoreFileRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListVectorStoreFilesResponse _$ListVectorStoreFilesResponseFromJson(
    Map<String, dynamic> json) {
  return _ListVectorStoreFilesResponse.fromJson(json);
}

/// @nodoc
mixin _$ListVectorStoreFilesResponse {
  /// The object type, which is always `list`.
  String get object => throw _privateConstructorUsedError;

  /// A list of message files.
  List<VectorStoreFileObject> get data => throw _privateConstructorUsedError;

  /// The ID of the first message file in the list.
  @JsonKey(name: 'first_id')
  String get firstId => throw _privateConstructorUsedError;

  /// The ID of the last message file in the list.
  @JsonKey(name: 'last_id')
  String get lastId => throw _privateConstructorUsedError;

  /// Whether there are more message files available.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListVectorStoreFilesResponseCopyWith<ListVectorStoreFilesResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListVectorStoreFilesResponseCopyWith<$Res> {
  factory $ListVectorStoreFilesResponseCopyWith(
          ListVectorStoreFilesResponse value,
          $Res Function(ListVectorStoreFilesResponse) then) =
      _$ListVectorStoreFilesResponseCopyWithImpl<$Res,
          ListVectorStoreFilesResponse>;
  @useResult
  $Res call(
      {String object,
      List<VectorStoreFileObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class _$ListVectorStoreFilesResponseCopyWithImpl<$Res,
        $Val extends ListVectorStoreFilesResponse>
    implements $ListVectorStoreFilesResponseCopyWith<$Res> {
  _$ListVectorStoreFilesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreFileObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListVectorStoreFilesResponseImplCopyWith<$Res>
    implements $ListVectorStoreFilesResponseCopyWith<$Res> {
  factory _$$ListVectorStoreFilesResponseImplCopyWith(
          _$ListVectorStoreFilesResponseImpl value,
          $Res Function(_$ListVectorStoreFilesResponseImpl) then) =
      __$$ListVectorStoreFilesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      List<VectorStoreFileObject> data,
      @JsonKey(name: 'first_id') String firstId,
      @JsonKey(name: 'last_id') String lastId,
      @JsonKey(name: 'has_more') bool hasMore});
}

/// @nodoc
class __$$ListVectorStoreFilesResponseImplCopyWithImpl<$Res>
    extends _$ListVectorStoreFilesResponseCopyWithImpl<$Res,
        _$ListVectorStoreFilesResponseImpl>
    implements _$$ListVectorStoreFilesResponseImplCopyWith<$Res> {
  __$$ListVectorStoreFilesResponseImplCopyWithImpl(
      _$ListVectorStoreFilesResponseImpl _value,
      $Res Function(_$ListVectorStoreFilesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? data = null,
    Object? firstId = null,
    Object? lastId = null,
    Object? hasMore = null,
  }) {
    return _then(_$ListVectorStoreFilesResponseImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<VectorStoreFileObject>,
      firstId: null == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String,
      lastId: null == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListVectorStoreFilesResponseImpl extends _ListVectorStoreFilesResponse {
  const _$ListVectorStoreFilesResponseImpl(
      {required this.object,
      required final List<VectorStoreFileObject> data,
      @JsonKey(name: 'first_id') required this.firstId,
      @JsonKey(name: 'last_id') required this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore})
      : _data = data,
        super._();

  factory _$ListVectorStoreFilesResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ListVectorStoreFilesResponseImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  final String object;

  /// A list of message files.
  final List<VectorStoreFileObject> _data;

  /// A list of message files.
  @override
  List<VectorStoreFileObject> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first message file in the list.
  @override
  @JsonKey(name: 'first_id')
  final String firstId;

  /// The ID of the last message file in the list.
  @override
  @JsonKey(name: 'last_id')
  final String lastId;

  /// Whether there are more message files available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  @override
  String toString() {
    return 'ListVectorStoreFilesResponse(object: $object, data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListVectorStoreFilesResponseImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, object,
      const DeepCollectionEquality().hash(_data), firstId, lastId, hasMore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListVectorStoreFilesResponseImplCopyWith<
          _$ListVectorStoreFilesResponseImpl>
      get copyWith => __$$ListVectorStoreFilesResponseImplCopyWithImpl<
          _$ListVectorStoreFilesResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListVectorStoreFilesResponseImplToJson(
      this,
    );
  }
}

abstract class _ListVectorStoreFilesResponse
    extends ListVectorStoreFilesResponse {
  const factory _ListVectorStoreFilesResponse(
          {required final String object,
          required final List<VectorStoreFileObject> data,
          @JsonKey(name: 'first_id') required final String firstId,
          @JsonKey(name: 'last_id') required final String lastId,
          @JsonKey(name: 'has_more') required final bool hasMore}) =
      _$ListVectorStoreFilesResponseImpl;
  const _ListVectorStoreFilesResponse._() : super._();

  factory _ListVectorStoreFilesResponse.fromJson(Map<String, dynamic> json) =
      _$ListVectorStoreFilesResponseImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  String get object;
  @override

  /// A list of message files.
  List<VectorStoreFileObject> get data;
  @override

  /// The ID of the first message file in the list.
  @JsonKey(name: 'first_id')
  String get firstId;
  @override

  /// The ID of the last message file in the list.
  @JsonKey(name: 'last_id')
  String get lastId;
  @override

  /// Whether there are more message files available.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override
  @JsonKey(ignore: true)
  _$$ListVectorStoreFilesResponseImplCopyWith<
          _$ListVectorStoreFilesResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

DeleteVectorStoreFileResponse _$DeleteVectorStoreFileResponseFromJson(
    Map<String, dynamic> json) {
  return _DeleteVectorStoreFileResponse.fromJson(json);
}

/// @nodoc
mixin _$DeleteVectorStoreFileResponse {
  /// The ID of the deleted vector store file.
  String get id => throw _privateConstructorUsedError;

  /// Whether the vector store file was deleted.
  bool get deleted => throw _privateConstructorUsedError;

  /// The object type, which is always `vector_store.file.deleted`.
  String get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeleteVectorStoreFileResponseCopyWith<DeleteVectorStoreFileResponse>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteVectorStoreFileResponseCopyWith<$Res> {
  factory $DeleteVectorStoreFileResponseCopyWith(
          DeleteVectorStoreFileResponse value,
          $Res Function(DeleteVectorStoreFileResponse) then) =
      _$DeleteVectorStoreFileResponseCopyWithImpl<$Res,
          DeleteVectorStoreFileResponse>;
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class _$DeleteVectorStoreFileResponseCopyWithImpl<$Res,
        $Val extends DeleteVectorStoreFileResponse>
    implements $DeleteVectorStoreFileResponseCopyWith<$Res> {
  _$DeleteVectorStoreFileResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DeleteVectorStoreFileResponseImplCopyWith<$Res>
    implements $DeleteVectorStoreFileResponseCopyWith<$Res> {
  factory _$$DeleteVectorStoreFileResponseImplCopyWith(
          _$DeleteVectorStoreFileResponseImpl value,
          $Res Function(_$DeleteVectorStoreFileResponseImpl) then) =
      __$$DeleteVectorStoreFileResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, bool deleted, String object});
}

/// @nodoc
class __$$DeleteVectorStoreFileResponseImplCopyWithImpl<$Res>
    extends _$DeleteVectorStoreFileResponseCopyWithImpl<$Res,
        _$DeleteVectorStoreFileResponseImpl>
    implements _$$DeleteVectorStoreFileResponseImplCopyWith<$Res> {
  __$$DeleteVectorStoreFileResponseImplCopyWithImpl(
      _$DeleteVectorStoreFileResponseImpl _value,
      $Res Function(_$DeleteVectorStoreFileResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deleted = null,
    Object? object = null,
  }) {
    return _then(_$DeleteVectorStoreFileResponseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deleted: null == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DeleteVectorStoreFileResponseImpl
    extends _DeleteVectorStoreFileResponse {
  const _$DeleteVectorStoreFileResponseImpl(
      {required this.id, required this.deleted, required this.object})
      : super._();

  factory _$DeleteVectorStoreFileResponseImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$DeleteVectorStoreFileResponseImplFromJson(json);

  /// The ID of the deleted vector store file.
  @override
  final String id;

  /// Whether the vector store file was deleted.
  @override
  final bool deleted;

  /// The object type, which is always `vector_store.file.deleted`.
  @override
  final String object;

  @override
  String toString() {
    return 'DeleteVectorStoreFileResponse(id: $id, deleted: $deleted, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteVectorStoreFileResponseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deleted, object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteVectorStoreFileResponseImplCopyWith<
          _$DeleteVectorStoreFileResponseImpl>
      get copyWith => __$$DeleteVectorStoreFileResponseImplCopyWithImpl<
          _$DeleteVectorStoreFileResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DeleteVectorStoreFileResponseImplToJson(
      this,
    );
  }
}

abstract class _DeleteVectorStoreFileResponse
    extends DeleteVectorStoreFileResponse {
  const factory _DeleteVectorStoreFileResponse(
      {required final String id,
      required final bool deleted,
      required final String object}) = _$DeleteVectorStoreFileResponseImpl;
  const _DeleteVectorStoreFileResponse._() : super._();

  factory _DeleteVectorStoreFileResponse.fromJson(Map<String, dynamic> json) =
      _$DeleteVectorStoreFileResponseImpl.fromJson;

  @override

  /// The ID of the deleted vector store file.
  String get id;
  @override

  /// Whether the vector store file was deleted.
  bool get deleted;
  @override

  /// The object type, which is always `vector_store.file.deleted`.
  String get object;
  @override
  @JsonKey(ignore: true)
  _$$DeleteVectorStoreFileResponseImplCopyWith<
          _$DeleteVectorStoreFileResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

VectorStoreFileBatchObject _$VectorStoreFileBatchObjectFromJson(
    Map<String, dynamic> json) {
  return _VectorStoreFileBatchObject.fromJson(json);
}

/// @nodoc
mixin _$VectorStoreFileBatchObject {
  /// The identifier, which can be referenced in API endpoints.
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `vector_store.file_batch`.
  String get object => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the vector store files batch was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'vector_store_id')
  String get vectorStoreId => throw _privateConstructorUsedError;

  /// The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
  VectorStoreFileBatchObjectStatus get status =>
      throw _privateConstructorUsedError;

  /// The number of files per status.
  @JsonKey(name: 'file_counts')
  VectorStoreFileBatchObjectFileCounts get fileCounts =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VectorStoreFileBatchObjectCopyWith<VectorStoreFileBatchObject>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VectorStoreFileBatchObjectCopyWith<$Res> {
  factory $VectorStoreFileBatchObjectCopyWith(VectorStoreFileBatchObject value,
          $Res Function(VectorStoreFileBatchObject) then) =
      _$VectorStoreFileBatchObjectCopyWithImpl<$Res,
          VectorStoreFileBatchObject>;
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileBatchObjectStatus status,
      @JsonKey(name: 'file_counts')
      VectorStoreFileBatchObjectFileCounts fileCounts});

  $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> get fileCounts;
}

/// @nodoc
class _$VectorStoreFileBatchObjectCopyWithImpl<$Res,
        $Val extends VectorStoreFileBatchObject>
    implements $VectorStoreFileBatchObjectCopyWith<$Res> {
  _$VectorStoreFileBatchObjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? fileCounts = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _value.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectStatus,
      fileCounts: null == fileCounts
          ? _value.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectFileCounts,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> get fileCounts {
    return $VectorStoreFileBatchObjectFileCountsCopyWith<$Res>(
        _value.fileCounts, (value) {
      return _then(_value.copyWith(fileCounts: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$VectorStoreFileBatchObjectImplCopyWith<$Res>
    implements $VectorStoreFileBatchObjectCopyWith<$Res> {
  factory _$$VectorStoreFileBatchObjectImplCopyWith(
          _$VectorStoreFileBatchObjectImpl value,
          $Res Function(_$VectorStoreFileBatchObjectImpl) then) =
      __$$VectorStoreFileBatchObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String object,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'vector_store_id') String vectorStoreId,
      VectorStoreFileBatchObjectStatus status,
      @JsonKey(name: 'file_counts')
      VectorStoreFileBatchObjectFileCounts fileCounts});

  @override
  $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> get fileCounts;
}

/// @nodoc
class __$$VectorStoreFileBatchObjectImplCopyWithImpl<$Res>
    extends _$VectorStoreFileBatchObjectCopyWithImpl<$Res,
        _$VectorStoreFileBatchObjectImpl>
    implements _$$VectorStoreFileBatchObjectImplCopyWith<$Res> {
  __$$VectorStoreFileBatchObjectImplCopyWithImpl(
      _$VectorStoreFileBatchObjectImpl _value,
      $Res Function(_$VectorStoreFileBatchObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? createdAt = null,
    Object? vectorStoreId = null,
    Object? status = null,
    Object? fileCounts = null,
  }) {
    return _then(_$VectorStoreFileBatchObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      vectorStoreId: null == vectorStoreId
          ? _value.vectorStoreId
          : vectorStoreId // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectStatus,
      fileCounts: null == fileCounts
          ? _value.fileCounts
          : fileCounts // ignore: cast_nullable_to_non_nullable
              as VectorStoreFileBatchObjectFileCounts,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VectorStoreFileBatchObjectImpl extends _VectorStoreFileBatchObject {
  const _$VectorStoreFileBatchObjectImpl(
      {required this.id,
      required this.object,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'vector_store_id') required this.vectorStoreId,
      required this.status,
      @JsonKey(name: 'file_counts') required this.fileCounts})
      : super._();

  factory _$VectorStoreFileBatchObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$VectorStoreFileBatchObjectImplFromJson(json);

  /// The identifier, which can be referenced in API endpoints.
  @override
  final String id;

  /// The object type, which is always `vector_store.file_batch`.
  @override
  final String object;

  /// The Unix timestamp (in seconds) for when the vector store files batch was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @override
  @JsonKey(name: 'vector_store_id')
  final String vectorStoreId;

  /// The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
  @override
  final VectorStoreFileBatchObjectStatus status;

  /// The number of files per status.
  @override
  @JsonKey(name: 'file_counts')
  final VectorStoreFileBatchObjectFileCounts fileCounts;

  @override
  String toString() {
    return 'VectorStoreFileBatchObject(id: $id, object: $object, createdAt: $createdAt, vectorStoreId: $vectorStoreId, status: $status, fileCounts: $fileCounts)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VectorStoreFileBatchObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.vectorStoreId, vectorStoreId) ||
                other.vectorStoreId == vectorStoreId) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.fileCounts, fileCounts) ||
                other.fileCounts == fileCounts));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, object, createdAt, vectorStoreId, status, fileCounts);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VectorStoreFileBatchObjectImplCopyWith<_$VectorStoreFileBatchObjectImpl>
      get copyWith => __$$VectorStoreFileBatchObjectImplCopyWithImpl<
          _$VectorStoreFileBatchObjectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VectorStoreFileBatchObjectImplToJson(
      this,
    );
  }
}

abstract class _VectorStoreFileBatchObject extends VectorStoreFileBatchObject {
  const factory _VectorStoreFileBatchObject(
          {required final String id,
          required final String object,
          @JsonKey(name: 'created_at') required final int createdAt,
          @JsonKey(name: 'vector_store_id') required final String vectorStoreId,
          required final VectorStoreFileBatchObjectStatus status,
          @JsonKey(name: 'file_counts')
          required final VectorStoreFileBatchObjectFileCounts fileCounts}) =
      _$VectorStoreFileBatchObjectImpl;
  const _VectorStoreFileBatchObject._() : super._();

  factory _VectorStoreFileBatchObject.fromJson(Map<String, dynamic> json) =
      _$VectorStoreFileBatchObjectImpl.fromJson;

  @override

  /// The identifier, which can be referenced in API endpoints.
  String get id;
  @override

  /// The object type, which is always `vector_store.file_batch`.
  String get object;
  @override

  /// The Unix timestamp (in seconds) for when the vector store files batch was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.
  @JsonKey(name: 'vector_store_id')
  String get vectorStoreId;
  @override

  /// The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
  VectorStoreFileBatchObjectStatus get status;
  @override

  /// The number of files per status.
  @JsonKey(name: 'file_counts')
  VectorStoreFileBatchObjectFileCounts get fileCounts;
  @override
  @JsonKey(ignore: true)
  _$$VectorStoreFileBatchObjectImplCopyWith<_$VectorStoreFileBatchObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

VectorStoreFileBatchObjectFileCounts
    _$VectorStoreFileBatchObjectFileCountsFromJson(Map<String, dynamic> json) {
  return _VectorStoreFileBatchObjectFileCounts.fromJson(json);
}

/// @nodoc
mixin _$VectorStoreFileBatchObjectFileCounts {
  /// The number of files that are currently being processed.
  @JsonKey(name: 'in_progress')
  int get inProgress => throw _privateConstructorUsedError;

  /// The number of files that have been processed.
  int get completed => throw _privateConstructorUsedError;

  /// The number of files that have failed to process.
  int get failed => throw _privateConstructorUsedError;

  /// The number of files that where cancelled.
  int get cancelled => throw _privateConstructorUsedError;

  /// The total number of files.
  int get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VectorStoreFileBatchObjectFileCountsCopyWith<
          VectorStoreFileBatchObjectFileCounts>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> {
  factory $VectorStoreFileBatchObjectFileCountsCopyWith(
          VectorStoreFileBatchObjectFileCounts value,
          $Res Function(VectorStoreFileBatchObjectFileCounts) then) =
      _$VectorStoreFileBatchObjectFileCountsCopyWithImpl<$Res,
          VectorStoreFileBatchObjectFileCounts>;
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class _$VectorStoreFileBatchObjectFileCountsCopyWithImpl<$Res,
        $Val extends VectorStoreFileBatchObjectFileCounts>
    implements $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> {
  _$VectorStoreFileBatchObjectFileCountsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_value.copyWith(
      inProgress: null == inProgress
          ? _value.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _value.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _value.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VectorStoreFileBatchObjectFileCountsImplCopyWith<$Res>
    implements $VectorStoreFileBatchObjectFileCountsCopyWith<$Res> {
  factory _$$VectorStoreFileBatchObjectFileCountsImplCopyWith(
          _$VectorStoreFileBatchObjectFileCountsImpl value,
          $Res Function(_$VectorStoreFileBatchObjectFileCountsImpl) then) =
      __$$VectorStoreFileBatchObjectFileCountsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'in_progress') int inProgress,
      int completed,
      int failed,
      int cancelled,
      int total});
}

/// @nodoc
class __$$VectorStoreFileBatchObjectFileCountsImplCopyWithImpl<$Res>
    extends _$VectorStoreFileBatchObjectFileCountsCopyWithImpl<$Res,
        _$VectorStoreFileBatchObjectFileCountsImpl>
    implements _$$VectorStoreFileBatchObjectFileCountsImplCopyWith<$Res> {
  __$$VectorStoreFileBatchObjectFileCountsImplCopyWithImpl(
      _$VectorStoreFileBatchObjectFileCountsImpl _value,
      $Res Function(_$VectorStoreFileBatchObjectFileCountsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inProgress = null,
    Object? completed = null,
    Object? failed = null,
    Object? cancelled = null,
    Object? total = null,
  }) {
    return _then(_$VectorStoreFileBatchObjectFileCountsImpl(
      inProgress: null == inProgress
          ? _value.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _value.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
      cancelled: null == cancelled
          ? _value.cancelled
          : cancelled // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VectorStoreFileBatchObjectFileCountsImpl
    extends _VectorStoreFileBatchObjectFileCounts {
  const _$VectorStoreFileBatchObjectFileCountsImpl(
      {@JsonKey(name: 'in_progress') required this.inProgress,
      required this.completed,
      required this.failed,
      required this.cancelled,
      required this.total})
      : super._();

  factory _$VectorStoreFileBatchObjectFileCountsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$VectorStoreFileBatchObjectFileCountsImplFromJson(json);

  /// The number of files that are currently being processed.
  @override
  @JsonKey(name: 'in_progress')
  final int inProgress;

  /// The number of files that have been processed.
  @override
  final int completed;

  /// The number of files that have failed to process.
  @override
  final int failed;

  /// The number of files that where cancelled.
  @override
  final int cancelled;

  /// The total number of files.
  @override
  final int total;

  @override
  String toString() {
    return 'VectorStoreFileBatchObjectFileCounts(inProgress: $inProgress, completed: $completed, failed: $failed, cancelled: $cancelled, total: $total)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VectorStoreFileBatchObjectFileCountsImpl &&
            (identical(other.inProgress, inProgress) ||
                other.inProgress == inProgress) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed) &&
            (identical(other.cancelled, cancelled) ||
                other.cancelled == cancelled) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, inProgress, completed, failed, cancelled, total);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VectorStoreFileBatchObjectFileCountsImplCopyWith<
          _$VectorStoreFileBatchObjectFileCountsImpl>
      get copyWith => __$$VectorStoreFileBatchObjectFileCountsImplCopyWithImpl<
          _$VectorStoreFileBatchObjectFileCountsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VectorStoreFileBatchObjectFileCountsImplToJson(
      this,
    );
  }
}

abstract class _VectorStoreFileBatchObjectFileCounts
    extends VectorStoreFileBatchObjectFileCounts {
  const factory _VectorStoreFileBatchObjectFileCounts(
      {@JsonKey(name: 'in_progress') required final int inProgress,
      required final int completed,
      required final int failed,
      required final int cancelled,
      required final int total}) = _$VectorStoreFileBatchObjectFileCountsImpl;
  const _VectorStoreFileBatchObjectFileCounts._() : super._();

  factory _VectorStoreFileBatchObjectFileCounts.fromJson(
          Map<String, dynamic> json) =
      _$VectorStoreFileBatchObjectFileCountsImpl.fromJson;

  @override

  /// The number of files that are currently being processed.
  @JsonKey(name: 'in_progress')
  int get inProgress;
  @override

  /// The number of files that have been processed.
  int get completed;
  @override

  /// The number of files that have failed to process.
  int get failed;
  @override

  /// The number of files that where cancelled.
  int get cancelled;
  @override

  /// The total number of files.
  int get total;
  @override
  @JsonKey(ignore: true)
  _$$VectorStoreFileBatchObjectFileCountsImplCopyWith<
          _$VectorStoreFileBatchObjectFileCountsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CreateVectorStoreFileBatchRequest _$CreateVectorStoreFileBatchRequestFromJson(
    Map<String, dynamic> json) {
  return _CreateVectorStoreFileBatchRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateVectorStoreFileBatchRequest {
  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds => throw _privateConstructorUsedError;

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateVectorStoreFileBatchRequestCopyWith<CreateVectorStoreFileBatchRequest>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateVectorStoreFileBatchRequestCopyWith<$Res> {
  factory $CreateVectorStoreFileBatchRequestCopyWith(
          CreateVectorStoreFileBatchRequest value,
          $Res Function(CreateVectorStoreFileBatchRequest) then) =
      _$CreateVectorStoreFileBatchRequestCopyWithImpl<$Res,
          CreateVectorStoreFileBatchRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class _$CreateVectorStoreFileBatchRequestCopyWithImpl<$Res,
        $Val extends CreateVectorStoreFileBatchRequest>
    implements $CreateVectorStoreFileBatchRequestCopyWith<$Res> {
  _$CreateVectorStoreFileBatchRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_value.copyWith(
      fileIds: null == fileIds
          ? _value.fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy {
    if (_value.chunkingStrategy == null) {
      return null;
    }

    return $ChunkingStrategyRequestParamCopyWith<$Res>(_value.chunkingStrategy!,
        (value) {
      return _then(_value.copyWith(chunkingStrategy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CreateVectorStoreFileBatchRequestImplCopyWith<$Res>
    implements $CreateVectorStoreFileBatchRequestCopyWith<$Res> {
  factory _$$CreateVectorStoreFileBatchRequestImplCopyWith(
          _$CreateVectorStoreFileBatchRequestImpl value,
          $Res Function(_$CreateVectorStoreFileBatchRequestImpl) then) =
      __$$CreateVectorStoreFileBatchRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'file_ids') List<String> fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      ChunkingStrategyRequestParam? chunkingStrategy});

  @override
  $ChunkingStrategyRequestParamCopyWith<$Res>? get chunkingStrategy;
}

/// @nodoc
class __$$CreateVectorStoreFileBatchRequestImplCopyWithImpl<$Res>
    extends _$CreateVectorStoreFileBatchRequestCopyWithImpl<$Res,
        _$CreateVectorStoreFileBatchRequestImpl>
    implements _$$CreateVectorStoreFileBatchRequestImplCopyWith<$Res> {
  __$$CreateVectorStoreFileBatchRequestImplCopyWithImpl(
      _$CreateVectorStoreFileBatchRequestImpl _value,
      $Res Function(_$CreateVectorStoreFileBatchRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileIds = null,
    Object? chunkingStrategy = freezed,
  }) {
    return _then(_$CreateVectorStoreFileBatchRequestImpl(
      fileIds: null == fileIds
          ? _value._fileIds
          : fileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      chunkingStrategy: freezed == chunkingStrategy
          ? _value.chunkingStrategy
          : chunkingStrategy // ignore: cast_nullable_to_non_nullable
              as ChunkingStrategyRequestParam?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateVectorStoreFileBatchRequestImpl
    extends _CreateVectorStoreFileBatchRequest {
  const _$CreateVectorStoreFileBatchRequestImpl(
      {@JsonKey(name: 'file_ids') required final List<String> fileIds,
      @JsonKey(name: 'chunking_strategy', includeIfNull: false)
      this.chunkingStrategy})
      : _fileIds = fileIds,
        super._();

  factory _$CreateVectorStoreFileBatchRequestImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$CreateVectorStoreFileBatchRequestImplFromJson(json);

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  final List<String> _fileIds;

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @override
  @JsonKey(name: 'file_ids')
  List<String> get fileIds {
    if (_fileIds is EqualUnmodifiableListView) return _fileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileIds);
  }

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @override
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  final ChunkingStrategyRequestParam? chunkingStrategy;

  @override
  String toString() {
    return 'CreateVectorStoreFileBatchRequest(fileIds: $fileIds, chunkingStrategy: $chunkingStrategy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateVectorStoreFileBatchRequestImpl &&
            const DeepCollectionEquality().equals(other._fileIds, _fileIds) &&
            (identical(other.chunkingStrategy, chunkingStrategy) ||
                other.chunkingStrategy == chunkingStrategy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_fileIds), chunkingStrategy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateVectorStoreFileBatchRequestImplCopyWith<
          _$CreateVectorStoreFileBatchRequestImpl>
      get copyWith => __$$CreateVectorStoreFileBatchRequestImplCopyWithImpl<
          _$CreateVectorStoreFileBatchRequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateVectorStoreFileBatchRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateVectorStoreFileBatchRequest
    extends CreateVectorStoreFileBatchRequest {
  const factory _CreateVectorStoreFileBatchRequest(
          {@JsonKey(name: 'file_ids') required final List<String> fileIds,
          @JsonKey(name: 'chunking_strategy', includeIfNull: false)
          final ChunkingStrategyRequestParam? chunkingStrategy}) =
      _$CreateVectorStoreFileBatchRequestImpl;
  const _CreateVectorStoreFileBatchRequest._() : super._();

  factory _CreateVectorStoreFileBatchRequest.fromJson(
          Map<String, dynamic> json) =
      _$CreateVectorStoreFileBatchRequestImpl.fromJson;

  @override

  /// A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
  @JsonKey(name: 'file_ids')
  List<String> get fileIds;
  @override

  /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
  /// Any of: [AutoChunkingStrategyRequestParam], [StaticChunkingStrategyRequestParam]
  @JsonKey(name: 'chunking_strategy', includeIfNull: false)
  ChunkingStrategyRequestParam? get chunkingStrategy;
  @override
  @JsonKey(ignore: true)
  _$$CreateVectorStoreFileBatchRequestImplCopyWith<
          _$CreateVectorStoreFileBatchRequestImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Error _$ErrorFromJson(Map<String, dynamic> json) {
  return _Error.fromJson(json);
}

/// @nodoc
mixin _$Error {
  /// The error code.
  String? get code => throw _privateConstructorUsedError;

  /// A human-readable description of the error.
  String get message => throw _privateConstructorUsedError;

  /// The parameter in the request that caused the error.
  String? get param => throw _privateConstructorUsedError;

  /// The type of error.
  String get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ErrorCopyWith<Error> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorCopyWith<$Res> {
  factory $ErrorCopyWith(Error value, $Res Function(Error) then) =
      _$ErrorCopyWithImpl<$Res, Error>;
  @useResult
  $Res call({String? code, String message, String? param, String type});
}

/// @nodoc
class _$ErrorCopyWithImpl<$Res, $Val extends Error>
    implements $ErrorCopyWith<$Res> {
  _$ErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = null,
    Object? param = freezed,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> implements $ErrorCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? code, String message, String? param, String type});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$ErrorCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = null,
    Object? param = freezed,
    Object? type = null,
  }) {
    return _then(_$ErrorImpl(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ErrorImpl extends _Error {
  const _$ErrorImpl(
      {required this.code,
      required this.message,
      required this.param,
      required this.type})
      : super._();

  factory _$ErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$ErrorImplFromJson(json);

  /// The error code.
  @override
  final String? code;

  /// A human-readable description of the error.
  @override
  final String message;

  /// The parameter in the request that caused the error.
  @override
  final String? param;

  /// The type of error.
  @override
  final String type;

  @override
  String toString() {
    return 'Error(code: $code, message: $message, param: $param, type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ErrorImplToJson(
      this,
    );
  }
}

abstract class _Error extends Error {
  const factory _Error(
      {required final String? code,
      required final String message,
      required final String? param,
      required final String type}) = _$ErrorImpl;
  const _Error._() : super._();

  factory _Error.fromJson(Map<String, dynamic> json) = _$ErrorImpl.fromJson;

  @override

  /// The error code.
  String? get code;
  @override

  /// A human-readable description of the error.
  String get message;
  @override

  /// The parameter in the request that caused the error.
  String? get param;
  @override

  /// The type of error.
  String get type;
  @override
  @JsonKey(ignore: true)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CreateBatchRequest _$CreateBatchRequestFromJson(Map<String, dynamic> json) {
  return _CreateBatchRequest.fromJson(json);
}

/// @nodoc
mixin _$CreateBatchRequest {
  /// The ID of an uploaded file that contains requests for the new batch.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your input file must be formatted as a [JSONL file](https://platform.openai.com/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 100 MB in size.
  @JsonKey(name: 'input_file_id')
  String get inputFileId => throw _privateConstructorUsedError;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  BatchEndpoint get endpoint => throw _privateConstructorUsedError;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @JsonKey(name: 'completion_window')
  BatchCompletionWindow get completionWindow =>
      throw _privateConstructorUsedError;

  /// Optional custom metadata for the batch.
  @JsonKey(includeIfNull: false)
  Map<String, String>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CreateBatchRequestCopyWith<CreateBatchRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateBatchRequestCopyWith<$Res> {
  factory $CreateBatchRequestCopyWith(
          CreateBatchRequest value, $Res Function(CreateBatchRequest) then) =
      _$CreateBatchRequestCopyWithImpl<$Res, CreateBatchRequest>;
  @useResult
  $Res call(
      {@JsonKey(name: 'input_file_id') String inputFileId,
      BatchEndpoint endpoint,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      @JsonKey(includeIfNull: false) Map<String, String>? metadata});
}

/// @nodoc
class _$CreateBatchRequestCopyWithImpl<$Res, $Val extends CreateBatchRequest>
    implements $CreateBatchRequestCopyWith<$Res> {
  _$CreateBatchRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inputFileId = null,
    Object? endpoint = null,
    Object? completionWindow = null,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      inputFileId: null == inputFileId
          ? _value.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      endpoint: null == endpoint
          ? _value.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      completionWindow: null == completionWindow
          ? _value.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateBatchRequestImplCopyWith<$Res>
    implements $CreateBatchRequestCopyWith<$Res> {
  factory _$$CreateBatchRequestImplCopyWith(_$CreateBatchRequestImpl value,
          $Res Function(_$CreateBatchRequestImpl) then) =
      __$$CreateBatchRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'input_file_id') String inputFileId,
      BatchEndpoint endpoint,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      @JsonKey(includeIfNull: false) Map<String, String>? metadata});
}

/// @nodoc
class __$$CreateBatchRequestImplCopyWithImpl<$Res>
    extends _$CreateBatchRequestCopyWithImpl<$Res, _$CreateBatchRequestImpl>
    implements _$$CreateBatchRequestImplCopyWith<$Res> {
  __$$CreateBatchRequestImplCopyWithImpl(_$CreateBatchRequestImpl _value,
      $Res Function(_$CreateBatchRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inputFileId = null,
    Object? endpoint = null,
    Object? completionWindow = null,
    Object? metadata = freezed,
  }) {
    return _then(_$CreateBatchRequestImpl(
      inputFileId: null == inputFileId
          ? _value.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      endpoint: null == endpoint
          ? _value.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      completionWindow: null == completionWindow
          ? _value.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CreateBatchRequestImpl extends _CreateBatchRequest {
  const _$CreateBatchRequestImpl(
      {@JsonKey(name: 'input_file_id') required this.inputFileId,
      required this.endpoint,
      @JsonKey(name: 'completion_window') required this.completionWindow,
      @JsonKey(includeIfNull: false) final Map<String, String>? metadata})
      : _metadata = metadata,
        super._();

  factory _$CreateBatchRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreateBatchRequestImplFromJson(json);

  /// The ID of an uploaded file that contains requests for the new batch.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your input file must be formatted as a [JSONL file](https://platform.openai.com/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 100 MB in size.
  @override
  @JsonKey(name: 'input_file_id')
  final String inputFileId;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  @override
  final BatchEndpoint endpoint;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @override
  @JsonKey(name: 'completion_window')
  final BatchCompletionWindow completionWindow;

  /// Optional custom metadata for the batch.
  final Map<String, String>? _metadata;

  /// Optional custom metadata for the batch.
  @override
  @JsonKey(includeIfNull: false)
  Map<String, String>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CreateBatchRequest(inputFileId: $inputFileId, endpoint: $endpoint, completionWindow: $completionWindow, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateBatchRequestImpl &&
            (identical(other.inputFileId, inputFileId) ||
                other.inputFileId == inputFileId) &&
            (identical(other.endpoint, endpoint) ||
                other.endpoint == endpoint) &&
            (identical(other.completionWindow, completionWindow) ||
                other.completionWindow == completionWindow) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, inputFileId, endpoint,
      completionWindow, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateBatchRequestImplCopyWith<_$CreateBatchRequestImpl> get copyWith =>
      __$$CreateBatchRequestImplCopyWithImpl<_$CreateBatchRequestImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreateBatchRequestImplToJson(
      this,
    );
  }
}

abstract class _CreateBatchRequest extends CreateBatchRequest {
  const factory _CreateBatchRequest(
          {@JsonKey(name: 'input_file_id') required final String inputFileId,
          required final BatchEndpoint endpoint,
          @JsonKey(name: 'completion_window')
          required final BatchCompletionWindow completionWindow,
          @JsonKey(includeIfNull: false) final Map<String, String>? metadata}) =
      _$CreateBatchRequestImpl;
  const _CreateBatchRequest._() : super._();

  factory _CreateBatchRequest.fromJson(Map<String, dynamic> json) =
      _$CreateBatchRequestImpl.fromJson;

  @override

  /// The ID of an uploaded file that contains requests for the new batch.
  ///
  /// See [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.
  ///
  /// Your input file must be formatted as a [JSONL file](https://platform.openai.com/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 100 MB in size.
  @JsonKey(name: 'input_file_id')
  String get inputFileId;
  @override

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  BatchEndpoint get endpoint;
  @override

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @JsonKey(name: 'completion_window')
  BatchCompletionWindow get completionWindow;
  @override

  /// Optional custom metadata for the batch.
  @JsonKey(includeIfNull: false)
  Map<String, String>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CreateBatchRequestImplCopyWith<_$CreateBatchRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Batch _$BatchFromJson(Map<String, dynamic> json) {
  return _Batch.fromJson(json);
}

/// @nodoc
mixin _$Batch {
  /// No Description
  String get id => throw _privateConstructorUsedError;

  /// The object type, which is always `batch`.
  BatchObject get object => throw _privateConstructorUsedError;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  BatchEndpoint get endpoint => throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(includeIfNull: false)
  BatchErrors? get errors => throw _privateConstructorUsedError;

  /// The ID of the input file for the batch.
  @JsonKey(name: 'input_file_id')
  String get inputFileId => throw _privateConstructorUsedError;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @JsonKey(name: 'completion_window')
  BatchCompletionWindow get completionWindow =>
      throw _privateConstructorUsedError;

  /// The current status of the batch.
  BatchStatus get status => throw _privateConstructorUsedError;

  /// The ID of the file containing the outputs of successfully executed requests.
  @JsonKey(name: 'output_file_id', includeIfNull: false)
  String? get outputFileId => throw _privateConstructorUsedError;

  /// The ID of the file containing the outputs of requests with errors.
  @JsonKey(name: 'error_file_id', includeIfNull: false)
  String? get errorFileId => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch was created.
  @JsonKey(name: 'created_at')
  int get createdAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch started processing.
  @JsonKey(name: 'in_progress_at', includeIfNull: false)
  int? get inProgressAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch will expire.
  @JsonKey(name: 'expires_at', includeIfNull: false)
  int? get expiresAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch started finalizing.
  @JsonKey(name: 'finalizing_at', includeIfNull: false)
  int? get finalizingAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch was completed.
  @JsonKey(name: 'completed_at', includeIfNull: false)
  int? get completedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch failed.
  @JsonKey(name: 'failed_at', includeIfNull: false)
  int? get failedAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch expired.
  @JsonKey(name: 'expired_at', includeIfNull: false)
  int? get expiredAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch started cancelling.
  @JsonKey(name: 'cancelling_at', includeIfNull: false)
  int? get cancellingAt => throw _privateConstructorUsedError;

  /// The Unix timestamp (in seconds) for when the batch was cancelled.
  @JsonKey(name: 'cancelled_at', includeIfNull: false)
  int? get cancelledAt => throw _privateConstructorUsedError;

  /// The request counts for different statuses within the batch.
  @JsonKey(name: 'request_counts', includeIfNull: false)
  BatchRequestCounts? get requestCounts => throw _privateConstructorUsedError;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BatchCopyWith<Batch> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BatchCopyWith<$Res> {
  factory $BatchCopyWith(Batch value, $Res Function(Batch) then) =
      _$BatchCopyWithImpl<$Res, Batch>;
  @useResult
  $Res call(
      {String id,
      BatchObject object,
      BatchEndpoint endpoint,
      @JsonKey(includeIfNull: false) BatchErrors? errors,
      @JsonKey(name: 'input_file_id') String inputFileId,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      BatchStatus status,
      @JsonKey(name: 'output_file_id', includeIfNull: false)
      String? outputFileId,
      @JsonKey(name: 'error_file_id', includeIfNull: false) String? errorFileId,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'in_progress_at', includeIfNull: false) int? inProgressAt,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'finalizing_at', includeIfNull: false) int? finalizingAt,
      @JsonKey(name: 'completed_at', includeIfNull: false) int? completedAt,
      @JsonKey(name: 'failed_at', includeIfNull: false) int? failedAt,
      @JsonKey(name: 'expired_at', includeIfNull: false) int? expiredAt,
      @JsonKey(name: 'cancelling_at', includeIfNull: false) int? cancellingAt,
      @JsonKey(name: 'cancelled_at', includeIfNull: false) int? cancelledAt,
      @JsonKey(name: 'request_counts', includeIfNull: false)
      BatchRequestCounts? requestCounts,
      @JsonKey(includeIfNull: false) dynamic metadata});

  $BatchErrorsCopyWith<$Res>? get errors;
  $BatchRequestCountsCopyWith<$Res>? get requestCounts;
}

/// @nodoc
class _$BatchCopyWithImpl<$Res, $Val extends Batch>
    implements $BatchCopyWith<$Res> {
  _$BatchCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? endpoint = null,
    Object? errors = freezed,
    Object? inputFileId = null,
    Object? completionWindow = null,
    Object? status = null,
    Object? outputFileId = freezed,
    Object? errorFileId = freezed,
    Object? createdAt = null,
    Object? inProgressAt = freezed,
    Object? expiresAt = freezed,
    Object? finalizingAt = freezed,
    Object? completedAt = freezed,
    Object? failedAt = freezed,
    Object? expiredAt = freezed,
    Object? cancellingAt = freezed,
    Object? cancelledAt = freezed,
    Object? requestCounts = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as BatchObject,
      endpoint: null == endpoint
          ? _value.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      errors: freezed == errors
          ? _value.errors
          : errors // ignore: cast_nullable_to_non_nullable
              as BatchErrors?,
      inputFileId: null == inputFileId
          ? _value.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      completionWindow: null == completionWindow
          ? _value.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as BatchStatus,
      outputFileId: freezed == outputFileId
          ? _value.outputFileId
          : outputFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      errorFileId: freezed == errorFileId
          ? _value.errorFileId
          : errorFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      inProgressAt: freezed == inProgressAt
          ? _value.inProgressAt
          : inProgressAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      finalizingAt: freezed == finalizingAt
          ? _value.finalizingAt
          : finalizingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiredAt: freezed == expiredAt
          ? _value.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellingAt: freezed == cancellingAt
          ? _value.cancellingAt
          : cancellingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      requestCounts: freezed == requestCounts
          ? _value.requestCounts
          : requestCounts // ignore: cast_nullable_to_non_nullable
              as BatchRequestCounts?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $BatchErrorsCopyWith<$Res>? get errors {
    if (_value.errors == null) {
      return null;
    }

    return $BatchErrorsCopyWith<$Res>(_value.errors!, (value) {
      return _then(_value.copyWith(errors: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $BatchRequestCountsCopyWith<$Res>? get requestCounts {
    if (_value.requestCounts == null) {
      return null;
    }

    return $BatchRequestCountsCopyWith<$Res>(_value.requestCounts!, (value) {
      return _then(_value.copyWith(requestCounts: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$BatchImplCopyWith<$Res> implements $BatchCopyWith<$Res> {
  factory _$$BatchImplCopyWith(
          _$BatchImpl value, $Res Function(_$BatchImpl) then) =
      __$$BatchImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      BatchObject object,
      BatchEndpoint endpoint,
      @JsonKey(includeIfNull: false) BatchErrors? errors,
      @JsonKey(name: 'input_file_id') String inputFileId,
      @JsonKey(name: 'completion_window')
      BatchCompletionWindow completionWindow,
      BatchStatus status,
      @JsonKey(name: 'output_file_id', includeIfNull: false)
      String? outputFileId,
      @JsonKey(name: 'error_file_id', includeIfNull: false) String? errorFileId,
      @JsonKey(name: 'created_at') int createdAt,
      @JsonKey(name: 'in_progress_at', includeIfNull: false) int? inProgressAt,
      @JsonKey(name: 'expires_at', includeIfNull: false) int? expiresAt,
      @JsonKey(name: 'finalizing_at', includeIfNull: false) int? finalizingAt,
      @JsonKey(name: 'completed_at', includeIfNull: false) int? completedAt,
      @JsonKey(name: 'failed_at', includeIfNull: false) int? failedAt,
      @JsonKey(name: 'expired_at', includeIfNull: false) int? expiredAt,
      @JsonKey(name: 'cancelling_at', includeIfNull: false) int? cancellingAt,
      @JsonKey(name: 'cancelled_at', includeIfNull: false) int? cancelledAt,
      @JsonKey(name: 'request_counts', includeIfNull: false)
      BatchRequestCounts? requestCounts,
      @JsonKey(includeIfNull: false) dynamic metadata});

  @override
  $BatchErrorsCopyWith<$Res>? get errors;
  @override
  $BatchRequestCountsCopyWith<$Res>? get requestCounts;
}

/// @nodoc
class __$$BatchImplCopyWithImpl<$Res>
    extends _$BatchCopyWithImpl<$Res, _$BatchImpl>
    implements _$$BatchImplCopyWith<$Res> {
  __$$BatchImplCopyWithImpl(
      _$BatchImpl _value, $Res Function(_$BatchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? object = null,
    Object? endpoint = null,
    Object? errors = freezed,
    Object? inputFileId = null,
    Object? completionWindow = null,
    Object? status = null,
    Object? outputFileId = freezed,
    Object? errorFileId = freezed,
    Object? createdAt = null,
    Object? inProgressAt = freezed,
    Object? expiresAt = freezed,
    Object? finalizingAt = freezed,
    Object? completedAt = freezed,
    Object? failedAt = freezed,
    Object? expiredAt = freezed,
    Object? cancellingAt = freezed,
    Object? cancelledAt = freezed,
    Object? requestCounts = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$BatchImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as BatchObject,
      endpoint: null == endpoint
          ? _value.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as BatchEndpoint,
      errors: freezed == errors
          ? _value.errors
          : errors // ignore: cast_nullable_to_non_nullable
              as BatchErrors?,
      inputFileId: null == inputFileId
          ? _value.inputFileId
          : inputFileId // ignore: cast_nullable_to_non_nullable
              as String,
      completionWindow: null == completionWindow
          ? _value.completionWindow
          : completionWindow // ignore: cast_nullable_to_non_nullable
              as BatchCompletionWindow,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as BatchStatus,
      outputFileId: freezed == outputFileId
          ? _value.outputFileId
          : outputFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      errorFileId: freezed == errorFileId
          ? _value.errorFileId
          : errorFileId // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as int,
      inProgressAt: freezed == inProgressAt
          ? _value.inProgressAt
          : inProgressAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiresAt: freezed == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as int?,
      finalizingAt: freezed == finalizingAt
          ? _value.finalizingAt
          : finalizingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      failedAt: freezed == failedAt
          ? _value.failedAt
          : failedAt // ignore: cast_nullable_to_non_nullable
              as int?,
      expiredAt: freezed == expiredAt
          ? _value.expiredAt
          : expiredAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancellingAt: freezed == cancellingAt
          ? _value.cancellingAt
          : cancellingAt // ignore: cast_nullable_to_non_nullable
              as int?,
      cancelledAt: freezed == cancelledAt
          ? _value.cancelledAt
          : cancelledAt // ignore: cast_nullable_to_non_nullable
              as int?,
      requestCounts: freezed == requestCounts
          ? _value.requestCounts
          : requestCounts // ignore: cast_nullable_to_non_nullable
              as BatchRequestCounts?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BatchImpl extends _Batch {
  const _$BatchImpl(
      {required this.id,
      required this.object,
      required this.endpoint,
      @JsonKey(includeIfNull: false) this.errors,
      @JsonKey(name: 'input_file_id') required this.inputFileId,
      @JsonKey(name: 'completion_window') required this.completionWindow,
      required this.status,
      @JsonKey(name: 'output_file_id', includeIfNull: false) this.outputFileId,
      @JsonKey(name: 'error_file_id', includeIfNull: false) this.errorFileId,
      @JsonKey(name: 'created_at') required this.createdAt,
      @JsonKey(name: 'in_progress_at', includeIfNull: false) this.inProgressAt,
      @JsonKey(name: 'expires_at', includeIfNull: false) this.expiresAt,
      @JsonKey(name: 'finalizing_at', includeIfNull: false) this.finalizingAt,
      @JsonKey(name: 'completed_at', includeIfNull: false) this.completedAt,
      @JsonKey(name: 'failed_at', includeIfNull: false) this.failedAt,
      @JsonKey(name: 'expired_at', includeIfNull: false) this.expiredAt,
      @JsonKey(name: 'cancelling_at', includeIfNull: false) this.cancellingAt,
      @JsonKey(name: 'cancelled_at', includeIfNull: false) this.cancelledAt,
      @JsonKey(name: 'request_counts', includeIfNull: false) this.requestCounts,
      @JsonKey(includeIfNull: false) this.metadata})
      : super._();

  factory _$BatchImpl.fromJson(Map<String, dynamic> json) =>
      _$$BatchImplFromJson(json);

  /// No Description
  @override
  final String id;

  /// The object type, which is always `batch`.
  @override
  final BatchObject object;

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  @override
  final BatchEndpoint endpoint;

  /// No Description
  @override
  @JsonKey(includeIfNull: false)
  final BatchErrors? errors;

  /// The ID of the input file for the batch.
  @override
  @JsonKey(name: 'input_file_id')
  final String inputFileId;

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @override
  @JsonKey(name: 'completion_window')
  final BatchCompletionWindow completionWindow;

  /// The current status of the batch.
  @override
  final BatchStatus status;

  /// The ID of the file containing the outputs of successfully executed requests.
  @override
  @JsonKey(name: 'output_file_id', includeIfNull: false)
  final String? outputFileId;

  /// The ID of the file containing the outputs of requests with errors.
  @override
  @JsonKey(name: 'error_file_id', includeIfNull: false)
  final String? errorFileId;

  /// The Unix timestamp (in seconds) for when the batch was created.
  @override
  @JsonKey(name: 'created_at')
  final int createdAt;

  /// The Unix timestamp (in seconds) for when the batch started processing.
  @override
  @JsonKey(name: 'in_progress_at', includeIfNull: false)
  final int? inProgressAt;

  /// The Unix timestamp (in seconds) for when the batch will expire.
  @override
  @JsonKey(name: 'expires_at', includeIfNull: false)
  final int? expiresAt;

  /// The Unix timestamp (in seconds) for when the batch started finalizing.
  @override
  @JsonKey(name: 'finalizing_at', includeIfNull: false)
  final int? finalizingAt;

  /// The Unix timestamp (in seconds) for when the batch was completed.
  @override
  @JsonKey(name: 'completed_at', includeIfNull: false)
  final int? completedAt;

  /// The Unix timestamp (in seconds) for when the batch failed.
  @override
  @JsonKey(name: 'failed_at', includeIfNull: false)
  final int? failedAt;

  /// The Unix timestamp (in seconds) for when the batch expired.
  @override
  @JsonKey(name: 'expired_at', includeIfNull: false)
  final int? expiredAt;

  /// The Unix timestamp (in seconds) for when the batch started cancelling.
  @override
  @JsonKey(name: 'cancelling_at', includeIfNull: false)
  final int? cancellingAt;

  /// The Unix timestamp (in seconds) for when the batch was cancelled.
  @override
  @JsonKey(name: 'cancelled_at', includeIfNull: false)
  final int? cancelledAt;

  /// The request counts for different statuses within the batch.
  @override
  @JsonKey(name: 'request_counts', includeIfNull: false)
  final BatchRequestCounts? requestCounts;

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @override
  @JsonKey(includeIfNull: false)
  final dynamic metadata;

  @override
  String toString() {
    return 'Batch(id: $id, object: $object, endpoint: $endpoint, errors: $errors, inputFileId: $inputFileId, completionWindow: $completionWindow, status: $status, outputFileId: $outputFileId, errorFileId: $errorFileId, createdAt: $createdAt, inProgressAt: $inProgressAt, expiresAt: $expiresAt, finalizingAt: $finalizingAt, completedAt: $completedAt, failedAt: $failedAt, expiredAt: $expiredAt, cancellingAt: $cancellingAt, cancelledAt: $cancelledAt, requestCounts: $requestCounts, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BatchImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.endpoint, endpoint) ||
                other.endpoint == endpoint) &&
            (identical(other.errors, errors) || other.errors == errors) &&
            (identical(other.inputFileId, inputFileId) ||
                other.inputFileId == inputFileId) &&
            (identical(other.completionWindow, completionWindow) ||
                other.completionWindow == completionWindow) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.outputFileId, outputFileId) ||
                other.outputFileId == outputFileId) &&
            (identical(other.errorFileId, errorFileId) ||
                other.errorFileId == errorFileId) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.inProgressAt, inProgressAt) ||
                other.inProgressAt == inProgressAt) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.finalizingAt, finalizingAt) ||
                other.finalizingAt == finalizingAt) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt) &&
            (identical(other.failedAt, failedAt) ||
                other.failedAt == failedAt) &&
            (identical(other.expiredAt, expiredAt) ||
                other.expiredAt == expiredAt) &&
            (identical(other.cancellingAt, cancellingAt) ||
                other.cancellingAt == cancellingAt) &&
            (identical(other.cancelledAt, cancelledAt) ||
                other.cancelledAt == cancelledAt) &&
            (identical(other.requestCounts, requestCounts) ||
                other.requestCounts == requestCounts) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        endpoint,
        errors,
        inputFileId,
        completionWindow,
        status,
        outputFileId,
        errorFileId,
        createdAt,
        inProgressAt,
        expiresAt,
        finalizingAt,
        completedAt,
        failedAt,
        expiredAt,
        cancellingAt,
        cancelledAt,
        requestCounts,
        const DeepCollectionEquality().hash(metadata)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BatchImplCopyWith<_$BatchImpl> get copyWith =>
      __$$BatchImplCopyWithImpl<_$BatchImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BatchImplToJson(
      this,
    );
  }
}

abstract class _Batch extends Batch {
  const factory _Batch(
      {required final String id,
      required final BatchObject object,
      required final BatchEndpoint endpoint,
      @JsonKey(includeIfNull: false) final BatchErrors? errors,
      @JsonKey(name: 'input_file_id') required final String inputFileId,
      @JsonKey(name: 'completion_window')
      required final BatchCompletionWindow completionWindow,
      required final BatchStatus status,
      @JsonKey(name: 'output_file_id', includeIfNull: false)
      final String? outputFileId,
      @JsonKey(name: 'error_file_id', includeIfNull: false)
      final String? errorFileId,
      @JsonKey(name: 'created_at') required final int createdAt,
      @JsonKey(name: 'in_progress_at', includeIfNull: false)
      final int? inProgressAt,
      @JsonKey(name: 'expires_at', includeIfNull: false) final int? expiresAt,
      @JsonKey(name: 'finalizing_at', includeIfNull: false)
      final int? finalizingAt,
      @JsonKey(name: 'completed_at', includeIfNull: false)
      final int? completedAt,
      @JsonKey(name: 'failed_at', includeIfNull: false) final int? failedAt,
      @JsonKey(name: 'expired_at', includeIfNull: false) final int? expiredAt,
      @JsonKey(name: 'cancelling_at', includeIfNull: false)
      final int? cancellingAt,
      @JsonKey(name: 'cancelled_at', includeIfNull: false)
      final int? cancelledAt,
      @JsonKey(name: 'request_counts', includeIfNull: false)
      final BatchRequestCounts? requestCounts,
      @JsonKey(includeIfNull: false) final dynamic metadata}) = _$BatchImpl;
  const _Batch._() : super._();

  factory _Batch.fromJson(Map<String, dynamic> json) = _$BatchImpl.fromJson;

  @override

  /// No Description
  String get id;
  @override

  /// The object type, which is always `batch`.
  BatchObject get object;
  @override

  /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
  BatchEndpoint get endpoint;
  @override

  /// No Description
  @JsonKey(includeIfNull: false)
  BatchErrors? get errors;
  @override

  /// The ID of the input file for the batch.
  @JsonKey(name: 'input_file_id')
  String get inputFileId;
  @override

  /// The time frame within which the batch should be processed. Currently only `24h` is supported.
  @JsonKey(name: 'completion_window')
  BatchCompletionWindow get completionWindow;
  @override

  /// The current status of the batch.
  BatchStatus get status;
  @override

  /// The ID of the file containing the outputs of successfully executed requests.
  @JsonKey(name: 'output_file_id', includeIfNull: false)
  String? get outputFileId;
  @override

  /// The ID of the file containing the outputs of requests with errors.
  @JsonKey(name: 'error_file_id', includeIfNull: false)
  String? get errorFileId;
  @override

  /// The Unix timestamp (in seconds) for when the batch was created.
  @JsonKey(name: 'created_at')
  int get createdAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch started processing.
  @JsonKey(name: 'in_progress_at', includeIfNull: false)
  int? get inProgressAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch will expire.
  @JsonKey(name: 'expires_at', includeIfNull: false)
  int? get expiresAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch started finalizing.
  @JsonKey(name: 'finalizing_at', includeIfNull: false)
  int? get finalizingAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch was completed.
  @JsonKey(name: 'completed_at', includeIfNull: false)
  int? get completedAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch failed.
  @JsonKey(name: 'failed_at', includeIfNull: false)
  int? get failedAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch expired.
  @JsonKey(name: 'expired_at', includeIfNull: false)
  int? get expiredAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch started cancelling.
  @JsonKey(name: 'cancelling_at', includeIfNull: false)
  int? get cancellingAt;
  @override

  /// The Unix timestamp (in seconds) for when the batch was cancelled.
  @JsonKey(name: 'cancelled_at', includeIfNull: false)
  int? get cancelledAt;
  @override

  /// The request counts for different statuses within the batch.
  @JsonKey(name: 'request_counts', includeIfNull: false)
  BatchRequestCounts? get requestCounts;
  @override

  /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
  @JsonKey(includeIfNull: false)
  dynamic get metadata;
  @override
  @JsonKey(ignore: true)
  _$$BatchImplCopyWith<_$BatchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BatchErrors _$BatchErrorsFromJson(Map<String, dynamic> json) {
  return _BatchErrors.fromJson(json);
}

/// @nodoc
mixin _$BatchErrors {
  /// The object type, which is always `list`.
  @JsonKey(includeIfNull: false)
  String? get object => throw _privateConstructorUsedError;

  /// No Description
  @JsonKey(includeIfNull: false)
  List<BatchErrorsDataInner>? get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BatchErrorsCopyWith<BatchErrors> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BatchErrorsCopyWith<$Res> {
  factory $BatchErrorsCopyWith(
          BatchErrors value, $Res Function(BatchErrors) then) =
      _$BatchErrorsCopyWithImpl<$Res, BatchErrors>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) List<BatchErrorsDataInner>? data});
}

/// @nodoc
class _$BatchErrorsCopyWithImpl<$Res, $Val extends BatchErrors>
    implements $BatchErrorsCopyWith<$Res> {
  _$BatchErrorsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = freezed,
    Object? data = freezed,
  }) {
    return _then(_value.copyWith(
      object: freezed == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<BatchErrorsDataInner>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BatchErrorsImplCopyWith<$Res>
    implements $BatchErrorsCopyWith<$Res> {
  factory _$$BatchErrorsImplCopyWith(
          _$BatchErrorsImpl value, $Res Function(_$BatchErrorsImpl) then) =
      __$$BatchErrorsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? object,
      @JsonKey(includeIfNull: false) List<BatchErrorsDataInner>? data});
}

/// @nodoc
class __$$BatchErrorsImplCopyWithImpl<$Res>
    extends _$BatchErrorsCopyWithImpl<$Res, _$BatchErrorsImpl>
    implements _$$BatchErrorsImplCopyWith<$Res> {
  __$$BatchErrorsImplCopyWithImpl(
      _$BatchErrorsImpl _value, $Res Function(_$BatchErrorsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = freezed,
    Object? data = freezed,
  }) {
    return _then(_$BatchErrorsImpl(
      object: freezed == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<BatchErrorsDataInner>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BatchErrorsImpl extends _BatchErrors {
  const _$BatchErrorsImpl(
      {@JsonKey(includeIfNull: false) this.object,
      @JsonKey(includeIfNull: false) final List<BatchErrorsDataInner>? data})
      : _data = data,
        super._();

  factory _$BatchErrorsImpl.fromJson(Map<String, dynamic> json) =>
      _$$BatchErrorsImplFromJson(json);

  /// The object type, which is always `list`.
  @override
  @JsonKey(includeIfNull: false)
  final String? object;

  /// No Description
  final List<BatchErrorsDataInner>? _data;

  /// No Description
  @override
  @JsonKey(includeIfNull: false)
  List<BatchErrorsDataInner>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'BatchErrors(object: $object, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BatchErrorsImpl &&
            (identical(other.object, object) || other.object == object) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, object, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BatchErrorsImplCopyWith<_$BatchErrorsImpl> get copyWith =>
      __$$BatchErrorsImplCopyWithImpl<_$BatchErrorsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BatchErrorsImplToJson(
      this,
    );
  }
}

abstract class _BatchErrors extends BatchErrors {
  const factory _BatchErrors(
      {@JsonKey(includeIfNull: false) final String? object,
      @JsonKey(includeIfNull: false)
      final List<BatchErrorsDataInner>? data}) = _$BatchErrorsImpl;
  const _BatchErrors._() : super._();

  factory _BatchErrors.fromJson(Map<String, dynamic> json) =
      _$BatchErrorsImpl.fromJson;

  @override

  /// The object type, which is always `list`.
  @JsonKey(includeIfNull: false)
  String? get object;
  @override

  /// No Description
  @JsonKey(includeIfNull: false)
  List<BatchErrorsDataInner>? get data;
  @override
  @JsonKey(ignore: true)
  _$$BatchErrorsImplCopyWith<_$BatchErrorsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BatchRequestCounts _$BatchRequestCountsFromJson(Map<String, dynamic> json) {
  return _BatchRequestCounts.fromJson(json);
}

/// @nodoc
mixin _$BatchRequestCounts {
  /// Total number of requests in the batch.
  int get total => throw _privateConstructorUsedError;

  /// Number of requests that have been completed successfully.
  int get completed => throw _privateConstructorUsedError;

  /// Number of requests that have failed.
  int get failed => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BatchRequestCountsCopyWith<BatchRequestCounts> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BatchRequestCountsCopyWith<$Res> {
  factory $BatchRequestCountsCopyWith(
          BatchRequestCounts value, $Res Function(BatchRequestCounts) then) =
      _$BatchRequestCountsCopyWithImpl<$Res, BatchRequestCounts>;
  @useResult
  $Res call({int total, int completed, int failed});
}

/// @nodoc
class _$BatchRequestCountsCopyWithImpl<$Res, $Val extends BatchRequestCounts>
    implements $BatchRequestCountsCopyWith<$Res> {
  _$BatchRequestCountsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? completed = null,
    Object? failed = null,
  }) {
    return _then(_value.copyWith(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _value.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BatchRequestCountsImplCopyWith<$Res>
    implements $BatchRequestCountsCopyWith<$Res> {
  factory _$$BatchRequestCountsImplCopyWith(_$BatchRequestCountsImpl value,
          $Res Function(_$BatchRequestCountsImpl) then) =
      __$$BatchRequestCountsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int total, int completed, int failed});
}

/// @nodoc
class __$$BatchRequestCountsImplCopyWithImpl<$Res>
    extends _$BatchRequestCountsCopyWithImpl<$Res, _$BatchRequestCountsImpl>
    implements _$$BatchRequestCountsImplCopyWith<$Res> {
  __$$BatchRequestCountsImplCopyWithImpl(_$BatchRequestCountsImpl _value,
      $Res Function(_$BatchRequestCountsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? completed = null,
    Object? failed = null,
  }) {
    return _then(_$BatchRequestCountsImpl(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as int,
      failed: null == failed
          ? _value.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BatchRequestCountsImpl extends _BatchRequestCounts {
  const _$BatchRequestCountsImpl(
      {required this.total, required this.completed, required this.failed})
      : super._();

  factory _$BatchRequestCountsImpl.fromJson(Map<String, dynamic> json) =>
      _$$BatchRequestCountsImplFromJson(json);

  /// Total number of requests in the batch.
  @override
  final int total;

  /// Number of requests that have been completed successfully.
  @override
  final int completed;

  /// Number of requests that have failed.
  @override
  final int failed;

  @override
  String toString() {
    return 'BatchRequestCounts(total: $total, completed: $completed, failed: $failed)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BatchRequestCountsImpl &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.failed, failed) || other.failed == failed));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, total, completed, failed);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BatchRequestCountsImplCopyWith<_$BatchRequestCountsImpl> get copyWith =>
      __$$BatchRequestCountsImplCopyWithImpl<_$BatchRequestCountsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BatchRequestCountsImplToJson(
      this,
    );
  }
}

abstract class _BatchRequestCounts extends BatchRequestCounts {
  const factory _BatchRequestCounts(
      {required final int total,
      required final int completed,
      required final int failed}) = _$BatchRequestCountsImpl;
  const _BatchRequestCounts._() : super._();

  factory _BatchRequestCounts.fromJson(Map<String, dynamic> json) =
      _$BatchRequestCountsImpl.fromJson;

  @override

  /// Total number of requests in the batch.
  int get total;
  @override

  /// Number of requests that have been completed successfully.
  int get completed;
  @override

  /// Number of requests that have failed.
  int get failed;
  @override
  @JsonKey(ignore: true)
  _$$BatchRequestCountsImplCopyWith<_$BatchRequestCountsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BatchErrorsDataInner _$BatchErrorsDataInnerFromJson(Map<String, dynamic> json) {
  return _BatchErrorsDataInner.fromJson(json);
}

/// @nodoc
mixin _$BatchErrorsDataInner {
  /// An error code identifying the error type.
  @JsonKey(includeIfNull: false)
  String? get code => throw _privateConstructorUsedError;

  /// A human-readable message providing more details about the error.
  @JsonKey(includeIfNull: false)
  String? get message => throw _privateConstructorUsedError;

  /// The name of the parameter that caused the error, if applicable.
  @JsonKey(includeIfNull: false)
  String? get param => throw _privateConstructorUsedError;

  /// The line number of the input file where the error occurred, if applicable.
  @JsonKey(includeIfNull: false)
  int? get line => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BatchErrorsDataInnerCopyWith<BatchErrorsDataInner> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BatchErrorsDataInnerCopyWith<$Res> {
  factory $BatchErrorsDataInnerCopyWith(BatchErrorsDataInner value,
          $Res Function(BatchErrorsDataInner) then) =
      _$BatchErrorsDataInnerCopyWithImpl<$Res, BatchErrorsDataInner>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? code,
      @JsonKey(includeIfNull: false) String? message,
      @JsonKey(includeIfNull: false) String? param,
      @JsonKey(includeIfNull: false) int? line});
}

/// @nodoc
class _$BatchErrorsDataInnerCopyWithImpl<$Res,
        $Val extends BatchErrorsDataInner>
    implements $BatchErrorsDataInnerCopyWith<$Res> {
  _$BatchErrorsDataInnerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = freezed,
    Object? param = freezed,
    Object? line = freezed,
  }) {
    return _then(_value.copyWith(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      line: freezed == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BatchErrorsDataInnerImplCopyWith<$Res>
    implements $BatchErrorsDataInnerCopyWith<$Res> {
  factory _$$BatchErrorsDataInnerImplCopyWith(_$BatchErrorsDataInnerImpl value,
          $Res Function(_$BatchErrorsDataInnerImpl) then) =
      __$$BatchErrorsDataInnerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? code,
      @JsonKey(includeIfNull: false) String? message,
      @JsonKey(includeIfNull: false) String? param,
      @JsonKey(includeIfNull: false) int? line});
}

/// @nodoc
class __$$BatchErrorsDataInnerImplCopyWithImpl<$Res>
    extends _$BatchErrorsDataInnerCopyWithImpl<$Res, _$BatchErrorsDataInnerImpl>
    implements _$$BatchErrorsDataInnerImplCopyWith<$Res> {
  __$$BatchErrorsDataInnerImplCopyWithImpl(_$BatchErrorsDataInnerImpl _value,
      $Res Function(_$BatchErrorsDataInnerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = freezed,
    Object? param = freezed,
    Object? line = freezed,
  }) {
    return _then(_$BatchErrorsDataInnerImpl(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      param: freezed == param
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String?,
      line: freezed == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BatchErrorsDataInnerImpl extends _BatchErrorsDataInner {
  const _$BatchErrorsDataInnerImpl(
      {@JsonKey(includeIfNull: false) this.code,
      @JsonKey(includeIfNull: false) this.message,
      @JsonKey(includeIfNull: false) this.param,
      @JsonKey(includeIfNull: false) this.line})
      : super._();

  factory _$BatchErrorsDataInnerImpl.fromJson(Map<String, dynamic> json) =>
      _$$BatchErrorsDataInnerImplFromJson(json);

  /// An error code identifying the error type.
  @override
  @JsonKey(includeIfNull: false)
  final String? code;

  /// A human-readable message providing more details about the error.
  @override
  @JsonKey(includeIfNull: false)
  final String? message;

  /// The name of the parameter that caused the error, if applicable.
  @override
  @JsonKey(includeIfNull: false)
  final String? param;

  /// The line number of the input file where the error occurred, if applicable.
  @override
  @JsonKey(includeIfNull: false)
  final int? line;

  @override
  String toString() {
    return 'BatchErrorsDataInner(code: $code, message: $message, param: $param, line: $line)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BatchErrorsDataInnerImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.param, param) || other.param == param) &&
            (identical(other.line, line) || other.line == line));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, param, line);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BatchErrorsDataInnerImplCopyWith<_$BatchErrorsDataInnerImpl>
      get copyWith =>
          __$$BatchErrorsDataInnerImplCopyWithImpl<_$BatchErrorsDataInnerImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BatchErrorsDataInnerImplToJson(
      this,
    );
  }
}

abstract class _BatchErrorsDataInner extends BatchErrorsDataInner {
  const factory _BatchErrorsDataInner(
          {@JsonKey(includeIfNull: false) final String? code,
          @JsonKey(includeIfNull: false) final String? message,
          @JsonKey(includeIfNull: false) final String? param,
          @JsonKey(includeIfNull: false) final int? line}) =
      _$BatchErrorsDataInnerImpl;
  const _BatchErrorsDataInner._() : super._();

  factory _BatchErrorsDataInner.fromJson(Map<String, dynamic> json) =
      _$BatchErrorsDataInnerImpl.fromJson;

  @override

  /// An error code identifying the error type.
  @JsonKey(includeIfNull: false)
  String? get code;
  @override

  /// A human-readable message providing more details about the error.
  @JsonKey(includeIfNull: false)
  String? get message;
  @override

  /// The name of the parameter that caused the error, if applicable.
  @JsonKey(includeIfNull: false)
  String? get param;
  @override

  /// The line number of the input file where the error occurred, if applicable.
  @JsonKey(includeIfNull: false)
  int? get line;
  @override
  @JsonKey(ignore: true)
  _$$BatchErrorsDataInnerImplCopyWith<_$BatchErrorsDataInnerImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ListBatchesResponse _$ListBatchesResponseFromJson(Map<String, dynamic> json) {
  return _ListBatchesResponse.fromJson(json);
}

/// @nodoc
mixin _$ListBatchesResponse {
  /// No Description
  List<Batch> get data => throw _privateConstructorUsedError;

  /// The ID of the first batch in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId => throw _privateConstructorUsedError;

  /// The ID of the last batch in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId => throw _privateConstructorUsedError;

  /// Whether there are more batches available.
  @JsonKey(name: 'has_more')
  bool get hasMore => throw _privateConstructorUsedError;

  /// The object type, which is always `list`.
  ListBatchesResponseObject get object => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListBatchesResponseCopyWith<ListBatchesResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListBatchesResponseCopyWith<$Res> {
  factory $ListBatchesResponseCopyWith(
          ListBatchesResponse value, $Res Function(ListBatchesResponse) then) =
      _$ListBatchesResponseCopyWithImpl<$Res, ListBatchesResponse>;
  @useResult
  $Res call(
      {List<Batch> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore,
      ListBatchesResponseObject object});
}

/// @nodoc
class _$ListBatchesResponseCopyWithImpl<$Res, $Val extends ListBatchesResponse>
    implements $ListBatchesResponseCopyWith<$Res> {
  _$ListBatchesResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Batch>,
      firstId: freezed == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListBatchesResponseObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListBatchesResponseImplCopyWith<$Res>
    implements $ListBatchesResponseCopyWith<$Res> {
  factory _$$ListBatchesResponseImplCopyWith(_$ListBatchesResponseImpl value,
          $Res Function(_$ListBatchesResponseImpl) then) =
      __$$ListBatchesResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Batch> data,
      @JsonKey(name: 'first_id', includeIfNull: false) String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) String? lastId,
      @JsonKey(name: 'has_more') bool hasMore,
      ListBatchesResponseObject object});
}

/// @nodoc
class __$$ListBatchesResponseImplCopyWithImpl<$Res>
    extends _$ListBatchesResponseCopyWithImpl<$Res, _$ListBatchesResponseImpl>
    implements _$$ListBatchesResponseImplCopyWith<$Res> {
  __$$ListBatchesResponseImplCopyWithImpl(_$ListBatchesResponseImpl _value,
      $Res Function(_$ListBatchesResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? firstId = freezed,
    Object? lastId = freezed,
    Object? hasMore = null,
    Object? object = null,
  }) {
    return _then(_$ListBatchesResponseImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Batch>,
      firstId: freezed == firstId
          ? _value.firstId
          : firstId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastId: freezed == lastId
          ? _value.lastId
          : lastId // ignore: cast_nullable_to_non_nullable
              as String?,
      hasMore: null == hasMore
          ? _value.hasMore
          : hasMore // ignore: cast_nullable_to_non_nullable
              as bool,
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as ListBatchesResponseObject,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListBatchesResponseImpl extends _ListBatchesResponse {
  const _$ListBatchesResponseImpl(
      {required final List<Batch> data,
      @JsonKey(name: 'first_id', includeIfNull: false) this.firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) this.lastId,
      @JsonKey(name: 'has_more') required this.hasMore,
      required this.object})
      : _data = data,
        super._();

  factory _$ListBatchesResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListBatchesResponseImplFromJson(json);

  /// No Description
  final List<Batch> _data;

  /// No Description
  @override
  List<Batch> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  /// The ID of the first batch in the list.
  @override
  @JsonKey(name: 'first_id', includeIfNull: false)
  final String? firstId;

  /// The ID of the last batch in the list.
  @override
  @JsonKey(name: 'last_id', includeIfNull: false)
  final String? lastId;

  /// Whether there are more batches available.
  @override
  @JsonKey(name: 'has_more')
  final bool hasMore;

  /// The object type, which is always `list`.
  @override
  final ListBatchesResponseObject object;

  @override
  String toString() {
    return 'ListBatchesResponse(data: $data, firstId: $firstId, lastId: $lastId, hasMore: $hasMore, object: $object)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListBatchesResponseImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.firstId, firstId) || other.firstId == firstId) &&
            (identical(other.lastId, lastId) || other.lastId == lastId) &&
            (identical(other.hasMore, hasMore) || other.hasMore == hasMore) &&
            (identical(other.object, object) || other.object == object));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_data),
      firstId,
      lastId,
      hasMore,
      object);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListBatchesResponseImplCopyWith<_$ListBatchesResponseImpl> get copyWith =>
      __$$ListBatchesResponseImplCopyWithImpl<_$ListBatchesResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListBatchesResponseImplToJson(
      this,
    );
  }
}

abstract class _ListBatchesResponse extends ListBatchesResponse {
  const factory _ListBatchesResponse(
      {required final List<Batch> data,
      @JsonKey(name: 'first_id', includeIfNull: false) final String? firstId,
      @JsonKey(name: 'last_id', includeIfNull: false) final String? lastId,
      @JsonKey(name: 'has_more') required final bool hasMore,
      required final ListBatchesResponseObject
          object}) = _$ListBatchesResponseImpl;
  const _ListBatchesResponse._() : super._();

  factory _ListBatchesResponse.fromJson(Map<String, dynamic> json) =
      _$ListBatchesResponseImpl.fromJson;

  @override

  /// No Description
  List<Batch> get data;
  @override

  /// The ID of the first batch in the list.
  @JsonKey(name: 'first_id', includeIfNull: false)
  String? get firstId;
  @override

  /// The ID of the last batch in the list.
  @JsonKey(name: 'last_id', includeIfNull: false)
  String? get lastId;
  @override

  /// Whether there are more batches available.
  @JsonKey(name: 'has_more')
  bool get hasMore;
  @override

  /// The object type, which is always `list`.
  ListBatchesResponseObject get object;
  @override
  @JsonKey(ignore: true)
  _$$ListBatchesResponseImplCopyWith<_$ListBatchesResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChatCompletionMessage _$ChatCompletionMessageFromJson(
    Map<String, dynamic> json) {
  switch (json['role']) {
    case 'system':
      return ChatCompletionSystemMessage.fromJson(json);
    case 'user':
      return ChatCompletionUserMessage.fromJson(json);
    case 'assistant':
      return ChatCompletionAssistantMessage.fromJson(json);
    case 'tool':
      return ChatCompletionToolMessage.fromJson(json);
    case 'function':
      return ChatCompletionFunctionMessage.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'role', 'ChatCompletionMessage',
          'Invalid union type "${json['role']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessage {
  /// The role of the messages author, in this case `system`.
  ChatCompletionMessageRole get role => throw _privateConstructorUsedError;

  /// The contents of the system message.
  Object? get content => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageCopyWith<ChatCompletionMessage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageCopyWith<$Res> {
  factory $ChatCompletionMessageCopyWith(ChatCompletionMessage value,
          $Res Function(ChatCompletionMessage) then) =
      _$ChatCompletionMessageCopyWithImpl<$Res, ChatCompletionMessage>;
  @useResult
  $Res call({ChatCompletionMessageRole role});
}

/// @nodoc
class _$ChatCompletionMessageCopyWithImpl<$Res,
        $Val extends ChatCompletionMessage>
    implements $ChatCompletionMessageCopyWith<$Res> {
  _$ChatCompletionMessageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
  }) {
    return _then(_value.copyWith(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionSystemMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionSystemMessageImplCopyWith(
          _$ChatCompletionSystemMessageImpl value,
          $Res Function(_$ChatCompletionSystemMessageImpl) then) =
      __$$ChatCompletionSystemMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String content,
      @JsonKey(includeIfNull: false) String? name});
}

/// @nodoc
class __$$ChatCompletionSystemMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionSystemMessageImpl>
    implements _$$ChatCompletionSystemMessageImplCopyWith<$Res> {
  __$$ChatCompletionSystemMessageImplCopyWithImpl(
      _$ChatCompletionSystemMessageImpl _value,
      $Res Function(_$ChatCompletionSystemMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? name = freezed,
  }) {
    return _then(_$ChatCompletionSystemMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionSystemMessageImpl extends ChatCompletionSystemMessage {
  const _$ChatCompletionSystemMessageImpl(
      {this.role = ChatCompletionMessageRole.system,
      required this.content,
      @JsonKey(includeIfNull: false) this.name})
      : super._();

  factory _$ChatCompletionSystemMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionSystemMessageImplFromJson(json);

  /// The role of the messages author, in this case `system`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the system message.
  @override
  final String content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  @override
  String toString() {
    return 'ChatCompletionMessage.system(role: $role, content: $content, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionSystemMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionSystemMessageImplCopyWith<_$ChatCompletionSystemMessageImpl>
      get copyWith => __$$ChatCompletionSystemMessageImplCopyWithImpl<
          _$ChatCompletionSystemMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return system(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return system?.call(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (system != null) {
      return system(role, content, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return system(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return system?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (system != null) {
      return system(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionSystemMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionSystemMessage extends ChatCompletionMessage {
  const factory ChatCompletionSystemMessage(
          {final ChatCompletionMessageRole role,
          required final String content,
          @JsonKey(includeIfNull: false) final String? name}) =
      _$ChatCompletionSystemMessageImpl;
  const ChatCompletionSystemMessage._() : super._();

  factory ChatCompletionSystemMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionSystemMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `system`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the system message.
  String get content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionSystemMessageImplCopyWith<_$ChatCompletionSystemMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionUserMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionUserMessageImplCopyWith(
          _$ChatCompletionUserMessageImpl value,
          $Res Function(_$ChatCompletionUserMessageImpl) then) =
      __$$ChatCompletionUserMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @_ChatCompletionUserMessageContentConverter()
      ChatCompletionUserMessageContent content,
      @JsonKey(includeIfNull: false) String? name});

  $ChatCompletionUserMessageContentCopyWith<$Res> get content;
}

/// @nodoc
class __$$ChatCompletionUserMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionUserMessageImpl>
    implements _$$ChatCompletionUserMessageImplCopyWith<$Res> {
  __$$ChatCompletionUserMessageImplCopyWithImpl(
      _$ChatCompletionUserMessageImpl _value,
      $Res Function(_$ChatCompletionUserMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? name = freezed,
  }) {
    return _then(_$ChatCompletionUserMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as ChatCompletionUserMessageContent,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionUserMessageContentCopyWith<$Res> get content {
    return $ChatCompletionUserMessageContentCopyWith<$Res>(_value.content,
        (value) {
      return _then(_value.copyWith(content: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionUserMessageImpl extends ChatCompletionUserMessage {
  const _$ChatCompletionUserMessageImpl(
      {this.role = ChatCompletionMessageRole.user,
      @_ChatCompletionUserMessageContentConverter() required this.content,
      @JsonKey(includeIfNull: false) this.name})
      : super._();

  factory _$ChatCompletionUserMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionUserMessageImplFromJson(json);

  /// The role of the messages author, in this case `user`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the user message.
  @override
  @_ChatCompletionUserMessageContentConverter()
  final ChatCompletionUserMessageContent content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  @override
  String toString() {
    return 'ChatCompletionMessage.user(role: $role, content: $content, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionUserMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionUserMessageImplCopyWith<_$ChatCompletionUserMessageImpl>
      get copyWith => __$$ChatCompletionUserMessageImplCopyWithImpl<
          _$ChatCompletionUserMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return user(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return user?.call(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(role, content, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return user(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return user?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionUserMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionUserMessage extends ChatCompletionMessage {
  const factory ChatCompletionUserMessage(
          {final ChatCompletionMessageRole role,
          @_ChatCompletionUserMessageContentConverter()
          required final ChatCompletionUserMessageContent content,
          @JsonKey(includeIfNull: false) final String? name}) =
      _$ChatCompletionUserMessageImpl;
  const ChatCompletionUserMessage._() : super._();

  factory ChatCompletionUserMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionUserMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `user`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the user message.
  @_ChatCompletionUserMessageContentConverter()
  ChatCompletionUserMessageContent get content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionUserMessageImplCopyWith<_$ChatCompletionUserMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionAssistantMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionAssistantMessageImplCopyWith(
          _$ChatCompletionAssistantMessageImpl value,
          $Res Function(_$ChatCompletionAssistantMessageImpl) then) =
      __$$ChatCompletionAssistantMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      @JsonKey(includeIfNull: false) String? content,
      @JsonKey(includeIfNull: false) String? name,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false)
      ChatCompletionMessageFunctionCall? functionCall});

  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall;
}

/// @nodoc
class __$$ChatCompletionAssistantMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionAssistantMessageImpl>
    implements _$$ChatCompletionAssistantMessageImplCopyWith<$Res> {
  __$$ChatCompletionAssistantMessageImplCopyWithImpl(
      _$ChatCompletionAssistantMessageImpl _value,
      $Res Function(_$ChatCompletionAssistantMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? name = freezed,
    Object? toolCalls = freezed,
    Object? functionCall = freezed,
  }) {
    return _then(_$ChatCompletionAssistantMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageToolCall>?,
      functionCall: freezed == functionCall
          ? _value.functionCall
          : functionCall // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageFunctionCall?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageFunctionCallCopyWith<$Res>? get functionCall {
    if (_value.functionCall == null) {
      return null;
    }

    return $ChatCompletionMessageFunctionCallCopyWith<$Res>(
        _value.functionCall!, (value) {
      return _then(_value.copyWith(functionCall: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionAssistantMessageImpl
    extends ChatCompletionAssistantMessage {
  const _$ChatCompletionAssistantMessageImpl(
      {this.role = ChatCompletionMessageRole.assistant,
      @JsonKey(includeIfNull: false) this.content,
      @JsonKey(includeIfNull: false) this.name,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<ChatCompletionMessageToolCall>? toolCalls,
      @JsonKey(name: 'function_call', includeIfNull: false) this.functionCall})
      : _toolCalls = toolCalls,
        super._();

  factory _$ChatCompletionAssistantMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionAssistantMessageImplFromJson(json);

  /// The role of the messages author, in this case `assistant`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
  @override
  @JsonKey(includeIfNull: false)
  final String? content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// No Description
  final List<ChatCompletionMessageToolCall>? _toolCalls;

  /// No Description
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @override
  @JsonKey(name: 'function_call', includeIfNull: false)
  final ChatCompletionMessageFunctionCall? functionCall;

  @override
  String toString() {
    return 'ChatCompletionMessage.assistant(role: $role, content: $content, name: $name, toolCalls: $toolCalls, functionCall: $functionCall)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionAssistantMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls) &&
            (identical(other.functionCall, functionCall) ||
                other.functionCall == functionCall));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name,
      const DeepCollectionEquality().hash(_toolCalls), functionCall);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionAssistantMessageImplCopyWith<
          _$ChatCompletionAssistantMessageImpl>
      get copyWith => __$$ChatCompletionAssistantMessageImplCopyWithImpl<
          _$ChatCompletionAssistantMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return assistant(role, content, name, toolCalls, functionCall);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return assistant?.call(role, content, name, toolCalls, functionCall);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (assistant != null) {
      return assistant(role, content, name, toolCalls, functionCall);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return assistant(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return assistant?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (assistant != null) {
      return assistant(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionAssistantMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionAssistantMessage extends ChatCompletionMessage {
  const factory ChatCompletionAssistantMessage(
          {final ChatCompletionMessageRole role,
          @JsonKey(includeIfNull: false) final String? content,
          @JsonKey(includeIfNull: false) final String? name,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<ChatCompletionMessageToolCall>? toolCalls,
          @JsonKey(name: 'function_call', includeIfNull: false)
          final ChatCompletionMessageFunctionCall? functionCall}) =
      _$ChatCompletionAssistantMessageImpl;
  const ChatCompletionAssistantMessage._() : super._();

  factory ChatCompletionAssistantMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionAssistantMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `assistant`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
  @JsonKey(includeIfNull: false)
  String? get content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  @JsonKey(includeIfNull: false)
  String? get name;

  /// No Description
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<ChatCompletionMessageToolCall>? get toolCalls;

  /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
  @JsonKey(name: 'function_call', includeIfNull: false)
  ChatCompletionMessageFunctionCall? get functionCall;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionAssistantMessageImplCopyWith<
          _$ChatCompletionAssistantMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionToolMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionToolMessageImplCopyWith(
          _$ChatCompletionToolMessageImpl value,
          $Res Function(_$ChatCompletionToolMessageImpl) then) =
      __$$ChatCompletionToolMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageRole role,
      String content,
      @JsonKey(name: 'tool_call_id') String toolCallId});
}

/// @nodoc
class __$$ChatCompletionToolMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionToolMessageImpl>
    implements _$$ChatCompletionToolMessageImplCopyWith<$Res> {
  __$$ChatCompletionToolMessageImplCopyWithImpl(
      _$ChatCompletionToolMessageImpl _value,
      $Res Function(_$ChatCompletionToolMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = null,
    Object? toolCallId = null,
  }) {
    return _then(_$ChatCompletionToolMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
      toolCallId: null == toolCallId
          ? _value.toolCallId
          : toolCallId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionToolMessageImpl extends ChatCompletionToolMessage {
  const _$ChatCompletionToolMessageImpl(
      {this.role = ChatCompletionMessageRole.tool,
      required this.content,
      @JsonKey(name: 'tool_call_id') required this.toolCallId})
      : super._();

  factory _$ChatCompletionToolMessageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChatCompletionToolMessageImplFromJson(json);

  /// The role of the messages author, in this case `tool`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the tool message.
  @override
  final String content;

  /// Tool call that this message is responding to.
  @override
  @JsonKey(name: 'tool_call_id')
  final String toolCallId;

  @override
  String toString() {
    return 'ChatCompletionMessage.tool(role: $role, content: $content, toolCallId: $toolCallId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionToolMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.toolCallId, toolCallId) ||
                other.toolCallId == toolCallId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, toolCallId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionToolMessageImplCopyWith<_$ChatCompletionToolMessageImpl>
      get copyWith => __$$ChatCompletionToolMessageImplCopyWithImpl<
          _$ChatCompletionToolMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return tool(role, content, toolCallId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return tool?.call(role, content, toolCallId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(role, content, toolCallId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return tool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return tool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (tool != null) {
      return tool(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionToolMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionToolMessage extends ChatCompletionMessage {
  const factory ChatCompletionToolMessage(
          {final ChatCompletionMessageRole role,
          required final String content,
          @JsonKey(name: 'tool_call_id') required final String toolCallId}) =
      _$ChatCompletionToolMessageImpl;
  const ChatCompletionToolMessage._() : super._();

  factory ChatCompletionToolMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionToolMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `tool`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the tool message.
  String get content;

  /// Tool call that this message is responding to.
  @JsonKey(name: 'tool_call_id')
  String get toolCallId;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionToolMessageImplCopyWith<_$ChatCompletionToolMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionFunctionMessageImplCopyWith<$Res>
    implements $ChatCompletionMessageCopyWith<$Res> {
  factory _$$ChatCompletionFunctionMessageImplCopyWith(
          _$ChatCompletionFunctionMessageImpl value,
          $Res Function(_$ChatCompletionFunctionMessageImpl) then) =
      __$$ChatCompletionFunctionMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionMessageRole role, String? content, String name});
}

/// @nodoc
class __$$ChatCompletionFunctionMessageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageCopyWithImpl<$Res,
        _$ChatCompletionFunctionMessageImpl>
    implements _$$ChatCompletionFunctionMessageImplCopyWith<$Res> {
  __$$ChatCompletionFunctionMessageImplCopyWithImpl(
      _$ChatCompletionFunctionMessageImpl _value,
      $Res Function(_$ChatCompletionFunctionMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? role = null,
    Object? content = freezed,
    Object? name = null,
  }) {
    return _then(_$ChatCompletionFunctionMessageImpl(
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageRole,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionFunctionMessageImpl
    extends ChatCompletionFunctionMessage {
  const _$ChatCompletionFunctionMessageImpl(
      {this.role = ChatCompletionMessageRole.function,
      required this.content,
      required this.name})
      : super._();

  factory _$ChatCompletionFunctionMessageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionFunctionMessageImplFromJson(json);

  /// The role of the messages author, in this case `function`.
  @override
  @JsonKey()
  final ChatCompletionMessageRole role;

  /// The contents of the function message.
  @override
  final String? content;

  /// The name of the function to call.
  @override
  final String name;

  @override
  String toString() {
    return 'ChatCompletionMessage.function(role: $role, content: $content, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionFunctionMessageImpl &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, role, content, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionFunctionMessageImplCopyWith<
          _$ChatCompletionFunctionMessageImpl>
      get copyWith => __$$ChatCompletionFunctionMessageImplCopyWithImpl<
          _$ChatCompletionFunctionMessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)
        system,
    required TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)
        user,
    required TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)
        assistant,
    required TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)
        tool,
    required TResult Function(
            ChatCompletionMessageRole role, String? content, String name)
        function,
  }) {
    return function(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult? Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult? Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult? Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult? Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
  }) {
    return function?.call(role, content, name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(includeIfNull: false) String? name)?
        system,
    TResult Function(
            ChatCompletionMessageRole role,
            @_ChatCompletionUserMessageContentConverter()
            ChatCompletionUserMessageContent content,
            @JsonKey(includeIfNull: false) String? name)?
        user,
    TResult Function(
            ChatCompletionMessageRole role,
            @JsonKey(includeIfNull: false) String? content,
            @JsonKey(includeIfNull: false) String? name,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<ChatCompletionMessageToolCall>? toolCalls,
            @JsonKey(name: 'function_call', includeIfNull: false)
            ChatCompletionMessageFunctionCall? functionCall)?
        assistant,
    TResult Function(ChatCompletionMessageRole role, String content,
            @JsonKey(name: 'tool_call_id') String toolCallId)?
        tool,
    TResult Function(
            ChatCompletionMessageRole role, String? content, String name)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(role, content, name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionSystemMessage value) system,
    required TResult Function(ChatCompletionUserMessage value) user,
    required TResult Function(ChatCompletionAssistantMessage value) assistant,
    required TResult Function(ChatCompletionToolMessage value) tool,
    required TResult Function(ChatCompletionFunctionMessage value) function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionSystemMessage value)? system,
    TResult? Function(ChatCompletionUserMessage value)? user,
    TResult? Function(ChatCompletionAssistantMessage value)? assistant,
    TResult? Function(ChatCompletionToolMessage value)? tool,
    TResult? Function(ChatCompletionFunctionMessage value)? function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionSystemMessage value)? system,
    TResult Function(ChatCompletionUserMessage value)? user,
    TResult Function(ChatCompletionAssistantMessage value)? assistant,
    TResult Function(ChatCompletionToolMessage value)? tool,
    TResult Function(ChatCompletionFunctionMessage value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionFunctionMessageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionFunctionMessage extends ChatCompletionMessage {
  const factory ChatCompletionFunctionMessage(
      {final ChatCompletionMessageRole role,
      required final String? content,
      required final String name}) = _$ChatCompletionFunctionMessageImpl;
  const ChatCompletionFunctionMessage._() : super._();

  factory ChatCompletionFunctionMessage.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionFunctionMessageImpl.fromJson;

  @override

  /// The role of the messages author, in this case `function`.
  ChatCompletionMessageRole get role;
  @override

  /// The contents of the function message.
  String? get content;

  /// The name of the function to call.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionFunctionMessageImplCopyWith<
          _$ChatCompletionFunctionMessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionUserMessageContent _$ChatCompletionUserMessageContentFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'parts':
      return ChatCompletionMessageContentParts.fromJson(json);
    case 'string':
      return ChatCompletionUserMessageContentString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'ChatCompletionUserMessageContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionUserMessageContent {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionUserMessageContentCopyWith<$Res> {
  factory $ChatCompletionUserMessageContentCopyWith(
          ChatCompletionUserMessageContent value,
          $Res Function(ChatCompletionUserMessageContent) then) =
      _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
          ChatCompletionUserMessageContent>;
}

/// @nodoc
class _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        $Val extends ChatCompletionUserMessageContent>
    implements $ChatCompletionUserMessageContentCopyWith<$Res> {
  _$ChatCompletionUserMessageContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartsImplCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartsImplCopyWith(
          _$ChatCompletionMessageContentPartsImpl value,
          $Res Function(_$ChatCompletionMessageContentPartsImpl) then) =
      __$$ChatCompletionMessageContentPartsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ChatCompletionMessageContentPart> value});
}

/// @nodoc
class __$$ChatCompletionMessageContentPartsImplCopyWithImpl<$Res>
    extends _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartsImpl>
    implements _$$ChatCompletionMessageContentPartsImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartsImplCopyWithImpl(
      _$ChatCompletionMessageContentPartsImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartsImpl(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<ChatCompletionMessageContentPart>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartsImpl
    extends ChatCompletionMessageContentParts {
  const _$ChatCompletionMessageContentPartsImpl(
      final List<ChatCompletionMessageContentPart> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'parts',
        super._();

  factory _$ChatCompletionMessageContentPartsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartsImplFromJson(json);

  final List<ChatCompletionMessageContentPart> _value;
  @override
  List<ChatCompletionMessageContentPart> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.parts(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartsImpl &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartsImplCopyWith<
          _$ChatCompletionMessageContentPartsImpl>
      get copyWith => __$$ChatCompletionMessageContentPartsImplCopyWithImpl<
          _$ChatCompletionMessageContentPartsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) {
    return parts(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) {
    return parts?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) {
    return parts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) {
    return parts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) {
    if (parts != null) {
      return parts(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartsImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentParts
    extends ChatCompletionUserMessageContent {
  const factory ChatCompletionMessageContentParts(
          final List<ChatCompletionMessageContentPart> value) =
      _$ChatCompletionMessageContentPartsImpl;
  const ChatCompletionMessageContentParts._() : super._();

  factory ChatCompletionMessageContentParts.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartsImpl.fromJson;

  @override
  List<ChatCompletionMessageContentPart> get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartsImplCopyWith<
          _$ChatCompletionMessageContentPartsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionUserMessageContentStringImplCopyWith<$Res> {
  factory _$$ChatCompletionUserMessageContentStringImplCopyWith(
          _$ChatCompletionUserMessageContentStringImpl value,
          $Res Function(_$ChatCompletionUserMessageContentStringImpl) then) =
      __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<$Res>
    extends _$ChatCompletionUserMessageContentCopyWithImpl<$Res,
        _$ChatCompletionUserMessageContentStringImpl>
    implements _$$ChatCompletionUserMessageContentStringImplCopyWith<$Res> {
  __$$ChatCompletionUserMessageContentStringImplCopyWithImpl(
      _$ChatCompletionUserMessageContentStringImpl _value,
      $Res Function(_$ChatCompletionUserMessageContentStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$ChatCompletionUserMessageContentStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionUserMessageContentStringImpl
    extends ChatCompletionUserMessageContentString {
  const _$ChatCompletionUserMessageContentStringImpl(this.value,
      {final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$ChatCompletionUserMessageContentStringImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionUserMessageContentStringImplFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ChatCompletionUserMessageContent.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionUserMessageContentStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionUserMessageContentStringImplCopyWith<
          _$ChatCompletionUserMessageContentStringImpl>
      get copyWith =>
          __$$ChatCompletionUserMessageContentStringImplCopyWithImpl<
              _$ChatCompletionUserMessageContentStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<ChatCompletionMessageContentPart> value)
        parts,
    required TResult Function(String value) string,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult? Function(String value)? string,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<ChatCompletionMessageContentPart> value)? parts,
    TResult Function(String value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentParts value) parts,
    required TResult Function(ChatCompletionUserMessageContentString value)
        string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentParts value)? parts,
    TResult? Function(ChatCompletionUserMessageContentString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentParts value)? parts,
    TResult Function(ChatCompletionUserMessageContentString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionUserMessageContentStringImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionUserMessageContentString
    extends ChatCompletionUserMessageContent {
  const factory ChatCompletionUserMessageContentString(final String value) =
      _$ChatCompletionUserMessageContentStringImpl;
  const ChatCompletionUserMessageContentString._() : super._();

  factory ChatCompletionUserMessageContentString.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionUserMessageContentStringImpl.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$ChatCompletionUserMessageContentStringImplCopyWith<
          _$ChatCompletionUserMessageContentStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageContentPart _$ChatCompletionMessageContentPartFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'text':
      return ChatCompletionMessageContentPartText.fromJson(json);
    case 'image_url':
      return ChatCompletionMessageContentPartImage.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChatCompletionMessageContentPart',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChatCompletionMessageContentPart {
  /// The type of the content part, in this case `text`.
  ChatCompletionMessageContentPartType get type =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageContentPartCopyWith<ChatCompletionMessageContentPart>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory $ChatCompletionMessageContentPartCopyWith(
          ChatCompletionMessageContentPart value,
          $Res Function(ChatCompletionMessageContentPart) then) =
      _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
          ChatCompletionMessageContentPart>;
  @useResult
  $Res call({ChatCompletionMessageContentPartType type});
}

/// @nodoc
class _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageContentPart>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  _$ChatCompletionMessageContentPartCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartTextImplCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartTextImplCopyWith(
          _$ChatCompletionMessageContentPartTextImpl value,
          $Res Function(_$ChatCompletionMessageContentPartTextImpl) then) =
      __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChatCompletionMessageContentPartType type, String text});
}

/// @nodoc
class __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartTextImpl>
    implements _$$ChatCompletionMessageContentPartTextImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartTextImplCopyWithImpl(
      _$ChatCompletionMessageContentPartTextImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartTextImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartTextImpl
    extends ChatCompletionMessageContentPartText {
  const _$ChatCompletionMessageContentPartTextImpl(
      {this.type = ChatCompletionMessageContentPartType.text,
      required this.text})
      : super._();

  factory _$ChatCompletionMessageContentPartTextImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartTextImplFromJson(json);

  /// The type of the content part, in this case `text`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The text content.
  @override
  final String text;

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.text(type: $type, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartTextImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartTextImplCopyWith<
          _$ChatCompletionMessageContentPartTextImpl>
      get copyWith => __$$ChatCompletionMessageContentPartTextImplCopyWithImpl<
          _$ChatCompletionMessageContentPartTextImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) {
    return text(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) {
    return text?.call(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(type, this.text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartTextImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentPartText
    extends ChatCompletionMessageContentPart {
  const factory ChatCompletionMessageContentPartText(
      {final ChatCompletionMessageContentPartType type,
      required final String text}) = _$ChatCompletionMessageContentPartTextImpl;
  const ChatCompletionMessageContentPartText._() : super._();

  factory ChatCompletionMessageContentPartText.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartTextImpl.fromJson;

  @override

  /// The type of the content part, in this case `text`.
  ChatCompletionMessageContentPartType get type;

  /// The text content.
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartTextImplCopyWith<
          _$ChatCompletionMessageContentPartTextImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatCompletionMessageContentPartImageImplCopyWith<$Res>
    implements $ChatCompletionMessageContentPartCopyWith<$Res> {
  factory _$$ChatCompletionMessageContentPartImageImplCopyWith(
          _$ChatCompletionMessageContentPartImageImpl value,
          $Res Function(_$ChatCompletionMessageContentPartImageImpl) then) =
      __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChatCompletionMessageContentPartType type,
      @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl});

  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl;
}

/// @nodoc
class __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageContentPartCopyWithImpl<$Res,
        _$ChatCompletionMessageContentPartImageImpl>
    implements _$$ChatCompletionMessageContentPartImageImplCopyWith<$Res> {
  __$$ChatCompletionMessageContentPartImageImplCopyWithImpl(
      _$ChatCompletionMessageContentPartImageImpl _value,
      $Res Function(_$ChatCompletionMessageContentPartImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? imageUrl = null,
  }) {
    return _then(_$ChatCompletionMessageContentPartImageImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageContentPartType,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageUrl,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChatCompletionMessageImageUrlCopyWith<$Res> get imageUrl {
    return $ChatCompletionMessageImageUrlCopyWith<$Res>(_value.imageUrl,
        (value) {
      return _then(_value.copyWith(imageUrl: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageContentPartImageImpl
    extends ChatCompletionMessageContentPartImage {
  const _$ChatCompletionMessageContentPartImageImpl(
      {this.type = ChatCompletionMessageContentPartType.imageUrl,
      @JsonKey(name: 'image_url') required this.imageUrl})
      : super._();

  factory _$ChatCompletionMessageContentPartImageImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageContentPartImageImplFromJson(json);

  /// The type of the content part, in this case `image_url`.
  @override
  @JsonKey()
  final ChatCompletionMessageContentPartType type;

  /// The URL of the image.
  @override
  @JsonKey(name: 'image_url')
  final ChatCompletionMessageImageUrl imageUrl;

  @override
  String toString() {
    return 'ChatCompletionMessageContentPart.image(type: $type, imageUrl: $imageUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageContentPartImageImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageContentPartImageImplCopyWith<
          _$ChatCompletionMessageContentPartImageImpl>
      get copyWith => __$$ChatCompletionMessageContentPartImageImplCopyWithImpl<
          _$ChatCompletionMessageContentPartImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            ChatCompletionMessageContentPartType type, String text)
        text,
    required TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)
        image,
  }) {
    return image(type, imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult? Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
  }) {
    return image?.call(type, imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartType type, String text)?
        text,
    TResult Function(ChatCompletionMessageContentPartType type,
            @JsonKey(name: 'image_url') ChatCompletionMessageImageUrl imageUrl)?
        image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(type, imageUrl);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChatCompletionMessageContentPartText value) text,
    required TResult Function(ChatCompletionMessageContentPartImage value)
        image,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChatCompletionMessageContentPartText value)? text,
    TResult? Function(ChatCompletionMessageContentPartImage value)? image,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChatCompletionMessageContentPartText value)? text,
    TResult Function(ChatCompletionMessageContentPartImage value)? image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageContentPartImageImplToJson(
      this,
    );
  }
}

abstract class ChatCompletionMessageContentPartImage
    extends ChatCompletionMessageContentPart {
  const factory ChatCompletionMessageContentPartImage(
          {final ChatCompletionMessageContentPartType type,
          @JsonKey(name: 'image_url')
          required final ChatCompletionMessageImageUrl imageUrl}) =
      _$ChatCompletionMessageContentPartImageImpl;
  const ChatCompletionMessageContentPartImage._() : super._();

  factory ChatCompletionMessageContentPartImage.fromJson(
          Map<String, dynamic> json) =
      _$ChatCompletionMessageContentPartImageImpl.fromJson;

  @override

  /// The type of the content part, in this case `image_url`.
  ChatCompletionMessageContentPartType get type;

  /// The URL of the image.
  @JsonKey(name: 'image_url')
  ChatCompletionMessageImageUrl get imageUrl;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageContentPartImageImplCopyWith<
          _$ChatCompletionMessageContentPartImageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChatCompletionMessageImageUrl _$ChatCompletionMessageImageUrlFromJson(
    Map<String, dynamic> json) {
  return _ChatCompletionMessageImageUrl.fromJson(json);
}

/// @nodoc
mixin _$ChatCompletionMessageImageUrl {
  /// Either a URL of the image or the base64 encoded image data.
  String get url => throw _privateConstructorUsedError;

  /// Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
  ChatCompletionMessageImageDetail get detail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChatCompletionMessageImageUrlCopyWith<ChatCompletionMessageImageUrl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory $ChatCompletionMessageImageUrlCopyWith(
          ChatCompletionMessageImageUrl value,
          $Res Function(ChatCompletionMessageImageUrl) then) =
      _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
          ChatCompletionMessageImageUrl>;
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
        $Val extends ChatCompletionMessageImageUrl>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  _$ChatCompletionMessageImageUrlCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_value.copyWith(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatCompletionMessageImageUrlImplCopyWith<$Res>
    implements $ChatCompletionMessageImageUrlCopyWith<$Res> {
  factory _$$ChatCompletionMessageImageUrlImplCopyWith(
          _$ChatCompletionMessageImageUrlImpl value,
          $Res Function(_$ChatCompletionMessageImageUrlImpl) then) =
      __$$ChatCompletionMessageImageUrlImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url, ChatCompletionMessageImageDetail detail});
}

/// @nodoc
class __$$ChatCompletionMessageImageUrlImplCopyWithImpl<$Res>
    extends _$ChatCompletionMessageImageUrlCopyWithImpl<$Res,
        _$ChatCompletionMessageImageUrlImpl>
    implements _$$ChatCompletionMessageImageUrlImplCopyWith<$Res> {
  __$$ChatCompletionMessageImageUrlImplCopyWithImpl(
      _$ChatCompletionMessageImageUrlImpl _value,
      $Res Function(_$ChatCompletionMessageImageUrlImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? detail = null,
  }) {
    return _then(_$ChatCompletionMessageImageUrlImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      detail: null == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as ChatCompletionMessageImageDetail,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChatCompletionMessageImageUrlImpl
    extends _ChatCompletionMessageImageUrl {
  const _$ChatCompletionMessageImageUrlImpl(
      {required this.url, this.detail = ChatCompletionMessageImageDetail.auto})
      : super._();

  factory _$ChatCompletionMessageImageUrlImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChatCompletionMessageImageUrlImplFromJson(json);

  /// Either a URL of the image or the base64 encoded image data.
  @override
  final String url;

  /// Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
  @override
  @JsonKey()
  final ChatCompletionMessageImageDetail detail;

  @override
  String toString() {
    return 'ChatCompletionMessageImageUrl(url: $url, detail: $detail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatCompletionMessageImageUrlImpl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.detail, detail) || other.detail == detail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, detail);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatCompletionMessageImageUrlImplCopyWith<
          _$ChatCompletionMessageImageUrlImpl>
      get copyWith => __$$ChatCompletionMessageImageUrlImplCopyWithImpl<
          _$ChatCompletionMessageImageUrlImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChatCompletionMessageImageUrlImplToJson(
      this,
    );
  }
}

abstract class _ChatCompletionMessageImageUrl
    extends ChatCompletionMessageImageUrl {
  const factory _ChatCompletionMessageImageUrl(
          {required final String url,
          final ChatCompletionMessageImageDetail detail}) =
      _$ChatCompletionMessageImageUrlImpl;
  const _ChatCompletionMessageImageUrl._() : super._();

  factory _ChatCompletionMessageImageUrl.fromJson(Map<String, dynamic> json) =
      _$ChatCompletionMessageImageUrlImpl.fromJson;

  @override

  /// Either a URL of the image or the base64 encoded image data.
  String get url;
  @override

  /// Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
  ChatCompletionMessageImageDetail get detail;
  @override
  @JsonKey(ignore: true)
  _$$ChatCompletionMessageImageUrlImplCopyWith<
          _$ChatCompletionMessageImageUrlImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantTools _$AssistantToolsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return AssistantToolsCodeInterpreter.fromJson(json);
    case 'file_search':
      return AssistantToolsFileSearch.fromJson(json);
    case 'function':
      return AssistantToolsFunction.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'AssistantTools',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$AssistantTools {
  /// The type of tool being defined: `code_interpreter`
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)
        fileSearch,
    required TResult Function(String type, FunctionObject function) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult? Function(String type, FunctionObject function)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsFileSearch value) fileSearch,
    required TResult Function(AssistantToolsFunction value) function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsFileSearch value)? fileSearch,
    TResult? Function(AssistantToolsFunction value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsFileSearch value)? fileSearch,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantToolsCopyWith<AssistantTools> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantToolsCopyWith<$Res> {
  factory $AssistantToolsCopyWith(
          AssistantTools value, $Res Function(AssistantTools) then) =
      _$AssistantToolsCopyWithImpl<$Res, AssistantTools>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$AssistantToolsCopyWithImpl<$Res, $Val extends AssistantTools>
    implements $AssistantToolsCopyWith<$Res> {
  _$AssistantToolsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssistantToolsCodeInterpreterImplCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory _$$AssistantToolsCodeInterpreterImplCopyWith(
          _$AssistantToolsCodeInterpreterImpl value,
          $Res Function(_$AssistantToolsCodeInterpreterImpl) then) =
      __$$AssistantToolsCodeInterpreterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class __$$AssistantToolsCodeInterpreterImplCopyWithImpl<$Res>
    extends _$AssistantToolsCopyWithImpl<$Res,
        _$AssistantToolsCodeInterpreterImpl>
    implements _$$AssistantToolsCodeInterpreterImplCopyWith<$Res> {
  __$$AssistantToolsCodeInterpreterImplCopyWithImpl(
      _$AssistantToolsCodeInterpreterImpl _value,
      $Res Function(_$AssistantToolsCodeInterpreterImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$AssistantToolsCodeInterpreterImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantToolsCodeInterpreterImpl
    extends AssistantToolsCodeInterpreter {
  const _$AssistantToolsCodeInterpreterImpl({this.type = 'code_interpreter'})
      : super._();

  factory _$AssistantToolsCodeInterpreterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$AssistantToolsCodeInterpreterImplFromJson(json);

  /// The type of tool being defined: `code_interpreter`
  @override
  @JsonKey()
  final String type;

  @override
  String toString() {
    return 'AssistantTools.codeInterpreter(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantToolsCodeInterpreterImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantToolsCodeInterpreterImplCopyWith<
          _$AssistantToolsCodeInterpreterImpl>
      get copyWith => __$$AssistantToolsCodeInterpreterImplCopyWithImpl<
          _$AssistantToolsCodeInterpreterImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)
        fileSearch,
    required TResult Function(String type, FunctionObject function) function,
  }) {
    return codeInterpreter(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult? Function(String type, FunctionObject function)? function,
  }) {
    return codeInterpreter?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsFileSearch value) fileSearch,
    required TResult Function(AssistantToolsFunction value) function,
  }) {
    return codeInterpreter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsFileSearch value)? fileSearch,
    TResult? Function(AssistantToolsFunction value)? function,
  }) {
    return codeInterpreter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsFileSearch value)? fileSearch,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantToolsCodeInterpreterImplToJson(
      this,
    );
  }
}

abstract class AssistantToolsCodeInterpreter extends AssistantTools {
  const factory AssistantToolsCodeInterpreter({final String type}) =
      _$AssistantToolsCodeInterpreterImpl;
  const AssistantToolsCodeInterpreter._() : super._();

  factory AssistantToolsCodeInterpreter.fromJson(Map<String, dynamic> json) =
      _$AssistantToolsCodeInterpreterImpl.fromJson;

  @override

  /// The type of tool being defined: `code_interpreter`
  String get type;
  @override
  @JsonKey(ignore: true)
  _$$AssistantToolsCodeInterpreterImplCopyWith<
          _$AssistantToolsCodeInterpreterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssistantToolsFileSearchImplCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory _$$AssistantToolsFileSearchImplCopyWith(
          _$AssistantToolsFileSearchImpl value,
          $Res Function(_$AssistantToolsFileSearchImpl) then) =
      __$$AssistantToolsFileSearchImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'file_search', includeIfNull: false)
      AssistantToolsFileSearchFileSearch? fileSearch});

  $AssistantToolsFileSearchFileSearchCopyWith<$Res>? get fileSearch;
}

/// @nodoc
class __$$AssistantToolsFileSearchImplCopyWithImpl<$Res>
    extends _$AssistantToolsCopyWithImpl<$Res, _$AssistantToolsFileSearchImpl>
    implements _$$AssistantToolsFileSearchImplCopyWith<$Res> {
  __$$AssistantToolsFileSearchImplCopyWithImpl(
      _$AssistantToolsFileSearchImpl _value,
      $Res Function(_$AssistantToolsFileSearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? fileSearch = freezed,
  }) {
    return _then(_$AssistantToolsFileSearchImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      fileSearch: freezed == fileSearch
          ? _value.fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as AssistantToolsFileSearchFileSearch?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AssistantToolsFileSearchFileSearchCopyWith<$Res>? get fileSearch {
    if (_value.fileSearch == null) {
      return null;
    }

    return $AssistantToolsFileSearchFileSearchCopyWith<$Res>(_value.fileSearch!,
        (value) {
      return _then(_value.copyWith(fileSearch: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantToolsFileSearchImpl extends AssistantToolsFileSearch {
  const _$AssistantToolsFileSearchImpl(
      {required this.type,
      @JsonKey(name: 'file_search', includeIfNull: false) this.fileSearch})
      : super._();

  factory _$AssistantToolsFileSearchImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantToolsFileSearchImplFromJson(json);

  /// The type of tool being defined: `file_search`
  @override
  final String type;

  /// Overrides for the file search tool.
  @override
  @JsonKey(name: 'file_search', includeIfNull: false)
  final AssistantToolsFileSearchFileSearch? fileSearch;

  @override
  String toString() {
    return 'AssistantTools.fileSearch(type: $type, fileSearch: $fileSearch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantToolsFileSearchImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.fileSearch, fileSearch) ||
                other.fileSearch == fileSearch));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, fileSearch);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantToolsFileSearchImplCopyWith<_$AssistantToolsFileSearchImpl>
      get copyWith => __$$AssistantToolsFileSearchImplCopyWithImpl<
          _$AssistantToolsFileSearchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)
        fileSearch,
    required TResult Function(String type, FunctionObject function) function,
  }) {
    return fileSearch(type, this.fileSearch);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult? Function(String type, FunctionObject function)? function,
  }) {
    return fileSearch?.call(type, this.fileSearch);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) {
    if (fileSearch != null) {
      return fileSearch(type, this.fileSearch);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsFileSearch value) fileSearch,
    required TResult Function(AssistantToolsFunction value) function,
  }) {
    return fileSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsFileSearch value)? fileSearch,
    TResult? Function(AssistantToolsFunction value)? function,
  }) {
    return fileSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsFileSearch value)? fileSearch,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) {
    if (fileSearch != null) {
      return fileSearch(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantToolsFileSearchImplToJson(
      this,
    );
  }
}

abstract class AssistantToolsFileSearch extends AssistantTools {
  const factory AssistantToolsFileSearch(
          {required final String type,
          @JsonKey(name: 'file_search', includeIfNull: false)
          final AssistantToolsFileSearchFileSearch? fileSearch}) =
      _$AssistantToolsFileSearchImpl;
  const AssistantToolsFileSearch._() : super._();

  factory AssistantToolsFileSearch.fromJson(Map<String, dynamic> json) =
      _$AssistantToolsFileSearchImpl.fromJson;

  @override

  /// The type of tool being defined: `file_search`
  String get type;

  /// Overrides for the file search tool.
  @JsonKey(name: 'file_search', includeIfNull: false)
  AssistantToolsFileSearchFileSearch? get fileSearch;
  @override
  @JsonKey(ignore: true)
  _$$AssistantToolsFileSearchImplCopyWith<_$AssistantToolsFileSearchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AssistantToolsFunctionImplCopyWith<$Res>
    implements $AssistantToolsCopyWith<$Res> {
  factory _$$AssistantToolsFunctionImplCopyWith(
          _$AssistantToolsFunctionImpl value,
          $Res Function(_$AssistantToolsFunctionImpl) then) =
      __$$AssistantToolsFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, FunctionObject function});

  $FunctionObjectCopyWith<$Res> get function;
}

/// @nodoc
class __$$AssistantToolsFunctionImplCopyWithImpl<$Res>
    extends _$AssistantToolsCopyWithImpl<$Res, _$AssistantToolsFunctionImpl>
    implements _$$AssistantToolsFunctionImplCopyWith<$Res> {
  __$$AssistantToolsFunctionImplCopyWithImpl(
      _$AssistantToolsFunctionImpl _value,
      $Res Function(_$AssistantToolsFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$AssistantToolsFunctionImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as FunctionObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionObjectCopyWith<$Res> get function {
    return $FunctionObjectCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantToolsFunctionImpl extends AssistantToolsFunction {
  const _$AssistantToolsFunctionImpl(
      {this.type = 'function', required this.function})
      : super._();

  factory _$AssistantToolsFunctionImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssistantToolsFunctionImplFromJson(json);

  /// The type of tool being defined: `function`
  @override
  @JsonKey()
  final String type;

  /// A function that the model may call.
  @override
  final FunctionObject function;

  @override
  String toString() {
    return 'AssistantTools.function(type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantToolsFunctionImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantToolsFunctionImplCopyWith<_$AssistantToolsFunctionImpl>
      get copyWith => __$$AssistantToolsFunctionImplCopyWithImpl<
          _$AssistantToolsFunctionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) codeInterpreter,
    required TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)
        fileSearch,
    required TResult Function(String type, FunctionObject function) function,
  }) {
    return function(type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? codeInterpreter,
    TResult? Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult? Function(String type, FunctionObject function)? function,
  }) {
    return function?.call(type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? codeInterpreter,
    TResult Function(
            String type,
            @JsonKey(name: 'file_search', includeIfNull: false)
            AssistantToolsFileSearchFileSearch? fileSearch)?
        fileSearch,
    TResult Function(String type, FunctionObject function)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(type, this.function);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AssistantToolsCodeInterpreter value)
        codeInterpreter,
    required TResult Function(AssistantToolsFileSearch value) fileSearch,
    required TResult Function(AssistantToolsFunction value) function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult? Function(AssistantToolsFileSearch value)? fileSearch,
    TResult? Function(AssistantToolsFunction value)? function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AssistantToolsCodeInterpreter value)? codeInterpreter,
    TResult Function(AssistantToolsFileSearch value)? fileSearch,
    TResult Function(AssistantToolsFunction value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantToolsFunctionImplToJson(
      this,
    );
  }
}

abstract class AssistantToolsFunction extends AssistantTools {
  const factory AssistantToolsFunction(
      {final String type,
      required final FunctionObject function}) = _$AssistantToolsFunctionImpl;
  const AssistantToolsFunction._() : super._();

  factory AssistantToolsFunction.fromJson(Map<String, dynamic> json) =
      _$AssistantToolsFunctionImpl.fromJson;

  @override

  /// The type of tool being defined: `function`
  String get type;

  /// A function that the model may call.
  FunctionObject get function;
  @override
  @JsonKey(ignore: true)
  _$$AssistantToolsFunctionImplCopyWith<_$AssistantToolsFunctionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantToolsFileSearchFileSearch _$AssistantToolsFileSearchFileSearchFromJson(
    Map<String, dynamic> json) {
  return _AssistantToolsFileSearchFileSearch.fromJson(json);
}

/// @nodoc
mixin _$AssistantToolsFileSearchFileSearch {
  /// The maximum number of results the file search tool should output. The default is 20 for gpt-4* models
  /// and 5 for gpt-3.5-turbo. This number should be between 1 and 50 inclusive.
  ///
  /// Note that the file search tool may output fewer than `max_num_results` results. See the [file search
  /// tool documentation](/docs/assistants/tools/file-search/number-of-chunks-returned) for more information.
  @JsonKey(name: 'max_num_results', includeIfNull: false)
  int? get maxNumResults => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantToolsFileSearchFileSearchCopyWith<
          AssistantToolsFileSearchFileSearch>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantToolsFileSearchFileSearchCopyWith<$Res> {
  factory $AssistantToolsFileSearchFileSearchCopyWith(
          AssistantToolsFileSearchFileSearch value,
          $Res Function(AssistantToolsFileSearchFileSearch) then) =
      _$AssistantToolsFileSearchFileSearchCopyWithImpl<$Res,
          AssistantToolsFileSearchFileSearch>;
  @useResult
  $Res call(
      {@JsonKey(name: 'max_num_results', includeIfNull: false)
      int? maxNumResults});
}

/// @nodoc
class _$AssistantToolsFileSearchFileSearchCopyWithImpl<$Res,
        $Val extends AssistantToolsFileSearchFileSearch>
    implements $AssistantToolsFileSearchFileSearchCopyWith<$Res> {
  _$AssistantToolsFileSearchFileSearchCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? maxNumResults = freezed,
  }) {
    return _then(_value.copyWith(
      maxNumResults: freezed == maxNumResults
          ? _value.maxNumResults
          : maxNumResults // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssistantToolsFileSearchFileSearchImplCopyWith<$Res>
    implements $AssistantToolsFileSearchFileSearchCopyWith<$Res> {
  factory _$$AssistantToolsFileSearchFileSearchImplCopyWith(
          _$AssistantToolsFileSearchFileSearchImpl value,
          $Res Function(_$AssistantToolsFileSearchFileSearchImpl) then) =
      __$$AssistantToolsFileSearchFileSearchImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'max_num_results', includeIfNull: false)
      int? maxNumResults});
}

/// @nodoc
class __$$AssistantToolsFileSearchFileSearchImplCopyWithImpl<$Res>
    extends _$AssistantToolsFileSearchFileSearchCopyWithImpl<$Res,
        _$AssistantToolsFileSearchFileSearchImpl>
    implements _$$AssistantToolsFileSearchFileSearchImplCopyWith<$Res> {
  __$$AssistantToolsFileSearchFileSearchImplCopyWithImpl(
      _$AssistantToolsFileSearchFileSearchImpl _value,
      $Res Function(_$AssistantToolsFileSearchFileSearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? maxNumResults = freezed,
  }) {
    return _then(_$AssistantToolsFileSearchFileSearchImpl(
      maxNumResults: freezed == maxNumResults
          ? _value.maxNumResults
          : maxNumResults // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssistantToolsFileSearchFileSearchImpl
    extends _AssistantToolsFileSearchFileSearch {
  const _$AssistantToolsFileSearchFileSearchImpl(
      {@JsonKey(name: 'max_num_results', includeIfNull: false)
      this.maxNumResults})
      : super._();

  factory _$AssistantToolsFileSearchFileSearchImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$AssistantToolsFileSearchFileSearchImplFromJson(json);

  /// The maximum number of results the file search tool should output. The default is 20 for gpt-4* models
  /// and 5 for gpt-3.5-turbo. This number should be between 1 and 50 inclusive.
  ///
  /// Note that the file search tool may output fewer than `max_num_results` results. See the [file search
  /// tool documentation](/docs/assistants/tools/file-search/number-of-chunks-returned) for more information.
  @override
  @JsonKey(name: 'max_num_results', includeIfNull: false)
  final int? maxNumResults;

  @override
  String toString() {
    return 'AssistantToolsFileSearchFileSearch(maxNumResults: $maxNumResults)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssistantToolsFileSearchFileSearchImpl &&
            (identical(other.maxNumResults, maxNumResults) ||
                other.maxNumResults == maxNumResults));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, maxNumResults);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssistantToolsFileSearchFileSearchImplCopyWith<
          _$AssistantToolsFileSearchFileSearchImpl>
      get copyWith => __$$AssistantToolsFileSearchFileSearchImplCopyWithImpl<
          _$AssistantToolsFileSearchFileSearchImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssistantToolsFileSearchFileSearchImplToJson(
      this,
    );
  }
}

abstract class _AssistantToolsFileSearchFileSearch
    extends AssistantToolsFileSearchFileSearch {
  const factory _AssistantToolsFileSearchFileSearch(
      {@JsonKey(name: 'max_num_results', includeIfNull: false)
      final int? maxNumResults}) = _$AssistantToolsFileSearchFileSearchImpl;
  const _AssistantToolsFileSearchFileSearch._() : super._();

  factory _AssistantToolsFileSearchFileSearch.fromJson(
          Map<String, dynamic> json) =
      _$AssistantToolsFileSearchFileSearchImpl.fromJson;

  @override

  /// The maximum number of results the file search tool should output. The default is 20 for gpt-4* models
  /// and 5 for gpt-3.5-turbo. This number should be between 1 and 50 inclusive.
  ///
  /// Note that the file search tool may output fewer than `max_num_results` results. See the [file search
  /// tool documentation](/docs/assistants/tools/file-search/number-of-chunks-returned) for more information.
  @JsonKey(name: 'max_num_results', includeIfNull: false)
  int? get maxNumResults;
  @override
  @JsonKey(ignore: true)
  _$$AssistantToolsFileSearchFileSearchImplCopyWith<
          _$AssistantToolsFileSearchFileSearchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContent _$MessageContentFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'image_file':
      return MessageContentImageFileObject.fromJson(json);
    case 'image_url':
      return MessageContentImageUrlObject.fromJson(json);
    case 'text':
      return MessageContentTextObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'MessageContent',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageContent {
  /// Always `image_file`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)
        imageUrl,
    required TResult Function(String type, MessageContentText text) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult? Function(String type, MessageContentText text)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult Function(String type, MessageContentText text)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentImageUrlObject value) imageUrl,
    required TResult Function(MessageContentTextObject value) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentImageUrlObject value)? imageUrl,
    TResult? Function(MessageContentTextObject value)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentImageUrlObject value)? imageUrl,
    TResult Function(MessageContentTextObject value)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentCopyWith<MessageContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentCopyWith<$Res> {
  factory $MessageContentCopyWith(
          MessageContent value, $Res Function(MessageContent) then) =
      _$MessageContentCopyWithImpl<$Res, MessageContent>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$MessageContentCopyWithImpl<$Res, $Val extends MessageContent>
    implements $MessageContentCopyWith<$Res> {
  _$MessageContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentImageFileObjectImplCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory _$$MessageContentImageFileObjectImplCopyWith(
          _$MessageContentImageFileObjectImpl value,
          $Res Function(_$MessageContentImageFileObjectImpl) then) =
      __$$MessageContentImageFileObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'image_file') MessageContentImageFile imageFile});

  $MessageContentImageFileCopyWith<$Res> get imageFile;
}

/// @nodoc
class __$$MessageContentImageFileObjectImplCopyWithImpl<$Res>
    extends _$MessageContentCopyWithImpl<$Res,
        _$MessageContentImageFileObjectImpl>
    implements _$$MessageContentImageFileObjectImplCopyWith<$Res> {
  __$$MessageContentImageFileObjectImplCopyWithImpl(
      _$MessageContentImageFileObjectImpl _value,
      $Res Function(_$MessageContentImageFileObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? imageFile = null,
  }) {
    return _then(_$MessageContentImageFileObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageFile: null == imageFile
          ? _value.imageFile
          : imageFile // ignore: cast_nullable_to_non_nullable
              as MessageContentImageFile,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageFileCopyWith<$Res> get imageFile {
    return $MessageContentImageFileCopyWith<$Res>(_value.imageFile, (value) {
      return _then(_value.copyWith(imageFile: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentImageFileObjectImpl
    extends MessageContentImageFileObject {
  const _$MessageContentImageFileObjectImpl(
      {this.type = 'image_file',
      @JsonKey(name: 'image_file') required this.imageFile})
      : super._();

  factory _$MessageContentImageFileObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentImageFileObjectImplFromJson(json);

  /// Always `image_file`.
  @override
  @JsonKey()
  final String type;

  /// The image file that is part of a message.
  @override
  @JsonKey(name: 'image_file')
  final MessageContentImageFile imageFile;

  @override
  String toString() {
    return 'MessageContent.imageFile(type: $type, imageFile: $imageFile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentImageFileObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageFile, imageFile) ||
                other.imageFile == imageFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentImageFileObjectImplCopyWith<
          _$MessageContentImageFileObjectImpl>
      get copyWith => __$$MessageContentImageFileObjectImplCopyWithImpl<
          _$MessageContentImageFileObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)
        imageUrl,
    required TResult Function(String type, MessageContentText text) text,
  }) {
    return imageFile(type, this.imageFile);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult? Function(String type, MessageContentText text)? text,
  }) {
    return imageFile?.call(type, this.imageFile);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult Function(String type, MessageContentText text)? text,
    required TResult orElse(),
  }) {
    if (imageFile != null) {
      return imageFile(type, this.imageFile);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentImageUrlObject value) imageUrl,
    required TResult Function(MessageContentTextObject value) text,
  }) {
    return imageFile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentImageUrlObject value)? imageUrl,
    TResult? Function(MessageContentTextObject value)? text,
  }) {
    return imageFile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentImageUrlObject value)? imageUrl,
    TResult Function(MessageContentTextObject value)? text,
    required TResult orElse(),
  }) {
    if (imageFile != null) {
      return imageFile(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentImageFileObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentImageFileObject extends MessageContent {
  const factory MessageContentImageFileObject(
          {final String type,
          @JsonKey(name: 'image_file')
          required final MessageContentImageFile imageFile}) =
      _$MessageContentImageFileObjectImpl;
  const MessageContentImageFileObject._() : super._();

  factory MessageContentImageFileObject.fromJson(Map<String, dynamic> json) =
      _$MessageContentImageFileObjectImpl.fromJson;

  @override

  /// Always `image_file`.
  String get type;

  /// The image file that is part of a message.
  @JsonKey(name: 'image_file')
  MessageContentImageFile get imageFile;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentImageFileObjectImplCopyWith<
          _$MessageContentImageFileObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageContentImageUrlObjectImplCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory _$$MessageContentImageUrlObjectImplCopyWith(
          _$MessageContentImageUrlObjectImpl value,
          $Res Function(_$MessageContentImageUrlObjectImpl) then) =
      __$$MessageContentImageUrlObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl});

  $MessageContentImageUrlCopyWith<$Res> get imageUrl;
}

/// @nodoc
class __$$MessageContentImageUrlObjectImplCopyWithImpl<$Res>
    extends _$MessageContentCopyWithImpl<$Res,
        _$MessageContentImageUrlObjectImpl>
    implements _$$MessageContentImageUrlObjectImplCopyWith<$Res> {
  __$$MessageContentImageUrlObjectImplCopyWithImpl(
      _$MessageContentImageUrlObjectImpl _value,
      $Res Function(_$MessageContentImageUrlObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? imageUrl = null,
  }) {
    return _then(_$MessageContentImageUrlObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as MessageContentImageUrl,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageUrlCopyWith<$Res> get imageUrl {
    return $MessageContentImageUrlCopyWith<$Res>(_value.imageUrl, (value) {
      return _then(_value.copyWith(imageUrl: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentImageUrlObjectImpl extends MessageContentImageUrlObject {
  const _$MessageContentImageUrlObjectImpl(
      {this.type = 'image_url',
      @JsonKey(name: 'image_url') required this.imageUrl})
      : super._();

  factory _$MessageContentImageUrlObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentImageUrlObjectImplFromJson(json);

  /// The type of the content part. Always `image_url`.
  @override
  @JsonKey()
  final String type;

  /// The image URL part of a message.
  @override
  @JsonKey(name: 'image_url')
  final MessageContentImageUrl imageUrl;

  @override
  String toString() {
    return 'MessageContent.imageUrl(type: $type, imageUrl: $imageUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentImageUrlObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, imageUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentImageUrlObjectImplCopyWith<
          _$MessageContentImageUrlObjectImpl>
      get copyWith => __$$MessageContentImageUrlObjectImplCopyWithImpl<
          _$MessageContentImageUrlObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)
        imageUrl,
    required TResult Function(String type, MessageContentText text) text,
  }) {
    return imageUrl(type, this.imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult? Function(String type, MessageContentText text)? text,
  }) {
    return imageUrl?.call(type, this.imageUrl);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult Function(String type, MessageContentText text)? text,
    required TResult orElse(),
  }) {
    if (imageUrl != null) {
      return imageUrl(type, this.imageUrl);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentImageUrlObject value) imageUrl,
    required TResult Function(MessageContentTextObject value) text,
  }) {
    return imageUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentImageUrlObject value)? imageUrl,
    TResult? Function(MessageContentTextObject value)? text,
  }) {
    return imageUrl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentImageUrlObject value)? imageUrl,
    TResult Function(MessageContentTextObject value)? text,
    required TResult orElse(),
  }) {
    if (imageUrl != null) {
      return imageUrl(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentImageUrlObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentImageUrlObject extends MessageContent {
  const factory MessageContentImageUrlObject(
          {final String type,
          @JsonKey(name: 'image_url')
          required final MessageContentImageUrl imageUrl}) =
      _$MessageContentImageUrlObjectImpl;
  const MessageContentImageUrlObject._() : super._();

  factory MessageContentImageUrlObject.fromJson(Map<String, dynamic> json) =
      _$MessageContentImageUrlObjectImpl.fromJson;

  @override

  /// The type of the content part. Always `image_url`.
  String get type;

  /// The image URL part of a message.
  @JsonKey(name: 'image_url')
  MessageContentImageUrl get imageUrl;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentImageUrlObjectImplCopyWith<
          _$MessageContentImageUrlObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageContentTextObjectImplCopyWith<$Res>
    implements $MessageContentCopyWith<$Res> {
  factory _$$MessageContentTextObjectImplCopyWith(
          _$MessageContentTextObjectImpl value,
          $Res Function(_$MessageContentTextObjectImpl) then) =
      __$$MessageContentTextObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, MessageContentText text});

  $MessageContentTextCopyWith<$Res> get text;
}

/// @nodoc
class __$$MessageContentTextObjectImplCopyWithImpl<$Res>
    extends _$MessageContentCopyWithImpl<$Res, _$MessageContentTextObjectImpl>
    implements _$$MessageContentTextObjectImplCopyWith<$Res> {
  __$$MessageContentTextObjectImplCopyWithImpl(
      _$MessageContentTextObjectImpl _value,
      $Res Function(_$MessageContentTextObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
  }) {
    return _then(_$MessageContentTextObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as MessageContentText,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextCopyWith<$Res> get text {
    return $MessageContentTextCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextObjectImpl extends MessageContentTextObject {
  const _$MessageContentTextObjectImpl({this.type = 'text', required this.text})
      : super._();

  factory _$MessageContentTextObjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageContentTextObjectImplFromJson(json);

  /// Always `text`.
  @override
  @JsonKey()
  final String type;

  /// The text content that is part of a message.
  @override
  final MessageContentText text;

  @override
  String toString() {
    return 'MessageContent.text(type: $type, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextObjectImplCopyWith<_$MessageContentTextObjectImpl>
      get copyWith => __$$MessageContentTextObjectImplCopyWithImpl<
          _$MessageContentTextObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)
        imageFile,
    required TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)
        imageUrl,
    required TResult Function(String type, MessageContentText text) text,
  }) {
    return text(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult? Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult? Function(String type, MessageContentText text)? text,
  }) {
    return text?.call(type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type,
            @JsonKey(name: 'image_file') MessageContentImageFile imageFile)?
        imageFile,
    TResult Function(String type,
            @JsonKey(name: 'image_url') MessageContentImageUrl imageUrl)?
        imageUrl,
    TResult Function(String type, MessageContentText text)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(type, this.text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageContentImageFileObject value) imageFile,
    required TResult Function(MessageContentImageUrlObject value) imageUrl,
    required TResult Function(MessageContentTextObject value) text,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentImageFileObject value)? imageFile,
    TResult? Function(MessageContentImageUrlObject value)? imageUrl,
    TResult? Function(MessageContentTextObject value)? text,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentImageFileObject value)? imageFile,
    TResult Function(MessageContentImageUrlObject value)? imageUrl,
    TResult Function(MessageContentTextObject value)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentTextObject extends MessageContent {
  const factory MessageContentTextObject(
      {final String type,
      required final MessageContentText text}) = _$MessageContentTextObjectImpl;
  const MessageContentTextObject._() : super._();

  factory MessageContentTextObject.fromJson(Map<String, dynamic> json) =
      _$MessageContentTextObjectImpl.fromJson;

  @override

  /// Always `text`.
  String get type;

  /// The text content that is part of a message.
  MessageContentText get text;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextObjectImplCopyWith<_$MessageContentTextObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageDeltaContent _$MessageDeltaContentFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'image_file':
      return MessageDeltaContentImageFileObject.fromJson(json);
    case 'text':
      return MessageDeltaContentTextObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'MessageDeltaContent',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageDeltaContent {
  /// The index of the content part in the message.
  int get index => throw _privateConstructorUsedError;

  /// Always `image_file`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)
        imageFile,
    required TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)
        text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageDeltaContentImageFileObject value)
        imageFile,
    required TResult Function(MessageDeltaContentTextObject value) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult? Function(MessageDeltaContentTextObject value)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult Function(MessageDeltaContentTextObject value)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaContentCopyWith<MessageDeltaContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaContentCopyWith<$Res> {
  factory $MessageDeltaContentCopyWith(
          MessageDeltaContent value, $Res Function(MessageDeltaContent) then) =
      _$MessageDeltaContentCopyWithImpl<$Res, MessageDeltaContent>;
  @useResult
  $Res call({int index, String type});
}

/// @nodoc
class _$MessageDeltaContentCopyWithImpl<$Res, $Val extends MessageDeltaContent>
    implements $MessageDeltaContentCopyWith<$Res> {
  _$MessageDeltaContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageDeltaContentImageFileObjectImplCopyWith<$Res>
    implements $MessageDeltaContentCopyWith<$Res> {
  factory _$$MessageDeltaContentImageFileObjectImplCopyWith(
          _$MessageDeltaContentImageFileObjectImpl value,
          $Res Function(_$MessageDeltaContentImageFileObjectImpl) then) =
      __$$MessageDeltaContentImageFileObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(name: 'image_file', includeIfNull: false)
      MessageContentImageFile? imageFile});

  $MessageContentImageFileCopyWith<$Res>? get imageFile;
}

/// @nodoc
class __$$MessageDeltaContentImageFileObjectImplCopyWithImpl<$Res>
    extends _$MessageDeltaContentCopyWithImpl<$Res,
        _$MessageDeltaContentImageFileObjectImpl>
    implements _$$MessageDeltaContentImageFileObjectImplCopyWith<$Res> {
  __$$MessageDeltaContentImageFileObjectImplCopyWithImpl(
      _$MessageDeltaContentImageFileObjectImpl _value,
      $Res Function(_$MessageDeltaContentImageFileObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? imageFile = freezed,
  }) {
    return _then(_$MessageDeltaContentImageFileObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      imageFile: freezed == imageFile
          ? _value.imageFile
          : imageFile // ignore: cast_nullable_to_non_nullable
              as MessageContentImageFile?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentImageFileCopyWith<$Res>? get imageFile {
    if (_value.imageFile == null) {
      return null;
    }

    return $MessageContentImageFileCopyWith<$Res>(_value.imageFile!, (value) {
      return _then(_value.copyWith(imageFile: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentImageFileObjectImpl
    extends MessageDeltaContentImageFileObject {
  const _$MessageDeltaContentImageFileObjectImpl(
      {required this.index,
      required this.type,
      @JsonKey(name: 'image_file', includeIfNull: false) this.imageFile})
      : super._();

  factory _$MessageDeltaContentImageFileObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageDeltaContentImageFileObjectImplFromJson(json);

  /// The index of the content part in the message.
  @override
  final int index;

  /// Always `image_file`.
  @override
  final String type;

  /// The image file that is part of a message.
  @override
  @JsonKey(name: 'image_file', includeIfNull: false)
  final MessageContentImageFile? imageFile;

  @override
  String toString() {
    return 'MessageDeltaContent.imageFile(index: $index, type: $type, imageFile: $imageFile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaContentImageFileObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imageFile, imageFile) ||
                other.imageFile == imageFile));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, imageFile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentImageFileObjectImplCopyWith<
          _$MessageDeltaContentImageFileObjectImpl>
      get copyWith => __$$MessageDeltaContentImageFileObjectImplCopyWithImpl<
          _$MessageDeltaContentImageFileObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)
        imageFile,
    required TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)
        text,
  }) {
    return imageFile(index, type, this.imageFile);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
  }) {
    return imageFile?.call(index, type, this.imageFile);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
    required TResult orElse(),
  }) {
    if (imageFile != null) {
      return imageFile(index, type, this.imageFile);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageDeltaContentImageFileObject value)
        imageFile,
    required TResult Function(MessageDeltaContentTextObject value) text,
  }) {
    return imageFile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult? Function(MessageDeltaContentTextObject value)? text,
  }) {
    return imageFile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult Function(MessageDeltaContentTextObject value)? text,
    required TResult orElse(),
  }) {
    if (imageFile != null) {
      return imageFile(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentImageFileObjectImplToJson(
      this,
    );
  }
}

abstract class MessageDeltaContentImageFileObject extends MessageDeltaContent {
  const factory MessageDeltaContentImageFileObject(
          {required final int index,
          required final String type,
          @JsonKey(name: 'image_file', includeIfNull: false)
          final MessageContentImageFile? imageFile}) =
      _$MessageDeltaContentImageFileObjectImpl;
  const MessageDeltaContentImageFileObject._() : super._();

  factory MessageDeltaContentImageFileObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageDeltaContentImageFileObjectImpl.fromJson;

  @override

  /// The index of the content part in the message.
  int get index;
  @override

  /// Always `image_file`.
  String get type;

  /// The image file that is part of a message.
  @JsonKey(name: 'image_file', includeIfNull: false)
  MessageContentImageFile? get imageFile;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentImageFileObjectImplCopyWith<
          _$MessageDeltaContentImageFileObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageDeltaContentTextObjectImplCopyWith<$Res>
    implements $MessageDeltaContentCopyWith<$Res> {
  factory _$$MessageDeltaContentTextObjectImplCopyWith(
          _$MessageDeltaContentTextObjectImpl value,
          $Res Function(_$MessageDeltaContentTextObjectImpl) then) =
      __$$MessageDeltaContentTextObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) MessageDeltaContentText? text});

  $MessageDeltaContentTextCopyWith<$Res>? get text;
}

/// @nodoc
class __$$MessageDeltaContentTextObjectImplCopyWithImpl<$Res>
    extends _$MessageDeltaContentCopyWithImpl<$Res,
        _$MessageDeltaContentTextObjectImpl>
    implements _$$MessageDeltaContentTextObjectImplCopyWith<$Res> {
  __$$MessageDeltaContentTextObjectImplCopyWithImpl(
      _$MessageDeltaContentTextObjectImpl _value,
      $Res Function(_$MessageDeltaContentTextObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
  }) {
    return _then(_$MessageDeltaContentTextObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as MessageDeltaContentText?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $MessageDeltaContentTextCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentTextObjectImpl
    extends MessageDeltaContentTextObject {
  const _$MessageDeltaContentTextObjectImpl(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.text})
      : super._();

  factory _$MessageDeltaContentTextObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageDeltaContentTextObjectImplFromJson(json);

  /// The index of the content part in the message.
  @override
  final int index;

  /// Always `text`.
  @override
  final String type;

  /// The text content that is part of a message.
  @override
  @JsonKey(includeIfNull: false)
  final MessageDeltaContentText? text;

  @override
  String toString() {
    return 'MessageDeltaContent.text(index: $index, type: $type, text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaContentTextObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentTextObjectImplCopyWith<
          _$MessageDeltaContentTextObjectImpl>
      get copyWith => __$$MessageDeltaContentTextObjectImplCopyWithImpl<
          _$MessageDeltaContentTextObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)
        imageFile,
    required TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)
        text,
  }) {
    return text(index, type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
  }) {
    return text?.call(index, type, this.text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(name: 'image_file', includeIfNull: false)
            MessageContentImageFile? imageFile)?
        imageFile,
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) MessageDeltaContentText? text)?
        text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(index, type, this.text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MessageDeltaContentImageFileObject value)
        imageFile,
    required TResult Function(MessageDeltaContentTextObject value) text,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult? Function(MessageDeltaContentTextObject value)? text,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageDeltaContentImageFileObject value)? imageFile,
    TResult Function(MessageDeltaContentTextObject value)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentTextObjectImplToJson(
      this,
    );
  }
}

abstract class MessageDeltaContentTextObject extends MessageDeltaContent {
  const factory MessageDeltaContentTextObject(
          {required final int index,
          required final String type,
          @JsonKey(includeIfNull: false) final MessageDeltaContentText? text}) =
      _$MessageDeltaContentTextObjectImpl;
  const MessageDeltaContentTextObject._() : super._();

  factory MessageDeltaContentTextObject.fromJson(Map<String, dynamic> json) =
      _$MessageDeltaContentTextObjectImpl.fromJson;

  @override

  /// The index of the content part in the message.
  int get index;
  @override

  /// Always `text`.
  String get type;

  /// The text content that is part of a message.
  @JsonKey(includeIfNull: false)
  MessageDeltaContentText? get text;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentTextObjectImplCopyWith<
          _$MessageDeltaContentTextObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentTextAnnotations _$MessageContentTextAnnotationsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'file_citation':
      return MessageContentTextAnnotationsFileCitationObject.fromJson(json);
    case 'file_path':
      return MessageContentTextAnnotationsFilePathObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'MessageContentTextAnnotations',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageContentTextAnnotations {
  /// Always `file_citation`.
  String get type => throw _privateConstructorUsedError;

  /// The text in the message content that needs to be replaced.
  String get text => throw _privateConstructorUsedError;

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index')
  int get startIndex => throw _privateConstructorUsedError;

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index')
  int get endIndex => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        fileCitation,
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(MessageContentTextAnnotationsFilePathObject value)
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextAnnotationsCopyWith<MessageContentTextAnnotations>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextAnnotationsCopyWith<$Res> {
  factory $MessageContentTextAnnotationsCopyWith(
          MessageContentTextAnnotations value,
          $Res Function(MessageContentTextAnnotations) then) =
      _$MessageContentTextAnnotationsCopyWithImpl<$Res,
          MessageContentTextAnnotations>;
  @useResult
  $Res call(
      {String type,
      String text,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});
}

/// @nodoc
class _$MessageContentTextAnnotationsCopyWithImpl<$Res,
        $Val extends MessageContentTextAnnotations>
    implements $MessageContentTextAnnotationsCopyWith<$Res> {
  _$MessageContentTextAnnotationsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      startIndex: null == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<
    $Res> implements $MessageContentTextAnnotationsCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith(
          _$MessageContentTextAnnotationsFileCitationObjectImpl value,
          $Res Function(_$MessageContentTextAnnotationsFileCitationObjectImpl)
              then) =
      __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      String text,
      @JsonKey(name: 'file_citation')
      MessageContentTextAnnotationsFileCitation fileCitation,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});

  $MessageContentTextAnnotationsFileCitationCopyWith<$Res> get fileCitation;
}

/// @nodoc
class __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFileCitationObjectImpl>
    implements
        _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl(
      _$MessageContentTextAnnotationsFileCitationObjectImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFileCitationObjectImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? fileCitation = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFileCitationObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      fileCitation: null == fileCitation
          ? _value.fileCitation
          : fileCitation // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFileCitation,
      startIndex: null == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFileCitationCopyWith<$Res> get fileCitation {
    return $MessageContentTextAnnotationsFileCitationCopyWith<$Res>(
        _value.fileCitation, (value) {
      return _then(_value.copyWith(fileCitation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFileCitationObjectImpl
    extends MessageContentTextAnnotationsFileCitationObject {
  const _$MessageContentTextAnnotationsFileCitationObjectImpl(
      {required this.type,
      required this.text,
      @JsonKey(name: 'file_citation') required this.fileCitation,
      @JsonKey(name: 'start_index') required this.startIndex,
      @JsonKey(name: 'end_index') required this.endIndex})
      : super._();

  factory _$MessageContentTextAnnotationsFileCitationObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFileCitationObjectImplFromJson(json);

  /// Always `file_citation`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  final String text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @override
  @JsonKey(name: 'file_citation')
  final MessageContentTextAnnotationsFileCitation fileCitation;

  /// The start index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'start_index')
  final int startIndex;

  /// The end index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'end_index')
  final int endIndex;

  @override
  String toString() {
    return 'MessageContentTextAnnotations.fileCitation(type: $type, text: $text, fileCitation: $fileCitation, startIndex: $startIndex, endIndex: $endIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFileCitationObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.fileCitation, fileCitation) ||
                other.fileCitation == fileCitation) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, text, fileCitation, startIndex, endIndex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationObjectImpl>
      get copyWith =>
          __$$MessageContentTextAnnotationsFileCitationObjectImplCopyWithImpl<
                  _$MessageContentTextAnnotationsFileCitationObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        fileCitation,
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        filePath,
  }) {
    return fileCitation(type, text, this.fileCitation, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
  }) {
    return fileCitation?.call(
        type, text, this.fileCitation, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    if (fileCitation != null) {
      return fileCitation(type, text, this.fileCitation, startIndex, endIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(MessageContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    return fileCitation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    return fileCitation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    if (fileCitation != null) {
      return fileCitation(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFileCitationObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentTextAnnotationsFileCitationObject
    extends MessageContentTextAnnotations {
  const factory MessageContentTextAnnotationsFileCitationObject(
          {required final String type,
          required final String text,
          @JsonKey(name: 'file_citation')
          required final MessageContentTextAnnotationsFileCitation fileCitation,
          @JsonKey(name: 'start_index') required final int startIndex,
          @JsonKey(name: 'end_index') required final int endIndex}) =
      _$MessageContentTextAnnotationsFileCitationObjectImpl;
  const MessageContentTextAnnotationsFileCitationObject._() : super._();

  factory MessageContentTextAnnotationsFileCitationObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFileCitationObjectImpl.fromJson;

  @override

  /// Always `file_citation`.
  String get type;
  @override

  /// The text in the message content that needs to be replaced.
  String get text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @JsonKey(name: 'file_citation')
  MessageContentTextAnnotationsFileCitation get fileCitation;
  @override

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index')
  int get startIndex;
  @override

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index')
  int get endIndex;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFileCitationObjectImplCopyWith<
          _$MessageContentTextAnnotationsFileCitationObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<$Res>
    implements $MessageContentTextAnnotationsCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith(
          _$MessageContentTextAnnotationsFilePathObjectImpl value,
          $Res Function(_$MessageContentTextAnnotationsFilePathObjectImpl)
              then) =
      __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      String text,
      @JsonKey(name: 'file_path')
      MessageContentTextAnnotationsFilePath filePath,
      @JsonKey(name: 'start_index') int startIndex,
      @JsonKey(name: 'end_index') int endIndex});

  $MessageContentTextAnnotationsFilePathCopyWith<$Res> get filePath;
}

/// @nodoc
class __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFilePathObjectImpl>
    implements
        _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl(
      _$MessageContentTextAnnotationsFilePathObjectImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFilePathObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? text = null,
    Object? filePath = null,
    Object? startIndex = null,
    Object? endIndex = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFilePathObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      filePath: null == filePath
          ? _value.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as MessageContentTextAnnotationsFilePath,
      startIndex: null == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int,
      endIndex: null == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageContentTextAnnotationsFilePathCopyWith<$Res> get filePath {
    return $MessageContentTextAnnotationsFilePathCopyWith<$Res>(_value.filePath,
        (value) {
      return _then(_value.copyWith(filePath: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFilePathObjectImpl
    extends MessageContentTextAnnotationsFilePathObject {
  const _$MessageContentTextAnnotationsFilePathObjectImpl(
      {required this.type,
      required this.text,
      @JsonKey(name: 'file_path') required this.filePath,
      @JsonKey(name: 'start_index') required this.startIndex,
      @JsonKey(name: 'end_index') required this.endIndex})
      : super._();

  factory _$MessageContentTextAnnotationsFilePathObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFilePathObjectImplFromJson(json);

  /// Always `file_path`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  final String text;

  /// No Description
  @override
  @JsonKey(name: 'file_path')
  final MessageContentTextAnnotationsFilePath filePath;

  /// No Description
  @override
  @JsonKey(name: 'start_index')
  final int startIndex;

  /// No Description
  @override
  @JsonKey(name: 'end_index')
  final int endIndex;

  @override
  String toString() {
    return 'MessageContentTextAnnotations.filePath(type: $type, text: $text, filePath: $filePath, startIndex: $startIndex, endIndex: $endIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFilePathObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.filePath, filePath) ||
                other.filePath == filePath) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, text, filePath, startIndex, endIndex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<
          _$MessageContentTextAnnotationsFilePathObjectImpl>
      get copyWith =>
          __$$MessageContentTextAnnotationsFilePathObjectImplCopyWithImpl<
                  _$MessageContentTextAnnotationsFilePathObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        fileCitation,
    required TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)
        filePath,
  }) {
    return filePath(type, text, this.filePath, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult? Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
  }) {
    return filePath?.call(type, text, this.filePath, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_citation')
            MessageContentTextAnnotationsFileCitation fileCitation,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        fileCitation,
    TResult Function(
            String type,
            String text,
            @JsonKey(name: 'file_path')
            MessageContentTextAnnotationsFilePath filePath,
            @JsonKey(name: 'start_index') int startIndex,
            @JsonKey(name: 'end_index') int endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(type, text, this.filePath, startIndex, endIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(MessageContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    return filePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    return filePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MessageContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFilePathObjectImplToJson(
      this,
    );
  }
}

abstract class MessageContentTextAnnotationsFilePathObject
    extends MessageContentTextAnnotations {
  const factory MessageContentTextAnnotationsFilePathObject(
          {required final String type,
          required final String text,
          @JsonKey(name: 'file_path')
          required final MessageContentTextAnnotationsFilePath filePath,
          @JsonKey(name: 'start_index') required final int startIndex,
          @JsonKey(name: 'end_index') required final int endIndex}) =
      _$MessageContentTextAnnotationsFilePathObjectImpl;
  const MessageContentTextAnnotationsFilePathObject._() : super._();

  factory MessageContentTextAnnotationsFilePathObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFilePathObjectImpl.fromJson;

  @override

  /// Always `file_path`.
  String get type;
  @override

  /// The text in the message content that needs to be replaced.
  String get text;

  /// No Description
  @JsonKey(name: 'file_path')
  MessageContentTextAnnotationsFilePath get filePath;
  @override

  /// No Description
  @JsonKey(name: 'start_index')
  int get startIndex;
  @override

  /// No Description
  @JsonKey(name: 'end_index')
  int get endIndex;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFilePathObjectImplCopyWith<
          _$MessageContentTextAnnotationsFilePathObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageContentTextAnnotationsFilePath
    _$MessageContentTextAnnotationsFilePathFromJson(Map<String, dynamic> json) {
  return _MessageContentTextAnnotationsFilePath.fromJson(json);
}

/// @nodoc
mixin _$MessageContentTextAnnotationsFilePath {
  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id')
  String get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageContentTextAnnotationsFilePathCopyWith<
          MessageContentTextAnnotationsFilePath>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  factory $MessageContentTextAnnotationsFilePathCopyWith(
          MessageContentTextAnnotationsFilePath value,
          $Res Function(MessageContentTextAnnotationsFilePath) then) =
      _$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res,
          MessageContentTextAnnotationsFilePath>;
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class _$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res,
        $Val extends MessageContentTextAnnotationsFilePath>
    implements $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  _$MessageContentTextAnnotationsFilePathCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_value.copyWith(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageContentTextAnnotationsFilePathImplCopyWith<$Res>
    implements $MessageContentTextAnnotationsFilePathCopyWith<$Res> {
  factory _$$MessageContentTextAnnotationsFilePathImplCopyWith(
          _$MessageContentTextAnnotationsFilePathImpl value,
          $Res Function(_$MessageContentTextAnnotationsFilePathImpl) then) =
      __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id') String fileId});
}

/// @nodoc
class __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl<$Res>
    extends _$MessageContentTextAnnotationsFilePathCopyWithImpl<$Res,
        _$MessageContentTextAnnotationsFilePathImpl>
    implements _$$MessageContentTextAnnotationsFilePathImplCopyWith<$Res> {
  __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl(
      _$MessageContentTextAnnotationsFilePathImpl _value,
      $Res Function(_$MessageContentTextAnnotationsFilePathImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = null,
  }) {
    return _then(_$MessageContentTextAnnotationsFilePathImpl(
      fileId: null == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageContentTextAnnotationsFilePathImpl
    extends _MessageContentTextAnnotationsFilePath {
  const _$MessageContentTextAnnotationsFilePathImpl(
      {@JsonKey(name: 'file_id') required this.fileId})
      : super._();

  factory _$MessageContentTextAnnotationsFilePathImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageContentTextAnnotationsFilePathImplFromJson(json);

  /// The ID of the file that was generated.
  @override
  @JsonKey(name: 'file_id')
  final String fileId;

  @override
  String toString() {
    return 'MessageContentTextAnnotationsFilePath(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageContentTextAnnotationsFilePathImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageContentTextAnnotationsFilePathImplCopyWith<
          _$MessageContentTextAnnotationsFilePathImpl>
      get copyWith => __$$MessageContentTextAnnotationsFilePathImplCopyWithImpl<
          _$MessageContentTextAnnotationsFilePathImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageContentTextAnnotationsFilePathImplToJson(
      this,
    );
  }
}

abstract class _MessageContentTextAnnotationsFilePath
    extends MessageContentTextAnnotationsFilePath {
  const factory _MessageContentTextAnnotationsFilePath(
          {@JsonKey(name: 'file_id') required final String fileId}) =
      _$MessageContentTextAnnotationsFilePathImpl;
  const _MessageContentTextAnnotationsFilePath._() : super._();

  factory _MessageContentTextAnnotationsFilePath.fromJson(
          Map<String, dynamic> json) =
      _$MessageContentTextAnnotationsFilePathImpl.fromJson;

  @override

  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id')
  String get fileId;
  @override
  @JsonKey(ignore: true)
  _$$MessageContentTextAnnotationsFilePathImplCopyWith<
          _$MessageContentTextAnnotationsFilePathImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageDeltaContentTextAnnotations _$MessageDeltaContentTextAnnotationsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'file_citation':
      return MessageDeltaContentTextAnnotationsFileCitationObject.fromJson(
          json);
    case 'file_path':
      return MessageDeltaContentTextAnnotationsFilePathObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'MessageDeltaContentTextAnnotations',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$MessageDeltaContentTextAnnotations {
  /// The index of the annotation in the text content part.
  int get index => throw _privateConstructorUsedError;

  /// Always `file_citation`.
  String get type => throw _privateConstructorUsedError;

  /// The text in the message content that needs to be replaced.
  @JsonKey(includeIfNull: false)
  String? get text => throw _privateConstructorUsedError;

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index', includeIfNull: false)
  int? get startIndex => throw _privateConstructorUsedError;

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index', includeIfNull: false)
  int? get endIndex => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        fileCitation,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(
            MessageDeltaContentTextAnnotationsFilePathObject value)
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaContentTextAnnotationsCopyWith<
          MessageDeltaContentTextAnnotations>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  factory $MessageDeltaContentTextAnnotationsCopyWith(
          MessageDeltaContentTextAnnotations value,
          $Res Function(MessageDeltaContentTextAnnotations) then) =
      _$MessageDeltaContentTextAnnotationsCopyWithImpl<$Res,
          MessageDeltaContentTextAnnotations>;
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) String? text,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex});
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsCopyWithImpl<$Res,
        $Val extends MessageDeltaContentTextAnnotations>
    implements $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  _$MessageDeltaContentTextAnnotationsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
    Object? startIndex = freezed,
    Object? endIndex = freezed,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      startIndex: freezed == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      endIndex: freezed == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWith<
    $Res> implements $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  factory _$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWith(
          _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl value,
          $Res Function(
                  _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl)
              then) =
      __$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) String? text,
      @JsonKey(name: 'file_citation', includeIfNull: false)
      MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex});

  $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res>?
      get fileCitation;
}

/// @nodoc
class __$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWithImpl<
        $Res>
    extends _$MessageDeltaContentTextAnnotationsCopyWithImpl<$Res,
        _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl>
    implements
        _$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWith<
            $Res> {
  __$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWithImpl(
      _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl _value,
      $Res Function(_$MessageDeltaContentTextAnnotationsFileCitationObjectImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
    Object? fileCitation = freezed,
    Object? startIndex = freezed,
    Object? endIndex = freezed,
  }) {
    return _then(_$MessageDeltaContentTextAnnotationsFileCitationObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      fileCitation: freezed == fileCitation
          ? _value.fileCitation
          : fileCitation // ignore: cast_nullable_to_non_nullable
              as MessageDeltaContentTextAnnotationsFileCitation?,
      startIndex: freezed == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      endIndex: freezed == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res>?
      get fileCitation {
    if (_value.fileCitation == null) {
      return null;
    }

    return $MessageDeltaContentTextAnnotationsFileCitationCopyWith<$Res>(
        _value.fileCitation!, (value) {
      return _then(_value.copyWith(fileCitation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl
    extends MessageDeltaContentTextAnnotationsFileCitationObject {
  const _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.text,
      @JsonKey(name: 'file_citation', includeIfNull: false) this.fileCitation,
      @JsonKey(name: 'start_index', includeIfNull: false) this.startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) this.endIndex})
      : super._();

  factory _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageDeltaContentTextAnnotationsFileCitationObjectImplFromJson(json);

  /// The index of the annotation in the text content part.
  @override
  final int index;

  /// Always `file_citation`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  @JsonKey(includeIfNull: false)
  final String? text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @override
  @JsonKey(name: 'file_citation', includeIfNull: false)
  final MessageDeltaContentTextAnnotationsFileCitation? fileCitation;

  /// The start index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'start_index', includeIfNull: false)
  final int? startIndex;

  /// The end index of the text in the message content that needs to be replaced.
  @override
  @JsonKey(name: 'end_index', includeIfNull: false)
  final int? endIndex;

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotations.fileCitation(index: $index, type: $type, text: $text, fileCitation: $fileCitation, startIndex: $startIndex, endIndex: $endIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.fileCitation, fileCitation) ||
                other.fileCitation == fileCitation) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, index, type, text, fileCitation, startIndex, endIndex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl>
      get copyWith =>
          __$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWithImpl<
                  _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        fileCitation,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        filePath,
  }) {
    return fileCitation(
        index, type, text, this.fileCitation, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
  }) {
    return fileCitation?.call(
        index, type, text, this.fileCitation, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    if (fileCitation != null) {
      return fileCitation(
          index, type, text, this.fileCitation, startIndex, endIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(
            MessageDeltaContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    return fileCitation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    return fileCitation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    if (fileCitation != null) {
      return fileCitation(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentTextAnnotationsFileCitationObjectImplToJson(
      this,
    );
  }
}

abstract class MessageDeltaContentTextAnnotationsFileCitationObject
    extends MessageDeltaContentTextAnnotations {
  const factory MessageDeltaContentTextAnnotationsFileCitationObject(
      {required final int index,
      required final String type,
      @JsonKey(includeIfNull: false) final String? text,
      @JsonKey(name: 'file_citation', includeIfNull: false)
      final MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
      @JsonKey(name: 'start_index', includeIfNull: false) final int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false)
      final int?
          endIndex}) = _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl;
  const MessageDeltaContentTextAnnotationsFileCitationObject._() : super._();

  factory MessageDeltaContentTextAnnotationsFileCitationObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl.fromJson;

  @override

  /// The index of the annotation in the text content part.
  int get index;
  @override

  /// Always `file_citation`.
  String get type;
  @override

  /// The text in the message content that needs to be replaced.
  @JsonKey(includeIfNull: false)
  String? get text;

  /// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message.
  @JsonKey(name: 'file_citation', includeIfNull: false)
  MessageDeltaContentTextAnnotationsFileCitation? get fileCitation;
  @override

  /// The start index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'start_index', includeIfNull: false)
  int? get startIndex;
  @override

  /// The end index of the text in the message content that needs to be replaced.
  @JsonKey(name: 'end_index', includeIfNull: false)
  int? get endIndex;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentTextAnnotationsFileCitationObjectImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFileCitationObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWith<
    $Res> implements $MessageDeltaContentTextAnnotationsCopyWith<$Res> {
  factory _$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWith(
          _$MessageDeltaContentTextAnnotationsFilePathObjectImpl value,
          $Res Function(_$MessageDeltaContentTextAnnotationsFilePathObjectImpl)
              then) =
      __$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false) String? text,
      @JsonKey(name: 'file_path', includeIfNull: false)
      MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
      @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex});

  $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<$Res>?
      get filePath;
}

/// @nodoc
class __$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWithImpl<$Res>
    extends _$MessageDeltaContentTextAnnotationsCopyWithImpl<$Res,
        _$MessageDeltaContentTextAnnotationsFilePathObjectImpl>
    implements
        _$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWith<$Res> {
  __$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWithImpl(
      _$MessageDeltaContentTextAnnotationsFilePathObjectImpl _value,
      $Res Function(_$MessageDeltaContentTextAnnotationsFilePathObjectImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? text = freezed,
    Object? filePath = freezed,
    Object? startIndex = freezed,
    Object? endIndex = freezed,
  }) {
    return _then(_$MessageDeltaContentTextAnnotationsFilePathObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      filePath: freezed == filePath
          ? _value.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as MessageDeltaContentTextAnnotationsFilePathObjectFilePath?,
      startIndex: freezed == startIndex
          ? _value.startIndex
          : startIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      endIndex: freezed == endIndex
          ? _value.endIndex
          : endIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<$Res>?
      get filePath {
    if (_value.filePath == null) {
      return null;
    }

    return $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
        $Res>(_value.filePath!, (value) {
      return _then(_value.copyWith(filePath: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentTextAnnotationsFilePathObjectImpl
    extends MessageDeltaContentTextAnnotationsFilePathObject {
  const _$MessageDeltaContentTextAnnotationsFilePathObjectImpl(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.text,
      @JsonKey(name: 'file_path', includeIfNull: false) this.filePath,
      @JsonKey(name: 'start_index', includeIfNull: false) this.startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false) this.endIndex})
      : super._();

  factory _$MessageDeltaContentTextAnnotationsFilePathObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageDeltaContentTextAnnotationsFilePathObjectImplFromJson(json);

  /// The index of the annotation in the text content part.
  @override
  final int index;

  /// Always `file_path`.
  @override
  final String type;

  /// The text in the message content that needs to be replaced.
  @override
  @JsonKey(includeIfNull: false)
  final String? text;

  /// No Description
  @override
  @JsonKey(name: 'file_path', includeIfNull: false)
  final MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath;

  /// No Description
  @override
  @JsonKey(name: 'start_index', includeIfNull: false)
  final int? startIndex;

  /// No Description
  @override
  @JsonKey(name: 'end_index', includeIfNull: false)
  final int? endIndex;

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotations.filePath(index: $index, type: $type, text: $text, filePath: $filePath, startIndex: $startIndex, endIndex: $endIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageDeltaContentTextAnnotationsFilePathObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.filePath, filePath) ||
                other.filePath == filePath) &&
            (identical(other.startIndex, startIndex) ||
                other.startIndex == startIndex) &&
            (identical(other.endIndex, endIndex) ||
                other.endIndex == endIndex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, index, type, text, filePath, startIndex, endIndex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFilePathObjectImpl>
      get copyWith =>
          __$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWithImpl<
                  _$MessageDeltaContentTextAnnotationsFilePathObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        fileCitation,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)
        filePath,
  }) {
    return filePath(index, type, text, this.filePath, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
  }) {
    return filePath?.call(
        index, type, text, this.filePath, startIndex, endIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_citation', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFileCitation? fileCitation,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        fileCitation,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false) String? text,
            @JsonKey(name: 'file_path', includeIfNull: false)
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
            @JsonKey(name: 'start_index', includeIfNull: false) int? startIndex,
            @JsonKey(name: 'end_index', includeIfNull: false) int? endIndex)?
        filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(index, type, text, this.filePath, startIndex, endIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)
        fileCitation,
    required TResult Function(
            MessageDeltaContentTextAnnotationsFilePathObject value)
        filePath,
  }) {
    return filePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult? Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
  }) {
    return filePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            MessageDeltaContentTextAnnotationsFileCitationObject value)?
        fileCitation,
    TResult Function(MessageDeltaContentTextAnnotationsFilePathObject value)?
        filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentTextAnnotationsFilePathObjectImplToJson(
      this,
    );
  }
}

abstract class MessageDeltaContentTextAnnotationsFilePathObject
    extends MessageDeltaContentTextAnnotations {
  const factory MessageDeltaContentTextAnnotationsFilePathObject(
      {required final int index,
      required final String type,
      @JsonKey(includeIfNull: false) final String? text,
      @JsonKey(name: 'file_path', includeIfNull: false)
      final MessageDeltaContentTextAnnotationsFilePathObjectFilePath? filePath,
      @JsonKey(name: 'start_index', includeIfNull: false) final int? startIndex,
      @JsonKey(name: 'end_index', includeIfNull: false)
      final int?
          endIndex}) = _$MessageDeltaContentTextAnnotationsFilePathObjectImpl;
  const MessageDeltaContentTextAnnotationsFilePathObject._() : super._();

  factory MessageDeltaContentTextAnnotationsFilePathObject.fromJson(
          Map<String, dynamic> json) =
      _$MessageDeltaContentTextAnnotationsFilePathObjectImpl.fromJson;

  @override

  /// The index of the annotation in the text content part.
  int get index;
  @override

  /// Always `file_path`.
  String get type;
  @override

  /// The text in the message content that needs to be replaced.
  @JsonKey(includeIfNull: false)
  String? get text;

  /// No Description
  @JsonKey(name: 'file_path', includeIfNull: false)
  MessageDeltaContentTextAnnotationsFilePathObjectFilePath? get filePath;
  @override

  /// No Description
  @JsonKey(name: 'start_index', includeIfNull: false)
  int? get startIndex;
  @override

  /// No Description
  @JsonKey(name: 'end_index', includeIfNull: false)
  int? get endIndex;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentTextAnnotationsFilePathObjectImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFilePathObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MessageDeltaContentTextAnnotationsFilePathObjectFilePath
    _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathFromJson(
        Map<String, dynamic> json) {
  return _MessageDeltaContentTextAnnotationsFilePathObjectFilePath.fromJson(
      json);
}

/// @nodoc
mixin _$MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
          MessageDeltaContentTextAnnotationsFilePathObjectFilePath>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
    $Res> {
  factory $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith(
          MessageDeltaContentTextAnnotationsFilePathObjectFilePath value,
          $Res Function(
                  MessageDeltaContentTextAnnotationsFilePathObjectFilePath)
              then) =
      _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl<
          $Res, MessageDeltaContentTextAnnotationsFilePathObjectFilePath>;
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl<
        $Res,
        $Val extends MessageDeltaContentTextAnnotationsFilePathObjectFilePath>
    implements
        $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
            $Res> {
  _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_value.copyWith(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWith<
        $Res>
    implements
        $MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWith<
            $Res> {
  factory _$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWith(
          _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl value,
          $Res Function(
                  _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl)
              then) =
      __$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'file_id', includeIfNull: false) String? fileId});
}

/// @nodoc
class __$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWithImpl<
        $Res>
    extends _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathCopyWithImpl<
        $Res, _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl>
    implements
        _$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWith<
            $Res> {
  __$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWithImpl(
      _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl _value,
      $Res Function(
              _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileId = freezed,
  }) {
    return _then(_$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl(
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl
    extends _MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
  const _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl(
      {@JsonKey(name: 'file_id', includeIfNull: false) this.fileId})
      : super._();

  factory _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplFromJson(
          json);

  /// The ID of the file that was generated.
  @override
  @JsonKey(name: 'file_id', includeIfNull: false)
  final String? fileId;

  @override
  String toString() {
    return 'MessageDeltaContentTextAnnotationsFilePathObjectFilePath(fileId: $fileId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl &&
            (identical(other.fileId, fileId) || other.fileId == fileId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fileId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl>
      get copyWith =>
          __$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWithImpl<
                  _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplToJson(
      this,
    );
  }
}

abstract class _MessageDeltaContentTextAnnotationsFilePathObjectFilePath
    extends MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
  const factory _MessageDeltaContentTextAnnotationsFilePathObjectFilePath(
          {@JsonKey(name: 'file_id', includeIfNull: false)
          final String? fileId}) =
      _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl;
  const _MessageDeltaContentTextAnnotationsFilePathObjectFilePath._()
      : super._();

  factory _MessageDeltaContentTextAnnotationsFilePathObjectFilePath.fromJson(
          Map<String, dynamic> json) =
      _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl.fromJson;

  @override

  /// The ID of the file that was generated.
  @JsonKey(name: 'file_id', includeIfNull: false)
  String? get fileId;
  @override
  @JsonKey(ignore: true)
  _$$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImplCopyWith<
          _$MessageDeltaContentTextAnnotationsFilePathObjectFilePathImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetails _$RunStepDetailsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'message_creation':
      return RunStepDetailsMessageCreationObject.fromJson(json);
    case 'tool_calls':
      return RunStepDetailsToolCallsObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDetails',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetails {
  /// Always `message_creation`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)
        toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDetailsToolCallsObject value) toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDetailsToolCallsObject value)? toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsCopyWith<RunStepDetails> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsCopyWith<$Res> {
  factory $RunStepDetailsCopyWith(
          RunStepDetails value, $Res Function(RunStepDetails) then) =
      _$RunStepDetailsCopyWithImpl<$Res, RunStepDetails>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$RunStepDetailsCopyWithImpl<$Res, $Val extends RunStepDetails>
    implements $RunStepDetailsCopyWith<$Res> {
  _$RunStepDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsMessageCreationObjectImplCopyWith<$Res>
    implements $RunStepDetailsCopyWith<$Res> {
  factory _$$RunStepDetailsMessageCreationObjectImplCopyWith(
          _$RunStepDetailsMessageCreationObjectImpl value,
          $Res Function(_$RunStepDetailsMessageCreationObjectImpl) then) =
      __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'message_creation')
      RunStepDetailsMessageCreation messageCreation});

  $RunStepDetailsMessageCreationCopyWith<$Res> get messageCreation;
}

/// @nodoc
class __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsCopyWithImpl<$Res,
        _$RunStepDetailsMessageCreationObjectImpl>
    implements _$$RunStepDetailsMessageCreationObjectImplCopyWith<$Res> {
  __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl(
      _$RunStepDetailsMessageCreationObjectImpl _value,
      $Res Function(_$RunStepDetailsMessageCreationObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? messageCreation = null,
  }) {
    return _then(_$RunStepDetailsMessageCreationObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      messageCreation: null == messageCreation
          ? _value.messageCreation
          : messageCreation // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsMessageCreation,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsMessageCreationCopyWith<$Res> get messageCreation {
    return $RunStepDetailsMessageCreationCopyWith<$Res>(_value.messageCreation,
        (value) {
      return _then(_value.copyWith(messageCreation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsMessageCreationObjectImpl
    extends RunStepDetailsMessageCreationObject {
  const _$RunStepDetailsMessageCreationObjectImpl(
      {required this.type,
      @JsonKey(name: 'message_creation') required this.messageCreation})
      : super._();

  factory _$RunStepDetailsMessageCreationObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsMessageCreationObjectImplFromJson(json);

  /// Always `message_creation`.
  @override
  final String type;

  /// Details of the message creation by the run step.
  @override
  @JsonKey(name: 'message_creation')
  final RunStepDetailsMessageCreation messageCreation;

  @override
  String toString() {
    return 'RunStepDetails.messageCreation(type: $type, messageCreation: $messageCreation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsMessageCreationObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.messageCreation, messageCreation) ||
                other.messageCreation == messageCreation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, messageCreation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsMessageCreationObjectImplCopyWith<
          _$RunStepDetailsMessageCreationObjectImpl>
      get copyWith => __$$RunStepDetailsMessageCreationObjectImplCopyWithImpl<
          _$RunStepDetailsMessageCreationObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)
        toolCalls,
  }) {
    return messageCreation(type, this.messageCreation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
  }) {
    return messageCreation?.call(type, this.messageCreation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    if (messageCreation != null) {
      return messageCreation(type, this.messageCreation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDetailsToolCallsObject value) toolCalls,
  }) {
    return messageCreation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDetailsToolCallsObject value)? toolCalls,
  }) {
    return messageCreation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    if (messageCreation != null) {
      return messageCreation(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsMessageCreationObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsMessageCreationObject extends RunStepDetails {
  const factory RunStepDetailsMessageCreationObject(
          {required final String type,
          @JsonKey(name: 'message_creation')
          required final RunStepDetailsMessageCreation messageCreation}) =
      _$RunStepDetailsMessageCreationObjectImpl;
  const RunStepDetailsMessageCreationObject._() : super._();

  factory RunStepDetailsMessageCreationObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsMessageCreationObjectImpl.fromJson;

  @override

  /// Always `message_creation`.
  String get type;

  /// Details of the message creation by the run step.
  @JsonKey(name: 'message_creation')
  RunStepDetailsMessageCreation get messageCreation;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsMessageCreationObjectImplCopyWith<
          _$RunStepDetailsMessageCreationObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsObjectImplCopyWith<$Res>
    implements $RunStepDetailsCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsObjectImplCopyWith(
          _$RunStepDetailsToolCallsObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsObjectImpl) then) =
      __$$RunStepDetailsToolCallsObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'tool_calls') List<RunStepDetailsToolCalls> toolCalls});
}

/// @nodoc
class __$$RunStepDetailsToolCallsObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsObjectImpl>
    implements _$$RunStepDetailsToolCallsObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? toolCalls = null,
  }) {
    return _then(_$RunStepDetailsToolCallsObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      toolCalls: null == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunStepDetailsToolCalls>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsObjectImpl
    extends RunStepDetailsToolCallsObject {
  const _$RunStepDetailsToolCallsObjectImpl(
      {required this.type,
      @JsonKey(name: 'tool_calls')
      required final List<RunStepDetailsToolCalls> toolCalls})
      : _toolCalls = toolCalls,
        super._();

  factory _$RunStepDetailsToolCallsObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsObjectImplFromJson(json);

  /// Always `tool_calls`.
  @override
  final String type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  final List<RunStepDetailsToolCalls> _toolCalls;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  @override
  @JsonKey(name: 'tool_calls')
  List<RunStepDetailsToolCalls> get toolCalls {
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toolCalls);
  }

  @override
  String toString() {
    return 'RunStepDetails.toolCalls(type: $type, toolCalls: $toolCalls)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, type, const DeepCollectionEquality().hash(_toolCalls));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsObjectImplCopyWith<
          _$RunStepDetailsToolCallsObjectImpl>
      get copyWith => __$$RunStepDetailsToolCallsObjectImplCopyWithImpl<
          _$RunStepDetailsToolCallsObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)
        toolCalls,
  }) {
    return toolCalls(type, this.toolCalls);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
  }) {
    return toolCalls?.call(type, this.toolCalls);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation')
            RunStepDetailsMessageCreation messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls')
            List<RunStepDetailsToolCalls> toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    if (toolCalls != null) {
      return toolCalls(type, this.toolCalls);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDetailsToolCallsObject value) toolCalls,
  }) {
    return toolCalls(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDetailsToolCallsObject value)? toolCalls,
  }) {
    return toolCalls?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    if (toolCalls != null) {
      return toolCalls(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsObject extends RunStepDetails {
  const factory RunStepDetailsToolCallsObject(
          {required final String type,
          @JsonKey(name: 'tool_calls')
          required final List<RunStepDetailsToolCalls> toolCalls}) =
      _$RunStepDetailsToolCallsObjectImpl;
  const RunStepDetailsToolCallsObject._() : super._();

  factory RunStepDetailsToolCallsObject.fromJson(Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsObjectImpl.fromJson;

  @override

  /// Always `tool_calls`.
  String get type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  @JsonKey(name: 'tool_calls')
  List<RunStepDetailsToolCalls> get toolCalls;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsObjectImplCopyWith<
          _$RunStepDetailsToolCallsObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDeltaDetails _$RunStepDeltaDetailsFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'message_creation':
      return RunStepDeltaStepDetailsMessageCreationObject.fromJson(json);
    case 'tool_calls':
      return RunStepDeltaStepDetailsToolCallsObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDeltaDetails',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDeltaDetails {
  /// Always `message_creation`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)
        toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDeltaStepDetailsToolCallsObject value)
        toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaDetailsCopyWith<RunStepDeltaDetails> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaDetailsCopyWith<$Res> {
  factory $RunStepDeltaDetailsCopyWith(
          RunStepDeltaDetails value, $Res Function(RunStepDeltaDetails) then) =
      _$RunStepDeltaDetailsCopyWithImpl<$Res, RunStepDeltaDetails>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$RunStepDeltaDetailsCopyWithImpl<$Res, $Val extends RunStepDeltaDetails>
    implements $RunStepDeltaDetailsCopyWith<$Res> {
  _$RunStepDeltaDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWith<$Res>
    implements $RunStepDeltaDetailsCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWith(
          _$RunStepDeltaStepDetailsMessageCreationObjectImpl value,
          $Res Function(_$RunStepDeltaStepDetailsMessageCreationObjectImpl)
              then) =
      __$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'message_creation', includeIfNull: false)
      RunStepDeltaStepDetailsMessageCreation? messageCreation});

  $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res>? get messageCreation;
}

/// @nodoc
class __$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWithImpl<$Res>
    extends _$RunStepDeltaDetailsCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsMessageCreationObjectImpl>
    implements
        _$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWithImpl(
      _$RunStepDeltaStepDetailsMessageCreationObjectImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsMessageCreationObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? messageCreation = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsMessageCreationObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      messageCreation: freezed == messageCreation
          ? _value.messageCreation
          : messageCreation // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsMessageCreation?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res>? get messageCreation {
    if (_value.messageCreation == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsMessageCreationCopyWith<$Res>(
        _value.messageCreation!, (value) {
      return _then(_value.copyWith(messageCreation: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsMessageCreationObjectImpl
    extends RunStepDeltaStepDetailsMessageCreationObject {
  const _$RunStepDeltaStepDetailsMessageCreationObjectImpl(
      {required this.type,
      @JsonKey(name: 'message_creation', includeIfNull: false)
      this.messageCreation})
      : super._();

  factory _$RunStepDeltaStepDetailsMessageCreationObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsMessageCreationObjectImplFromJson(json);

  /// Always `message_creation`.
  @override
  final String type;

  /// Details of the message creation by the run step.
  @override
  @JsonKey(name: 'message_creation', includeIfNull: false)
  final RunStepDeltaStepDetailsMessageCreation? messageCreation;

  @override
  String toString() {
    return 'RunStepDeltaDetails.messageCreation(type: $type, messageCreation: $messageCreation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsMessageCreationObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.messageCreation, messageCreation) ||
                other.messageCreation == messageCreation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, messageCreation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWith<
          _$RunStepDeltaStepDetailsMessageCreationObjectImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsMessageCreationObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)
        toolCalls,
  }) {
    return messageCreation(type, this.messageCreation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
  }) {
    return messageCreation?.call(type, this.messageCreation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    if (messageCreation != null) {
      return messageCreation(type, this.messageCreation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDeltaStepDetailsToolCallsObject value)
        toolCalls,
  }) {
    return messageCreation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
  }) {
    return messageCreation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    if (messageCreation != null) {
      return messageCreation(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsMessageCreationObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDeltaStepDetailsMessageCreationObject
    extends RunStepDeltaDetails {
  const factory RunStepDeltaStepDetailsMessageCreationObject(
          {required final String type,
          @JsonKey(name: 'message_creation', includeIfNull: false)
          final RunStepDeltaStepDetailsMessageCreation? messageCreation}) =
      _$RunStepDeltaStepDetailsMessageCreationObjectImpl;
  const RunStepDeltaStepDetailsMessageCreationObject._() : super._();

  factory RunStepDeltaStepDetailsMessageCreationObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsMessageCreationObjectImpl.fromJson;

  @override

  /// Always `message_creation`.
  String get type;

  /// Details of the message creation by the run step.
  @JsonKey(name: 'message_creation', includeIfNull: false)
  RunStepDeltaStepDetailsMessageCreation? get messageCreation;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsMessageCreationObjectImplCopyWith<
          _$RunStepDeltaStepDetailsMessageCreationObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWith<$Res>
    implements $RunStepDeltaDetailsCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsObjectImpl value,
          $Res Function(_$RunStepDeltaStepDetailsToolCallsObjectImpl) then) =
      __$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      List<RunStepDeltaStepDetailsToolCalls>? toolCalls});
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWithImpl<$Res>
    extends _$RunStepDeltaDetailsCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsObjectImpl>
    implements _$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsObjectImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? toolCalls = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      toolCalls: freezed == toolCalls
          ? _value._toolCalls
          : toolCalls // ignore: cast_nullable_to_non_nullable
              as List<RunStepDeltaStepDetailsToolCalls>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsObjectImpl
    extends RunStepDeltaStepDetailsToolCallsObject {
  const _$RunStepDeltaStepDetailsToolCallsObjectImpl(
      {required this.type,
      @JsonKey(name: 'tool_calls', includeIfNull: false)
      final List<RunStepDeltaStepDetailsToolCalls>? toolCalls})
      : _toolCalls = toolCalls,
        super._();

  factory _$RunStepDeltaStepDetailsToolCallsObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsObjectImplFromJson(json);

  /// Always `tool_calls`.
  @override
  final String type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  final List<RunStepDeltaStepDetailsToolCalls>? _toolCalls;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  @override
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCalls>? get toolCalls {
    final value = _toolCalls;
    if (value == null) return null;
    if (_toolCalls is EqualUnmodifiableListView) return _toolCalls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'RunStepDeltaDetails.toolCalls(type: $type, toolCalls: $toolCalls)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsToolCallsObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._toolCalls, _toolCalls));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, type, const DeepCollectionEquality().hash(_toolCalls));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsObjectImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWithImpl<
              _$RunStepDeltaStepDetailsToolCallsObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)
        messageCreation,
    required TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)
        toolCalls,
  }) {
    return toolCalls(type, this.toolCalls);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult? Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
  }) {
    return toolCalls?.call(type, this.toolCalls);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String type,
            @JsonKey(name: 'message_creation', includeIfNull: false)
            RunStepDeltaStepDetailsMessageCreation? messageCreation)?
        messageCreation,
    TResult Function(
            String type,
            @JsonKey(name: 'tool_calls', includeIfNull: false)
            List<RunStepDeltaStepDetailsToolCalls>? toolCalls)?
        toolCalls,
    required TResult orElse(),
  }) {
    if (toolCalls != null) {
      return toolCalls(type, this.toolCalls);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsMessageCreationObject value)
        messageCreation,
    required TResult Function(RunStepDeltaStepDetailsToolCallsObject value)
        toolCalls,
  }) {
    return toolCalls(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult? Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
  }) {
    return toolCalls?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsMessageCreationObject value)?
        messageCreation,
    TResult Function(RunStepDeltaStepDetailsToolCallsObject value)? toolCalls,
    required TResult orElse(),
  }) {
    if (toolCalls != null) {
      return toolCalls(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDeltaStepDetailsToolCallsObject
    extends RunStepDeltaDetails {
  const factory RunStepDeltaStepDetailsToolCallsObject(
          {required final String type,
          @JsonKey(name: 'tool_calls', includeIfNull: false)
          final List<RunStepDeltaStepDetailsToolCalls>? toolCalls}) =
      _$RunStepDeltaStepDetailsToolCallsObjectImpl;
  const RunStepDeltaStepDetailsToolCallsObject._() : super._();

  factory RunStepDeltaStepDetailsToolCallsObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsObjectImpl.fromJson;

  @override

  /// Always `tool_calls`.
  String get type;

  /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
  @JsonKey(name: 'tool_calls', includeIfNull: false)
  List<RunStepDeltaStepDetailsToolCalls>? get toolCalls;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCalls _$RunStepDetailsToolCallsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return RunStepDetailsToolCallsCodeObject.fromJson(json);
    case 'file_search':
      return RunStepDetailsToolCallsFileSearchObject.fromJson(json);
    case 'function':
      return RunStepDetailsToolCallsFunctionObject.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'RunStepDetailsToolCalls',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCalls {
  /// The ID of the tool call.
  String get id => throw _privateConstructorUsedError;

  /// Always `code_interpreter`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsFileSearchObject value)? fileSearch,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsCopyWith<RunStepDetailsToolCalls> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCopyWith(RunStepDetailsToolCalls value,
          $Res Function(RunStepDetailsToolCalls) then) =
      _$RunStepDetailsToolCallsCopyWithImpl<$Res, RunStepDetailsToolCalls>;
  @useResult
  $Res call({String id, String type});
}

/// @nodoc
class _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCalls>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  _$RunStepDetailsToolCallsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeObjectImplCopyWith(
          _$RunStepDetailsToolCallsCodeObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeObjectImpl) then) =
      __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String type,
      @JsonKey(name: 'code_interpreter')
      RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter});

  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>
      get codeInterpreter;
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeObjectImpl>
    implements _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? codeInterpreter = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      codeInterpreter: null == codeInterpreter
          ? _value.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeObjectCodeInterpreter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>
      get codeInterpreter {
    return $RunStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>(
        _value.codeInterpreter, (value) {
      return _then(_value.copyWith(codeInterpreter: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeObjectImpl
    extends RunStepDetailsToolCallsCodeObject {
  const _$RunStepDetailsToolCallsCodeObjectImpl(
      {required this.id,
      required this.type,
      @JsonKey(name: 'code_interpreter') required this.codeInterpreter})
      : super._();

  factory _$RunStepDetailsToolCallsCodeObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeObjectImplFromJson(json);

  /// The ID of the tool call.
  @override
  final String id;

  /// Always `code_interpreter`.
  @override
  final String type;

  /// The Code Interpreter tool call definition.
  @override
  @JsonKey(name: 'code_interpreter')
  final RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter;

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.codeInterpreter(id: $id, type: $type, codeInterpreter: $codeInterpreter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, codeInterpreter);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectImpl>
      get copyWith => __$$RunStepDetailsToolCallsCodeObjectImplCopyWithImpl<
          _$RunStepDetailsToolCallsCodeObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)
        function,
  }) {
    return codeInterpreter(id, type, this.codeInterpreter);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
  }) {
    return codeInterpreter?.call(id, type, this.codeInterpreter);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(id, type, this.codeInterpreter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return codeInterpreter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) {
    return codeInterpreter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsFileSearchObject value)? fileSearch,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsCodeObject
    extends RunStepDetailsToolCalls {
  const factory RunStepDetailsToolCallsCodeObject(
      {required final String id,
      required final String type,
      @JsonKey(name: 'code_interpreter')
      required final RunStepDetailsToolCallsCodeObjectCodeInterpreter
          codeInterpreter}) = _$RunStepDetailsToolCallsCodeObjectImpl;
  const RunStepDetailsToolCallsCodeObject._() : super._();

  factory RunStepDetailsToolCallsCodeObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeObjectImpl.fromJson;

  @override

  /// The ID of the tool call.
  String get id;
  @override

  /// Always `code_interpreter`.
  String get type;

  /// The Code Interpreter tool call definition.
  @JsonKey(name: 'code_interpreter')
  RunStepDetailsToolCallsCodeObjectCodeInterpreter get codeInterpreter;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsFileSearchObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsFileSearchObjectImplCopyWith(
          _$RunStepDetailsToolCallsFileSearchObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsFileSearchObjectImpl) then) =
      __$$RunStepDetailsToolCallsFileSearchObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String type,
      @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch});
}

/// @nodoc
class __$$RunStepDetailsToolCallsFileSearchObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsFileSearchObjectImpl>
    implements _$$RunStepDetailsToolCallsFileSearchObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsFileSearchObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsFileSearchObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsFileSearchObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? fileSearch = null,
  }) {
    return _then(_$RunStepDetailsToolCallsFileSearchObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      fileSearch: null == fileSearch
          ? _value._fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsFileSearchObjectImpl
    extends RunStepDetailsToolCallsFileSearchObject {
  const _$RunStepDetailsToolCallsFileSearchObjectImpl(
      {required this.id,
      required this.type,
      @JsonKey(name: 'file_search')
      required final Map<String, dynamic> fileSearch})
      : _fileSearch = fileSearch,
        super._();

  factory _$RunStepDetailsToolCallsFileSearchObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsFileSearchObjectImplFromJson(json);

  /// The ID of the tool call object.
  @override
  final String id;

  /// The type of tool call. This is always going to be `file_search` for this type of tool call.
  @override
  final String type;

  /// For now, this is always going to be an empty object.
  final Map<String, dynamic> _fileSearch;

  /// For now, this is always going to be an empty object.
  @override
  @JsonKey(name: 'file_search')
  Map<String, dynamic> get fileSearch {
    if (_fileSearch is EqualUnmodifiableMapView) return _fileSearch;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_fileSearch);
  }

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.fileSearch(id: $id, type: $type, fileSearch: $fileSearch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsFileSearchObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._fileSearch, _fileSearch));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, type, const DeepCollectionEquality().hash(_fileSearch));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsFileSearchObjectImplCopyWith<
          _$RunStepDetailsToolCallsFileSearchObjectImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsFileSearchObjectImplCopyWithImpl<
              _$RunStepDetailsToolCallsFileSearchObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)
        function,
  }) {
    return fileSearch(id, type, this.fileSearch);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
  }) {
    return fileSearch?.call(id, type, this.fileSearch);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) {
    if (fileSearch != null) {
      return fileSearch(id, type, this.fileSearch);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return fileSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) {
    return fileSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsFileSearchObject value)? fileSearch,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) {
    if (fileSearch != null) {
      return fileSearch(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsFileSearchObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsFileSearchObject
    extends RunStepDetailsToolCalls {
  const factory RunStepDetailsToolCallsFileSearchObject(
          {required final String id,
          required final String type,
          @JsonKey(name: 'file_search')
          required final Map<String, dynamic> fileSearch}) =
      _$RunStepDetailsToolCallsFileSearchObjectImpl;
  const RunStepDetailsToolCallsFileSearchObject._() : super._();

  factory RunStepDetailsToolCallsFileSearchObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsFileSearchObjectImpl.fromJson;

  @override

  /// The ID of the tool call object.
  String get id;
  @override

  /// The type of tool call. This is always going to be `file_search` for this type of tool call.
  String get type;

  /// For now, this is always going to be an empty object.
  @JsonKey(name: 'file_search')
  Map<String, dynamic> get fileSearch;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsFileSearchObjectImplCopyWith<
          _$RunStepDetailsToolCallsFileSearchObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith(
          _$RunStepDetailsToolCallsFunctionObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsFunctionObjectImpl) then) =
      __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String type, RunStepDetailsToolCallsFunction function});

  $RunStepDetailsToolCallsFunctionCopyWith<$Res> get function;
}

/// @nodoc
class __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsFunctionObjectImpl>
    implements _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsFunctionObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsFunctionObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? function = null,
  }) {
    return _then(_$RunStepDetailsToolCallsFunctionObjectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsFunction,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsFunctionCopyWith<$Res> get function {
    return $RunStepDetailsToolCallsFunctionCopyWith<$Res>(_value.function,
        (value) {
      return _then(_value.copyWith(function: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsFunctionObjectImpl
    extends RunStepDetailsToolCallsFunctionObject {
  const _$RunStepDetailsToolCallsFunctionObjectImpl(
      {required this.id, required this.type, required this.function})
      : super._();

  factory _$RunStepDetailsToolCallsFunctionObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsFunctionObjectImplFromJson(json);

  /// The ID of the tool call object.
  @override
  final String id;

  /// Always `function`.
  @override
  final String type;

  /// The definition of the function that was called.
  @override
  final RunStepDetailsToolCallsFunction function;

  @override
  String toString() {
    return 'RunStepDetailsToolCalls.function(id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsFunctionObjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<
          _$RunStepDetailsToolCallsFunctionObjectImpl>
      get copyWith => __$$RunStepDetailsToolCallsFunctionObjectImplCopyWithImpl<
          _$RunStepDetailsToolCallsFunctionObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)
        codeInterpreter,
    required TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)
        function,
  }) {
    return function(id, type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult? Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
  }) {
    return function?.call(id, type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String id,
            String type,
            @JsonKey(name: 'code_interpreter')
            RunStepDetailsToolCallsCodeObjectCodeInterpreter codeInterpreter)?
        codeInterpreter,
    TResult Function(String id, String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            String id, String type, RunStepDetailsToolCallsFunction function)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(id, type, this.function);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(RunStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(RunStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult? Function(RunStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDetailsToolCallsFunctionObject value)? function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeObject value)? codeInterpreter,
    TResult Function(RunStepDetailsToolCallsFileSearchObject value)? fileSearch,
    TResult Function(RunStepDetailsToolCallsFunctionObject value)? function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsFunctionObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsFunctionObject
    extends RunStepDetailsToolCalls {
  const factory RunStepDetailsToolCallsFunctionObject(
          {required final String id,
          required final String type,
          required final RunStepDetailsToolCallsFunction function}) =
      _$RunStepDetailsToolCallsFunctionObjectImpl;
  const RunStepDetailsToolCallsFunctionObject._() : super._();

  factory RunStepDetailsToolCallsFunctionObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsFunctionObjectImpl.fromJson;

  @override

  /// The ID of the tool call object.
  String get id;
  @override

  /// Always `function`.
  String get type;

  /// The definition of the function that was called.
  RunStepDetailsToolCallsFunction get function;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsFunctionObjectImplCopyWith<
          _$RunStepDetailsToolCallsFunctionObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsFunction _$RunStepDetailsToolCallsFunctionFromJson(
    Map<String, dynamic> json) {
  return _RunStepDetailsToolCallsFunction.fromJson(json);
}

/// @nodoc
mixin _$RunStepDetailsToolCallsFunction {
  /// The name of the function.
  String get name => throw _privateConstructorUsedError;

  /// The arguments passed to the function.
  String get arguments => throw _privateConstructorUsedError;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  String? get output => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsFunctionCopyWith<RunStepDetailsToolCallsFunction>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory $RunStepDetailsToolCallsFunctionCopyWith(
          RunStepDetailsToolCallsFunction value,
          $Res Function(RunStepDetailsToolCallsFunction) then) =
      _$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res,
          RunStepDetailsToolCallsFunction>;
  @useResult
  $Res call({String name, String arguments, String? output});
}

/// @nodoc
class _$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsFunction>
    implements $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  _$RunStepDetailsToolCallsFunctionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
    Object? output = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsFunctionImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsFunctionImplCopyWith(
          _$RunStepDetailsToolCallsFunctionImpl value,
          $Res Function(_$RunStepDetailsToolCallsFunctionImpl) then) =
      __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String arguments, String? output});
}

/// @nodoc
class __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsFunctionCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsFunctionImpl>
    implements _$$RunStepDetailsToolCallsFunctionImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl(
      _$RunStepDetailsToolCallsFunctionImpl _value,
      $Res Function(_$RunStepDetailsToolCallsFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? arguments = null,
    Object? output = freezed,
  }) {
    return _then(_$RunStepDetailsToolCallsFunctionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsFunctionImpl
    extends _RunStepDetailsToolCallsFunction {
  const _$RunStepDetailsToolCallsFunctionImpl(
      {required this.name, required this.arguments, required this.output})
      : super._();

  factory _$RunStepDetailsToolCallsFunctionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsFunctionImplFromJson(json);

  /// The name of the function.
  @override
  final String name;

  /// The arguments passed to the function.
  @override
  final String arguments;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @override
  final String? output;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsFunction(name: $name, arguments: $arguments, output: $output)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsFunctionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments, output);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsFunctionImplCopyWith<
          _$RunStepDetailsToolCallsFunctionImpl>
      get copyWith => __$$RunStepDetailsToolCallsFunctionImplCopyWithImpl<
          _$RunStepDetailsToolCallsFunctionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsFunctionImplToJson(
      this,
    );
  }
}

abstract class _RunStepDetailsToolCallsFunction
    extends RunStepDetailsToolCallsFunction {
  const factory _RunStepDetailsToolCallsFunction(
      {required final String name,
      required final String arguments,
      required final String? output}) = _$RunStepDetailsToolCallsFunctionImpl;
  const _RunStepDetailsToolCallsFunction._() : super._();

  factory _RunStepDetailsToolCallsFunction.fromJson(Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsFunctionImpl.fromJson;

  @override

  /// The name of the function.
  String get name;
  @override

  /// The arguments passed to the function.
  String get arguments;
  @override

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  String? get output;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsFunctionImplCopyWith<
          _$RunStepDetailsToolCallsFunctionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDeltaStepDetailsToolCalls _$RunStepDeltaStepDetailsToolCallsFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'code_interpreter':
      return RunStepDeltaStepDetailsToolCallsCodeObject.fromJson(json);
    case 'file_search':
      return RunStepDeltaStepDetailsToolCallsFileSearchObject.fromJson(json);
    case 'function':
      return RunStepDeltaStepDetailsToolCallsFunctionObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'RunStepDeltaStepDetailsToolCalls',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCalls {
  /// The index of the tool call in the tool calls array.
  int get index => throw _privateConstructorUsedError;

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id => throw _privateConstructorUsedError;

  /// Always `code_interpreter`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)
        codeInterpreter,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFunctionObject value)
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaStepDetailsToolCallsCopyWith<RunStepDeltaStepDetailsToolCalls>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCopyWith(
          RunStepDeltaStepDetailsToolCalls value,
          $Res Function(RunStepDeltaStepDetailsToolCalls) then) =
      _$RunStepDeltaStepDetailsToolCallsCopyWithImpl<$Res,
          RunStepDeltaStepDetailsToolCalls>;
  @useResult
  $Res call(
      {int index, @JsonKey(includeIfNull: false) String? id, String type});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCopyWithImpl<$Res,
        $Val extends RunStepDeltaStepDetailsToolCalls>
    implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWith<$Res>
    implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl value,
          $Res Function(_$RunStepDeltaStepDetailsToolCallsCodeObjectImpl)
              then) =
      __$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      String type,
      @JsonKey(name: 'code_interpreter', includeIfNull: false)
      RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
          codeInterpreter});

  $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>?
      get codeInterpreter;
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWithImpl<$Res>
    extends _$RunStepDeltaStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl>
    implements _$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsCodeObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
    Object? codeInterpreter = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsCodeObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      codeInterpreter: freezed == codeInterpreter
          ? _value.codeInterpreter
          : codeInterpreter // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<$Res>?
      get codeInterpreter {
    if (_value.codeInterpreter == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterCopyWith<
        $Res>(_value.codeInterpreter!, (value) {
      return _then(_value.copyWith(codeInterpreter: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl
    extends RunStepDeltaStepDetailsToolCallsCodeObject {
  const _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      required this.type,
      @JsonKey(name: 'code_interpreter', includeIfNull: false)
      this.codeInterpreter})
      : super._();

  factory _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsCodeObjectImplFromJson(json);

  /// The index of the tool call in the tool calls array.
  @override
  final int index;

  /// The ID of the tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// Always `code_interpreter`.
  @override
  final String type;

  /// The Code Interpreter tool call definition. - outputs
  @override
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  final RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
      codeInterpreter;

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCalls.codeInterpreter(index: $index, id: $id, type: $type, codeInterpreter: $codeInterpreter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.codeInterpreter, codeInterpreter) ||
                other.codeInterpreter == codeInterpreter));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, index, id, type, codeInterpreter);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)
        codeInterpreter,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)
        function,
  }) {
    return codeInterpreter(index, id, type, this.codeInterpreter);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
  }) {
    return codeInterpreter?.call(index, id, type, this.codeInterpreter);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(index, id, type, this.codeInterpreter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return codeInterpreter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
  }) {
    return codeInterpreter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
    required TResult orElse(),
  }) {
    if (codeInterpreter != null) {
      return codeInterpreter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsCodeObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDeltaStepDetailsToolCallsCodeObject
    extends RunStepDeltaStepDetailsToolCalls {
  const factory RunStepDeltaStepDetailsToolCallsCodeObject(
      {required final int index,
      @JsonKey(includeIfNull: false) final String? id,
      required final String type,
      @JsonKey(name: 'code_interpreter', includeIfNull: false)
      final RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
          codeInterpreter}) = _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl;
  const RunStepDeltaStepDetailsToolCallsCodeObject._() : super._();

  factory RunStepDeltaStepDetailsToolCallsCodeObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl.fromJson;

  @override

  /// The index of the tool call in the tool calls array.
  int get index;
  @override

  /// The ID of the tool call.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// Always `code_interpreter`.
  String get type;

  /// The Code Interpreter tool call definition. - outputs
  @JsonKey(name: 'code_interpreter', includeIfNull: false)
  RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
      get codeInterpreter;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsCodeObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl value,
          $Res Function(_$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl)
              then) =
      __$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      String type,
      @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch});
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWithImpl<$Res>
    extends _$RunStepDeltaStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl>
    implements
        _$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
    Object? fileSearch = null,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      fileSearch: null == fileSearch
          ? _value._fileSearch
          : fileSearch // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl
    extends RunStepDeltaStepDetailsToolCallsFileSearchObject {
  const _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      required this.type,
      @JsonKey(name: 'file_search')
      required final Map<String, dynamic> fileSearch})
      : _fileSearch = fileSearch,
        super._();

  factory _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplFromJson(json);

  /// The index of the tool call in the tool calls array.
  @override
  final int index;

  /// The ID of the tool call object.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// The type of tool call. This is always going to be `file_search` for this type of tool call.
  @override
  final String type;

  /// For now, this is always going to be an empty object.
  final Map<String, dynamic> _fileSearch;

  /// For now, this is always going to be an empty object.
  @override
  @JsonKey(name: 'file_search')
  Map<String, dynamic> get fileSearch {
    if (_fileSearch is EqualUnmodifiableMapView) return _fileSearch;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_fileSearch);
  }

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCalls.fileSearch(index: $index, id: $id, type: $type, fileSearch: $fileSearch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._fileSearch, _fileSearch));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type,
      const DeepCollectionEquality().hash(_fileSearch));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)
        codeInterpreter,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)
        function,
  }) {
    return fileSearch(index, id, type, this.fileSearch);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
  }) {
    return fileSearch?.call(index, id, type, this.fileSearch);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
    required TResult orElse(),
  }) {
    if (fileSearch != null) {
      return fileSearch(index, id, type, this.fileSearch);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return fileSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
  }) {
    return fileSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
    required TResult orElse(),
  }) {
    if (fileSearch != null) {
      return fileSearch(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDeltaStepDetailsToolCallsFileSearchObject
    extends RunStepDeltaStepDetailsToolCalls {
  const factory RunStepDeltaStepDetailsToolCallsFileSearchObject(
          {required final int index,
          @JsonKey(includeIfNull: false) final String? id,
          required final String type,
          @JsonKey(name: 'file_search')
          required final Map<String, dynamic> fileSearch}) =
      _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl;
  const RunStepDeltaStepDetailsToolCallsFileSearchObject._() : super._();

  factory RunStepDeltaStepDetailsToolCallsFileSearchObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl.fromJson;

  @override

  /// The index of the tool call in the tool calls array.
  int get index;
  @override

  /// The ID of the tool call object.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// The type of tool call. This is always going to be `file_search` for this type of tool call.
  String get type;

  /// For now, this is always going to be an empty object.
  @JsonKey(name: 'file_search')
  Map<String, dynamic> get fileSearch;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsFileSearchObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsFileSearchObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl value,
          $Res Function(_$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl)
              then) =
      __$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      @JsonKey(includeIfNull: false) String? id,
      String type,
      @JsonKey(includeIfNull: false)
      RunStepDeltaStepDetailsToolCallsFunction? function});

  $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res>? get function;
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWithImpl<$Res>
    extends _$RunStepDeltaStepDetailsToolCallsCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl>
    implements
        _$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? id = freezed,
    Object? type = null,
    Object? function = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsToolCallsFunction?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res>? get function {
    if (_value.function == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res>(
        _value.function!, (value) {
      return _then(_value.copyWith(function: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl
    extends RunStepDeltaStepDetailsToolCallsFunctionObject {
  const _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl(
      {required this.index,
      @JsonKey(includeIfNull: false) this.id,
      required this.type,
      @JsonKey(includeIfNull: false) this.function})
      : super._();

  factory _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplFromJson(json);

  /// The index of the tool call in the tool calls array.
  @override
  final int index;

  /// The ID of the tool call object.
  @override
  @JsonKey(includeIfNull: false)
  final String? id;

  /// Always `function`.
  @override
  final String type;

  /// The definition of the function that was called.
  @override
  @JsonKey(includeIfNull: false)
  final RunStepDeltaStepDetailsToolCallsFunction? function;

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCalls.function(index: $index, id: $id, type: $type, function: $function)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.function, function) ||
                other.function == function));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, id, type, function);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)
        codeInterpreter,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)
        fileSearch,
    required TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)
        function,
  }) {
    return function(index, id, type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult? Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
  }) {
    return function?.call(index, id, type, this.function);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'code_interpreter', includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter?
                codeInterpreter)?
        codeInterpreter,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(name: 'file_search') Map<String, dynamic> fileSearch)?
        fileSearch,
    TResult Function(
            int index,
            @JsonKey(includeIfNull: false) String? id,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsFunction? function)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(index, id, type, this.function);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)
        codeInterpreter,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFileSearchObject value)
        fileSearch,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsFunctionObject value)
        function,
  }) {
    return function(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult? Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
  }) {
    return function?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDeltaStepDetailsToolCallsCodeObject value)?
        codeInterpreter,
    TResult Function(RunStepDeltaStepDetailsToolCallsFileSearchObject value)?
        fileSearch,
    TResult Function(RunStepDeltaStepDetailsToolCallsFunctionObject value)?
        function,
    required TResult orElse(),
  }) {
    if (function != null) {
      return function(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDeltaStepDetailsToolCallsFunctionObject
    extends RunStepDeltaStepDetailsToolCalls {
  const factory RunStepDeltaStepDetailsToolCallsFunctionObject(
          {required final int index,
          @JsonKey(includeIfNull: false) final String? id,
          required final String type,
          @JsonKey(includeIfNull: false)
          final RunStepDeltaStepDetailsToolCallsFunction? function}) =
      _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl;
  const RunStepDeltaStepDetailsToolCallsFunctionObject._() : super._();

  factory RunStepDeltaStepDetailsToolCallsFunctionObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl.fromJson;

  @override

  /// The index of the tool call in the tool calls array.
  int get index;
  @override

  /// The ID of the tool call object.
  @JsonKey(includeIfNull: false)
  String? get id;
  @override

  /// Always `function`.
  String get type;

  /// The definition of the function that was called.
  @JsonKey(includeIfNull: false)
  RunStepDeltaStepDetailsToolCallsFunction? get function;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsFunctionObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsFunctionObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDeltaStepDetailsToolCallsFunction
    _$RunStepDeltaStepDetailsToolCallsFunctionFromJson(
        Map<String, dynamic> json) {
  return _RunStepDeltaStepDetailsToolCallsFunction.fromJson(json);
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsFunction {
  /// The name of the function.
  @JsonKey(includeIfNull: false)
  String? get name => throw _privateConstructorUsedError;

  /// The arguments passed to the function.
  @JsonKey(includeIfNull: false)
  String? get arguments => throw _privateConstructorUsedError;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @JsonKey(includeIfNull: false)
  String? get output => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<
          RunStepDeltaStepDetailsToolCallsFunction>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsFunctionCopyWith(
          RunStepDeltaStepDetailsToolCallsFunction value,
          $Res Function(RunStepDeltaStepDetailsToolCallsFunction) then) =
      _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl<$Res,
          RunStepDeltaStepDetailsToolCallsFunction>;
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl<$Res,
        $Val extends RunStepDeltaStepDetailsToolCallsFunction>
    implements $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
    Object? output = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWith<$Res>
    implements $RunStepDeltaStepDetailsToolCallsFunctionCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsFunctionImpl value,
          $Res Function(_$RunStepDeltaStepDetailsToolCallsFunctionImpl) then) =
      __$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(includeIfNull: false) String? name,
      @JsonKey(includeIfNull: false) String? arguments,
      @JsonKey(includeIfNull: false) String? output});
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWithImpl<$Res>
    extends _$RunStepDeltaStepDetailsToolCallsFunctionCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsFunctionImpl>
    implements _$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWith<$Res> {
  __$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsFunctionImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsFunctionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? arguments = freezed,
    Object? output = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsFunctionImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      arguments: freezed == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as String?,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsFunctionImpl
    extends _RunStepDeltaStepDetailsToolCallsFunction {
  const _$RunStepDeltaStepDetailsToolCallsFunctionImpl(
      {@JsonKey(includeIfNull: false) this.name,
      @JsonKey(includeIfNull: false) this.arguments,
      @JsonKey(includeIfNull: false) this.output})
      : super._();

  factory _$RunStepDeltaStepDetailsToolCallsFunctionImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsFunctionImplFromJson(json);

  /// The name of the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? name;

  /// The arguments passed to the function.
  @override
  @JsonKey(includeIfNull: false)
  final String? arguments;

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @override
  @JsonKey(includeIfNull: false)
  final String? output;

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsFunction(name: $name, arguments: $arguments, output: $output)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDeltaStepDetailsToolCallsFunctionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.arguments, arguments) ||
                other.arguments == arguments) &&
            (identical(other.output, output) || other.output == output));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, arguments, output);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsFunctionImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWithImpl<
              _$RunStepDeltaStepDetailsToolCallsFunctionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsFunctionImplToJson(
      this,
    );
  }
}

abstract class _RunStepDeltaStepDetailsToolCallsFunction
    extends RunStepDeltaStepDetailsToolCallsFunction {
  const factory _RunStepDeltaStepDetailsToolCallsFunction(
          {@JsonKey(includeIfNull: false) final String? name,
          @JsonKey(includeIfNull: false) final String? arguments,
          @JsonKey(includeIfNull: false) final String? output}) =
      _$RunStepDeltaStepDetailsToolCallsFunctionImpl;
  const _RunStepDeltaStepDetailsToolCallsFunction._() : super._();

  factory _RunStepDeltaStepDetailsToolCallsFunction.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsFunctionImpl.fromJson;

  @override

  /// The name of the function.
  @JsonKey(includeIfNull: false)
  String? get name;
  @override

  /// The arguments passed to the function.
  @JsonKey(includeIfNull: false)
  String? get arguments;
  @override

  /// The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet.
  @JsonKey(includeIfNull: false)
  String? get output;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsFunctionImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsFunctionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDetailsToolCallsCodeOutput _$RunStepDetailsToolCallsCodeOutputFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'logs':
      return RunStepDetailsToolCallsCodeOutputLogsObject.fromJson(json);
    case 'image':
      return RunStepDetailsToolCallsCodeOutputImageObject.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'RunStepDetailsToolCallsCodeOutput',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDetailsToolCallsCodeOutput {
  /// Always `logs`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, String logs) logs,
    required TResult Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, String logs)? logs,
    TResult? Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, String logs)? logs,
    TResult Function(String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObject value)? image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDetailsToolCallsCodeOutputCopyWith<RunStepDetailsToolCallsCodeOutput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDetailsToolCallsCodeOutputCopyWith(
          RunStepDetailsToolCallsCodeOutput value,
          $Res Function(RunStepDetailsToolCallsCodeOutput) then) =
      _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
          RunStepDetailsToolCallsCodeOutput>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        $Val extends RunStepDetailsToolCallsCodeOutput>
    implements $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  _$RunStepDetailsToolCallsCodeOutputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith(
          _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeOutputLogsObjectImpl)
              then) =
      __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, String logs});
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>
    implements
        _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeOutputLogsObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? logs = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeOutputLogsObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      logs: null == logs
          ? _value.logs
          : logs // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl
    extends RunStepDetailsToolCallsCodeOutputLogsObject {
  const _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl(
      {required this.type, required this.logs})
      : super._();

  factory _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplFromJson(json);

  /// Always `logs`.
  @override
  final String type;

  /// The text output from the Code Interpreter tool call.
  @override
  final String logs;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutput.logs(type: $type, logs: $logs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.logs, logs) || other.logs == logs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, logs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<
                  _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, String logs) logs,
    required TResult Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)
        image,
  }) {
    return logs(type, this.logs);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, String logs)? logs,
    TResult? Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
  }) {
    return logs?.call(type, this.logs);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, String logs)? logs,
    TResult Function(String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
    required TResult orElse(),
  }) {
    if (logs != null) {
      return logs(type, this.logs);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    return logs(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    return logs?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObject value)? image,
    required TResult orElse(),
  }) {
    if (logs != null) {
      return logs(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsCodeOutputLogsObject
    extends RunStepDetailsToolCallsCodeOutput {
  const factory RunStepDetailsToolCallsCodeOutputLogsObject(
          {required final String type, required final String logs}) =
      _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl;
  const RunStepDetailsToolCallsCodeOutputLogsObject._() : super._();

  factory RunStepDetailsToolCallsCodeOutputLogsObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl.fromJson;

  @override

  /// Always `logs`.
  String get type;

  /// The text output from the Code Interpreter tool call.
  String get logs;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputLogsObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<$Res>
    implements $RunStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith(
          _$RunStepDetailsToolCallsCodeOutputImageObjectImpl value,
          $Res Function(_$RunStepDetailsToolCallsCodeOutputImageObjectImpl)
              then) =
      __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, RunStepDetailsToolCallsCodeOutputImage image});

  $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> get image;
}

/// @nodoc
class __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<$Res>
    extends _$RunStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>
    implements
        _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<$Res> {
  __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl(
      _$RunStepDetailsToolCallsCodeOutputImageObjectImpl _value,
      $Res Function(_$RunStepDetailsToolCallsCodeOutputImageObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? image = null,
  }) {
    return _then(_$RunStepDetailsToolCallsCodeOutputImageObjectImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as RunStepDetailsToolCallsCodeOutputImage,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res> get image {
    return $RunStepDetailsToolCallsCodeOutputImageCopyWith<$Res>(_value.image,
        (value) {
      return _then(_value.copyWith(image: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDetailsToolCallsCodeOutputImageObjectImpl
    extends RunStepDetailsToolCallsCodeOutputImageObject {
  const _$RunStepDetailsToolCallsCodeOutputImageObjectImpl(
      {required this.type, required this.image})
      : super._();

  factory _$RunStepDetailsToolCallsCodeOutputImageObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDetailsToolCallsCodeOutputImageObjectImplFromJson(json);

  /// Always `image`.
  @override
  final String type;

  /// Code interpreter image output.
  @override
  final RunStepDetailsToolCallsCodeOutputImage image;

  @override
  String toString() {
    return 'RunStepDetailsToolCallsCodeOutput.image(type: $type, image: $image)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepDetailsToolCallsCodeOutputImageObjectImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, image);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>
      get copyWith =>
          __$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<
                  _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, String logs) logs,
    required TResult Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)
        image,
  }) {
    return image(type, this.image);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, String logs)? logs,
    TResult? Function(
            String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
  }) {
    return image?.call(type, this.image);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, String logs)? logs,
    TResult Function(String type, RunStepDetailsToolCallsCodeOutputImage image)?
        image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(type, this.image);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult? Function(RunStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RunStepDetailsToolCallsCodeOutputLogsObject value)? logs,
    TResult Function(RunStepDetailsToolCallsCodeOutputImageObject value)? image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDetailsToolCallsCodeOutputImageObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDetailsToolCallsCodeOutputImageObject
    extends RunStepDetailsToolCallsCodeOutput {
  const factory RunStepDetailsToolCallsCodeOutputImageObject(
          {required final String type,
          required final RunStepDetailsToolCallsCodeOutputImage image}) =
      _$RunStepDetailsToolCallsCodeOutputImageObjectImpl;
  const RunStepDetailsToolCallsCodeOutputImageObject._() : super._();

  factory RunStepDetailsToolCallsCodeOutputImageObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDetailsToolCallsCodeOutputImageObjectImpl.fromJson;

  @override

  /// Always `image`.
  String get type;

  /// Code interpreter image output.
  RunStepDetailsToolCallsCodeOutputImage get image;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
          _$RunStepDetailsToolCallsCodeOutputImageObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RunStepDeltaStepDetailsToolCallsCodeOutput
    _$RunStepDeltaStepDetailsToolCallsCodeOutputFromJson(
        Map<String, dynamic> json) {
  switch (json['type']) {
    case 'logs':
      return RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject.fromJson(
          json);
    case 'image':
      return RunStepDeltaStepDetailsToolCallsCodeOutputImageObject.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'RunStepDeltaStepDetailsToolCallsCodeOutput',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$RunStepDeltaStepDetailsToolCallsCodeOutput {
  /// The index of the output in the outputs array.
  int get index => throw _privateConstructorUsedError;

  /// Always `logs`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index, String type, @JsonKey(includeIfNull: false) String? logs)
        logs,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<
          RunStepDeltaStepDetailsToolCallsCodeOutput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith(
          RunStepDeltaStepDetailsToolCallsCodeOutput value,
          $Res Function(RunStepDeltaStepDetailsToolCallsCodeOutput) then) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
          RunStepDeltaStepDetailsToolCallsCodeOutput>;
  @useResult
  $Res call({int index, String type});
}

/// @nodoc
class _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        $Val extends RunStepDeltaStepDetailsToolCallsCodeOutput>
    implements $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl value,
          $Res Function(
                  _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl)
              then) =
      __$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {int index, String type, @JsonKey(includeIfNull: false) String? logs});
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<
        $Res>
    extends _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl>
    implements
        _$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
            $Res> {
  __$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? logs = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      logs: freezed == logs
          ? _value.logs
          : logs // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl
    extends RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
  const _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.logs})
      : super._();

  factory _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplFromJson(json);

  /// The index of the output in the outputs array.
  @override
  final int index;

  /// Always `logs`.
  @override
  final String type;

  /// The text output from the Code Interpreter tool call.
  @override
  @JsonKey(includeIfNull: false)
  final String? logs;

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutput.logs(index: $index, type: $type, logs: $logs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.logs, logs) || other.logs == logs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, logs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index, String type, @JsonKey(includeIfNull: false) String? logs)
        logs,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)
        image,
  }) {
    return logs(index, type, this.logs);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
  }) {
    return logs?.call(index, type, this.logs);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
    required TResult orElse(),
  }) {
    if (logs != null) {
      return logs(index, type, this.logs);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    return logs(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    return logs?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
    required TResult orElse(),
  }) {
    if (logs != null) {
      return logs(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
    extends RunStepDeltaStepDetailsToolCallsCodeOutput {
  const factory RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject(
          {required final int index,
          required final String type,
          @JsonKey(includeIfNull: false) final String? logs}) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl;
  const RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject._() : super._();

  factory RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl.fromJson;

  @override

  /// The index of the output in the outputs array.
  int get index;
  @override

  /// Always `logs`.
  String get type;

  /// The text output from the Code Interpreter tool call.
  @JsonKey(includeIfNull: false)
  String? get logs;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
    $Res> implements $RunStepDeltaStepDetailsToolCallsCodeOutputCopyWith<$Res> {
  factory _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWith(
          _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl value,
          $Res Function(
                  _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl)
              then) =
      __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {int index,
      String type,
      @JsonKey(includeIfNull: false)
      RunStepDeltaStepDetailsToolCallsCodeOutputImage? image});

  $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res>? get image;
}

/// @nodoc
class __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<
        $Res>
    extends _$RunStepDeltaStepDetailsToolCallsCodeOutputCopyWithImpl<$Res,
        _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl>
    implements
        _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
            $Res> {
  __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl(
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl _value,
      $Res Function(_$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? type = null,
    Object? image = freezed,
  }) {
    return _then(_$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaStepDetailsToolCallsCodeOutputImage?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res>? get image {
    if (_value.image == null) {
      return null;
    }

    return $RunStepDeltaStepDetailsToolCallsCodeOutputImageCopyWith<$Res>(
        _value.image!, (value) {
      return _then(_value.copyWith(image: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl
    extends RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
  const _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl(
      {required this.index,
      required this.type,
      @JsonKey(includeIfNull: false) this.image})
      : super._();

  factory _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplFromJson(
          json);

  /// The index of the output in the outputs array.
  @override
  final int index;

  /// Always `image`.
  @override
  final String type;

  /// Code interpreter image output.
  @override
  @JsonKey(includeIfNull: false)
  final RunStepDeltaStepDetailsToolCallsCodeOutputImage? image;

  @override
  String toString() {
    return 'RunStepDeltaStepDetailsToolCallsCodeOutput.image(index: $index, type: $type, image: $image)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, index, type, image);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl>
      get copyWith =>
          __$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWithImpl<
                  _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            int index, String type, @JsonKey(includeIfNull: false) String? logs)
        logs,
    required TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)
        image,
  }) {
    return image(index, type, this.image);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult? Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
  }) {
    return image?.call(index, type, this.image);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int index, String type,
            @JsonKey(includeIfNull: false) String? logs)?
        logs,
    TResult Function(
            int index,
            String type,
            @JsonKey(includeIfNull: false)
            RunStepDeltaStepDetailsToolCallsCodeOutputImage? image)?
        image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(index, type, this.image);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)
        logs,
    required TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)
        image,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult? Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value)?
        logs,
    TResult Function(
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value)?
        image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplToJson(
      this,
    );
  }
}

abstract class RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
    extends RunStepDeltaStepDetailsToolCallsCodeOutput {
  const factory RunStepDeltaStepDetailsToolCallsCodeOutputImageObject(
          {required final int index,
          required final String type,
          @JsonKey(includeIfNull: false)
          final RunStepDeltaStepDetailsToolCallsCodeOutputImage? image}) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl;
  const RunStepDeltaStepDetailsToolCallsCodeOutputImageObject._() : super._();

  factory RunStepDeltaStepDetailsToolCallsCodeOutputImageObject.fromJson(
          Map<String, dynamic> json) =
      _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl.fromJson;

  @override

  /// The index of the output in the outputs array.
  int get index;
  @override

  /// Always `image`.
  String get type;

  /// Code interpreter image output.
  @JsonKey(includeIfNull: false)
  RunStepDeltaStepDetailsToolCallsCodeOutputImage? get image;
  @override
  @JsonKey(ignore: true)
  _$$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImplCopyWith<
          _$RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChunkingStrategyRequestParam _$ChunkingStrategyRequestParamFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'auto':
      return AutoChunkingStrategyRequestParam.fromJson(json);
    case 'static':
      return StaticChunkingStrategyRequestParam.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChunkingStrategyRequestParam',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChunkingStrategyRequestParam {
  /// Always `auto`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) auto,
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? auto,
    TResult? Function(String type, StaticChunkingStrategy static)? static,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? auto,
    TResult Function(String type, StaticChunkingStrategy static)? static,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AutoChunkingStrategyRequestParam value) auto,
    required TResult Function(StaticChunkingStrategyRequestParam value) static,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult? Function(StaticChunkingStrategyRequestParam value)? static,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult Function(StaticChunkingStrategyRequestParam value)? static,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChunkingStrategyRequestParamCopyWith<ChunkingStrategyRequestParam>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChunkingStrategyRequestParamCopyWith<$Res> {
  factory $ChunkingStrategyRequestParamCopyWith(
          ChunkingStrategyRequestParam value,
          $Res Function(ChunkingStrategyRequestParam) then) =
      _$ChunkingStrategyRequestParamCopyWithImpl<$Res,
          ChunkingStrategyRequestParam>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$ChunkingStrategyRequestParamCopyWithImpl<$Res,
        $Val extends ChunkingStrategyRequestParam>
    implements $ChunkingStrategyRequestParamCopyWith<$Res> {
  _$ChunkingStrategyRequestParamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AutoChunkingStrategyRequestParamImplCopyWith<$Res>
    implements $ChunkingStrategyRequestParamCopyWith<$Res> {
  factory _$$AutoChunkingStrategyRequestParamImplCopyWith(
          _$AutoChunkingStrategyRequestParamImpl value,
          $Res Function(_$AutoChunkingStrategyRequestParamImpl) then) =
      __$$AutoChunkingStrategyRequestParamImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class __$$AutoChunkingStrategyRequestParamImplCopyWithImpl<$Res>
    extends _$ChunkingStrategyRequestParamCopyWithImpl<$Res,
        _$AutoChunkingStrategyRequestParamImpl>
    implements _$$AutoChunkingStrategyRequestParamImplCopyWith<$Res> {
  __$$AutoChunkingStrategyRequestParamImplCopyWithImpl(
      _$AutoChunkingStrategyRequestParamImpl _value,
      $Res Function(_$AutoChunkingStrategyRequestParamImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$AutoChunkingStrategyRequestParamImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AutoChunkingStrategyRequestParamImpl
    extends AutoChunkingStrategyRequestParam {
  const _$AutoChunkingStrategyRequestParamImpl({required this.type})
      : super._();

  factory _$AutoChunkingStrategyRequestParamImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$AutoChunkingStrategyRequestParamImplFromJson(json);

  /// Always `auto`.
  @override
  final String type;

  @override
  String toString() {
    return 'ChunkingStrategyRequestParam.auto(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AutoChunkingStrategyRequestParamImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AutoChunkingStrategyRequestParamImplCopyWith<
          _$AutoChunkingStrategyRequestParamImpl>
      get copyWith => __$$AutoChunkingStrategyRequestParamImplCopyWithImpl<
          _$AutoChunkingStrategyRequestParamImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) auto,
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
  }) {
    return auto(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? auto,
    TResult? Function(String type, StaticChunkingStrategy static)? static,
  }) {
    return auto?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? auto,
    TResult Function(String type, StaticChunkingStrategy static)? static,
    required TResult orElse(),
  }) {
    if (auto != null) {
      return auto(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AutoChunkingStrategyRequestParam value) auto,
    required TResult Function(StaticChunkingStrategyRequestParam value) static,
  }) {
    return auto(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult? Function(StaticChunkingStrategyRequestParam value)? static,
  }) {
    return auto?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult Function(StaticChunkingStrategyRequestParam value)? static,
    required TResult orElse(),
  }) {
    if (auto != null) {
      return auto(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AutoChunkingStrategyRequestParamImplToJson(
      this,
    );
  }
}

abstract class AutoChunkingStrategyRequestParam
    extends ChunkingStrategyRequestParam {
  const factory AutoChunkingStrategyRequestParam({required final String type}) =
      _$AutoChunkingStrategyRequestParamImpl;
  const AutoChunkingStrategyRequestParam._() : super._();

  factory AutoChunkingStrategyRequestParam.fromJson(Map<String, dynamic> json) =
      _$AutoChunkingStrategyRequestParamImpl.fromJson;

  @override

  /// Always `auto`.
  String get type;
  @override
  @JsonKey(ignore: true)
  _$$AutoChunkingStrategyRequestParamImplCopyWith<
          _$AutoChunkingStrategyRequestParamImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StaticChunkingStrategyRequestParamImplCopyWith<$Res>
    implements $ChunkingStrategyRequestParamCopyWith<$Res> {
  factory _$$StaticChunkingStrategyRequestParamImplCopyWith(
          _$StaticChunkingStrategyRequestParamImpl value,
          $Res Function(_$StaticChunkingStrategyRequestParamImpl) then) =
      __$$StaticChunkingStrategyRequestParamImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, StaticChunkingStrategy static});

  $StaticChunkingStrategyCopyWith<$Res> get static;
}

/// @nodoc
class __$$StaticChunkingStrategyRequestParamImplCopyWithImpl<$Res>
    extends _$ChunkingStrategyRequestParamCopyWithImpl<$Res,
        _$StaticChunkingStrategyRequestParamImpl>
    implements _$$StaticChunkingStrategyRequestParamImplCopyWith<$Res> {
  __$$StaticChunkingStrategyRequestParamImplCopyWithImpl(
      _$StaticChunkingStrategyRequestParamImpl _value,
      $Res Function(_$StaticChunkingStrategyRequestParamImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? static = null,
  }) {
    return _then(_$StaticChunkingStrategyRequestParamImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      static: null == static
          ? _value.static
          : static // ignore: cast_nullable_to_non_nullable
              as StaticChunkingStrategy,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StaticChunkingStrategyCopyWith<$Res> get static {
    return $StaticChunkingStrategyCopyWith<$Res>(_value.static, (value) {
      return _then(_value.copyWith(static: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$StaticChunkingStrategyRequestParamImpl
    extends StaticChunkingStrategyRequestParam {
  const _$StaticChunkingStrategyRequestParamImpl(
      {required this.type, required this.static})
      : super._();

  factory _$StaticChunkingStrategyRequestParamImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$StaticChunkingStrategyRequestParamImplFromJson(json);

  /// Always `static`.
  @override
  final String type;

  /// Static chunking strategy
  @override
  final StaticChunkingStrategy static;

  @override
  String toString() {
    return 'ChunkingStrategyRequestParam.static(type: $type, static: $static)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StaticChunkingStrategyRequestParamImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.static, static) || other.static == static));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, static);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StaticChunkingStrategyRequestParamImplCopyWith<
          _$StaticChunkingStrategyRequestParamImpl>
      get copyWith => __$$StaticChunkingStrategyRequestParamImplCopyWithImpl<
          _$StaticChunkingStrategyRequestParamImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type) auto,
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
  }) {
    return static(type, this.static);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type)? auto,
    TResult? Function(String type, StaticChunkingStrategy static)? static,
  }) {
    return static?.call(type, this.static);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type)? auto,
    TResult Function(String type, StaticChunkingStrategy static)? static,
    required TResult orElse(),
  }) {
    if (static != null) {
      return static(type, this.static);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AutoChunkingStrategyRequestParam value) auto,
    required TResult Function(StaticChunkingStrategyRequestParam value) static,
  }) {
    return static(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult? Function(StaticChunkingStrategyRequestParam value)? static,
  }) {
    return static?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AutoChunkingStrategyRequestParam value)? auto,
    TResult Function(StaticChunkingStrategyRequestParam value)? static,
    required TResult orElse(),
  }) {
    if (static != null) {
      return static(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$StaticChunkingStrategyRequestParamImplToJson(
      this,
    );
  }
}

abstract class StaticChunkingStrategyRequestParam
    extends ChunkingStrategyRequestParam {
  const factory StaticChunkingStrategyRequestParam(
          {required final String type,
          required final StaticChunkingStrategy static}) =
      _$StaticChunkingStrategyRequestParamImpl;
  const StaticChunkingStrategyRequestParam._() : super._();

  factory StaticChunkingStrategyRequestParam.fromJson(
          Map<String, dynamic> json) =
      _$StaticChunkingStrategyRequestParamImpl.fromJson;

  @override

  /// Always `static`.
  String get type;

  /// Static chunking strategy
  StaticChunkingStrategy get static;
  @override
  @JsonKey(ignore: true)
  _$$StaticChunkingStrategyRequestParamImplCopyWith<
          _$StaticChunkingStrategyRequestParamImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChunkingStrategyResponseParam _$ChunkingStrategyResponseParamFromJson(
    Map<String, dynamic> json) {
  switch (json['type']) {
    case 'static':
      return StaticChunkingStrategyResponseParam.fromJson(json);
    case 'other':
      return OtherChunkingStrategyResponseParam.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'type',
          'ChunkingStrategyResponseParam',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$ChunkingStrategyResponseParam {
  /// Always `static`.
  String get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
    required TResult Function(String type) other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, StaticChunkingStrategy static)? static,
    TResult? Function(String type)? other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, StaticChunkingStrategy static)? static,
    TResult Function(String type)? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StaticChunkingStrategyResponseParam value) static,
    required TResult Function(OtherChunkingStrategyResponseParam value) other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StaticChunkingStrategyResponseParam value)? static,
    TResult? Function(OtherChunkingStrategyResponseParam value)? other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StaticChunkingStrategyResponseParam value)? static,
    TResult Function(OtherChunkingStrategyResponseParam value)? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChunkingStrategyResponseParamCopyWith<ChunkingStrategyResponseParam>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChunkingStrategyResponseParamCopyWith<$Res> {
  factory $ChunkingStrategyResponseParamCopyWith(
          ChunkingStrategyResponseParam value,
          $Res Function(ChunkingStrategyResponseParam) then) =
      _$ChunkingStrategyResponseParamCopyWithImpl<$Res,
          ChunkingStrategyResponseParam>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$ChunkingStrategyResponseParamCopyWithImpl<$Res,
        $Val extends ChunkingStrategyResponseParam>
    implements $ChunkingStrategyResponseParamCopyWith<$Res> {
  _$ChunkingStrategyResponseParamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StaticChunkingStrategyResponseParamImplCopyWith<$Res>
    implements $ChunkingStrategyResponseParamCopyWith<$Res> {
  factory _$$StaticChunkingStrategyResponseParamImplCopyWith(
          _$StaticChunkingStrategyResponseParamImpl value,
          $Res Function(_$StaticChunkingStrategyResponseParamImpl) then) =
      __$$StaticChunkingStrategyResponseParamImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, StaticChunkingStrategy static});

  $StaticChunkingStrategyCopyWith<$Res> get static;
}

/// @nodoc
class __$$StaticChunkingStrategyResponseParamImplCopyWithImpl<$Res>
    extends _$ChunkingStrategyResponseParamCopyWithImpl<$Res,
        _$StaticChunkingStrategyResponseParamImpl>
    implements _$$StaticChunkingStrategyResponseParamImplCopyWith<$Res> {
  __$$StaticChunkingStrategyResponseParamImplCopyWithImpl(
      _$StaticChunkingStrategyResponseParamImpl _value,
      $Res Function(_$StaticChunkingStrategyResponseParamImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? static = null,
  }) {
    return _then(_$StaticChunkingStrategyResponseParamImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      static: null == static
          ? _value.static
          : static // ignore: cast_nullable_to_non_nullable
              as StaticChunkingStrategy,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StaticChunkingStrategyCopyWith<$Res> get static {
    return $StaticChunkingStrategyCopyWith<$Res>(_value.static, (value) {
      return _then(_value.copyWith(static: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$StaticChunkingStrategyResponseParamImpl
    extends StaticChunkingStrategyResponseParam {
  const _$StaticChunkingStrategyResponseParamImpl(
      {required this.type, required this.static})
      : super._();

  factory _$StaticChunkingStrategyResponseParamImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$StaticChunkingStrategyResponseParamImplFromJson(json);

  /// Always `static`.
  @override
  final String type;

  /// Static chunking strategy
  @override
  final StaticChunkingStrategy static;

  @override
  String toString() {
    return 'ChunkingStrategyResponseParam.static(type: $type, static: $static)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StaticChunkingStrategyResponseParamImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.static, static) || other.static == static));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, static);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StaticChunkingStrategyResponseParamImplCopyWith<
          _$StaticChunkingStrategyResponseParamImpl>
      get copyWith => __$$StaticChunkingStrategyResponseParamImplCopyWithImpl<
          _$StaticChunkingStrategyResponseParamImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
    required TResult Function(String type) other,
  }) {
    return static(type, this.static);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, StaticChunkingStrategy static)? static,
    TResult? Function(String type)? other,
  }) {
    return static?.call(type, this.static);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, StaticChunkingStrategy static)? static,
    TResult Function(String type)? other,
    required TResult orElse(),
  }) {
    if (static != null) {
      return static(type, this.static);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StaticChunkingStrategyResponseParam value) static,
    required TResult Function(OtherChunkingStrategyResponseParam value) other,
  }) {
    return static(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StaticChunkingStrategyResponseParam value)? static,
    TResult? Function(OtherChunkingStrategyResponseParam value)? other,
  }) {
    return static?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StaticChunkingStrategyResponseParam value)? static,
    TResult Function(OtherChunkingStrategyResponseParam value)? other,
    required TResult orElse(),
  }) {
    if (static != null) {
      return static(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$StaticChunkingStrategyResponseParamImplToJson(
      this,
    );
  }
}

abstract class StaticChunkingStrategyResponseParam
    extends ChunkingStrategyResponseParam {
  const factory StaticChunkingStrategyResponseParam(
          {required final String type,
          required final StaticChunkingStrategy static}) =
      _$StaticChunkingStrategyResponseParamImpl;
  const StaticChunkingStrategyResponseParam._() : super._();

  factory StaticChunkingStrategyResponseParam.fromJson(
          Map<String, dynamic> json) =
      _$StaticChunkingStrategyResponseParamImpl.fromJson;

  @override

  /// Always `static`.
  String get type;

  /// Static chunking strategy
  StaticChunkingStrategy get static;
  @override
  @JsonKey(ignore: true)
  _$$StaticChunkingStrategyResponseParamImplCopyWith<
          _$StaticChunkingStrategyResponseParamImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OtherChunkingStrategyResponseParamImplCopyWith<$Res>
    implements $ChunkingStrategyResponseParamCopyWith<$Res> {
  factory _$$OtherChunkingStrategyResponseParamImplCopyWith(
          _$OtherChunkingStrategyResponseParamImpl value,
          $Res Function(_$OtherChunkingStrategyResponseParamImpl) then) =
      __$$OtherChunkingStrategyResponseParamImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class __$$OtherChunkingStrategyResponseParamImplCopyWithImpl<$Res>
    extends _$ChunkingStrategyResponseParamCopyWithImpl<$Res,
        _$OtherChunkingStrategyResponseParamImpl>
    implements _$$OtherChunkingStrategyResponseParamImplCopyWith<$Res> {
  __$$OtherChunkingStrategyResponseParamImplCopyWithImpl(
      _$OtherChunkingStrategyResponseParamImpl _value,
      $Res Function(_$OtherChunkingStrategyResponseParamImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$OtherChunkingStrategyResponseParamImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OtherChunkingStrategyResponseParamImpl
    extends OtherChunkingStrategyResponseParam {
  const _$OtherChunkingStrategyResponseParamImpl({required this.type})
      : super._();

  factory _$OtherChunkingStrategyResponseParamImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$OtherChunkingStrategyResponseParamImplFromJson(json);

  /// Always `other`.
  @override
  final String type;

  @override
  String toString() {
    return 'ChunkingStrategyResponseParam.other(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OtherChunkingStrategyResponseParamImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OtherChunkingStrategyResponseParamImplCopyWith<
          _$OtherChunkingStrategyResponseParamImpl>
      get copyWith => __$$OtherChunkingStrategyResponseParamImplCopyWithImpl<
          _$OtherChunkingStrategyResponseParamImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String type, StaticChunkingStrategy static)
        static,
    required TResult Function(String type) other,
  }) {
    return other(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String type, StaticChunkingStrategy static)? static,
    TResult? Function(String type)? other,
  }) {
    return other?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String type, StaticChunkingStrategy static)? static,
    TResult Function(String type)? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StaticChunkingStrategyResponseParam value) static,
    required TResult Function(OtherChunkingStrategyResponseParam value) other,
  }) {
    return other(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StaticChunkingStrategyResponseParam value)? static,
    TResult? Function(OtherChunkingStrategyResponseParam value)? other,
  }) {
    return other?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StaticChunkingStrategyResponseParam value)? static,
    TResult Function(OtherChunkingStrategyResponseParam value)? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$OtherChunkingStrategyResponseParamImplToJson(
      this,
    );
  }
}

abstract class OtherChunkingStrategyResponseParam
    extends ChunkingStrategyResponseParam {
  const factory OtherChunkingStrategyResponseParam(
      {required final String type}) = _$OtherChunkingStrategyResponseParamImpl;
  const OtherChunkingStrategyResponseParam._() : super._();

  factory OtherChunkingStrategyResponseParam.fromJson(
          Map<String, dynamic> json) =
      _$OtherChunkingStrategyResponseParamImpl.fromJson;

  @override

  /// Always `other`.
  String get type;
  @override
  @JsonKey(ignore: true)
  _$$OtherChunkingStrategyResponseParamImplCopyWith<
          _$OtherChunkingStrategyResponseParamImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AssistantStreamEvent _$AssistantStreamEventFromJson(Map<String, dynamic> json) {
  switch (json['event']) {
    case 'thread_stream_event':
      return ThreadStreamEvent.fromJson(json);
    case 'run_stream_event':
      return RunStreamEvent.fromJson(json);
    case 'run_step_stream_event':
      return RunStepStreamEvent.fromJson(json);
    case 'run_step_stream_delta_event':
      return RunStepStreamDeltaEvent.fromJson(json);
    case 'message_stream_event':
      return MessageStreamEvent.fromJson(json);
    case 'message_stream_delta_event':
      return MessageStreamDeltaEvent.fromJson(json);
    case 'error_event':
      return ErrorEvent.fromJson(json);
    case 'done_event':
      return DoneEvent.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'event', 'AssistantStreamEvent',
          'Invalid union type "${json['event']}"!');
  }
}

/// @nodoc
mixin _$AssistantStreamEvent {
  /// The type of the event.
  EventType get event => throw _privateConstructorUsedError;

  /// Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages).
  Object get data => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssistantStreamEventCopyWith<AssistantStreamEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssistantStreamEventCopyWith<$Res> {
  factory $AssistantStreamEventCopyWith(AssistantStreamEvent value,
          $Res Function(AssistantStreamEvent) then) =
      _$AssistantStreamEventCopyWithImpl<$Res, AssistantStreamEvent>;
  @useResult
  $Res call({EventType event});
}

/// @nodoc
class _$AssistantStreamEventCopyWithImpl<$Res,
        $Val extends AssistantStreamEvent>
    implements $AssistantStreamEventCopyWith<$Res> {
  _$AssistantStreamEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
  }) {
    return _then(_value.copyWith(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ThreadStreamEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$ThreadStreamEventImplCopyWith(_$ThreadStreamEventImpl value,
          $Res Function(_$ThreadStreamEventImpl) then) =
      __$$ThreadStreamEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, ThreadObject data});

  $ThreadObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$ThreadStreamEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res, _$ThreadStreamEventImpl>
    implements _$$ThreadStreamEventImplCopyWith<$Res> {
  __$$ThreadStreamEventImplCopyWithImpl(_$ThreadStreamEventImpl _value,
      $Res Function(_$ThreadStreamEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$ThreadStreamEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as ThreadObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ThreadObjectCopyWith<$Res> get data {
    return $ThreadObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ThreadStreamEventImpl extends ThreadStreamEvent {
  const _$ThreadStreamEventImpl({required this.event, required this.data})
      : super._();

  factory _$ThreadStreamEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$ThreadStreamEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages).
  @override
  final ThreadObject data;

  @override
  String toString() {
    return 'AssistantStreamEvent.threadStreamEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThreadStreamEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ThreadStreamEventImplCopyWith<_$ThreadStreamEventImpl> get copyWith =>
      __$$ThreadStreamEventImplCopyWithImpl<_$ThreadStreamEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return threadStreamEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return threadStreamEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (threadStreamEvent != null) {
      return threadStreamEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return threadStreamEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return threadStreamEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (threadStreamEvent != null) {
      return threadStreamEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ThreadStreamEventImplToJson(
      this,
    );
  }
}

abstract class ThreadStreamEvent extends AssistantStreamEvent {
  const factory ThreadStreamEvent(
      {required final EventType event,
      required final ThreadObject data}) = _$ThreadStreamEventImpl;
  const ThreadStreamEvent._() : super._();

  factory ThreadStreamEvent.fromJson(Map<String, dynamic> json) =
      _$ThreadStreamEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages).
  ThreadObject get data;
  @override
  @JsonKey(ignore: true)
  _$$ThreadStreamEventImplCopyWith<_$ThreadStreamEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStreamEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$RunStreamEventImplCopyWith(_$RunStreamEventImpl value,
          $Res Function(_$RunStreamEventImpl) then) =
      __$$RunStreamEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, RunObject data});

  $RunObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$RunStreamEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res, _$RunStreamEventImpl>
    implements _$$RunStreamEventImplCopyWith<$Res> {
  __$$RunStreamEventImplCopyWithImpl(
      _$RunStreamEventImpl _value, $Res Function(_$RunStreamEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$RunStreamEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as RunObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunObjectCopyWith<$Res> get data {
    return $RunObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStreamEventImpl extends RunStreamEvent {
  const _$RunStreamEventImpl({required this.event, required this.data})
      : super._();

  factory _$RunStreamEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStreamEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents an execution run on a [thread](https://platform.openai.com/docs/api-reference/threads).
  @override
  final RunObject data;

  @override
  String toString() {
    return 'AssistantStreamEvent.runStreamEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStreamEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStreamEventImplCopyWith<_$RunStreamEventImpl> get copyWith =>
      __$$RunStreamEventImplCopyWithImpl<_$RunStreamEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return runStreamEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return runStreamEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (runStreamEvent != null) {
      return runStreamEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return runStreamEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return runStreamEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (runStreamEvent != null) {
      return runStreamEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStreamEventImplToJson(
      this,
    );
  }
}

abstract class RunStreamEvent extends AssistantStreamEvent {
  const factory RunStreamEvent(
      {required final EventType event,
      required final RunObject data}) = _$RunStreamEventImpl;
  const RunStreamEvent._() : super._();

  factory RunStreamEvent.fromJson(Map<String, dynamic> json) =
      _$RunStreamEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// Represents an execution run on a [thread](https://platform.openai.com/docs/api-reference/threads).
  RunObject get data;
  @override
  @JsonKey(ignore: true)
  _$$RunStreamEventImplCopyWith<_$RunStreamEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepStreamEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$RunStepStreamEventImplCopyWith(_$RunStepStreamEventImpl value,
          $Res Function(_$RunStepStreamEventImpl) then) =
      __$$RunStepStreamEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, RunStepObject data});

  $RunStepObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$RunStepStreamEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res, _$RunStepStreamEventImpl>
    implements _$$RunStepStreamEventImplCopyWith<$Res> {
  __$$RunStepStreamEventImplCopyWithImpl(_$RunStepStreamEventImpl _value,
      $Res Function(_$RunStepStreamEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$RunStepStreamEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as RunStepObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepObjectCopyWith<$Res> get data {
    return $RunStepObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepStreamEventImpl extends RunStepStreamEvent {
  const _$RunStepStreamEventImpl({required this.event, required this.data})
      : super._();

  factory _$RunStepStreamEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepStreamEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a step in execution of a run.
  @override
  final RunStepObject data;

  @override
  String toString() {
    return 'AssistantStreamEvent.runStepStreamEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepStreamEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepStreamEventImplCopyWith<_$RunStepStreamEventImpl> get copyWith =>
      __$$RunStepStreamEventImplCopyWithImpl<_$RunStepStreamEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return runStepStreamEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return runStepStreamEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (runStepStreamEvent != null) {
      return runStepStreamEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return runStepStreamEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return runStepStreamEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (runStepStreamEvent != null) {
      return runStepStreamEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepStreamEventImplToJson(
      this,
    );
  }
}

abstract class RunStepStreamEvent extends AssistantStreamEvent {
  const factory RunStepStreamEvent(
      {required final EventType event,
      required final RunStepObject data}) = _$RunStepStreamEventImpl;
  const RunStepStreamEvent._() : super._();

  factory RunStepStreamEvent.fromJson(Map<String, dynamic> json) =
      _$RunStepStreamEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// Represents a step in execution of a run.
  RunStepObject get data;
  @override
  @JsonKey(ignore: true)
  _$$RunStepStreamEventImplCopyWith<_$RunStepStreamEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RunStepStreamDeltaEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$RunStepStreamDeltaEventImplCopyWith(
          _$RunStepStreamDeltaEventImpl value,
          $Res Function(_$RunStepStreamDeltaEventImpl) then) =
      __$$RunStepStreamDeltaEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, RunStepDeltaObject data});

  $RunStepDeltaObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$RunStepStreamDeltaEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res,
        _$RunStepStreamDeltaEventImpl>
    implements _$$RunStepStreamDeltaEventImplCopyWith<$Res> {
  __$$RunStepStreamDeltaEventImplCopyWithImpl(
      _$RunStepStreamDeltaEventImpl _value,
      $Res Function(_$RunStepStreamDeltaEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$RunStepStreamDeltaEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as RunStepDeltaObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RunStepDeltaObjectCopyWith<$Res> get data {
    return $RunStepDeltaObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$RunStepStreamDeltaEventImpl extends RunStepStreamDeltaEvent {
  const _$RunStepStreamDeltaEventImpl({required this.event, required this.data})
      : super._();

  factory _$RunStepStreamDeltaEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$RunStepStreamDeltaEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a run step delta i.e. any changed fields on a run step during streaming.
  @override
  final RunStepDeltaObject data;

  @override
  String toString() {
    return 'AssistantStreamEvent.runStepStreamDeltaEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunStepStreamDeltaEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunStepStreamDeltaEventImplCopyWith<_$RunStepStreamDeltaEventImpl>
      get copyWith => __$$RunStepStreamDeltaEventImplCopyWithImpl<
          _$RunStepStreamDeltaEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return runStepStreamDeltaEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return runStepStreamDeltaEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (runStepStreamDeltaEvent != null) {
      return runStepStreamDeltaEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return runStepStreamDeltaEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return runStepStreamDeltaEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (runStepStreamDeltaEvent != null) {
      return runStepStreamDeltaEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RunStepStreamDeltaEventImplToJson(
      this,
    );
  }
}

abstract class RunStepStreamDeltaEvent extends AssistantStreamEvent {
  const factory RunStepStreamDeltaEvent(
      {required final EventType event,
      required final RunStepDeltaObject data}) = _$RunStepStreamDeltaEventImpl;
  const RunStepStreamDeltaEvent._() : super._();

  factory RunStepStreamDeltaEvent.fromJson(Map<String, dynamic> json) =
      _$RunStepStreamDeltaEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// Represents a run step delta i.e. any changed fields on a run step during streaming.
  RunStepDeltaObject get data;
  @override
  @JsonKey(ignore: true)
  _$$RunStepStreamDeltaEventImplCopyWith<_$RunStepStreamDeltaEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageStreamEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$MessageStreamEventImplCopyWith(_$MessageStreamEventImpl value,
          $Res Function(_$MessageStreamEventImpl) then) =
      __$$MessageStreamEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, MessageObject data});

  $MessageObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$MessageStreamEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res, _$MessageStreamEventImpl>
    implements _$$MessageStreamEventImplCopyWith<$Res> {
  __$$MessageStreamEventImplCopyWithImpl(_$MessageStreamEventImpl _value,
      $Res Function(_$MessageStreamEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$MessageStreamEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as MessageObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageObjectCopyWith<$Res> get data {
    return $MessageObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageStreamEventImpl extends MessageStreamEvent {
  const _$MessageStreamEventImpl({required this.event, required this.data})
      : super._();

  factory _$MessageStreamEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageStreamEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a message within a [thread](https://platform.openai.com/docs/api-reference/threads).
  @override
  final MessageObject data;

  @override
  String toString() {
    return 'AssistantStreamEvent.messageStreamEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageStreamEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageStreamEventImplCopyWith<_$MessageStreamEventImpl> get copyWith =>
      __$$MessageStreamEventImplCopyWithImpl<_$MessageStreamEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return messageStreamEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return messageStreamEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (messageStreamEvent != null) {
      return messageStreamEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return messageStreamEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return messageStreamEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (messageStreamEvent != null) {
      return messageStreamEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageStreamEventImplToJson(
      this,
    );
  }
}

abstract class MessageStreamEvent extends AssistantStreamEvent {
  const factory MessageStreamEvent(
      {required final EventType event,
      required final MessageObject data}) = _$MessageStreamEventImpl;
  const MessageStreamEvent._() : super._();

  factory MessageStreamEvent.fromJson(Map<String, dynamic> json) =
      _$MessageStreamEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// Represents a message within a [thread](https://platform.openai.com/docs/api-reference/threads).
  MessageObject get data;
  @override
  @JsonKey(ignore: true)
  _$$MessageStreamEventImplCopyWith<_$MessageStreamEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageStreamDeltaEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$MessageStreamDeltaEventImplCopyWith(
          _$MessageStreamDeltaEventImpl value,
          $Res Function(_$MessageStreamDeltaEventImpl) then) =
      __$$MessageStreamDeltaEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, MessageDeltaObject data});

  $MessageDeltaObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$MessageStreamDeltaEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res,
        _$MessageStreamDeltaEventImpl>
    implements _$$MessageStreamDeltaEventImplCopyWith<$Res> {
  __$$MessageStreamDeltaEventImplCopyWithImpl(
      _$MessageStreamDeltaEventImpl _value,
      $Res Function(_$MessageStreamDeltaEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$MessageStreamDeltaEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as MessageDeltaObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MessageDeltaObjectCopyWith<$Res> get data {
    return $MessageDeltaObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MessageStreamDeltaEventImpl extends MessageStreamDeltaEvent {
  const _$MessageStreamDeltaEventImpl({required this.event, required this.data})
      : super._();

  factory _$MessageStreamDeltaEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$MessageStreamDeltaEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents a message delta i.e. any changed fields on a message during streaming.
  @override
  final MessageDeltaObject data;

  @override
  String toString() {
    return 'AssistantStreamEvent.messageStreamDeltaEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageStreamDeltaEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageStreamDeltaEventImplCopyWith<_$MessageStreamDeltaEventImpl>
      get copyWith => __$$MessageStreamDeltaEventImplCopyWithImpl<
          _$MessageStreamDeltaEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return messageStreamDeltaEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return messageStreamDeltaEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (messageStreamDeltaEvent != null) {
      return messageStreamDeltaEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return messageStreamDeltaEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return messageStreamDeltaEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (messageStreamDeltaEvent != null) {
      return messageStreamDeltaEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MessageStreamDeltaEventImplToJson(
      this,
    );
  }
}

abstract class MessageStreamDeltaEvent extends AssistantStreamEvent {
  const factory MessageStreamDeltaEvent(
      {required final EventType event,
      required final MessageDeltaObject data}) = _$MessageStreamDeltaEventImpl;
  const MessageStreamDeltaEvent._() : super._();

  factory MessageStreamDeltaEvent.fromJson(Map<String, dynamic> json) =
      _$MessageStreamDeltaEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// Represents a message delta i.e. any changed fields on a message during streaming.
  MessageDeltaObject get data;
  @override
  @JsonKey(ignore: true)
  _$$MessageStreamDeltaEventImplCopyWith<_$MessageStreamDeltaEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$ErrorEventImplCopyWith(
          _$ErrorEventImpl value, $Res Function(_$ErrorEventImpl) then) =
      __$$ErrorEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, Error data});

  $ErrorCopyWith<$Res> get data;
}

/// @nodoc
class __$$ErrorEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res, _$ErrorEventImpl>
    implements _$$ErrorEventImplCopyWith<$Res> {
  __$$ErrorEventImplCopyWithImpl(
      _$ErrorEventImpl _value, $Res Function(_$ErrorEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$ErrorEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Error,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ErrorCopyWith<$Res> get data {
    return $ErrorCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ErrorEventImpl extends ErrorEvent {
  const _$ErrorEventImpl({required this.event, required this.data}) : super._();

  factory _$ErrorEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$ErrorEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// Represents an error that occurred during an API request.
  @override
  final Error data;

  @override
  String toString() {
    return 'AssistantStreamEvent.errorEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorEventImplCopyWith<_$ErrorEventImpl> get copyWith =>
      __$$ErrorEventImplCopyWithImpl<_$ErrorEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return errorEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return errorEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (errorEvent != null) {
      return errorEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return errorEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return errorEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (errorEvent != null) {
      return errorEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ErrorEventImplToJson(
      this,
    );
  }
}

abstract class ErrorEvent extends AssistantStreamEvent {
  const factory ErrorEvent(
      {required final EventType event,
      required final Error data}) = _$ErrorEventImpl;
  const ErrorEvent._() : super._();

  factory ErrorEvent.fromJson(Map<String, dynamic> json) =
      _$ErrorEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// Represents an error that occurred during an API request.
  Error get data;
  @override
  @JsonKey(ignore: true)
  _$$ErrorEventImplCopyWith<_$ErrorEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DoneEventImplCopyWith<$Res>
    implements $AssistantStreamEventCopyWith<$Res> {
  factory _$$DoneEventImplCopyWith(
          _$DoneEventImpl value, $Res Function(_$DoneEventImpl) then) =
      __$$DoneEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({EventType event, String data});
}

/// @nodoc
class __$$DoneEventImplCopyWithImpl<$Res>
    extends _$AssistantStreamEventCopyWithImpl<$Res, _$DoneEventImpl>
    implements _$$DoneEventImplCopyWith<$Res> {
  __$$DoneEventImplCopyWithImpl(
      _$DoneEventImpl _value, $Res Function(_$DoneEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? event = null,
    Object? data = null,
  }) {
    return _then(_$DoneEventImpl(
      event: null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as EventType,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DoneEventImpl extends DoneEvent {
  const _$DoneEventImpl({required this.event, required this.data}) : super._();

  factory _$DoneEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$DoneEventImplFromJson(json);

  /// The type of the event.
  @override
  final EventType event;

  /// No Description
  @override
  final String data;

  @override
  String toString() {
    return 'AssistantStreamEvent.doneEvent(event: $event, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DoneEventImpl &&
            (identical(other.event, event) || other.event == event) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, event, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DoneEventImplCopyWith<_$DoneEventImpl> get copyWith =>
      __$$DoneEventImplCopyWithImpl<_$DoneEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EventType event, ThreadObject data)
        threadStreamEvent,
    required TResult Function(EventType event, RunObject data) runStreamEvent,
    required TResult Function(EventType event, RunStepObject data)
        runStepStreamEvent,
    required TResult Function(EventType event, RunStepDeltaObject data)
        runStepStreamDeltaEvent,
    required TResult Function(EventType event, MessageObject data)
        messageStreamEvent,
    required TResult Function(EventType event, MessageDeltaObject data)
        messageStreamDeltaEvent,
    required TResult Function(EventType event, Error data) errorEvent,
    required TResult Function(EventType event, String data) doneEvent,
  }) {
    return doneEvent(event, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult? Function(EventType event, RunObject data)? runStreamEvent,
    TResult? Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult? Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult? Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult? Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult? Function(EventType event, Error data)? errorEvent,
    TResult? Function(EventType event, String data)? doneEvent,
  }) {
    return doneEvent?.call(event, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EventType event, ThreadObject data)? threadStreamEvent,
    TResult Function(EventType event, RunObject data)? runStreamEvent,
    TResult Function(EventType event, RunStepObject data)? runStepStreamEvent,
    TResult Function(EventType event, RunStepDeltaObject data)?
        runStepStreamDeltaEvent,
    TResult Function(EventType event, MessageObject data)? messageStreamEvent,
    TResult Function(EventType event, MessageDeltaObject data)?
        messageStreamDeltaEvent,
    TResult Function(EventType event, Error data)? errorEvent,
    TResult Function(EventType event, String data)? doneEvent,
    required TResult orElse(),
  }) {
    if (doneEvent != null) {
      return doneEvent(event, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ThreadStreamEvent value) threadStreamEvent,
    required TResult Function(RunStreamEvent value) runStreamEvent,
    required TResult Function(RunStepStreamEvent value) runStepStreamEvent,
    required TResult Function(RunStepStreamDeltaEvent value)
        runStepStreamDeltaEvent,
    required TResult Function(MessageStreamEvent value) messageStreamEvent,
    required TResult Function(MessageStreamDeltaEvent value)
        messageStreamDeltaEvent,
    required TResult Function(ErrorEvent value) errorEvent,
    required TResult Function(DoneEvent value) doneEvent,
  }) {
    return doneEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult? Function(RunStreamEvent value)? runStreamEvent,
    TResult? Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult? Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult? Function(MessageStreamEvent value)? messageStreamEvent,
    TResult? Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult? Function(ErrorEvent value)? errorEvent,
    TResult? Function(DoneEvent value)? doneEvent,
  }) {
    return doneEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ThreadStreamEvent value)? threadStreamEvent,
    TResult Function(RunStreamEvent value)? runStreamEvent,
    TResult Function(RunStepStreamEvent value)? runStepStreamEvent,
    TResult Function(RunStepStreamDeltaEvent value)? runStepStreamDeltaEvent,
    TResult Function(MessageStreamEvent value)? messageStreamEvent,
    TResult Function(MessageStreamDeltaEvent value)? messageStreamDeltaEvent,
    TResult Function(ErrorEvent value)? errorEvent,
    TResult Function(DoneEvent value)? doneEvent,
    required TResult orElse(),
  }) {
    if (doneEvent != null) {
      return doneEvent(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DoneEventImplToJson(
      this,
    );
  }
}

abstract class DoneEvent extends AssistantStreamEvent {
  const factory DoneEvent(
      {required final EventType event,
      required final String data}) = _$DoneEventImpl;
  const DoneEvent._() : super._();

  factory DoneEvent.fromJson(Map<String, dynamic> json) =
      _$DoneEventImpl.fromJson;

  @override

  /// The type of the event.
  EventType get event;
  @override

  /// No Description
  String get data;
  @override
  @JsonKey(ignore: true)
  _$$DoneEventImplCopyWith<_$DoneEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
